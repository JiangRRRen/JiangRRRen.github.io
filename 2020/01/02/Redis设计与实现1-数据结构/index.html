<!DOCTYPE html>
<html>
<head>
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'true', 'auto');
ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!-- End Google Analytics -->


    

    



    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="google-site-verification=6xKBD4e783W5YvEkBJE-d7v5QxyEqF7MRInlhMNq8YU">
    
    
    
    
    <title>Redis设计与实现1-数据结构 | JR&#39;s Blog | 直挂云帆济沧海</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="计算机网络,读书笔记,数据库,Redis,数据结构">
    <meta name="description" content="由于C语言的缺陷，Redis自身创建了许多有用的数据结构，包括：简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis设计与实现1-数据结构">
<meta property="og:url" content="jiangren.work/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
<meta property="og:site_name" content="JR&#39;s Blog">
<meta property="og:description" content="由于C语言的缺陷，Redis自身创建了许多有用的数据结构，包括：简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102110541.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102113458.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102124804.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102125720.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102130802.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102132429.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102133053.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102133229.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102142228.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102142348.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102142612.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102142837.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102143732.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102144352.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102150529.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102151704.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102151747.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102154549.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102155025.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102155739.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102161121.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102161401.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102161414.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102162612.png">
<meta property="article:published_time" content="2020-01-02T02:30:29.000Z">
<meta property="article:modified_time" content="2020-01-07T12:47:02.000Z">
<meta property="article:author" content="Jiang Ren">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="读书笔记">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102110541.png">
    
        <link rel="alternate" type="application/atom+xml" title="JR&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <link rel="stylesheet" href="/css/prism/prism-tomorrow-night.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-list-ul"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/MapleStory.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/fong.jpg" style="max-width: 100%;">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Jiang Ren</h5>
          <a href="mailto:jiangren@whu.edu.cn" title="jiangren@whu.edu.cn" class="mail">jiangren@whu.edu.cn</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives/"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/JiangRRRen" target="_blank" rel="noopener"  >
                <i class="icon icon-lg icon-github"></i>
                代码
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Redis设计与实现1-数据结构</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Redis设计与实现1-数据结构</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-01-02T02:30:29.000Z" itemprop="datePublished" class="page-time">
  2020-01-02
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-简单动态字符串"><span class="post-toc-text">1. 简单动态字符串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-1-SDS的定义"><span class="post-toc-text">1.1 SDS的定义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-2-SDS-与-C-字符串的区别"><span class="post-toc-text">1.2 SDS 与 C 字符串的区别</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-链表"><span class="post-toc-text">2. 链表</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-字典"><span class="post-toc-text">3. 字典</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-1-字典的实现"><span class="post-toc-text">3.1 字典的实现</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-2-哈希算法"><span class="post-toc-text">3.2 哈希算法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-3-Rehash"><span class="post-toc-text">3.3 Rehash</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-4-渐进式Rehash"><span class="post-toc-text">3.4 渐进式Rehash</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-跳跃表"><span class="post-toc-text">4. 跳跃表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-1-什么是跳跃表"><span class="post-toc-text">4.1 什么是跳跃表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-2-跳跃表的实现"><span class="post-toc-text">4.2 跳跃表的实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#5-整数集合"><span class="post-toc-text">5. 整数集合</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-1-整数集合的实现"><span class="post-toc-text">5.1 整数集合的实现</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-2-升级"><span class="post-toc-text">5.2 升级</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-3-降级"><span class="post-toc-text">5.3 降级</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#6-压缩列表"><span class="post-toc-text">6. 压缩列表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-1-压缩列表的构成"><span class="post-toc-text">6.1 压缩列表的构成</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-2-压缩列表的节点构成"><span class="post-toc-text">6.2 压缩列表的节点构成</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-3-连锁更新"><span class="post-toc-text">6.3 连锁更新</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Redis设计与实现1-数据结构"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Redis设计与实现1-数据结构</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-01-02 10:30:29" datetime="2020-01-02T02:30:29.000Z"  itemprop="datePublished">2020-01-02</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>由于C语言的缺陷，Redis自身创建了许多有用的数据结构，包括：简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表。<a id="more"></a></p>
<h1 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1. 简单动态字符串"></a>1. 简单动态字符串</h1><p>传统C语言的字符串以空字符结尾，而Redis自己重新构建了一种新的字符串结构，命名为简单动态字符串(simple dynamic string, SDS)。</p>
<p>在Redis中，<strong>C字符串只会用在一些无须修改的地方</strong>，比如打印常量：</p>
<pre><code class="lang-C">redisLog(REDIS_WARNING,&quot;Redis is now ready to exit, bye bye...&quot;);
</code></pre>
<p>如果是需要修改的地方，会使用SDS来表示：</p>
<pre><code class="lang-SHELL">redis&gt; RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;
(integer) 3
</code></pre>
<p> Redis 将在数据库中创建一个<strong>新的键值对</strong>，其中：</p>
<ul>
<li>key是一个<strong>字符串对象</strong>，底层保存了一个字符串fruits的SDS。</li>
<li>value是一个<strong>列表对象</strong>，<strong>列表包含了三个字符串对象</strong>，由SDS实现。</li>
</ul>
<h2 id="1-1-SDS的定义"><a href="#1-1-SDS的定义" class="headerlink" title="1.1 SDS的定义"></a>1.1 SDS的定义</h2><p>SDS是一个结构体，定义在<code>sds.h/sdshdr</code>中</p>
<pre><code class="lang-C">struct sdshdr {
    // 记录 buf 数组中已使用字节的数量
    // 等于 SDS 所保存字符串的长度
    int len;
    // 记录 buf 数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
};
</code></pre>
<p>下面给出了一个示例，free为0代表所有空间都被使用，len长度为5，表示SDS保存的字符串长度为5，buf就是字符串实体。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102110541.png"  style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<p>保存空字符的1字节空间<strong>不计算在len属性内</strong>。遵循空字符结尾这一惯例的好处是， <strong>SDS 可以直接重用一部分 C 字符串函数库里面的函数。</strong></p>
<p>比如我们不需要对SDS专门设置打印函数。</p>
<pre><code class="lang-C">printf(&quot;%s&quot;,s-&gt;buf);
</code></pre>
<h2 id="1-2-SDS-与-C-字符串的区别"><a href="#1-2-SDS-与-C-字符串的区别" class="headerlink" title="1.2 SDS 与 C 字符串的区别"></a>1.2 SDS 与 C 字符串的区别</h2><p>C 语言使用的简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求。主要有以下几个弊端。</p>
<p><strong>（1）C字符串获取长度的能力有限</strong></p>
<p>C字符串需要依靠遍历获取长度，时间复杂度$O(N)$，而SDS本身记录了len，所以时间复杂度$O (1)$，<strong>常数时间</strong>。</p>
<p><strong>（2）杜绝缓冲区溢出</strong></p>
<p>由于C字符串不记录长度，当我们拼接两个字符串的时候，容器可能<strong>因为空间不足发生溢出</strong>。redis中的<code>sdscat</code>将在执行拼接操作前<strong>检查长度是否充足</strong>，若不足则先拓展空间，再拼接。</p>
<p><strong>（3）减少修改字符串时带来的内存重分配次数</strong></p>
<p>C字符串类似于数组，每次修改大小都会重新分配以此内存。Redis的分配原理类似于<code>std::vector</code>，通过<strong>空间预分配</strong>的办法<strong>优化字符串增加</strong>，分配规则如下：</p>
<ul>
<li>若len比较小（小于1MB），则free是len一样大。如果修改后len为13字节，则free也为13字节，buf实际长度为13+13+1=27字节。</li>
<li>若len比较大（大于1MB），则每次free只会有1MB，比如修改后len为30MB，则free为1MB，总长度为30MB+1MB+1byte。</li>
</ul>
<p>此外，使用<strong>惰性空间释放</strong>来<strong>优化字符串缩短</strong>。当缩短时，将释放的空间放入free中保存起来，等待使用。</p>
<p><strong>（4）二进制安全</strong></p>
<p>C字符串以空字符<code>\0</code>结尾，使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。我们希望<strong>有一种使用空字符来分割多个单词的特殊数据格式</strong>。换句话说，<strong>数据写入时什么样，读取时就是什么样</strong>。</p>
<p>SDS利用len来判断是否结束，而不是空字符<code>\0</code></p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102113458.png" style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<h1 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h1><p>链表随机读写能力差，但增删和重排能力较强。C语言没有链表结构，所以Redis自制了一个。</p>
<p><strong>链表节点</strong>定义在<code>adlist.h/listNode</code>，如下：</p>
<pre><code class="lang-C">typedef struct listNode {
    // 前置节点
    struct listNode *prev;
    // 后置节点
    struct listNode *next;
    // 节点的值
    void *value;
} listNode;
</code></pre>
<p>这是一个<strong>双端链表</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102124804.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>虽然可以多个Node组成链表，但是为了方便，Redis设计了<code>adlist.h/list</code> 来持有链表。</p>
<pre><code class="lang-C">typedef struct list {
    // 表头节点
    listNode *head;
    // 表尾节点
    listNode *tail;
    // 链表所包含的节点数量
    unsigned long len;
    // 节点值复制函数
    void *(*dup)(void *ptr);
    // 节点值释放函数
    void (*free)(void *ptr);
    // 节点值对比函数
    int (*match)(void *ptr, void *key);
} list;
</code></pre>
<p>Redis 的链表实现的特性可以总结如下：</p>
<ul>
<li>双端</li>
<li>无环，表头和结尾都指向<code>NULL</code></li>
<li>带有表头表位指针，访问$ O (1)$</li>
<li>自带链表长度计数器</li>
<li><strong>多态</strong>：使用<code>void*</code>来保存节点值，有泛型编程内味了。</li>
</ul>
<h1 id="3-字典"><a href="#3-字典" class="headerlink" title="3. 字典"></a>3. 字典</h1><p>在字典中， 一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些<strong>关联的键和值就被称为键值对</strong>。字典中的每个键必须保证都是独一无二的。C并没有这样的结构，所以Redis自己实现了。</p>
<h2 id="3-1-字典的实现"><a href="#3-1-字典的实现" class="headerlink" title="3.1 字典的实现"></a>3.1 字典的实现</h2><p>Redis 字典所使用的<strong>哈希表</strong>由 <code>dict.h/dictht</code> 结构定义：</p>
<pre><code class="lang-C">typedef struct dictht {
    // 哈希表数组
    dictEntry **table;
    // 哈希表大小
    unsigned long size;
    // 哈希表大小掩码，用于计算索引值
    // 总是等于 size - 1
    unsigned long sizemask
    // 该哈希表已有节点的数量
    unsigned long used;
} dictht;
</code></pre>
<p><code>table</code> 是一个数组， 数组中的每个元素都是一个指向 <code>dict.h/dictEntry</code> 结构的指针。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102125720.png" style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<p><strong>哈希表节点</strong>使用 <code>dictEntry</code> 结构表示， 每个 <code>dictEntry</code> 结构都保存着一个键值对：</p>
<pre><code class="lang-C">typedef struct dictEntry {
    // 键
    void *key;
    // 值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;
    // 指向下个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
</code></pre>
<p><code>v</code> 属性则保存着键值对中的值， 值可以是一个指针， 或者是一个 <code>uint64_t</code> 整数， 又或者是一个 <code>int64_t</code> 整数。</p>
<p><code>next</code> 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来<strong>解决键冲突（collision）的问题</strong>。</p>
<p>下图中，键的索引值都是2，通过链表的形式完成了冲突的规避。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102130802.png" style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<hr>
<p>上面提到的是哈希表和哈希表节点的实现，现在来说真正的<strong>字典结构</strong>。Redis 中的字典由 <code>dict.h/dict</code> 结构表示：</p>
<pre><code class="lang-C">typedef struct dict {
    // 类型特定函数
    dictType *type;
    // 私有数据
    void *privdata;
    // 哈希表
    dictht ht[2];
    // rehash 索引
    // 当 rehash 不在进行时，值为 -1
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */
} dict;
</code></pre>
<p>其中<code>type</code> 属性和 <code>privdata</code> 属性是<strong>针对不同类型的键值对， 为创建多态字典而设置的</strong>。</p>
<ul>
<li><code>type</code> 属性是一个指向 <code>dictType</code> 结构的指针， 每个 <code>dictType</code> 结构保存了一簇用于操作特定类型键值对的函数。</li>
<li><code>privdata</code> 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<pre><code class="lang-C">typedef struct dictType {
    // 计算哈希值的函数
    unsigned int (*hashFunction)(const void *key);
    // 复制键的函数
    void *(*keyDup)(void *privdata, const void *key);
    // 复制值的函数
    void *(*valDup)(void *privdata, const void *obj);
    // 对比键的函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    // 销毁键的函数
    void (*keyDestructor)(void *privdata, void *key);
    // 销毁值的函数
    void (*valDestructor)(void *privdata, void *obj);
} dictType;
</code></pre>
<p>哈希表数组ht包含了两个元素， 一般情况下， 字典只使用 <code>ht[0]</code> 哈希表， <code>ht[1]</code> 哈希表只会在对 <code>ht[0]</code> 哈希表进行 rehash 时使用。</p>
<p>除了 <code>ht[1]</code> 之外， 另一个和 rehash 有关的属性就是 <code>rehashidx</code> ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 <code>-1</code> 。</p>
<p>下图展示了一个普通状态下（没有rehash）的字典</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102132429.png" style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<h2 id="3-2-哈希算法"><a href="#3-2-哈希算法" class="headerlink" title="3.2 哈希算法"></a>3.2 哈希算法</h2><p> 程序需要先根据键值对的键计算出<strong>哈希值和索引值</strong>， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>Redis 计算哈希值和索引值的方法如下：</p>
<pre><code class="lang-C">// 使用字典设置的哈希函数，计算键 key 的哈希值
hash = dict-&gt;type-&gt;hashFunction(key);

// 使用哈希表的 sizemask 属性和哈希值，计算出索引值
// 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]
index = hash &amp; dict-&gt;ht[x].sizemask;
</code></pre>
<p>举个例子，假如想要将键值对<code>k0</code> 和 <code>v0</code> 添加到下面的字典中。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102133053.png" style="zoom:50%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<p>假设计算出的hash值是8，则index为</p>
<pre><code class="lang-c">index = hash &amp; dict-&gt;ht[0].sizemask = 8 &amp; 3 = 0;
</code></pre>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102133229.png" style="zoom:62%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<p>至于Redis的哈希值计算方法，使用的是 MurmurHash2。这种算法的优点在于， 即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。</p>
<h2 id="3-3-Rehash"><a href="#3-3-Rehash" class="headerlink" title="3.3 Rehash"></a>3.3 Rehash</h2><p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的<strong>负载因子（load factor）</strong>维持在一个合理的范围之内， <strong>当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</strong></p>
<p>再哈希的关键在于<strong>重新分配哈希表的大小</strong>，分配的原则如下：</p>
<ul>
<li>如果执行拓展操作<code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used * 2</code> 的 $2^n$，比如原表大小为4，则 <code>ht[0].used * 2</code>结果为8，而8刚好是$2^3$，所以新的大小是8。</li>
<li>如果执行的是收缩操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used</code> 的$2^ n$</li>
</ul>
<p>完成分配后，将保存在 <code>ht[0]</code> 中的所有键值对 <strong>rehash</strong> 到 <code>ht[1]</code> 上面，然后 将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ， 并在 <code>ht[1]</code> 新创建一个空白哈希表， 为下一次 rehash 做准备。</p>
<p>决定是否再Hash的要素来自于负载因子，计算方法如下：</p>
<pre><code class="lang-C">//负载因子 = 哈希表已保存节点数量 / 哈希表大小
load_factor = ht[0].used / ht[0].size
</code></pre>
<h2 id="3-4-渐进式Rehash"><a href="#3-4-渐进式Rehash" class="headerlink" title="3.4 渐进式Rehash"></a>3.4 渐进式Rehash</h2><p>如果键值对很多，则将<code>ht[0]</code>重新hash到<code>ht[1]</code>上，则会导致服务器在一段时间内停止服务。为了避免这种问题，需要分多次渐进式的慢慢映射。</p>
<p>关键点在于维持一个<strong>索引计数器变量</strong> <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</p>
<p>在 rehash 进行期间， 每次对字典执行增删改查， 程序除了执行指定的操作以外， <strong>还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code></strong> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> <strong>属性的值增一</strong>。</p>
<p>完成后程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</p>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个增删改查上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<h1 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4. 跳跃表"></a>4. 跳跃表</h1><h2 id="4-1-什么是跳跃表"><a href="#4-1-什么是跳跃表" class="headerlink" title="4.1 什么是跳跃表"></a>4.1 什么是跳跃表</h2><p>我们知道链表随机读写的能力很差，当增删改查的时候，如果要找到目标元素就需要遍历链表。假设某个数据结构是有序的，我们就会想到用二分法来快速查找，但<strong>链表是没有索引的</strong>，所以我们需要添加。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102142228.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>可以继续向上拓展层数：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102142348.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>但是我们的链表不是静态的，增加和删除会破坏二分结构，所以我们就不强制要求 <code>1:2</code> 了，一个节点要不要被索引，建几层的索引，都在节点插入时由<strong>随机决定</strong>。</p>
<p>现在假设节点 <code>17</code> 是最后插入的，在插入之前，我们需要搜索得到插入的位置：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102142612.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="4-2-跳跃表的实现"><a href="#4-2-跳跃表的实现" class="headerlink" title="4.2 跳跃表的实现"></a>4.2 跳跃表的实现</h2><p>Redis 的跳跃表由 <code>redis.h/zskiplistNode</code> 和 <code>redis.h/zskiplist</code> 两个结构定义， 其中 <code>zskiplistNode</code> 结构用于表示跳跃表<strong>节点</strong>， 而 <code>zskiplist</code>结构则用于保存跳跃表节点的相关信息， 比如<strong>节点的数量， 以及指向表头节点和表尾节点的指针</strong>， 等等。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102142837.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>在<code>zskiplist</code>中<code>level</code> 记录目前跳跃表内最大层数（表头不算），<code>length</code>记录包含的节点数量（表头不算）。</p>
<p><code>zskiplistNode</code> 结构包含以下属性：</p>
<ul>
<li>层：每一层有两个属性<ul>
<li>前进指针用于访问位于表尾方向的其他节点</li>
<li>跨度则记录了前进指针所指向节点和当前节点的距离。</li>
</ul>
</li>
<li>后退指针(bw)：指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值(score)：各个节点中的 <code>1.0</code> 、 <code>2.0</code> 和 <code>3.0</code> 是节点所保存的分值。用于从小到大排列。<strong>如果分值相同，则成员对象小的排在前面。</strong></li>
<li>成员对象（obj）：各个节点中的 <code>o1</code> 、 <code>o2</code> 和 <code>o3</code> 是节点所保存的成员对象。</li>
</ul>
<pre><code class="lang-C">typedef struct zskiplistNode {
    // 后退指针
    struct zskiplistNode *backward;
    // 分值
    double score;
    // 成员对象
    robj *obj;
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[];
} zskiplistNode;
</code></pre>
<p><strong>（1）层</strong></p>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （<a href="http://en.wikipedia.org/wiki/Power_law" target="_blank" rel="noopener">power law</a>，<strong>越大的数出现的概率越小</strong>） <strong>随机</strong>生成一个介于 <code>1</code> 和 <code>32</code> 之间的值作为 <code>level</code> 数组的大小， 这个大小就是层的“高度”。</p>
<p>下图展示了三个高度为 <code>1</code> 层、 <code>3</code> 层和 <code>5</code> 层的节点</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102143732.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>（2）前进指针</strong></p>
<p>前进指针分属于不同的层，<code>level[i].forward</code>，用于从表头向表尾方向访问节点。</p>
<p><strong>（3）跨度</strong></p>
<p>跨度也分属不同的层，指向 <code>NULL</code> 的所有前进指针的跨度都为 <code>0</code>， 因为它们没有连向任何节点。</p>
<p> 跨度实际上是用来计算<strong>位次</strong>（rank）的： <strong>将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</strong></p>
<p>下图的例子中，查找分值为3.0的节点，由于只经过了一个层，跨度为3，所以跳跃表中的排位为3。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102144352.png" style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<hr>
<p>使用一个 <code>zskiplist</code> 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理。</p>
<pre><code class="lang-C">typedef struct zskiplist {
    // 表头节点和表尾节点
    struct zskiplistNode *header, *tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int level;
} zskiplist;
</code></pre>
<h1 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5. 整数集合"></a>5. 整数集合</h1><p>当一个集合中<strong>只包含整数</strong>，并且<strong>元素的个数不是很多</strong>的话，redis 会用<strong>整数集合</strong>作为底层存储，它可以节省很多内存。</p>
<h2 id="5-1-整数集合的实现"><a href="#5-1-整数集合的实现" class="headerlink" title="5.1 整数集合的实现"></a>5.1 整数集合的实现</h2><p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 的整数值， 并且保证集合中不会出现重复元素。</p>
<p>每个 <code>intset.h/intset</code> 结构表示一个整数集合：</p>
<pre><code class="lang-C">typedef struct intset {
    // 编码方式
    uint32_t encoding;
    // 集合包含的元素数量
    uint32_t length;
    // 保存元素的数组
    int8_t contents[];
} intset;
</code></pre>
<p><code>contents</code> 数组是整数集合的底层实现： 整数集合的每个元素都是 <code>contents</code> 数组的一个数组项（item）， 从小到大有序地排列，不包含任何重复项。</p>
<p>虽然 <code>intset</code> 结构将 <code>contents</code> 属性声明为 <code>int8_t</code> 类型的数组， 但实际上 <code>contents</code> 数组并不保存任何 <code>int8_t</code> 类型的值 —— <strong><code>contents</code> 数组的真正类型取决于 <code>encoding</code> 属性的值</strong>：</p>
<ul>
<li><code>encoding</code> 为 <code>INTSET_ENC_INT16</code>，<code>int16_t</code> 类型的数组，范围$[-2^{16},2^{16}-1]$</li>
<li><code>encoding</code>  <code>INTSET_ENC_INT32</code> ， 是一个 <code>int32_t</code> 类型的数组。</li>
<li><code>encoding</code> 为 <code>INTSET_ENC_INT64</code> ， 是一个 <code>int64_t</code> 类型的数组</li>
</ul>
<p>下图展示了一个示例：</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102150529.png" style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<h2 id="5-2-升级"><a href="#5-2-升级" class="headerlink" title="5.2 升级"></a>5.2 升级</h2><p>每当我们要将一个新元素添加到整数集合里面， 并且<strong>新元素的类型比整数集合元素的类型长时</strong>， 整数集合需要先进行<strong>升级（upgrade）</strong>， 然后才能将新元素添加到整数集合里面。</p>
<p>过程如下：</p>
<ol>
<li>根据新类型，扩展整数集合底层数组的空间大小， 并为新元素分配空间</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素有序放置。</li>
<li>将新元素添加到底层数组里面。</li>
</ol>
<p>假设想要在16位编码的intset中插入32位的65535数据，原来的集合是这样的：</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102151704.png"  style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<p>需要扩容为$32\times4=128$位，新intset结构会扩容成这样：</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102151747.png"  style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<p>剩下就需要对元素重排。</p>
<p>先将3移动到新intset结构的索引2的位置上，然后将2移动到索引1的位置，然后将1移动到索引0的位置。最后再讲65535移动到索引3的位置。</p>
<h2 id="5-3-降级"><a href="#5-3-降级" class="headerlink" title="5.3 降级"></a>5.3 降级</h2><p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<p>即使我们将集合里唯一一个真正需要使用 <code>int64_t</code> 类型来保存的元素 <code>4294967295</code> 删除了， 整数集合的编码仍然会维持 <code>INTSET_ENC_INT64</code>。</p>
<h1 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6. 压缩列表"></a>6. 压缩列表</h1><p>压缩列表（ziplist）<strong>是列表键和哈希键的底层实现之一。</strong>当一个列表键只包含少量列表项， 并且每个列表项要么就是<strong>小整数值或长度比较短的字符串</strong>， 那么 Redis 就会使用压缩列表来做列表键的底层实现。</p>
<h2 id="6-1-压缩列表的构成"><a href="#6-1-压缩列表的构成" class="headerlink" title="6.1 压缩列表的构成"></a>6.1 压缩列表的构成</h2><p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的<strong>连续内存块组成的顺序型（sequential）数据结构。</strong></p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102154549.png"  style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">长度</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">zlbytes</td>
<td style="text-align:center">uint32_t</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">整个压缩列表占用内存字节数</td>
</tr>
<tr>
<td style="text-align:center">zltail</td>
<td style="text-align:center">uint32_t</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">记录表尾节点距离表起始地址有多少个字节</td>
</tr>
<tr>
<td style="text-align:center">zllen</td>
<td style="text-align:center">uint16_t</td>
<td style="text-align:center">2字节</td>
<td style="text-align:center">记录节点数量</td>
</tr>
<tr>
<td style="text-align:center">entryX</td>
<td style="text-align:center"></td>
<td style="text-align:center">不定</td>
<td style="text-align:center">节点</td>
</tr>
<tr>
<td style="text-align:center">zlend</td>
<td style="text-align:center">uint8_t</td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">用于标记末端</td>
</tr>
</tbody>
</table>
</div>
<p>下面展示了一个例子：</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102155025.png"  style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<ul>
<li><code>zlbytes</code> 属性的值为 <code>0x50</code> （十进制 <code>80</code>）， 表示压缩列表的总长为 <code>80</code> 字节。</li>
<li><code>zltail</code> 属性的值为 <code>0x3c</code> （十进制 <code>60</code>），如果一个指向压缩列表起始地址的指针 <code>p</code> ， 那么只要用指针 <code>p</code> 加上偏移量 <code>60</code> ， 就可以计算出表尾节点 <code>entry3</code> 的地址。</li>
<li><code>zllen</code> 属性的值为 <code>0x3</code> （十进制 <code>3</code>）， 表示压缩列表包含三个节点。</li>
</ul>
<h2 id="6-2-压缩列表的节点构成"><a href="#6-2-压缩列表的节点构成" class="headerlink" title="6.2 压缩列表的节点构成"></a>6.2 压缩列表的节点构成</h2><p>每个压缩列表节点可以保存一个字节数组或者一个整数值， 其中， 字节数组可以是以下三种长度的其中一种：</p>
<ol>
<li>长度小于等于<code>63</code>($2^6-1$)字节的字节数组；</li>
<li>长度小于等于 <code>16383</code> ($2^{14}-1$)字节的字节数组；</li>
<li>长度小于等于 <code>4294967295</code> ($2^{32}-1$)字节的字节数组；</li>
</ol>
<p>而整数值则可以是以下六种长度的其中一种：</p>
<ol>
<li><code>4</code> 位长，介于 <code>0</code> 至 <code>12</code> 之间的无符号整数；</li>
<li><code>1</code> 字节长的有符号整数；</li>
<li><code>3</code> 字节长的有符号整数；</li>
<li><code>int16_t</code> 类型整数；</li>
<li><code>int32_t</code> 类型整数；</li>
<li><code>int64_t</code> 类型整数。</li>
</ol>
<p>每个压缩列表节点都由 <code>previous_entry_length</code> 、 <code>encoding</code> 、 <code>content</code> 三个部分组成。</p>
<hr>
<p><strong>（1）previous_entry_length</strong></p>
<p>以字节为单位， 记录了压缩列表中<strong>前一个节点的长度。</strong>这个属性的长度可以是1字节或5字节，如果前一个小于254则使用1字节，反之使用5字节（ 其中属性的<strong>第一字节会被设置为 <code>0xFE</code>（十进制值 <code>254</code>）</strong>， 而之后的四个字节则用于保存前一节点的长度）</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102155739.png"  style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<p>程序可以通过指针运算， 根据当前节点的起始地址来<strong>计算出前一个节点的起始地址</strong>。进而可以回溯到表头。</p>
<p><strong>（2）encoding</strong></p>
<p>节点的 <code>encoding</code> 属性记录了节点的 <code>content</code> 属性所保存数据的类型以及长度。编码由8位组成。</p>
<p><strong>如果是字符类型</strong>，则开头两位<code>00</code>,<code>01</code>,<code>10</code>分别表示1字节，2字节，5字节，后6位表示字符串长度。</p>
<p>保存每个元素是1个字节的数组，长度11。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102161121.png"  style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<p>如果是整数类型，则开头必是11，然后从第6位开始往低位开始计数：</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102161401.png"  style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<p>每个元素<code>int16_t</code>，值为10086</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102161414.png"  style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<h2 id="6-3-连锁更新"><a href="#6-3-连锁更新" class="headerlink" title="6.3 连锁更新"></a>6.3 连锁更新</h2><p>每个节点的 <code>previous_entry_length</code> 属性都记录了前一个节点的长度：</p>
<ul>
<li>如果前一节点的长度小于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性需要用 <code>1</code> 字节长的空间来保存这个长度值。</li>
<li>如果前一节点的长度大于等于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性需要用 <code>5</code> 字节长的空间来保存这个长度值。</li>
</ul>
<p>假设现在有一些长度为252字节的节点，他们在<code>previous_entry_length</code>中保存为1字节。现在插入了一个260字节的新节点，<code>new</code> 将成为 <code>e1</code> 的前置节点。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200102162612.png"  style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<p>因为 <code>e1</code> 的 <code>previous_entry_length</code> 属性仅长 <code>1</code> 字节， 它没办法保存新节点 <code>new</code> 的长度， 所以程序将对压缩列表执行空间重分配操作， <strong>并将<code>e1</code> 节点的 <code>previous_entry_length</code> 属性从原来的 <code>1</code> 字节长扩展为 <code>5</code> 字节长。</strong></p>
<p>由于<code>previous_entry_length</code> 的变化，导致<code>e1</code>的长度也发生了变化$252+4=256&gt;254$，所以导致<code>e2</code>也必须更新它的<code>previous_entry_length</code> 。这就是连锁更新。</p>
<p>除了添加节点外，删除节点也会导致连锁更新，若删除一个260字节的节点，则后一个节点长度也会变化。如果很不凑巧，小于254，则又会引起后序效应。</p>
<p>连锁更新在最坏情况下需要对压缩列表执行 <code>N</code> 次空间重分配操作， 而每次空间重分配的最坏复杂度为$O(N)$ ， 所以连锁更新的最坏复杂度为 $O(N^2)$ 。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        

        
        文章发布地址：<a href="/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" target="_blank" rel="external">jiangren.work/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a>
        
    </div>
    
    <footer>
        <a href="jiangren.work">
            <img src="/img/fong.jpg" alt="Jiang Ren">
            Jiang Ren
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=jiangren.work/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&title=《Redis设计与实现1-数据结构》 — JR's Blog&pic=jiangren.work/img/fong.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=jiangren.work/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&title=《Redis设计与实现1-数据结构》 — JR's Blog&source=由于C语言的缺陷，Redis自身创建了许多有用的数据结构，包括：简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=jiangren.work/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Redis设计与实现1-数据结构》 — JR's Blog&url=jiangren.work/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&via=jiangren.work" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=jiangren.work/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/01/03/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B02-%E5%AF%B9%E8%B1%A1/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Redis设计与实现2-对象</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/12/30/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">CPP泛型编程4-可变参数模板</h4>
      </a>
    </div>
  
</nav>



    





















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持！
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/true" alt="打赏二维码">
        </div>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


            <p>
                
                    <span>
                        <a href="/atom.xml" target="_blank" class="rss" title="rss">
                            <i class="icon icon-lg icon-rss"></i>
                        </a>
                    </span>
                    
                        <span>
                            博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
                        </span>
            </p>
    </div>
    <div class="bottom">
        <p>
            <span>
                Jiang Ren &copy;
                    
                        2019 -
                            
                                2020
            </span>
            <span>
                
                        Power by
                        <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
                        <a href="https://github.com/abelsu7/hexo-theme-indigo-plus" target="_blank">indigo plus</a>
                        <p>Hosted by <a href="https://pages.github.com" target="_blank" style="font-weight: bold">Github Pages</a></p>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>
<a href="javascript:;" id="gobottom" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-comments"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=jiangren.work/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&title=《Redis设计与实现1-数据结构》 — JR's Blog&pic=jiangren.work/img/fong.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=jiangren.work/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&title=《Redis设计与实现1-数据结构》 — JR's Blog&source=由于C语言的缺陷，Redis自身创建了许多有用的数据结构，包括：简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=jiangren.work/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Redis设计与实现1-数据结构》 — JR's Blog&url=jiangren.work/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&via=jiangren.work" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=jiangren.work/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=jiangren.work/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" alt="微信分享二维码">
</div>




    <script src="//cdn.jsdelivr.net/npm/node-waves@0.7.6/src/js/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<!-- <script async src="//cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script> -->
<!-- <script async src="//cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script> -->




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="/js/prism.min.js?v=1.7.2"></script>
<script src="/js/prism-vim.min.js?v=1.7.2"></script>
</body>
</html>
