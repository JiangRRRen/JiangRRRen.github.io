<!DOCTYPE html>
<html>
<head>
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'true', 'auto');
ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!-- End Google Analytics -->


    

    



    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="google-site-verification=6xKBD4e783W5YvEkBJE-d7v5QxyEqF7MRInlhMNq8YU">
    
    
    
    
    <title>Redis面试常见基本问题 | JR&#39;s Blog | 直挂云帆济沧海</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="计算机网络,读书笔记,数据库,面试经验,Redis">
    <meta name="description" content="redis的原理性问题总结。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis面试常见基本问题">
<meta property="og:url" content="jiangren.work/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/">
<meta property="og:site_name" content="JR&#39;s Blog">
<meta property="og:description" content="redis的原理性问题总结。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103112837.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103113250.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103132547.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103133909.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103134109.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103134827.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103140005.png">
<meta property="og:image" content="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200113150533.png">
<meta property="og:image" content="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200113152209.png">
<meta property="og:image" content="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200113154703.png">
<meta property="og:image" content="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200113160426.png">
<meta property="og:image" content="https://cdn.cnbj1.fds.api.mi-img.com/book/images/fcccd0065c411e2492d097f9bb0fb378?thumb=1&w=1024&h=1024">
<meta property="og:image" content="https://cdn.cnbj1.fds.api.mi-img.com/book/images/7fb4b031c86ff72f6478b8e16718b43d?thumb=1&w=1024&h=1024">
<meta property="og:image" content="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200112133931.png">
<meta property="og:image" content="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200112105535.png">
<meta property="article:published_time" content="2020-01-16T08:11:46.000Z">
<meta property="article:modified_time" content="2020-03-26T14:50:21.000Z">
<meta property="article:author" content="Jiang Ren">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="读书笔记">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="面试经验">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103112837.png">
    
        <link rel="alternate" type="application/atom+xml" title="JR&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <link rel="stylesheet" href="/css/prism/prism-tomorrow-night.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-list-ul"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/MapleStory.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/fong.jpg" style="max-width: 100%;">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Jiang Ren</h5>
          <a href="mailto:jiangren@whu.edu.cn" title="jiangren@whu.edu.cn" class="mail">jiangren@whu.edu.cn</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives/"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/JiangRRRen" target="_blank" rel="noopener"  >
                <i class="icon icon-lg icon-github"></i>
                代码
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Redis面试常见基本问题</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Redis面试常见基本问题</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-01-16T08:11:46.000Z" itemprop="datePublished" class="page-time">
  2020-01-16
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-基础"><span class="post-toc-text">1.基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-1-什么是Redis？"><span class="post-toc-text">1.1 什么是Redis？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-2-Redis的优劣势？"><span class="post-toc-text">1.2 Redis的优劣势？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-3-Redis和Memcached比较"><span class="post-toc-text">1.3 Redis和Memcached比较</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-4-Redis支持哪些数据类型"><span class="post-toc-text">1.4 Redis支持哪些数据类型</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-缓存相关"><span class="post-toc-text">2. 缓存相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-1-什么是缓存雪崩？"><span class="post-toc-text">2.1 什么是缓存雪崩？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-2-如何解决缓存雪崩？"><span class="post-toc-text">2.2 如何解决缓存雪崩？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-3-什么是缓存穿透？"><span class="post-toc-text">2.3 什么是缓存穿透？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-4-如何解决缓存穿透？"><span class="post-toc-text">2.4 如何解决缓存穿透？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-5-如何解决缓存与数据库双写不一致？"><span class="post-toc-text">2.5 如何解决缓存与数据库双写不一致？</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-线程模型"><span class="post-toc-text">3. 线程模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-1-为什么Redis是单线程？"><span class="post-toc-text">3.1 为什么Redis是单线程？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-2-介绍一下IO多路复用"><span class="post-toc-text">3.2 介绍一下IO多路复用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-3-介绍一下redis线程模型的处理流程"><span class="post-toc-text">3.3 介绍一下redis线程模型的处理流程</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-数据删除与淘汰机制"><span class="post-toc-text">4. 数据删除与淘汰机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-1-介绍一下redis的过期删除策略"><span class="post-toc-text">4.1 介绍一下redis的过期删除策略</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-2-介绍一下Redis的内存淘汰机制"><span class="post-toc-text">4.2 介绍一下Redis的内存淘汰机制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-3-写一个LRU算法"><span class="post-toc-text">4.3 写一个LRU算法</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#5-Redis高并发和高可用"><span class="post-toc-text">5. Redis高并发和高可用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-1-Redis的高并发是如何实现的？"><span class="post-toc-text">5.1 Redis的高并发是如何实现的？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-2-Redis的高可用是如何实现的？"><span class="post-toc-text">5.2 Redis的高可用是如何实现的？</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#6-多机架构"><span class="post-toc-text">6. 多机架构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-1-Redis有哪些多机架构？"><span class="post-toc-text">6.1 Redis有哪些多机架构？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-2-介绍一下复制过程"><span class="post-toc-text">6.2 介绍一下复制过程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-3-介绍一下集群"><span class="post-toc-text">6.3 介绍一下集群</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-4-集群的通信方式是怎样的？"><span class="post-toc-text">6.4 集群的通信方式是怎样的？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-5-集群分片的原理是什么"><span class="post-toc-text">6.5 集群分片的原理是什么?</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-6-集群扩容和收缩是怎么实现的？"><span class="post-toc-text">6.6 集群扩容和收缩是怎么实现的？</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#7-持久化"><span class="post-toc-text">7. 持久化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-1-为什么采用持久化？"><span class="post-toc-text">7.1 为什么采用持久化？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-2-持久化的方式有哪些？"><span class="post-toc-text">7.2 持久化的方式有哪些？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-3-AOF的重写是什么意思？"><span class="post-toc-text">7.3 AOF的重写是什么意思？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-4-AOF和RDB优劣势比较"><span class="post-toc-text">7.4 AOF和RDB优劣势比较</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#8-事务"><span class="post-toc-text">8. 事务</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-1-什么是事务？"><span class="post-toc-text">8.1 什么是事务？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-2-Redis中事务是如何实现的？"><span class="post-toc-text">8.2 Redis中事务是如何实现的？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-3-事务中的乐观锁是什么？"><span class="post-toc-text">8.3 事务中的乐观锁是什么？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-4-WATCH命令的原理是什么？"><span class="post-toc-text">8.4 WATCH命令的原理是什么？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-5-解释一下事务的ACID性质"><span class="post-toc-text">8.5 解释一下事务的ACID性质</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Redis面试常见基本问题"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Redis面试常见基本问题</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-01-16 16:11:46" datetime="2020-01-16T08:11:46.000Z"  itemprop="datePublished">2020-01-16</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>redis的原理性问题总结。<a id="more"></a></p>
<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><h2 id="1-1-什么是Redis？"><a href="#1-1-什么是Redis？" class="headerlink" title="1.1 什么是Redis？"></a>1.1 什么是Redis？</h2><p>Redis的全称是：Remote Dictionary Server，本质上是一个 <strong>Key-Value</strong> 类型的<strong>内存</strong>数据库。</p>
<p>整个数据库统统<strong>加载在内存</strong>当中进行操作，定期通过异步操作把数据库数据保存在硬盘。因为是纯内存操作，Redis 的性能非常出色。</p>
<h2 id="1-2-Redis的优劣势？"><a href="#1-2-Redis的优劣势？" class="headerlink" title="1.2 Redis的优劣势？"></a>1.2 Redis的优劣势？</h2><p>优势：</p>
<ul>
<li>纯内存读写操作，性能好。</li>
<li>单线程，不用担心竞争</li>
<li>特性丰富，支持发布订阅、过期、sentinel等功能。</li>
</ul>
<p>劣势：</p>
<ul>
<li>容量受物理内存限制，不能用作海量数据的高性能读写。</li>
</ul>
<h2 id="1-3-Redis和Memcached比较"><a href="#1-3-Redis和Memcached比较" class="headerlink" title="1.3 Redis和Memcached比较"></a>1.3 Redis和Memcached比较</h2><p>Memcached早年被很多公司使用，现在内存越来越便宜，基本都是用Redis。Redis被认为是Memcached的替代者，优势有：</p>
<ul>
<li>memcached值均为简单字符串，redis支持更丰富的类型</li>
<li>redis性能更好（速度快，内存大）Memcached内存限制为1MB，而Redis可以达到1GB</li>
<li>redis可以持久化</li>
<li>Memcached集群功能不好，没有原生集群模式</li>
</ul>
<p>劣势有：</p>
<ul>
<li>redis只是用一个核，而memcached使用多核，在大数据处理上，memecached效率要好一些。</li>
</ul>
<h2 id="1-4-Redis支持哪些数据类型"><a href="#1-4-Redis支持哪些数据类型" class="headerlink" title="1.4 Redis支持哪些数据类型"></a>1.4 Redis支持哪些数据类型</h2><p>对象：</p>
<ul>
<li><p>字符串对象，支持int、raw、embstr编码</p>
<ul>
<li><p>int针对整数</p>
</li>
<li><p>raw较长的字符串，分为redisObject和sdshdr</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103112837.png" style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
</li>
<li><p>embstr较短的字符串，redisObject和sdshdr同时分配，挨在一起</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103113250.png" style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
</li>
</ul>
</li>
<li><p>列表对象，支持ziplist和linkedlist编码</p>
<ul>
<li><p>ziplist<strong>压缩列表每个节点(entry)只保存一个列表元素</strong></p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103132547.png" style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
</li>
<li><p><code>linkedlist</code>双端链表，嵌套编码，链表下面还嵌入了字符类型</p>
</li>
</ul>
</li>
<li><p>哈希对象，支持ziplist和hashtable</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103133909.png"  style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103134109.png"  style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
</li>
<li><p>集合对象，支持intset和hashtable</p>
<ul>
<li><code>intset</code> 编码时，元素将被密集得堆叠在位上</li>
<li><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103134827.png"  style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></li>
</ul>
</li>
<li><p>有序集合对象，支持ziplist和skiplist</p>
<p><code>skiplist</code> 编码的有序集合对象使用 <code>zset</code> 结构作为底层实现， 一个 <code>zset</code> 结构同时<strong>包含一个字典和一个跳跃表</strong></p>
<p>起作用主要是跳跃表，字典是辅助加速用。<strong>字典的键记录了元素的成员，而值则保存了元素的分值</strong>。通过字典，能实现$O(1)$复杂度的查找给定成员分值。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200103140005.png"  style="zoom:80%;display: block; margin: 0px auto; vertical-align: middle;"></p>
</li>
</ul>
<h1 id="2-缓存相关"><a href="#2-缓存相关" class="headerlink" title="2. 缓存相关"></a>2. 缓存相关</h1><h2 id="2-1-什么是缓存雪崩？"><a href="#2-1-什么是缓存雪崩？" class="headerlink" title="2.1 什么是缓存雪崩？"></a>2.1 什么是缓存雪崩？</h2><p>首先，为什么要使用缓存？</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200113150533.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<p>缓存区域的大小是有限的，为了避免数量膨胀，redis采取了<a href="https://jiangren.work/2020/01/04/Redis设计与实现3-数据库/#3-过期键">过期删除策略</a>。但是如果缓存数据设置的过期时间是相同的，会导致这些缓存<strong>同时失效</strong>，所有请求全部跑向数据库，造成巨大冲击。这就是<strong>缓存雪崩</strong>。</p>
<p>发生的原因可能是：</p>
<ul>
<li>Redis挂掉。</li>
<li>由于过期键时间问题，导致同时失效。</li>
</ul>
<h2 id="2-2-如何解决缓存雪崩？"><a href="#2-2-如何解决缓存雪崩？" class="headerlink" title="2.2 如何解决缓存雪崩？"></a>2.2 如何解决缓存雪崩？</h2><p>对于过期键失效问题：</p>
<ul>
<li>在缓存的时候给过期时间加上一个<strong>随机值</strong>，这样就会大幅度的<strong>减少缓存在同一时间过期</strong>。</li>
</ul>
<p>对于redis挂掉的问题：</p>
<ul>
<li>主从服务器+sentinel+集群模式，保证有继承人存在，及时推举。</li>
<li>如果redis真的挂了，可以设置<strong>本地缓存+限流</strong></li>
<li>事发后，利用持久化特性，尽快从磁盘上加载数据，恢复缓存。</li>
</ul>
<h2 id="2-3-什么是缓存穿透？"><a href="#2-3-什么是缓存穿透？" class="headerlink" title="2.3 什么是缓存穿透？"></a>2.3 什么是缓存穿透？</h2><p>缓存穿透是指查询一个一定<strong>不存在的数据</strong>。由于缓存不命中，并且出于容错考虑，如果从<strong>数据库查不到数据则不写入缓存</strong>，这将导致这个不存在的数据<strong>每次请求都要到数据库去查询</strong>，失去了缓存的意义。</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200113152209.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<h2 id="2-4-如何解决缓存穿透？"><a href="#2-4-如何解决缓存穿透？" class="headerlink" title="2.4 如何解决缓存穿透？"></a>2.4 如何解决缓存穿透？</h2><ul>
<li>使用<strong>布隆过滤器</strong></li>
<li>当我们从数据库找不到的时候，我们也将这个<strong>空对象设置到缓存里边去</strong>。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个<strong>较短的过期时间</strong></li>
</ul>
<p>布隆过滤器的原理解释<a href="https://zhuanlan.zhihu.com/p/43263751。" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43263751。</a></p>
<h2 id="2-5-如何解决缓存与数据库双写不一致？"><a href="#2-5-如何解决缓存与数据库双写不一致？" class="headerlink" title="2.5 如何解决缓存与数据库双写不一致？"></a>2.5 如何解决缓存与数据库双写不一致？</h2><p>在写更新数据时，我们要进行两步操作：<strong>删除缓存</strong>和<strong>更新数据库</strong>（一般不使用更新缓存，都是直接删除），现在的问题就是：这两步先做哪一个？</p>
<ol>
<li>先更新数据库，再删除缓存</li>
<li>先删除缓存，再更新数据库</li>
</ol>
<p><strong>如果是1</strong>，则</p>
<ul>
<li>当原子性破坏时（更新了库，没删缓存），<strong>导致数据不一致</strong></li>
<li>并发场景<strong>出现问题的概率较低</strong>，仅发生在<strong>缓存失效时</strong><ol>
<li>线程A查询数据库，得到旧值</li>
<li>线程B将新值写入数据库</li>
<li>线程B删除缓存</li>
<li>线程A将查到的旧值写入缓存</li>
</ol>
</li>
</ul>
<p>为什么说发生概率低呢？</p>
<ul>
<li>仅发生在缓存失效时</li>
<li><strong>写入数据库的操作一般比较慢</strong>，c一般会慢于d。</li>
</ul>
<p><strong>如果是2</strong>，则：</p>
<ul>
<li>原子性被破坏时，不影响一致性</li>
<li>并发时，问题很大<ol>
<li>线程A删除缓存</li>
<li>线程B查询时缓存不存在，于是到数据库取了一个旧值</li>
<li>线程B将旧值写入缓存</li>
<li>线程A将新值写入数据库</li>
</ol>
</li>
</ul>
<p>如何保证并发下的一致呢？</p>
<p>将删除缓存、修改数据库、读取缓存等的操作积压到<strong>队列</strong>里边，实现<strong>串行化</strong>。</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200113154703.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<h1 id="3-线程模型"><a href="#3-线程模型" class="headerlink" title="3. 线程模型"></a>3. 线程模型</h1><h2 id="3-1-为什么Redis是单线程？"><a href="#3-1-为什么Redis是单线程？" class="headerlink" title="3.1 为什么Redis是单线程？"></a>3.1 为什么Redis是单线程？</h2><p>首先CPU的性能并不是瓶颈，主要考虑本地内存和网络带宽。其次，单线程可以避免线程切换的资源消耗和竞争问题，有利于性能提升。</p>
<h2 id="3-2-介绍一下IO多路复用"><a href="#3-2-介绍一下IO多路复用" class="headerlink" title="3.2 介绍一下IO多路复用"></a>3.2 介绍一下IO多路复用</h2><p>IO多路复用的原理是：存在一个接线员，当有客户连接时，接线员接收连接，分派到制定执行函数，然后接着监听。这样就可以避免处理某一个连接而阻塞其他用户的情况。</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200113160426.png"/></p>
<hr>
<p>Redis的I/O多路复用程序的所有功能都是<strong>通过包装常见的select、epoll这些I/O多路复用函数库来实现的</strong>。由于IO复用程序提供了统一的接口，所以<strong>底层实现方法可以互换。</strong></p>
<h2 id="3-3-介绍一下redis线程模型的处理流程"><a href="#3-3-介绍一下redis线程模型的处理流程" class="headerlink" title="3.3 介绍一下redis线程模型的处理流程"></a>3.3 介绍一下redis线程模型的处理流程</h2><p>Redis网络事件处理器称为<strong>文件事件处理器（file event handler）</strong>，包括：</p>
<ul>
<li>套接字</li>
<li>IO复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器</li>
</ul>
<p>事件处理器包括：</p>
<ul>
<li>连接应答处理器</li>
<li>命令请求处理器</li>
<li>命令回复处理器</li>
</ul>
<p>详情参见<a href="https://jiangren.work/2020/01/05/Redis设计与实现5-事件/#1-2-IO多路复用程序的实现">事件处理器讲解</a></p>
<h1 id="4-数据删除与淘汰机制"><a href="#4-数据删除与淘汰机制" class="headerlink" title="4. 数据删除与淘汰机制"></a>4. 数据删除与淘汰机制</h1><h2 id="4-1-介绍一下redis的过期删除策略"><a href="#4-1-介绍一下redis的过期删除策略" class="headerlink" title="4.1 介绍一下redis的过期删除策略"></a>4.1 介绍一下redis的过期删除策略</h2><p><strong>（1）惰性删除</strong></p>
<p>放着不管，每次从键空间获取时检查是否过期，过期就删除。</p>
<p><strong>对CPU最友好</strong>，<strong>但浪费内存</strong>。如果数据库中有很多过期键，而这些过期键永远也不会被访问的话，他们就会永远占据空间，可视为<strong>内存泄漏</strong>。比如一些和时间有关的数据（日志）。</p>
<p><strong>（2）定期删除</strong></p>
<p>每隔一段时间，程序检查一次数据库，删除过期键。</p>
<p><strong>对CPU和内存是一种折中</strong>。通过选择较为空闲的时间点来处理过期键，减少CPU压力。同时也能及时释放内存，避免内存泄漏。</p>
<p>在redis中由周期函数severCron负责，它在规定的时间内，<strong>分多次遍历服务器中的各个数据库</strong>，从数据库的expires字典中<strong>随机检查一部分键的过期时间</strong>，并删除其中的过期键。他会记录检查进度，在<strong>下一次检查时接着上一次的进度进行处理</strong>。比如说，如果当前函数在遍历10号数据库时返回了，那么下次就会从11号数据库开始工作。</p>
<h2 id="4-2-介绍一下Redis的内存淘汰机制"><a href="#4-2-介绍一下Redis的内存淘汰机制" class="headerlink" title="4.2 介绍一下Redis的内存淘汰机制"></a>4.2 介绍一下Redis的内存淘汰机制</h2><p>惰性删除和定期删除依然可能保留大量过期键，这时候需要用到内存淘汰机制。内存淘汰机制有6个：</p>
<ul>
<li><strong>noeviction</strong>：eviction是驱逐的意思，当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，移除最近最少使用的 key :ok_hand::ok_hand:</li>
<li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，随机移除某个 key。</li>
<li><strong>volatile-lru</strong>：[ˈvɒlətaɪl]易挥发的，易丢失的。当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，移除最近最少使用的 key。</li>
<li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，<strong>随机移除</strong>某个 key。:ok_hand:</li>
<li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，有<strong>更早过期时间</strong>的 key 优先移除。:ok_hand:</li>
</ul>
<h2 id="4-3-写一个LRU算法"><a href="#4-3-写一个LRU算法" class="headerlink" title="4.3 写一个LRU算法"></a>4.3 写一个LRU算法</h2><p>我的博客有总结，是一道Leetcode题目，C++版本：</p>
<p><a href="https://jiangren.work/2019/09/05/Leetcode题目总结7-容器的应用/">Leetcode146-LRU缓存机制</a></p>
<h1 id="5-Redis高并发和高可用"><a href="#5-Redis高并发和高可用" class="headerlink" title="5. Redis高并发和高可用"></a>5. Redis高并发和高可用</h1><h2 id="5-1-Redis的高并发是如何实现的？"><a href="#5-1-Redis的高并发是如何实现的？" class="headerlink" title="5.1 Redis的高并发是如何实现的？"></a>5.1 Redis的高并发是如何实现的？</h2><p>首先<strong>从程序编写的角度上</strong>来说，</p>
<ul>
<li>Redis是纯内存数据库，读写速度快，</li>
<li>采用了非阻塞IO复用，</li>
<li>采用了优秀的数据结构设计，</li>
</ul>
<p>然后，<strong>从布局架构上</strong>来说，实现<strong>高并发</strong>主要依靠<strong>主从架构</strong>（<strong>单线程多进程</strong>），比如<strong>单机写数据，多机查数据</strong>。单机能达到几万QPS(queries per sec)，多个从实例能达到10W的QPS。</p>
<p>更进一步，可以采用集群，不仅能实现高并发，还能容纳大量数据。</p>
<h2 id="5-2-Redis的高可用是如何实现的？"><a href="#5-2-Redis的高可用是如何实现的？" class="headerlink" title="5.2 Redis的高可用是如何实现的？"></a>5.2 Redis的高可用是如何实现的？</h2><p>高可用性指<strong>系统无中断地执行其功能的能力</strong>。Redis实现高可用依靠的是Sentinel哨兵机制。Sentinel<strong>本质上只是一个运行在特殊模式下的Redis服务器</strong>，是一个进程。</p>
<p><strong>Sentinel作用：</strong></p>
<ul>
<li>监控Redis整体是否正常运行。</li>
<li>某个节点出问题时，<strong>通知给其他进程</strong>（比如他的客户端）。</li>
<li>主服务器下线时，在从服务器中<strong>选举</strong>出一个新的主服务器。</li>
</ul>
<p><strong>Sentinel互相监督：</strong></p>
<ol>
<li>Sentinel和服务器之间建立hello频道连接</li>
<li>Sentinel在hello频道发送信息时会被其他Sentinel发现，达到握手的目的。</li>
<li>发现后，Sentinel之间建立连接，形成环形网络。</li>
</ol>
<p><strong>Sentinel监督下线：</strong></p>
<ul>
<li>按频率向所有创建连接的实例发送PING，查看是否回复PONG来判断是否在线，不回复则<strong>标记为主观下线状态</strong>。</li>
<li>向其他Sentinel询问，如果足够数量的Sentinel也标记为下线状态，则改为<strong>客观下线</strong>。</li>
</ul>
<p><strong>Sentinel应对服务器下线的补救措施：</strong></p>
<p><strong>（1）选举领头的Sentinel</strong></p>
<p>过程：一个Sentinel向另一个Sentinel发送设置请求命令。<strong>最先向目标Sentinel</strong>发送设置要求的源Sentinel将成为目标Sentinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝。</p>
<p>如果有某个Sentinel<strong>被半数</strong>以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel。</p>
<p><strong>（2）故障转移</strong></p>
<ol>
<li>从已下线的主服务器的从服务器中<strong>拔举</strong>一个作为主服务器。标准：<strong>偏移量最大</strong></li>
<li>让已下线主服务器属下的所有从服务器改为复制新的主服务器</li>
<li>将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</li>
</ol>
<h1 id="6-多机架构"><a href="#6-多机架构" class="headerlink" title="6. 多机架构"></a>6. 多机架构</h1><h2 id="6-1-Redis有哪些多机架构？"><a href="#6-1-Redis有哪些多机架构？" class="headerlink" title="6.1 Redis有哪些多机架构？"></a>6.1 Redis有哪些多机架构？</h2><p>不考虑中间件，原生的架构有<strong>主从复制架构</strong>和<strong>集群架构</strong>。</p>
<h2 id="6-2-介绍一下复制过程"><a href="#6-2-介绍一下复制过程" class="headerlink" title="6.2 介绍一下复制过程"></a>6.2 介绍一下复制过程</h2><p>Redis中复制有新老两版。</p>
<p>老版：分为同步和命令传播两个阶段。</p>
<hr>
<p><strong>老版：</strong></p>
<p><strong>在同步阶段：</strong></p>
<ol>
<li>从机向主机发送SYNC命令</li>
<li>主机收到后，执行BGSAVE生成RDB文件，并使用缓冲区记录现在开始执行的所有写操作。</li>
<li>将RDB文件发给从服务器</li>
<li>将缓冲区内容发送给从服务器</li>
</ol>
<p><strong>在命令传播阶段：</strong></p>
<p>主服务器将自己执行的写命令发送给从服务器，让他执行相同的命令</p>
<p><strong>缺陷：</strong></p>
<p>初次复制效果较好，但断线后重连复制效率很低，需要全部重录RDB文件。</p>
<hr>
<p><strong>新版：</strong></p>
<p>分为完整重同步和部分重同步，前者和旧版一样。部分重同步有三个部分：</p>
<ul>
<li>主从服务器的复制偏移量</li>
<li>主服务器的复制积压缓冲区</li>
<li>服务器的运行ID</li>
</ul>
<p>主服务器和从服务器会分别维护一个复制偏移量，<strong>通过对比偏移量来知道主从服务器是否处于一致状态</strong>：</p>
<ul>
<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。</li>
<li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。</li>
</ul>
<p>复制积压缓冲区是由主服务器维护的一个<strong>固定长度</strong>（fixed-size）先进先出（FIFO）队列。当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会<strong>将写命令入队到复制积压缓冲区里面</strong>。同时，主服务器也会向积压缓冲区添加偏移量。重新上线时根据偏移量决定如何重同步：</p>
<ul>
<li>下线后，数据长度超过了缓冲区，导致溢出，说明下线时间太长，执行完全重同步。</li>
<li>否则，部分重同步。</li>
</ul>
<p>而主服务器ID则帮助重新上线的从服务器识别，</p>
<ul>
<li>如果ID和从服务器记录的相同，则表示<strong>之前同步的主服务器就是这个</strong>，执行部分重同步。</li>
<li>如果ID不同，则表明从<strong>服务器断线之前复制的主服务器并不是当前连接的这个主服务器</strong>，执行完整重同步操作。</li>
</ul>
<h2 id="6-3-介绍一下集群"><a href="#6-3-介绍一下集群" class="headerlink" title="6.3 介绍一下集群"></a>6.3 介绍一下集群</h2><p>集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能，保证高可用性。</p>
<p><strong>集群的结构</strong>是：多个节点（node）组成一个集群，节点是Redis中数据存储的单位，在刚开始的时候，每个节点都是相互独立的。通过<code>CLUSTER MEET</code>命令相互握手，组成集群。</p>
<p><strong>集群数据的存储方式</strong>是：集群的整个数据库被分一万多个槽（slot）<strong>，</strong>数据库中的每个键都属于槽的其中一个。<strong>当所有槽都有节点在处理时，集群处于上线状态</strong>。</p>
<h2 id="6-4-集群的通信方式是怎样的？"><a href="#6-4-集群的通信方式是怎样的？" class="headerlink" title="6.4 集群的通信方式是怎样的？"></a>6.4 集群的通信方式是怎样的？</h2><p>集群依靠消息通信，消息有5种：MEET, PING, PONG, FAIL, PUBLISH。</p>
<p>Redis集群中的各个节点通过<strong>Gossip协议</strong>来交换各自关于不同节点的状态信息，其中Gossip协议由MEET、PING、PONG三种消息实现。</p>
<hr>
<p>所谓Gossip是八卦消息的意思，在Redis中，发送每次发送MEET、PING、PONG消息时，发送者都从自己的已知节点列表中<strong>随机选出两个节点</strong>（可以是主节点或者从节点），保存到一个特殊结构体中。</p>
<p>接受者接收到MEET、PING、PONG消息时，根据保存的两个节点是否认识来选择进行哪种操作：</p>
<ul>
<li>不认识，说明接收者<strong>第一次接触被选中节点</strong>，则接收者与被选中节点握手</li>
<li>认识，根据结构信息进行更新。</li>
</ul>
<p>比如A节点发送的PING给B，携带了CD两个节点，然后B回复PONG携带了EF两个节点，这样就完成了ABCDEF六个节点的信息交换。<strong>每个节点按照周期向不同节点传播PING-PONG信息，就能完成整个集群的状态更新。</strong></p>
<hr>
<p>如果节点很多，则Gossip消息比较慢，而主节点下线的消息需要立即通知给所有人。FAIL消息的正文只包含已下线的节点名称，直接通知给所有已知节点。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.cnbj1.fds.api.mi-img.com/book/images/fcccd0065c411e2492d097f9bb0fb378?thumb=1&w=1024&h=1024" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.cnbj1.fds.api.mi-img.com/book/images/7fb4b031c86ff72f6478b8e16718b43d?thumb=1&w=1024&h=1024" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<hr>
<p>接收到PUBLISH命令的节点<strong>不仅会向channel频道发送消息message，它还会向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会向channel频道发送message消息</strong>。</p>
<p>也就是说，向集群发送<code>PUBLISH</code>，会导致集群所有节点都向channel发送message消息。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200112133931.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="6-5-集群分片的原理是什么"><a href="#6-5-集群分片的原理是什么" class="headerlink" title="6.5 集群分片的原理是什么?"></a>6.5 集群分片的原理是什么?</h2><p>Redis引入了哈希槽的概念，<strong>通过槽指派的方式存储数据</strong>。</p>
<p>Redis集群有$2^{14}=16384$个哈希槽,<strong>每个key通过CRC16校验后对16384取模来决定放置哪个槽</strong><code>slot = CRC16(key) &amp; 16383</code>，集群的每个节点负责一部分hash槽。</p>
<p><strong>使用哈希槽的好处就在于可以方便的添加或移除节点。</strong></p>
<ol>
<li>当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；</li>
<li>当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了。</li>
</ol>
<p>CRC16算法能分配65535个槽位，但作为包发送太臃肿，一般情况下一个redis集群不会有超过1000个master节点，所以采用$1/4$</p>
<h2 id="6-6-集群扩容和收缩是怎么实现的？"><a href="#6-6-集群扩容和收缩是怎么实现的？" class="headerlink" title="6.6 集群扩容和收缩是怎么实现的？"></a>6.6 集群扩容和收缩是怎么实现的？</h2><p>集群的伸缩是通过重新分片的方式实现的，重新分片操作可以将<strong>任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点）</strong>，并且相关槽所属的键值对也会从源节点被移动到目标节点。</p>
<p>重新分片操作可以<strong>在线（online）进行</strong>，在重新分片的过程中，集群不需要下线，并且<strong>源节点和目标节点都可以继续处理命令请求</strong>。</p>
<p>//以下可以略</p>
<p>重新分片由redis-trib负责，步骤如下：</p>
<ol>
<li>trib向源节点发送命令，包含了执行迁移的槽slot，要迁移键的数量count。</li>
<li>源节点返回属于槽slot的count个键。</li>
<li>对于每个返回键，trib向源节点发送一个MIGRATE命令</li>
<li>源节点根据MIGRATE命令将键迁移到目标节点，</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200112105535.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>如果多槽，则分别对不同槽执行多次。</p>
<h1 id="7-持久化"><a href="#7-持久化" class="headerlink" title="7. 持久化"></a>7. 持久化</h1><h2 id="7-1-为什么采用持久化？"><a href="#7-1-为什么采用持久化？" class="headerlink" title="7.1 为什么采用持久化？"></a>7.1 为什么采用持久化？</h2><p>持久化有两个作用：方便主从复制和灾难恢复。</p>
<p>由于Redis的数据全都放在内存而不是磁盘里面，如果Redis挂了，没有配置持久化的话，重启的时候数据会全部丢失。所以需要将数据写入磁盘，本地化保存。</p>
<h2 id="7-2-持久化的方式有哪些？"><a href="#7-2-持久化的方式有哪些？" class="headerlink" title="7.2 持久化的方式有哪些？"></a>7.2 持久化的方式有哪些？</h2><p>有RDB持久化和AOF持久化。</p>
<hr>
<p>RDB持久化：</p>
<p>将数据库状态以RDB文件格式保存。可以采用SAVE命令<strong>阻塞</strong>服务器进程，也可以用BGSAVE命令fork一个子进程。</p>
<p>通过周期性函数serverCron不断的判断保存条件，如果条件满足就保存。</p>
<hr>
<p>AOF持久化：</p>
<p>AOF(Append Only File)<strong>记录Redis服务器所执行的写命令</strong>。AOF实现原理是<strong>命令追加</strong>和<strong>文件写入同步</strong>，</p>
<ul>
<li>命令追加：服务器执行完一个命令后，会以协议格式将命令<strong>追加到服务器状态aof_buf缓冲区的结尾</strong></li>
<li>文件写入同步：服务器每次结束一个事件循环之前都<strong>考虑是否需要将<code>aof_buf</code>缓冲区中的内容写入和保存到AOF文件里面</strong>。</li>
</ul>
<p>AOF还原时需要建立一个<strong>不带网络连接的伪客户端</strong>，因为<strong>Redis的命令只能在客户端上下文中执行。</strong></p>
<h2 id="7-3-AOF的重写是什么意思？"><a href="#7-3-AOF的重写是什么意思？" class="headerlink" title="7.3 AOF的重写是什么意思？"></a>7.3 AOF的重写是什么意思？</h2><p>随着时间的增长，AOF文件的大小将会越来越大。通过重写，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个<strong>AOF文件保存的数据库状态完全相同</strong>，但新的文件体积更小。</p>
<p>重写的策略是：<strong>从数据库中读取键现在的值，然后用一条命令去记录键值对</strong>。相当于折叠命令，只求最终结果。</p>
<p>此外，子进程AOF重写时，主进程也在写命令，导致两者状态不一致。因此，<strong>Redis服务器设置了一个AOF重写缓冲区</strong>，当Redis服务器执行完一个写命令之后，它会<strong>同时</strong>将这个写命令发送给<strong>AOF缓冲区</strong>和<strong>AOF重写缓冲区</strong>。</p>
<h2 id="7-4-AOF和RDB优劣势比较"><a href="#7-4-AOF和RDB优劣势比较" class="headerlink" title="7.4 AOF和RDB优劣势比较"></a>7.4 AOF和RDB优劣势比较</h2><p>RDB</p>
<p>优势：完整，恢复迅速</p>
<p>劣势：消耗资源大，每次保存的间隔周期长，丢失数据多</p>
<hr>
<p>AOF</p>
<p>优势：保存间隔短，丢失数据少，系统资源消耗少。保存格式清晰，适合误操作的恢复。</p>
<p>劣势：恢复速度较慢，需要建立伪客户端，如果发生崩溃的情况需要尽快恢复，最好采用RDB。重写后数据保存不一定完整，可能有BUG。</p>
<h1 id="8-事务"><a href="#8-事务" class="headerlink" title="8. 事务"></a>8. 事务</h1><h2 id="8-1-什么是事务？"><a href="#8-1-什么是事务？" class="headerlink" title="8.1 什么是事务？"></a>8.1 什么是事务？</h2><p>Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能。事务将<strong>一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制</strong>，并且在事务执行期间，<strong>服务器不会中断事务</strong>而改去执行其他客户端的命令请求。</p>
<h2 id="8-2-Redis中事务是如何实现的？"><a href="#8-2-Redis中事务是如何实现的？" class="headerlink" title="8.2 Redis中事务是如何实现的？"></a>8.2 Redis中事务是如何实现的？</h2><p>事务从开始到结束经历三个阶段：</p>
<ol>
<li>事务开始</li>
<li>事务入队</li>
<li>事务执行</li>
</ol>
<hr>
<p>通过MULTI命令可以将执行该命令的客户端<strong>从非事务状态切换至事务状态</strong>，在是事务状态下，</p>
<ul>
<li>如果客户端发送EXEC，DISCARD，WATCH，MULTI这四个命令，则立即执行。</li>
<li>如果发送的是其他命令，则放到事务队列里面，向客户端返回QUEUED回复。</li>
</ul>
<hr>
<p>每个Redis客户端都有自己的<strong>事务状态结构体</strong>，每个结构体中又包含了一个<strong>事务队列</strong>和<strong>已入队命令计数器。</strong>在事务队列中包含了<strong>具体的命令cmd</strong>。</p>
<hr>
<p>当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。<strong>服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</strong>过程是：</p>
<ol>
<li>创建空白回复队列</li>
<li>抽取一条命令，读取参数、参数个数以及要执行的函数</li>
<li>行命令，取得返回值</li>
<li>将返回值追加到1中的队列末尾，重复步骤2</li>
<li>完成后，清除事务标志，回到非事务状态，同时清空计数器和释放事务队列。</li>
</ol>
<h2 id="8-3-事务中的乐观锁是什么？"><a href="#8-3-事务中的乐观锁是什么？" class="headerlink" title="8.3 事务中的乐观锁是什么？"></a>8.3 事务中的乐观锁是什么？</h2><p>乐观锁，也称CAS(check and set)，属于无罪推定原则，每次别人拿数据都假定他不修改，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。</p>
<p>悲观锁则是每次读取都会加锁。</p>
<p>Redis中通过WATCH来实现，它可以<strong>在EXEC命令执行之前</strong>，<strong>监视任意数量的数据库键</strong>，并在EXEC命令执行时，<strong>检查被监视的键是否被其他客户修改过，</strong>如果是的话，<strong>服务器将拒绝执行事务</strong>，并向客户端返回代表事务执行失败的空回复。</p>
<h2 id="8-4-WATCH命令的原理是什么？"><a href="#8-4-WATCH命令的原理是什么？" class="headerlink" title="8.4 WATCH命令的原理是什么？"></a>8.4 WATCH命令的原理是什么？</h2><p>每个Redis数据库都保存着一个<code>watched_keys</code>字典，这个字典的<strong>键是某个被WATCH命令监视的数据库键</strong>，而<strong>字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端</strong>。</p>
<p>对数据库<strong>执行修改命令</strong>时，会对字典进行检查。<strong>查看当前命令修改的键是否在<code>watched_keys</code>字典中</strong>，如果有，且事务标志被打开<strong>，表示该客户端的事务安全性已经被破坏</strong>。将<code>REDIS_DIRTY_CAS</code>标识打开。</p>
<p>在EXEC命令执行时，检查<code>REDIS_DIRTY_CAS</code>标志是否打开判断是否应该执行。</p>
<h2 id="8-5-解释一下事务的ACID性质"><a href="#8-5-解释一下事务的ACID性质" class="headerlink" title="8.5 解释一下事务的ACID性质"></a>8.5 解释一下事务的ACID性质</h2><p>所谓ACID性质是指：<strong>有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、耐久性（Durability）。</strong></p>
<p><strong>原子性</strong>：事务在执行前用WATCH检查，命令有没有被插入执行过。</p>
<p><strong>一致性</strong>：<strong>入队错误</strong>：事务入队时命令格式不正确，则Redis拒绝执行；<strong>执行错误</strong>：执行时操作不正确，会被服务器识别，并做错误处理，所以这些出错命令不会对数据库做任何修改；<strong>停机后</strong>根据持久化，也能还原为一致状态。</p>
<p><strong>隔离性</strong>：单线程，且事务不会被打断，串行的方式保证不同事务的隔离性（不保证键不会冲突）</p>
<p><strong>耐久性</strong>：不一定，得看哪种持久化，只有always模式下的AOF才有。（每次执行命令都会调用同步函数）</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        

        
        文章发布地址：<a href="/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/" target="_blank" rel="external">jiangren.work/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/</a>
        
    </div>
    
    <footer>
        <a href="jiangren.work">
            <img src="/img/fong.jpg" alt="Jiang Ren">
            Jiang Ren
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/" rel="tag">面试经验</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=jiangren.work/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/&title=《Redis面试常见基本问题》 — JR's Blog&pic=jiangren.work/img/fong.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=jiangren.work/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/&title=《Redis面试常见基本问题》 — JR's Blog&source=redis的原理性问题总结。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=jiangren.work/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Redis面试常见基本问题》 — JR's Blog&url=jiangren.work/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/&via=jiangren.work" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=jiangren.work/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/01/16/Redis%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Redis的简单应用场景总结</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/01/08/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B012-Lua%E8%84%9A%E6%9C%AC/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Redis设计与实现12-Lua脚本</h4>
      </a>
    </div>
  
</nav>



    





















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持！
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/true" alt="打赏二维码">
        </div>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


            <p>
                
                    <span>
                        <a href="/atom.xml" target="_blank" class="rss" title="rss">
                            <i class="icon icon-lg icon-rss"></i>
                        </a>
                    </span>
                    
                        <span>
                            博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
                        </span>
            </p>
    </div>
    <div class="bottom">
        <p>
            <span>
                Jiang Ren &copy;
                    
                        2019 -
                            
                                2020
            </span>
            <span>
                
                        Power by
                        <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
                        <a href="https://github.com/abelsu7/hexo-theme-indigo-plus" target="_blank">indigo plus</a>
                        <p>Hosted by <a href="https://pages.github.com" target="_blank" style="font-weight: bold">Github Pages</a></p>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>
<a href="javascript:;" id="gobottom" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-comments"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=jiangren.work/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/&title=《Redis面试常见基本问题》 — JR's Blog&pic=jiangren.work/img/fong.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=jiangren.work/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/&title=《Redis面试常见基本问题》 — JR's Blog&source=redis的原理性问题总结。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=jiangren.work/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Redis面试常见基本问题》 — JR's Blog&url=jiangren.work/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/&via=jiangren.work" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=jiangren.work/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=jiangren.work/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/" alt="微信分享二维码">
</div>




    <script src="//cdn.jsdelivr.net/npm/node-waves@0.7.6/src/js/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<!-- <script async src="//cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script> -->
<!-- <script async src="//cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script> -->




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="/js/prism.min.js?v=1.7.2"></script>
<script src="/js/prism-vim.min.js?v=1.7.2"></script>
</body>
</html>
