<!DOCTYPE html>
<html>
<head>
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'true', 'auto');
ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!-- End Google Analytics -->


    

    



    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="google-site-verification=6xKBD4e783W5YvEkBJE-d7v5QxyEqF7MRInlhMNq8YU">
    
    
    
    
    <title>CPP多线程总结3-同步异步并发 | JR&#39;s Blog | 直挂云帆济沧海</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="C++,读书笔记,并发">
    <meta name="description" content="以同步或异步的方式实现并发。">
<meta property="og:type" content="article">
<meta property="og:title" content="CPP多线程总结3-同步异步并发">
<meta property="og:url" content="jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/">
<meta property="og:site_name" content="JR&#39;s Blog">
<meta property="og:description" content="以同步或异步的方式实现并发。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191116132353.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191116132408.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191117101811.png">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191117101934.png">
<meta property="article:published_time" content="2019-12-27T07:35:10.000Z">
<meta property="article:modified_time" content="2019-12-30T21:21:32.000Z">
<meta property="article:author" content="Jiang Ren">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="读书笔记">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191116132353.png">
    
        <link rel="alternate" type="application/atom+xml" title="JR&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <link rel="stylesheet" href="/css/prism/prism-tomorrow-night.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-list-ul"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/MapleStory.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/fong.jpg" style="max-width: 100%;">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Jiang Ren</h5>
          <a href="mailto:jiangren@whu.edu.cn" title="jiangren@whu.edu.cn" class="mail">jiangren@whu.edu.cn</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives/"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/JiangRRRen" target="_blank" rel="noopener"  >
                <i class="icon icon-lg icon-github"></i>
                代码
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">CPP多线程总结3-同步异步并发</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">CPP多线程总结3-同步异步并发</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-12-27T07:35:10.000Z" itemprop="datePublished" class="page-time">
  2019-12-27
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-条件等待"><span class="post-toc-text">1. 条件等待</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-1-达成等待条件"><span class="post-toc-text">1.1 达成等待条件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-2-实战示例：使用等待条件构建线程安全队列"><span class="post-toc-text">1.2 实战示例：使用等待条件构建线程安全队列</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-期望等待"><span class="post-toc-text">2. 期望等待</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-1-std-async"><span class="post-toc-text">2.1 std::async</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-2-std-packaged-task-lt-gt"><span class="post-toc-text">2.2 std::packaged_task&lt;&gt;</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-3-std-promise-lt-gt"><span class="post-toc-text">2.3 std::promise&lt;&gt;</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-4-std-shared-future"><span class="post-toc-text">2.4 std::shared_future</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-等待时间"><span class="post-toc-text">3. 等待时间</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-1-时钟"><span class="post-toc-text">3.1 时钟</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-2-时延"><span class="post-toc-text">3.2 时延</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-3-时间点"><span class="post-toc-text">3.3 时间点</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-使用同步操作简化代码"><span class="post-toc-text">4. 使用同步操作简化代码</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-1-期望的函数化编程"><span class="post-toc-text">4.1 期望的函数化编程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-2-持续性并发"><span class="post-toc-text">4.2 持续性并发</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-CPP多线程总结3-同步并发操作"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">CPP多线程总结3-同步异步并发</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-12-27 15:35:10" datetime="2019-12-27T07:35:10.000Z"  itemprop="datePublished">2019-12-27</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>以同步或异步的方式实现并发。<a id="more"></a></p>
<h1 id="1-条件等待"><a href="#1-条件等待" class="headerlink" title="1. 条件等待"></a>1. 条件等待</h1><h2 id="1-1-达成等待条件"><a href="#1-1-达成等待条件" class="headerlink" title="1.1 达成等待条件"></a>1.1 达成等待条件</h2><p>C++标准库对条件变量有两套实现：<code>std::condition_variable</code>和<code>std::condition_variable_any</code>。两者都需要与一个互斥量一起才能工作(互斥量是为了同步)；前者仅限于与<code>std::mutex</code>一起工作，而后者可以和任何满足最低标准的互斥量一起工作。一般默认使用前者。</p>
<p>下面展示了<strong>等待唤醒机制</strong>的使用：</p>
<pre><code class="lang-cpp">std::mutex mut;
std::queue&lt;data_chunk&gt; data_queue;  // 1
std::condition_variable data_cond;

void data_preparation_thread()
{
  while(more_data_to_prepare())
  {
    data_chunk const data=prepare_data();
    std::lock_guard&lt;std::mutex&gt; lk(mut);
    data_queue.push(data);  // 2
    data_cond.notify_one();  // 3
  }
}

void data_processing_thread()
{
  while(true)
  {
    std::unique_lock&lt;std::mutex&gt; lk(mut);  // 4
    data_cond.wait(
         lk,[]{return !data_queue.empty();});  // 5
    data_chunk data=data_queue.front();
    data_queue.pop();
    lk.unlock();  // 6
    process(data);
    if(is_last_chunk(data))
      break;
  }
}
</code></pre>
<p>上面的代码使用一个队列在两个线程间传递数据。</p>
<p>在<code>void data_processing_thread()</code>中，我们要从队列中读取数据，首先4锁住互斥量；5在<code>wait()</code>函数中传递锁和lambda表达式，当判断结果为空时，线程<strong>休眠</strong>。</p>
<p>在<code>void data_preparation_thread()</code>中，2准备好数据后，先锁住互斥量，然后压入队列中；3通过<code>notify_one()</code>函数唤醒，结束后自动析构。</p>
<p>回到<code>void data_processing_thread()</code>中，由于唤醒消息的到来，这个函数重新启动，从头开始上锁、检查。</p>
<h2 id="1-2-实战示例：使用等待条件构建线程安全队列"><a href="#1-2-实战示例：使用等待条件构建线程安全队列" class="headerlink" title="1.2 实战示例：使用等待条件构建线程安全队列"></a>1.2 实战示例：使用等待条件构建线程安全队列</h2><p>我们模仿第二篇讲到的线程安全栈，构建一个线程安全的队列。所谓线程安全就是要像栈那样将<code>top</code>和<code>pop</code>合并。这里提供<code>pop()</code>函数的两个变种：<code>try_pop()</code>和<code>wait_and_pop()</code>。<code>try_pop()</code> ，尝试从队列中弹出数据，即使为空也会直接返回；<code>wait_and_pop()</code>，将会等待有值可检索的时候才返回。接口就可能会是下面这样：</p>
<pre><code class="lang-cpp">template&lt;typename T&gt;
class threadsafe_queue
{
public:
  threadsafe_queue();
  threadsafe_queue(const threadsafe_queue&amp;);
  threadsafe_queue&amp; operator=(
      const threadsafe_queue&amp;) = delete;  // 不允许简单的赋值

  void push(T new_value);

  bool try_pop(T&amp; value);  // 1
  std::shared_ptr&lt;T&gt; try_pop();  // 2

  void wait_and_pop(T&amp; value);
  std::shared_ptr&lt;T&gt; wait_and_pop();

  bool empty() const;
};
</code></pre>
<p>和之前一样，也需要提供两个版本的<code>try_pop()</code>和<code>wait_for_pop()</code>。第一个重载的<code>try_pop()</code>①在引用变量中存储着检索值，所以它可以用来返回队列中值的状态；当检索到一个变量时，他将返回true，否则将返回false。第二个重载②就不能做这样了，因为它是用来直接返回检索值的。当没有值可检索时，这个函数可以返回<code>NULL</code>指针。</p>
<p>完整版如下：</p>
<pre><code class="lang-cpp">template&lt;typename T&gt;
class threadsafe_queue
{
private:
  mutable std::mutex mut;  // 1 互斥量必须是可变的 
  std::queue&lt;T&gt; data_queue;
  std::condition_variable data_cond;
public:
  threadsafe_queue()
  {}
  threadsafe_queue(threadsafe_queue const&amp; other)
  {
    std::lock_guard&lt;std::mutex&gt; lk(other.mut);
    data_queue=other.data_queue;
  }

  void push(T new_value)
  {
    std::lock_guard&lt;std::mutex&gt; lk(mut);
    data_queue.push(new_value);
    data_cond.notify_one();
  }

  void wait_and_pop(T&amp; value)
  {
    std::unique_lock&lt;std::mutex&gt; lk(mut);
    data_cond.wait(lk,[this]{return !data_queue.empty();});
    value=data_queue.front();
    data_queue.pop();
  }

  std::shared_ptr&lt;T&gt; wait_and_pop()
  {
    std::unique_lock&lt;std::mutex&gt; lk(mut);
    data_cond.wait(lk,[this]{return !data_queue.empty();});
    std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(data_queue.front()));
    data_queue.pop();
    return res;
  }

  bool try_pop(T&amp; value)
  {
    std::lock_guard&lt;std::mutex&gt; lk(mut);
    if(data_queue.empty())
      return false;
    value=data_queue.front();
    data_queue.pop();
    return true;
  }

  std::shared_ptr&lt;T&gt; try_pop()
  {
    std::lock_guard&lt;std::mutex&gt; lk(mut);
    if(data_queue.empty())
      return std::shared_ptr&lt;T&gt;();
    std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(data_queue.front()));
    data_queue.pop();
    return res;
  }

  bool empty() const
  {
    std::lock_guard&lt;std::mutex&gt; lk(mut);
    return data_queue.empty();
  }
};
</code></pre>
<p>当新的数据准备完成，调用<code>notify_one()</code>将会触发<strong>一个</strong>正在执行<code>wait()</code>的线程，去检查条件和<code>wait()</code>函数的返回状态。 这里不保证线程一定会被通知到，即使只有一个等待线程收到通知，所有处理线程也有可能仍然在处理数据，而忽略了这个通知。</p>
<p>在<strong>定期重新初始化(periodic reinitialization)</strong>情况下，线程准备数据数据时，就会通过条件变量调用<code>notify_all()</code>成员函数，而非直接调用<code>notify_one()</code>函数。顾名思义，这就是<strong>全部线程</strong>在都去执行<code>wait()</code>(检查他们等待的条件是否满足)的原因。</p>
<h1 id="2-期望等待"><a href="#2-期望等待" class="headerlink" title="2. 期望等待"></a>2. 期望等待</h1><p>条件等待是指<strong>某个条件满足后，线程被激活</strong>，这是一个可重复利用的过程，流程是：条件不足—休眠—条件满足—激活—条件不足—休眠….</p>
<p>而期望模型(future)则是对某一<strong>一次性特定事件</strong>的等待。某种程度上来说就需要知道这个事件在未来的期望结果，之后这个线程<strong>会在短周期内等待或检查</strong>，<strong>期间也会执行其他任务</strong>。</p>
<p>C++标准库中，有两种期望值，使用两种类型模板实现，声明在<future>头文件中： <strong>唯一期望值(unique futures)(<code>std::future&lt;&gt;</code>)和共享期望值(shared futures)(<code>std::shared_future&lt;&gt;</code>)</strong>。仿照了<code>std::unique_ptr</code>和<code>std::shared_ptr</code>。<code>std::future</code>的实例只能与一个指定事件相关联，而<code>std::shared_future</code>的实例就能关联多个事件</p>
<h2 id="2-1-std-async"><a href="#2-1-std-async" class="headerlink" title="2.1 std::async"></a>2.1 std::async</h2><p>有的时候我们需要一个长时间计算的结果，但却并不急着需要它，所以我们使用<code>std::async</code>函数模板。当不着急要任务结果时，可以使用<code>std::async</code>启动一个异步任务。与<code>std::thread</code>对象等待的方式不同，<code>std::async</code>会<strong>返回一个<code>std::future</code>对象，这个对象持有最终计算出来的结果</strong>。当需要这个值时，只需要调用这个对象的get()成员函数，<strong>会阻塞线程直到期望值状态为就绪为止</strong>；之后，返回计算结果。</p>
<p>下面举一个简单的例子：</p>
<pre><code class="lang-cpp">void main() {
    auto maxnum = 10000;
    vector&lt;int&gt; hello;
    auto fun = [maxnum  = maxnum , &amp;hello]()
    {
        for (int i = 0; i &lt; maxnum; i++)
            hello.push_back(i);
        return std::accumulate(hello.begin(), hello.end(), 0);    
    };
    auto the_answer = std::async(fun);
    for (int i = 0; i &lt; 100; i++)
    {
        cout &lt;&lt; i &lt;&lt;&quot; &quot;;
        Sleep(1000);
        if(i==5)
            std::cout &lt;&lt; the_answer.get()&lt;&lt;&quot; &quot; &lt;&lt; endl;
    }
}
/*
output:
0 1 2 3 4 5 49995000 6 ...
*/
</code></pre>
<p>与<code>std::thread</code> 做的方式一样，<code>std::async</code>允许你通过添加额外的调用参数，向函数传递额外的参数。当第一个参数是一个指向成员函数的指针，第二个参数提供有这个函数成员类的具体对象(不是直接的，就是通过指针，还可以包装在<code>std::ref</code>中)，剩余的参数可作为成员函数的参数传入。</p>
<p>在函数调用之前向<code>std::async</code>传递一个额外参数，这个参数的类型是<code>std::launch</code>，还可以是<code>std::launch::defered</code>，表明函数调用被延迟到<code>wait()</code>或<code>get()</code>函数调用时才执行，<code>std::launch::async</code> 表明函数必须在其所在的独立线程上执行，并且立即执行，<code>std::launch::deferred | std::launch::async</code>表明实现可以选择这两种方式的一种。</p>
<h2 id="2-2-std-packaged-task-lt-gt"><a href="#2-2-std-packaged-task-lt-gt" class="headerlink" title="2.2 std::packaged_task&lt;&gt;"></a>2.2 std::packaged_task&lt;&gt;</h2><p><code>std::packaged_task&lt;&gt;</code><strong>包装任何可调用 (Callable) 目标</strong>，包括函数、 lambda 表达式、 bind 表达式或其他函数对象，使得能异步调用它，其返回值或所抛异常被存储于能通过 std::future 对象访问的共享状态中。简言之，将一个<strong>普通的可调用函数对象转换为异步执行的任务</strong>。</p>
<p>模板参数是一个函数签名，比如<code>void()</code>就是一个没有参数也没有返回值的函数，或<code>int(std::string&amp;, double*)</code>就是有一个非<code>const</code>引用的<code>std::string</code>和一个指向<code>double</code>类型的指针，并且返回类型是<code>int</code>。</p>
<p>下面给出它的使用范例：</p>
<pre><code class="lang-cpp">//1.包装lambda表达式
auto cmp = [](auto a, auto b) {return a &lt; b; };
packaged_task&lt;bool(int, int)&gt; task(cmp);
//仿函数形式启动任务
task(2, 10);
//获取共享状态中的值,直到ready才能返回结果或者异常
auto res = task.get_future();
cout &lt;&lt;boolalpha&lt;&lt; res.get() &lt;&lt; endl;


//2.包装普通函数
bool cmp(int a, int b)
{
    return a &lt; b;
}
std::packaged_task&lt;bool(int, int)&gt; task(cmp);
task(6, 3);
auto res = task.get_future();
cout &lt;&lt; boolalpha &lt;&lt; res.get() &lt;&lt; endl;

//3.通过线程启动
task.reset();
res = task.get_future();

//通过线程启动任务
thread td(move(task), 2, 10);
td.join();
//获取执行结果
cout &lt;&lt; &quot;task_thread :&quot; &lt;&lt; res.get() &lt;&lt; &quot;\n&quot;;
</code></pre>
<h2 id="2-3-std-promise-lt-gt"><a href="#2-3-std-promise-lt-gt" class="headerlink" title="2.3 std::promise&lt;&gt;"></a>2.3 std::promise&lt;&gt;</h2><p>顾名思义，就是承诺的意思。承诺和期望是好朋友，先申明一个承诺，再获得期望结果。<code>std::packaged_task</code>是他更高级的抽象。通过<code>set_value</code>将结果转化为指定值，从而实现他的承诺。</p>
<pre><code class="lang-cpp">void accumulate(std::vector&lt;int&gt;::iterator first,
                std::vector&lt;int&gt;::iterator last,
                std::promise&lt;int&gt; accumulate_promise)
{
    int sum = std::accumulate(first, last, 0);
    accumulate_promise.set_value(sum);  // 提醒 future
}

// 演示用 promise&lt;int&gt; 在线程间传递结果。
std::vector&lt;int&gt; numbers = { 1, 2, 3, 4, 5, 6 };
std::promise&lt;int&gt; accumulate_promise;
std::future&lt;int&gt; accumulate_future = accumulate_promise.get_future();
std::thread work_thread(accumulate, numbers.begin(), numbers.end(),
                        std::move(accumulate_promise));
std::cout &lt;&lt; &quot;result=&quot; &lt;&lt; accumulate_future.get() &lt;&lt; &#39;\n&#39;;
work_thread.join();
</code></pre>
<h2 id="2-4-std-shared-future"><a href="#2-4-std-shared-future" class="headerlink" title="2.4 std::shared_future"></a>2.4 std::shared_future</h2><p>虽然<code>std::future</code>可以处理所有在线程间数据转移的同步，但他是一个<strong>独享变量</strong>，换句话说，当一个线程取得他以后，他就变成一个空壳，其他线程就无法共享这个数据。所以有了可以共享的期望<code>std::shared_future</code>。</p>
<p><code>std::future</code>是只移动的，所以其所有权可以在不同的实例中互相传递，但是只有一个实例可以获得特定的同步结果，而<code>std::shared_future</code>实例是可拷贝的，所以多个对象可以引用同一关联期望值的结果。</p>
<p>每一个<code>std::shared_future</code>的独立对象上，成员函数调用返回的结果还是不同步的，所以为了在多个线程访问一个独立对象时避免数据竞争，必须<strong>使用锁来对访问进行保护</strong>。优先使用的办法：为了替代只有一个拷贝对象的情况，可以<strong>让每个线程都拥有自己对应的拷贝对象</strong>。这样，当每个线程都通过自己拥有的<code>std::shared_future</code>对象获取结果，那么多个线程访问共享同步结果就是安全的。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191116132353.png" alt="img" style="zoom:67%;" /></p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191116132408.png" alt="img" style="zoom:67%;" /></p>
<p>下面展示了他的使用过程：可以想象为两个选手的赛跑比赛，<code>std::async</code>作用是让两个选手上跑道准备就绪，选手准备好后就等待<code>ready_future</code>的信号。<code>ready_promise.set_value();</code>发令枪响，开始计时，两个选手开始。跑完后结果存在<code>result1,result2</code>中。</p>
<pre><code class="lang-cpp">void main()
{
    std::promise&lt;void&gt; ready_promise;
    std::shared_future&lt;void&gt; ready_future(ready_promise.get_future());

    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start;

    auto fun1 = [&amp;, ready_future]() -&gt; std::chrono::duration&lt;double, std::milli&gt;
    {
        auto fun1_future = ready_future;
        fun1_future.wait(); // 等待来自 main() 的信号
        return std::chrono::high_resolution_clock::now() - start;
    };

    auto fun2 = [&amp;, ready_future]() -&gt; std::chrono::duration&lt;double, std::milli&gt;
    {
        auto fun2_future = ready_future;
        fun2_future.wait(); // 等待来自 main() 的信号
        return std::chrono::high_resolution_clock::now() - start;
    };

    auto result1 = std::async(std::launch::async, fun1);
    auto result2 = std::async(std::launch::async, fun2);

    // 向线程发信使之运行
    ready_promise.set_value();
    // 线程已就绪，开始时钟
    start = std::chrono::high_resolution_clock::now();

    std::cout &lt;&lt; &quot;Thread 1 received the signal &quot;
        &lt;&lt; result1.get().count() &lt;&lt; &quot; ms after start\n&quot;
        &lt;&lt; &quot;Thread 2 received the signal &quot;
        &lt;&lt; result2.get().count() &lt;&lt; &quot; ms after start\n&quot;;
}
</code></pre>
<h1 id="3-等待时间"><a href="#3-等待时间" class="headerlink" title="3. 等待时间"></a>3. 等待时间</h1><h2 id="3-1-时钟"><a href="#3-1-时钟" class="headerlink" title="3.1 时钟"></a>3.1 时钟</h2><p>对于C++标准库来说，时钟就是时间信息源。并且，时钟是一个类，提供了四种不同的信息：</p>
<ul>
<li>当前时间</li>
<li>时间类型</li>
<li>时钟节拍</li>
<li>通过时钟节拍的分布，判断时钟是否稳定</li>
</ul>
<p>当前时间可以通过调用静态成员函数<code>now()</code>从时钟类中获取；例如，<code>std::chrono::system_clock::now()</code>是将返回系统时钟的当前时间。</p>
<p>时钟节拍被指定为1/x(x在不同硬件上有不同的值)秒，这是由时间周期所决定——一个时钟一秒有25个节拍，因此一个周期为<code>std::ratio&lt;1, 25&gt;</code>，当一个时钟的时钟节拍每2.5秒一次，周期就可以表示为<code>std::ratio&lt;5, 2&gt;</code>。</p>
<p>当时钟节拍均匀分布(无论是否与周期匹配)，并且不可调整，这种时钟就称为稳定时钟。当<code>is_steady</code>静态数据成员为<code>true</code>时，表明这个时钟就是稳定的；否则，就是不稳定的。通常情况下，<code>std::chrono::system_clock</code>是不稳定的，因为时钟是可调的，即是这种是完全自动适应本地账户的调节。稳定闹钟对于超时的计算很重要，所以C++标准库提供一个稳定时钟<code>std::chrono::steady_clock</code>。</p>
<h2 id="3-2-时延"><a href="#3-2-时延" class="headerlink" title="3.2 时延"></a>3.2 时延</h2><p><code>std::chrono::duration&lt;&gt;</code>函数模板能够创建一段时延，比如<code>std::chrono::duration&gt;</code>时间为60秒，<code>std::chrono::duration&gt;</code>时间为1毫秒。</p>
<p>标准库在<code>std::chrono</code>命名空间内，为延时变量提供一系列预定义类型：nanoseconds[纳秒] , microseconds[微秒] , milliseconds[毫秒] , seconds[秒] , minutes[分]和hours[时]。</p>
<pre><code class="lang-cpp">std::chrono::milliseconds ms(54802);
</code></pre>
<p>方便起见，C++14中<code>std::chrono_literals</code>命名空间中，有许多预定义的后缀操作符用来表示时长。下面简单的代码就是使用硬编码的方式赋予具体的时长值：</p>
<pre><code class="lang-cpp">using namespace std::chrono_literals;
auto one_day=24h;
auto half_an_hour=30min;
auto max_time_between_messages=30ms;
</code></pre>
<p>基于时延的等待可由<code>std::chrono::duration&lt;&gt;</code>来完成，例如：等待期望值状态变为就绪已经35毫秒：</p>
<pre><code class="lang-cpp">std::future&lt;int&gt; f=std::async(some_task);
if(f.wait_for(std::chrono::milliseconds(35))==std::future_status::ready)
  do_something_with(f.get());
</code></pre>
<p>等待函数会返回一个状态值，表示是等待是超时，还是继续等待。这里可以等待期望值，所以当函数等待超时时，会返回<code>std::future_status::timeout</code>；当期望值状态改变，函数会返回<code>std::future_status::ready</code>；当与期望值相关的任务延迟了，函数会返回<code>std::future_status::deferred</code>。</p>
<h2 id="3-3-时间点"><a href="#3-3-时间点" class="headerlink" title="3.3 时间点"></a>3.3 时间点</h2><p>时间点可以用<code>std::chrono::time_point&lt;&gt;</code>类型模板来表示，实例的第一个参数用来指定所要使用的时钟，第二个函数参数用来表示时间的计量单位(特化的<code>std::chrono::duration&lt;&gt;</code>)，比如说<code>std::chrono::time_point</code>。</p>
<p>可以通过<code>std::chrono::time_point&lt;&gt;</code>实例来加/减时延，来获得一个新的时间点，所以<code>std::chrono::hight_resolution_clock::now() + std::chrono::nanoseconds(500)</code>将得到500纳秒后的时间。</p>
<pre><code class="lang-cpp">auto start=std::chrono::high_resolution_clock::now()+std::chrono::nanoseconds(500);
</code></pre>
<p>我们可以通过做减法来计算时间：</p>
<pre><code class="lang-cpp">auto start=std::chrono::high_resolution_clock::now();
do_something();
auto stop=std::chrono::high_resolution_clock::now();
std::cout&lt;&lt;”do_something() took “
  &lt;&lt;std::chrono::duration&lt;double,std::chrono::seconds&gt;(stop-start).count()
  &lt;&lt;” seconds”&lt;&lt;std::endl;
</code></pre>
<p>我们可以利用时间点做超时等待的工作，如果下面的代码换成<code>wait_for()</code>以时延为基础做判断的话，可能<strong>引发重复等待</strong>。</p>
<pre><code class="lang-cpp">std::condition_variable cv;
bool done;
std::mutex m;

bool wait_loop()
{
  auto const timeout= std::chrono::steady_clock::now()+
      std::chrono::milliseconds(500);
  std::unique_lock&lt;std::mutex&gt; lk(m);
  while(!done)
  {
    if(cv.wait_until(lk,timeout)==std::cv_status::timeout)
      break;
  }
  return done;
}
</code></pre>
<h1 id="4-使用同步操作简化代码"><a href="#4-使用同步操作简化代码" class="headerlink" title="4. 使用同步操作简化代码"></a>4. 使用同步操作简化代码</h1><h2 id="4-1-期望的函数化编程"><a href="#4-1-期望的函数化编程" class="headerlink" title="4.1 期望的函数化编程"></a>4.1 期望的函数化编程</h2><p>所谓的<strong>函数式编程(functional programming)</strong>是一种编程方式，这种方式中函数结果只依赖于传入函数的参数，并不依赖外部状态，就像f(x)=cosx+exf(x)=cos⁡x+ex一样，输出的结果仅仅取决于输入的参数。我们以快排为例介绍如何使用<strong>函数式并发</strong>：</p>
<p><strong>（1）快速排序FP模式版</strong></p>
<p>下面的代码与<code>std::sort()</code>不同，<code>std::sort()</code>是无返回值的，因为参数接收的是迭代器，所以其可以对原始列表直进行修改与排序。</p>
<pre><code class="lang-cpp">template&lt;typename T&gt;
std::list&lt;T&gt; sequential_quiksort(std::list&lt;T&gt; input)
{
    if (input.empty()) return input;
    std::list&lt;T&gt; res;
    res.splice(res.begin(), input, input.begin());
    const T&amp; pivot = *res.begin();
    auto divided_point = std::partition(input.begin(),
        input.end(), [pivot = pivot](auto&amp; t) {return t &lt; pivot; });
    std::list&lt;T&gt; lower_part;
    lower_part.splice(lower_part.begin(), input, input.begin(),
        divided_point);
    auto new_lower(sequential_quiksort(std::move(lower_part)));
    auto new_higher(sequential_quiksort(std::move(input)));
    res.splice(res.begin(), new_lower);
    res.splice(res.end(), new_higher);
    return res;
}
</code></pre>
<p>主要介绍一下里面用到的STL库函数：</p>
<ul>
<li><p><code>std::splice</code>移动拼接</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191117101811.png" alt="img"></p>
</li>
<li><p><code>std::partition</code>分离(predicate 谓语，这里指lambda表达式)</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191117101934.png" alt="img"></p>
</li>
</ul>
<p><strong>（2）快速排序FP并发版</strong></p>
<pre><code class="lang-cpp">template&lt;typename T&gt;
std::list&lt;T&gt; parallel_quick_sort(std::list&lt;T&gt; input)
{
  if(input.empty())
  {
    return input;
  }
  std::list&lt;T&gt; result;
  result.splice(result.begin(),input,input.begin());
  T const&amp; pivot=*result.begin();

  auto divide_point=std::partition(input.begin(),input.end(),
                [&amp;](T const&amp; t){return t&lt;pivot;});

  std::list&lt;T&gt; lower_part;
  lower_part.splice(lower_part.end(),input,input.begin(),
                divide_point);

  std::future&lt;std::list&lt;T&gt; &gt; new_lower(  // 1
                std::async(&amp;parallel_quick_sort&lt;T&gt;,std::move(lower_part)));

  auto new_higher(
                parallel_quick_sort(std::move(input)));  // 2

  result.splice(result.end(),new_higher);  // 3
  result.splice(result.begin(),new_lower.get());  // 4
  return result;
}
</code></pre>
<p>当前线程不对小于“中间”值部分的列表进行排序，使用<code>std::async()</code>①在另一线程对其进行排序。大于部分列表，如同之前一样，使用递归的方式进行排序②。如果开启线程过多，运行库会自动裁剪线程。</p>
<p>因避开了共享可变数据，函数化编程可算作是并发编程的范型，并且也是<strong>通讯顺序进程(CSP，Communicating Sequential Processer)</strong>的范型。</p>
<h2 id="4-2-持续性并发"><a href="#4-2-持续性并发" class="headerlink" title="4.2 持续性并发"></a>4.2 持续性并发</h2><p>这里主要介绍<code>std::experimental::future</code>的特性：持续性。</p>
<p>与<code>std::future</code>类似 , <code>std::experimental::future</code>存储值也只能检索一次。如果期望值正处于持续使用状态，那这个期望值就不能被其他代码所访问。因此，使用<code>fut.then()</code>为<code>fut</code>期望值添加持续性后，对原始期望值<code>fut</code>的操作就是非法的。另外，调用<code>fut.then()</code>会返回一个新期望值，这个新期望值会持有持续性调用的结果。</p>
<pre><code class="lang-cpp">std::experimental::future&lt;int&gt; find_the_answer;
auto fut=find_the_answer();
auto fut2=fut.then(find_the_question);
assert(!fut.valid());
assert(fut2.valid());
</code></pre>
<p>与直接调用<code>std::async</code>或<code>std::thread</code>不同，<strong>持续性函数不需要传入参</strong>数，因为运行库已经为其定义好了参数——会传入一个就绪态持续性期望值，这个期望值保存了持续性触发后的结果。假设<code>find_the_answer</code>返回类型为<code>int</code>，<code>find_the_question</code>函数根据之前的例子将会传入一个<code>std::experimental::future</code>作为唯一参数：</p>
<pre><code class="lang-cpp">std::string find_the_question(std::experimental::future&lt;int&gt; the_answer);
</code></pre>
<p>下面举一个利用持续性的例子：</p>
<p>假如用户要登录你的应用，输入账号密码后，将账号送达后台获取ID，然后根据ID检查密码，通过后将信息显示出来。如果我们采用串行执行：</p>
<pre><code class="lang-cpp">void process_login(std::string const&amp; username, std::string const&amp; password)
{
  try{
    user_id const id = backend.authenticate_user(username, password);
    user_data const info_to_display = backend.request_current_info(id);
    update_display(info_to_display);
  } catch(std::exception&amp; e){
    display_error(e);
  }
}
</code></pre>
<p>串行可能会阻塞UI线程，如果我们采用<code>async</code>的方式将他们放到其他线程上，依旧会阻塞UI：</p>
<pre><code class="lang-cpp">std::future&lt;void&gt; process_login(
  std::string const&amp; username, std::string const&amp; password)
{
  return std::async(std::launch::async,[=](){
    try{
      user_id consst id = backend.authenticate_user(username, password);
      user_data const info_to_display = 
        backend.request_current_info(id);
      update_display(info_to_display);
    } catch(std::exception&amp; e){
      display_error(e);
    }      
  });
}
</code></pre>
<p>为了避免阻塞相应线程，需要有机制<strong>对每个完成的任务进行连接</strong>：持续性。</p>
<pre><code class="lang-cpp">std::experimental::future&lt;void&gt; process_login(
  std::string const&amp; username, std::string const&amp; password)
{
  return backend.async_authenticate_user(username, password).then(
    [](std::experimental::future&lt;user_id&gt; id){
      return backend.async_request_current_info(id.get());      
    }).then([](std::experimental::future&lt;user_data&gt; info_to_display){
      try{
        update_display(info_to_display.get());  
      } catch(std::exception&amp; e){
        display_error(e);
      }
    });
}
</code></pre>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        

        
        文章发布地址：<a href="/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/" target="_blank" rel="external">jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/</a>
        
    </div>
    
    <footer>
        <a href="jiangren.work">
            <img src="/img/fong.jpg" alt="Jiang Ren">
            Jiang Ren
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/&title=《CPP多线程总结3-同步异步并发》 — JR's Blog&pic=jiangren.work/img/fong.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/&title=《CPP多线程总结3-同步异步并发》 — JR's Blog&source=以同步或异步的方式实现并发。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《CPP多线程总结3-同步异步并发》 — JR's Blog&url=jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/&via=jiangren.work" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/12/28/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">CPP多线程总结4-并发数据结构设计实例</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%932-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">CPP多线程总结2-线程间共享数据</h4>
      </a>
    </div>
  
</nav>



    





















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持！
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/true" alt="打赏二维码">
        </div>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


            <p>
                
                    <span>
                        <a href="/atom.xml" target="_blank" class="rss" title="rss">
                            <i class="icon icon-lg icon-rss"></i>
                        </a>
                    </span>
                    
                        <span>
                            博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
                        </span>
            </p>
    </div>
    <div class="bottom">
        <p>
            <span>
                Jiang Ren &copy;
                    
                        2019 -
                            
                                2020
            </span>
            <span>
                
                        Power by
                        <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
                        <a href="https://github.com/abelsu7/hexo-theme-indigo-plus" target="_blank">indigo plus</a>
                        <p>Hosted by <a href="https://pages.github.com" target="_blank" style="font-weight: bold">Github Pages</a></p>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>
<a href="javascript:;" id="gobottom" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-comments"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/&title=《CPP多线程总结3-同步异步并发》 — JR's Blog&pic=jiangren.work/img/fong.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/&title=《CPP多线程总结3-同步异步并发》 — JR's Blog&source=以同步或异步的方式实现并发。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《CPP多线程总结3-同步异步并发》 — JR's Blog&url=jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/&via=jiangren.work" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/" alt="微信分享二维码">
</div>




    <script src="//cdn.jsdelivr.net/npm/node-waves@0.7.6/src/js/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<!-- <script async src="//cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script> -->
<!-- <script async src="//cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script> -->




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="/js/prism.min.js?v=1.7.2"></script>
<script src="/js/prism-vim.min.js?v=1.7.2"></script>
</body>
</html>
