<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>ROS基础 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="结合Tutorial.pdf观看 ROS是一个适用于机器人编程的框架，这个框架把原本松散的零部件耦合在了一起，为他们提供通信架构，相当于应用程序之间的沟通桥梁。 ROS采用了分布式的框架，通过点对点的设计让机器人的进程可以分别运行。  分布式：将不同功能数据放到不同模块，将相同数据放到不同服务器，他们之间依靠通信网络沟通。  1. ROS文件系统1.1 Catkin编译  Catkin是基于CMa">
<meta property="og:type" content="article">
<meta property="og:title" content="ROS基础">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;18&#x2F;ROS%E5%9F%BA%E7%A1%80&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="结合Tutorial.pdf观看 ROS是一个适用于机器人编程的框架，这个框架把原本松散的零部件耦合在了一起，为他们提供通信架构，相当于应用程序之间的沟通桥梁。 ROS采用了分布式的框架，通过点对点的设计让机器人的进程可以分别运行。  分布式：将不同功能数据放到不同模块，将相同数据放到不同服务器，他们之间依靠通信网络沟通。  1. ROS文件系统1.1 Catkin编译  Catkin是基于CMa">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20190909094836.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20190909100930.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20190909102134.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20190909105742.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20190909133157.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20190909140438.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20190909141757.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20190909142519.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;%E6%97%A0%E6%A0%87%E9%A2%98.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20190910160813.png">
<meta property="article:published_time" content="2019-12-18T15:41:30.000Z">
<meta property="article:modified_time" content="2019-12-18T16:02:39.701Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20190909094836.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ROS基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/18/ROS%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2019-12-18T15:41:30.000Z" itemprop="datePublished">2019-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ROS基础
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>结合Tutorial.pdf观看</p>
<p>ROS是一个适用于机器人编程的框架，这个框架把原本松散的零部件耦合在了一起，为他们提供通信架构，相当于应用程序之间的沟通桥梁。</p>
<p>ROS采用了分布式的框架，通过点对点的设计让机器人的进程可以分别运行。</p>
<blockquote>
<p>分布式：将不同功能数据放到不同模块，将相同数据放到不同服务器，他们之间依靠通信网络沟通。</p>
</blockquote>
<h1 id="1-ROS文件系统"><a href="#1-ROS文件系统" class="headerlink" title="1. ROS文件系统"></a>1. ROS文件系统</h1><h2 id="1-1-Catkin编译"><a href="#1-1-Catkin编译" class="headerlink" title="1.1 Catkin编译"></a>1.1 Catkin编译</h2><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909094836.png" alt="img" style="zoom:80%;" />

<p>Catkin是基于CMake的编译构建系统，具有以下特点：</p>
<ul>
<li>Catkin沿用了包管理的传统像<code>find_package()</code>基础结构</li>
<li>扩展了CMake，例如：软件包编译后无需安装就可使用；自动生成 <code>find_package()</code>代码，<code>pkg-config</code>文件；解决了多个软件包构建顺序问题。</li>
</ul>
<p>一个Catkin的软件包（package）必须要包括两个文件：</p>
<ul>
<li><code>package.xml</code>:包括了package的描述信息</li>
<li><code>CMakeLists.txt</code>:构建package所需的CMake文件</li>
</ul>
<p>Catkin工作流程如下：</p>
<ol>
<li>首先在工作空间<code>catkin_ws/src/</code>下递归的查找其中每一个ROS的package。</li>
<li>package中会有<code>package.xml</code>和<code>CMakeLists.txt</code>文件，Catkin(CMake)编译系统 据<code>CMakeLists.txt</code>文件,从而生成makefiles(放在<code>catkin_ws/build/</code>)。</li>
<li>然后make刚刚生成的makefiles等文件，编译链接生成可执行文件(放在<code>catkin_ws/devel</code>)。</li>
</ol>
<p>可以看到，Catkin就是将<code>cmake</code>与<code>make</code>指令做了一个封装从而完成整个编译过程的工具。</p>
<p>实际的使用过程如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd    ~/catkin_ws    #回到工作空间,catkin_make必须在工作空间下执行</span><br><span class="line">sudo catkin_make                #开始编译 </span><br><span class="line">source    ~/catkin_ws/devel/setup.bash    #刷新坏</span><br></pre></td></tr></table></figure>

<p>注意：catkin编译之前必须要回到工作空间目录(work station)，在其他路径下编译不会成功；如果有新的目标文件产生，那么需要刷新环境，是的系统1.2 Package软件包够遭到刚才编译生成的ROS可执行文件。</p>
<p>package是ROS的基本编译单元，任何ROS程序只有组织成package才能编译，所以package也是ROS源代码存放的地方。一个package可以编译出来多个目标文件（ROS可执行程序、动态静态库、头文件等等）。</p>
<p>一个package下常见的文件、路径有：</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909100930.png" alt="img" style="zoom:50%;" />

<p>其中定义package的是CMakeLists.txt和package.xml，这两个文件是package中必不可少的。catkin编译系统在编译前，首先就要解析这两个文件，这两个文件就定义了一个package。</p>
<p>创建package需要在工作空间目录<code>catkin_ws/src</code>，使用<code>catkin_create_pkg</code>命令，用法是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> catkin_create_pkg    package    depends</span></span><br></pre></td></tr></table></figure>

<p>其中package是包名，depends是依赖的包名，可以依赖多个软件包。</p>
<p>例如，新建一个package叫做<code>test_pkg</code>,依赖roscpp、rospy、std_msgs(常用依赖)。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> catkin_create_pkg    test_pkg    roscpp    rospy    std_msgs</span></span><br></pre></td></tr></table></figure>

<p>这样就会在当前路径下新建test_pkg软件包，包括：</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909102134.png" alt="img" style="zoom: 67%;" />

<p><code>catkin_create_pkg</code>帮你完成了软件包的初始化，填充好了<code>CMakeLists.txt</code>和<code>package.xml</code>，并且将依赖项填进了这两个文件中。需要注意的是，需要刷新文件才能找到。</p>
<h2 id="1-3-CMakeList写法"><a href="#1-3-CMakeList写法" class="headerlink" title="1.3 CMakeList写法"></a>1.3 CMakeList写法</h2><p>思路是：这个package的依赖是什么？要生成哪些目标？如何编译？</p>
<p>以turtlesim小海龟这个pacakge为例，可<code>roscd</code>到<code>tuetlesim</code>包下查看，在 <code>turtlesim/CMakeLists.txt</code></p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909105742.png" alt="img" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS ...)</span><br></pre></td></tr></table></figure>

<p>项目依赖的其他软件包，都会自动成为catkin的组件（components）（就CMake而言）。因此可以将这些依赖包指定为catkin的组件，而不必再使用<code>find_package</code>，这样将会变得简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include_directories(include $&#123;catkin_INCLUDE_DIRS&#125; $&#123;Boost_INCLUDE_DIRS&#125;)</span><br></pre></td></tr></table></figure>

<p>头文件地址，配合后面的link链接过程，参数由上一步<code>find_package</code>生成（省略了Boost的find过程）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_message_files(DIRECTORY msg FILES Color.msg Pose.msg)</span><br></pre></td></tr></table></figure>

<p>在被ROS软件包编译和使用之前，ROS中的消息（.msg）、服务（.srv）和操作（.action）文件需要特殊的预处理器编译步骤。这些宏的要点是生成编程语言特定的文件，以便可以在编程语言中使用消息、服务和操作。编译系统将使用所有可用的生成器（例如gencpp、genpy、genlisp）生成绑定。</p>
<p>提供了三个宏来分别处理消息，服务和操作：</p>
<ul>
<li>add_message_files</li>
<li>add_service_files</li>
<li>add_action_files</li>
</ul>
<p>这些宏后面必须调用一个调用生成的宏<code>generate_messages()</code>（不是message专有，通用，只写一次）</p>
<p>示例的命令，是从目标文件的msg子文件下面，添加文件名(FILES) <code>Color.msg</code>和<code>Pose.msg</code>的消息。服务也是同理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_package(CATKIN_DEPENDS geometry_msgs message_runtime std_msgs std_srvs)</span><br></pre></td></tr></table></figure>

<p>catkin_package() 是catkin支持的 CMake 宏指令。用来向编译系统指明 catkin-specific 的信息，而编译系统来生成 pkg-config和CMake files。<strong>必须放在消息、服务和操作之后，链接执行之前</strong>。</p>
<p>该函数有5个参数，这里只用了<code>CATKIN_DEPENDS</code>这一个，在之前的<code>find_package</code>中就已经找到了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_executable(turtlesim_node $&#123;turtlesim_node_SRCS&#125; $&#123;turtlesim_node_MOCS&#125;)</span><br></pre></td></tr></table></figure>

<p>作用是添加一个可执行文件构建目标，可执行文件名字叫做<code>turtlesim_node</code>，源代码由<code>set(turtlesim_node_SRCS ...)</code>设置；mocs是QT相关<code>qt5_wrap_cpp(turtlesim_node_MOCS ${turtlesim_node_HDRS})</code></p>
<p>后面的<code>target_link_libraries</code>则是将node和widgets与之前find的catkin和boost相链接；然后再为node添加依赖<code>turtlesim_gencpp</code></p>
<h1 id="2-ROS通信架构"><a href="#2-ROS通信架构" class="headerlink" title="2. ROS通信架构"></a>2. ROS通信架构</h1><p>ROS的通信方式有以下四种：</p>
<ul>
<li>Topic 主题</li>
<li>Service 服务</li>
<li>Parameter Service 参数服务器</li>
<li>Actionlib 动作库</li>
</ul>
<h2 id="2-1-Node-amp-Master"><a href="#2-1-Node-amp-Master" class="headerlink" title="2.1 Node &amp; Master"></a>2.1 Node &amp; Master</h2><p>在Ros中最小的进程单元是节点(Node)，一个软件包里可以有多个可执行文件，可执行文件在运行之后就成了一个<strong>进程</strong>(process)，这个进程在ROS中就叫做<strong>节点</strong>。从程序的角度来说，node是一个<strong>可执行文件</strong>；从功能角度来说，一个node负责某一个<strong>单独的功能</strong>。</p>
<p>Master是<strong>节点管理器</strong>，由于实际情况中node数量众多，需要一个管理器在整个网络通信架构里管理各种node。node首先在master处进行注册，之后master会将该node纳入整个ROS程序中。 node之间的通信也是先由master进行“牵线”，才能两两的进行点对点通信。当ROS程序启动 时，第一步<strong>首先启动master</strong>，由节点管理器处理依次启动node。</p>
<p>当我们要启动ROS时，输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> roscore</span></span><br></pre></td></tr></table></figure>

<p>此时会启动三个功能：<code>ROS master</code>，<code>rosout</code>，<code>parameter server</code>。这其中<code>rosout</code>负责日志输出的一个节点，其作用是告知用户当前系统的状态，包括输出系统的error、warning等 ，并且将log记录于日志文件中。<code>parameter server</code>是参数服务器，它并不是一个node， 而是存储参数配置的一个服务器。</p>
<p>启动master以后，节点管理器就开始按照系统的安排协调进行启动具体的节点，具体启动node的语句是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">    rosrun    pkg_name    node_name</span></span><br></pre></td></tr></table></figure>

<p><code>rosrun</code>将会寻找<code>pkg_name</code>下的名为<code>node_name</code>的可执行程序。</p>
<p><strong>rosnode</strong>的常用命令如下：</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909133157.png" alt="img" style="zoom:67%;" />

<h2 id="2-2-launch文件"><a href="#2-2-launch文件" class="headerlink" title="2.2 launch文件"></a>2.2 launch文件</h2><p>通常运行一个机器人系统我们需要启动<strong>多个node</strong>，为了方便我们用<strong>launch</strong>的方式来统一启动，命令是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">    roslaunch    pkg_name    file_name.launch</span></span><br></pre></td></tr></table></figure>

<p><code>roslaunch</code>命令首先会自动进行检测系统的<code>roscore</code>有没有运行，也即是确认节点管理器是否在运行状态中，如果<code>master</code>没有启动，那么<code>roslaunch</code>就会首先启动<code>master</code>，然后再按照<code>launch</code>的规则执行。</p>
<p><code>launch</code>文件里已经配置好了启动的规则。所以<code>roslaunch</code>就像是一个启动工 具，减少我们在终端中一条条输入指令的麻烦。</p>
<h2 id="2-3-Topic"><a href="#2-3-Topic" class="headerlink" title="2.3 Topic"></a>2.3 Topic</h2><p>对于<strong>实时性、周期性</strong>的消息，使用topic来传输是最佳的选择。topic是一种<strong>点对点的单向通信方式</strong>，这里的“点”指的是node，也就是说node之 间可以通过topic方式来传递信息。</p>
<p>topic的步骤是：</p>
<ol>
<li>publisher节点和subscriber节点到节点管理器进行注册</li>
<li>publisher发布topic</li>
<li>subscriber在master的指挥下订阅该topic</li>
</ol>
<p>Subscriber接收消息会进行处理，一般这个过程叫做<strong>回调(Callback)</strong>。所谓回调就是提前定义好了一个处理函数（写在代码中），当有消息来就会触发这个处理函数，函数会对消息进行处理。</p>
<p>topic通信的特点是：</p>
<ol>
<li>异步通信。发送时调用publish()方法，发送完成立即返回，不用等待反 馈。</li>
<li>subscriber通过回调函数的方式来处理消息</li>
<li>topic可以同时有多个subscribers，也可以同时有多个publishers</li>
</ol>
<p><strong>Msg</strong></p>
<p>topic有很严格的格式要求，比如摄像头拍摄的rgb图像topic，就必然要遵循ROS中 义好的rgb图像格式，这种<strong>数据格式</strong>就是Message。Message按照定义解释就是topic内容的数据类型，也称之为topic的格式标准，这里和我们平常用到的Massage直观概念有所不同。</p>
<p>基本的msg包括bool、int8、int16、int32等等常用的数据类型，但实际情况中，我们需要重新封装，比如image类型：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std_msg/Header    header                </span><br><span class="line">    uint32                seq                </span><br><span class="line">    time                stamp                </span><br><span class="line">    string                frame_id </span><br><span class="line">uint32                height </span><br><span class="line">uint32                width </span><br><span class="line">string                encoding </span><br><span class="line">uint8                is_bigendian </span><br><span class="line">uint32                step </span><br><span class="line">uint8[]                data</span><br></pre></td></tr></table></figure>

<p>这种结构类似于C语言结构体，我们可以将msg进一步理解为一个<strong>类</strong>，我们每次发布的内容可以理解为<strong>实例化的对象</strong>。</p>
<p>ROS中往往针对不同的传感器、导航系统封装好了许多msg。</p>
<h2 id="2-4-Service"><a href="#2-4-Service" class="headerlink" title="2.4 Service"></a>2.4 Service</h2><p>道topic是ROS中的一种单向的异步通信方式。然而有些时候<strong>单向的通信满足不了通信要求</strong>，比如当一些节点只是临时而 非周期性的需要某些数据，如果用topic通信方式时就会消耗大量不必要的系统资源，造成系统的低效率高功耗。</p>
<p>这种情况下，就需要有另外一种<strong>请求-查询式</strong>的通信模型。这节我们来介绍ROS通信中的另一 种通信方式——service(服务)。</p>
<p>步骤是：</p>
<ol>
<li>请求方（Client）就会发送一个request，阻塞等待。</li>
<li>server处理，反馈回一个reply。</li>
</ol>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909140438.png" alt="img" style="zoom:67%;" />

<p>NodeB是server（应答方），提供了一个服务的接口，叫做/Service，通过这个接口和Clinet通信。</p>
<p>Service是同步通信方式，所谓同步就是说，此时NodeA发布请求后会在原地等待reply，直到 NodeB处理完了请求并且完成了reply，NodeA才会继续执行。这样避免了频繁的消息传递。</p>
<p><strong>Srv</strong></p>
<p>类似msg文件，srv文件是用来描述service数据类型的, service通信的数据格式定义在 <code>*.srv</code>中</p>
<p>举个例子<code>msgs_demo/srv/DetectHuman.srv</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span>    start_detect </span><br><span class="line">---</span><br><span class="line">my_pkg/HumanPose[]    pose_data</span><br></pre></td></tr></table></figure>

<p>该服务例子取自OpenNI的人体检测ROS软件包。它是用来查 询当前深度摄像头中的人体姿态和关节数的。第一行是请求格式，中间用—-隔开，第三行是应答格式。在本例中，请求为是否开始检测，应答为一个数组，数组的每个元素为某个人的姿态。而对于人的姿态<code>HumanPose</code>，其实是一个msg，如下。所以srv<strong>可以嵌套msg在其中</strong>，但它不能嵌套srv。</p>
<p><code>msgs_demo/msg/HumanPose.msg</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header    header </span><br><span class="line">string    uuid </span><br><span class="line">int32    number_of_joints </span><br><span class="line">my_pkg/JointPose[]    joint_data</span><br></pre></td></tr></table></figure>

<h2 id="2-5-Parameter-server"><a href="#2-5-Parameter-server" class="headerlink" title="2.5 Parameter server"></a>2.5 Parameter server</h2><p>除了前文介绍的主题和服务这两种通信方式，另一种特殊的通信方式是参数服务器。于参数服务器是节点存储参数的地方、用于配置参数，全局共享参数。参数服务器使用互联网传输，在节点管理器中运行，实现整个通信过程。参数服务器维护着一个<strong>数据字典</strong>，字典里存储着各种参数和配置。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909141757.png" alt="img"></p>
<p><strong>每一个key不重复，且每一个key对应着一个value</strong>，这就是字典的映射关系。，我们往往将一些不常用到的参数和配置放入参数服务器里的字典里，这样对这些数据进行读写都将方便高效。</p>
<h2 id="2-6-Action"><a href="#2-6-Action" class="headerlink" title="2.6 Action"></a>2.6 Action</h2><p>Action是对service的一个改进，适合于<strong>长时间通信</strong>。假如利用service通信方式，那么publisher会很长时间接受不到反馈的reply，会致使通信受阻。actionlib通信过程可以<strong>随时被查看过程进度，也可以终止请求</strong>，使得 在一些特别的机制中拥有很高的效率。</p>
<p>通信双方在<strong>ROS Action Protocol</strong>下进行交流通信是通过接口来实现，类似于TCP下的socket套接字接口。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909142519.png" alt="img" style="zoom: 80%;" />

<p>如上图，客户端会向服务器发送目标指令和取消动作指令,而服务器则可以给客户端发送 实时的状态信息，结果信息，反馈信息等等,从而完成了service没法做到的部分。</p>
<p>动作的内容格式应包含三个部分：<strong>目标、结果、反馈</strong></p>
<ul>
<li>目标：机器人执行一个动作，应该有明确的移动目标信息，包括一些参数的设定，方向、角度、速 度等等。从而使机器人完成动作任务。</li>
<li>结果：当运动最终完成时，动作服务器把本次运动的结果数据发送给客户端，使客户端得到本次动作的全部信息，例如可能包含机器人的运动时长，最终姿势等等。</li>
<li>反馈：在动作进行的过程中，应该有实时的状态信息反馈给服务器的实施者，告诉实施者动作完成的状态，可以使实施者作出准确的判断去修正命令。</li>
</ul>
<p>Action规范文件的后缀名是<code>.action</code>，它的内容格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">    Define the    goal </span></span><br><span class="line">uint32    dishwasher_id        </span><br><span class="line">--</span><br><span class="line"><span class="meta">#</span><span class="bash">    Define the    result </span></span><br><span class="line">uint32    total_dishes_cleaned </span><br><span class="line">--</span><br><span class="line"><span class="meta">#</span><span class="bash">    Define a feedback message </span></span><br><span class="line">float32    percent_complete</span><br></pre></td></tr></table></figure>

<h1 id="3-roscpp"><a href="#3-roscpp" class="headerlink" title="3. roscpp"></a>3. roscpp</h1><p>如roscpp是C++语言ROS接口，我们直接调用它所 提供的函数就可以实现topic、service等通信功能。roscpp位于<code>/opt/ros/kinetic</code>之下，用C++实现了ROS通信。通常我们要调用ROS的C++接口，首先就需要<code>#include</code></p>
<p>roscpp的主要部分包括：</p>
<ul>
<li><code>ros::init()</code> 解析传入的ROS参数，创建node第一步需要用到的函数</li>
<li><code>ros::NodeHandle</code> 和topic、service、param等交互的公共接口</li>
<li><code>ros::master</code> 包含从master查询信息的函数</li>
<li><code>ros::this_nod</code> 包含查询这个进程(node)的函数</li>
<li><code>ros::service</code> 包含查询服务的函数</li>
<li><code>ros::param</code> 包含查询参数服务器的函数，而不需要用到NodeHandle</li>
<li><code>ros::names</code> 包含处理ROS图资源名称的函数</li>
</ul>
<h2 id="3-1-编写消息发布器和订阅器"><a href="#3-1-编写消息发布器和订阅器" class="headerlink" title="3.1 编写消息发布器和订阅器"></a>3.1 编写消息发布器和订阅器</h2><h3 id="创建程序包"><a href="#创建程序包" class="headerlink" title="创建程序包"></a>创建程序包</h3><p>首先需要创建Catkin工作空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p ~/catkin_ws/src <span class="comment">#创建一个目录，-p表示如果不存在就创建否则不创建</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/catkin_ws/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> catkin_make</span></span><br></pre></td></tr></table></figure>

<p>在<code>catkin_ws</code>工作空间内<code>$ cd ~/catkin_ws/src</code></p>
<p>然后创建一个名为<code>beginner_tutorials</code>的新程序包，这个包依赖于std_msg、roscpp和rospy：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> catkin_create_pkg beginner_tutorials std_msgs rospy roscpp</span></span><br></pre></td></tr></table></figure>

<p>这将会创建一个名为<code>beginner_tutorials</code>的文件夹，这个文件夹里面包含一个<a href="http://wiki.ros.org/catkin/package.xml" target="_blank" rel="noopener">package.xml</a>文件和一个<a href="http://wiki.ros.org/catkin/CMakeLists.txt" target="_blank" rel="noopener">CMakeLists.txt</a>文件，这两个文件都已经自动包含了部分在执行<code>catkin_create_pkg</code>命令时提供的信息。</p>
<h3 id="发布器节点"><a href="#发布器节点" class="headerlink" title="发布器节点"></a>发布器节点</h3><p>首先进入之前创建的 beginner_tutorials package 路径下，在这之中创建一个src文件夹：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/src/beginner_tutorials</span><br><span class="line">mkdir -p ~/catkin_ws/src/beginner_tutorials/src</span><br></pre></td></tr></table></figure>

<p>这个文件夹将会用来放置 beginner_tutorials package 的所有源代码。然后创建<code>src/talker.cpp</code> 文件，在其中写发布器源代码，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ros/ros.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"std_msgs/String.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  ros::init(argc, argv, <span class="string">"talker"</span>);</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">  ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(<span class="string">"chatter"</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  ros::<span class="function">Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (ros::ok())</span><br><span class="line">  &#123;</span><br><span class="line">    std_msgs::String msg;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">"hello world "</span> &lt;&lt; count;</span><br><span class="line">    msg.data = ss.str();</span><br><span class="line">    ROS_INFO(<span class="string">"%s"</span>, msg.data.c_str());</span><br><span class="line">    chatter_pub.publish(msg);</span><br><span class="line">    ros::spinOnce();</span><br><span class="line">    loop_rate.sleep();</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面分块解释：</p>
<p>1.用<code>init</code>初始化这个节点，唯一命名为<code>talker</code>，然后为他创建一个句柄<code>n</code>（这里是自动对应上的，一个一个进程只能有一个节点）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros::init(argc, argv, <span class="string">"talker"</span>);</span><br><span class="line">ros::NodeHandle n;</span><br></pre></td></tr></table></figure>

<p>2.告诉 <code>master</code> 我们将要在 <code>chatter</code>（话题名） 上发布 <a href="http://docs.ros.org/api/std_msgs/html/msg/String.html" target="_blank" rel="noopener">std_msgs/String</a> 消息类型的消息。这样 master 就会告诉所有订阅了 <code>chatter</code> 话题的节点，将要有数据发布。第二个参数是发布序列的大小，如果我们发布的消息的频率太高，缓冲区中的消息在大于 1000 个的时候就会开始丢弃先前发布的消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher chatter_pub = n.advertise&lt;std_msgs::<span class="keyword">String</span>&gt;(<span class="string">"chatter"</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>3.<code>ros::Rate</code> 对象可以允许你指定自循环的频率。它会追踪记录自上一次调用 <code>Rate::sleep()</code> 后时间的流逝，并休眠直到一个频率周期的时间。在这个例子中，我们让它以 10Hz 的频率运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="function">Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>4.roscpp 会默认生成一个 SIGINT 句柄，它负责处理 Ctrl-C 键盘操作——使得 <code>ros::ok()</code> 返回 false。如果下列条件之一发生，<code>ros::ok()</code> 返回false：</p>
<ul>
<li>SIGINT 被触发 (Ctrl+C)</li>
<li>被另一同名节点踢出 ROS 网络</li>
<li><code>ros::shutdown()</code> 被程序的另一部分调用</li>
<li>节点中的所有 <code>ros::NodeHandles</code> 都已经被销毁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (ros::ok())</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>5.为<code>msg</code>添加数据成员<code>hello world</code>；用<code>ROS_INFO</code> 和其他类似的函数可以用来代替 <code>printf</code>/<code>cout</code> 等函数；在这个例子中 <code>ros::spinOnce()</code>非必须，因为我们不接受回调。然而，如果程序里包含其他回调函数，加上 <code>ros::spinOnce()</code>这一语句，否则回调函数就永远也不会被调用了。</p>
<p>这是<strong>ROS消息回调处理函数</strong>，在ROS的主循环中，程序需要不断调用<code>ros::spin()</code>或 <code>ros::spinOnce()</code>，<strong>两者区别在于前者调用后不会再返回，也就是你的主程序到这儿就不往下执行了，而后者在调用后还可以继续执行之后的程序。</strong></p>
<p><code>loop_rate.sleep();</code>是调用 <code>ros::Rate</code> 对象来休眠一段时间以使得发布频率为 10Hz。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">  std_msgs::<span class="keyword">String</span> msg;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">  ss &lt;&lt; <span class="string">"hello world "</span> &lt;&lt; count;</span><br><span class="line">  msg.data = ss.str();</span><br><span class="line">  ROS_INFO(<span class="string">"%s"</span>, msg.data.c_str());</span><br><span class="line"></span><br><span class="line">  chatter_pub.publish(msg);</span><br><span class="line">  ros::spinOnce();</span><br><span class="line"></span><br><span class="line">  loop_rate.sleep();</span><br><span class="line">  ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="订阅器节点"><a href="#订阅器节点" class="headerlink" title="订阅器节点"></a>订阅器节点</h3><p>在 <code>beginner_tutorials package</code> 目录下创建 <code>src/listener.cpp</code> 文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ros/ros.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"std_msgs/String.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chatterCallback</span><span class="params">(<span class="keyword">const</span> std_msgs::<span class="keyword">String</span>::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"I heard: [%s]"</span>, msg-&gt;data.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::init(argc, argv, <span class="string">"listener"</span>);</span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    ros::Subscriber sub = n.subscribe(<span class="string">"chatter"</span>, <span class="number">1000</span>, chatterCallback);</span><br><span class="line"></span><br><span class="line">    ros::spin();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个回调函数，当接收到 <code>chatter</code> 话题的时候就会被调用。消息是以 <a href="http://www.boost.org/doc/libs/1_37_0/libs/smart_ptr/shared_ptr.htm" target="_blank" rel="noopener">boost shared_ptr</a> 指针的形式传输，这就意味着可以存储它而又不需要复制数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chatterCallback</span><span class="params">(<span class="keyword">const</span> std_msgs::<span class="keyword">String</span>::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ROS_INFO(<span class="string">"I heard: [%s]"</span>, msg-&gt;data.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>告诉 master 我们要订阅 <code>chatter</code> 话题上的消息。当有消息发布到这个话题时，ROS 就会调用 <code>chatterCallback()</code> 函数。第二个参数是队列大小，以防我们处理消息的速度不够快，当缓存达到 1000 条消息后，再有新的消息到来就将开始丢弃先前接收的消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::Subscriber sub = n.subscribe(<span class="string">"chatter"</span>, <span class="number">1000</span>, chatterCallback);</span><br></pre></td></tr></table></figure>

<h3 id="编译节点并测试"><a href="#编译节点并测试" class="headerlink" title="编译节点并测试"></a>编译节点并测试</h3><p>之前创建包时，创建了创建了 <a href="http://wiki.ros.org/catkin/package_manifest" target="_blank" rel="noopener">package.xml</a> 和 <a href="http://wiki.ros.org/catkin/CMakeLists.txt" target="_blank" rel="noopener">CMakeLists.txt</a> 文件，在生成好的<code>CMakeLists.txt</code>后面加入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Build talker and listener</span></span></span><br><span class="line">include_directories(include $&#123;catkin_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">add_executable(talker src/talker.cpp)</span><br><span class="line">target_link_libraries(talker $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(talker beginner_tutorials_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line">add_executable(listener src/listener.cpp)</span><br><span class="line">target_link_libraries(listener $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(listener beginner_tutorials_generate_messages_cpp)</span><br></pre></td></tr></table></figure>

<p>然后运行<code>catkin_make</code>。注意：如果你是添加了新的 package，你需要通过 <code>--force-cmake</code> 选项告诉 catkin 进行强制编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> In your catkin workspace</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> catkin_make</span></span><br></pre></td></tr></table></figure>

<p>按顺序启动并刷新：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> roscore</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> In your catkin workspace</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/catkin_ws</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ./devel/setup.bash</span></span><br></pre></td></tr></table></figure>

<p><strong>注意！</strong>roscore,talker,listener需要开三个不同的terminal，talker和listener开启时都需要刷新。</p>
<p>启动发布器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ./devel/setup.bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun beginner_tutorials talker</span></span><br></pre></td></tr></table></figure>

<p>启动订阅器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ./devel/setup.bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun beginner_tutorials listener</span></span><br></pre></td></tr></table></figure>

<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="img"></p>
<h2 id="3-2-编写简单的服务器和客户端"><a href="#3-2-编写简单的服务器和客户端" class="headerlink" title="3.2 编写简单的服务器和客户端"></a>3.2 编写简单的服务器和客户端</h2><p>首先需要创建一个srv，用来描述服务器数据类型。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure>

<h3 id="编写服务器节点"><a href="#编写服务器节点" class="headerlink" title="编写服务器节点"></a>编写服务器节点</h3><p>创建<code>add_two_ints_server.cpp</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ros/ros.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"beginner_tutorials/AddTwoInts.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(beginner_tutorials::AddTwoInts::Request  &amp;req,</span></span></span><br><span class="line"><span class="function"><span class="params">         beginner_tutorials::AddTwoInts::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  res.sum = req.a + req.b;</span><br><span class="line">  ROS_INFO(<span class="string">"request: x=%ld, y=%ld"</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)req.a, (<span class="keyword">long</span> <span class="keyword">int</span>)req.b);</span><br><span class="line">  ROS_INFO(<span class="string">"sending back response: [%ld]"</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)res.sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::init(argc, argv, <span class="string">"add_two_ints_server"</span>);</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">  ros::ServiceServer service = n.advertiseService(<span class="string">"add_two_ints"</span>, add);</span><br><span class="line">  ROS_INFO(<span class="string">"Ready to add two ints."</span>);</span><br><span class="line">  ros::spin();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们自己创建了一个<code>add</code>函数，这个函数提供两个int值求和的服务，int值从request里面获取，而返回数据装入response内，这些数据类型都定义在srv文件内部，函数返回一个boolean值。</p>
<p><code>Request</code>值从分割线上方获取，<code>Response</code>值从分割线下方获取</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(beginner_tutorials::AddTwoInts::Request  &amp;req,</span></span></span><br><span class="line"><span class="function"><span class="params">         beginner_tutorials::AddTwoInts::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  res.sum = req.a + req.b;</span><br><span class="line">  ROS_INFO(<span class="string">"request: x=%ld, y=%ld"</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)req.a, (<span class="keyword">long</span> <span class="keyword">int</span>)req.b);</span><br><span class="line">  ROS_INFO(<span class="string">"sending back response: [%ld]"</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)res.sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>ros::NodeHandle::advertiseService()</code>来创建<code>ros::ServiceServer</code>。 <code>advertiseService()</code> 工作方式类似 <code>subscribe()</code>函数，提供一个服务名和回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros::ServiceServer service = n.advertiseService(<span class="string">"add_two_ints"</span>, add);</span><br><span class="line">ROS_INFO(<span class="string">"Ready to add two ints."</span>);</span><br></pre></td></tr></table></figure>

<h3 id="编写客户端节点"><a href="#编写客户端节点" class="headerlink" title="编写客户端节点"></a>编写客户端节点</h3><p>在beginner_tutorials包中创建src/add_two_ints_client.cpp文件，并复制粘贴下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ros/ros.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"beginner_tutorials/AddTwoInts.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::init(argc, argv, <span class="string">"add_two_ints_client"</span>);</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_INFO(<span class="string">"usage: add_two_ints_client X Y"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line">  ros::ServiceClient client = n.serviceClient&lt;beginner_tutorials::AddTwoInts&gt;(<span class="string">"add_two_ints"</span>);</span><br><span class="line">  beginner_tutorials::AddTwoInts srv;</span><br><span class="line">  srv.request.a = atoll(argv[<span class="number">1</span>]);</span><br><span class="line">  srv.request.b = atoll(argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">if</span> (client.call(srv))</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_INFO(<span class="string">"Sum: %ld"</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)srv.response.sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ROS_ERROR(<span class="string">"Failed to call service add_two_ints"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>add_two_ints</code> service创建一个client。<code>ros::ServiceClient</code> 对象待会用来调用service。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::ServiceClient client = n.serviceClient&lt;beginner_tutorials::AddTwoInts&gt;(<span class="string">"add_two_ints"</span>);</span><br></pre></td></tr></table></figure>

<p>实例化一个由ROS编译系统自动生成的service类，并给其request成员赋值。一个service类包含两个成员<code>request</code>和<code>response</code>。同时也包括两个类定义<code>Request</code>和<code>Response</code>。atoll把字符串转换为long long integer</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beginner_tutorials::AddTwoInts srv;</span><br><span class="line">srv.request.a = atoll(argv[<span class="number">1</span>]);</span><br><span class="line">srv.request.b = atoll(argv[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>代码是在调用service。由于service的调用是模态过程（调用的时候占用进程阻止其他代码的执行），一旦调用完成，将返回调用结果。如果service调用成功，<code>call()</code>函数将返回true，<code>srv.response</code>里面的值将是合法的值。如果调用失败，<code>call()</code>函数将返回false，<code>srv.response</code>里面的值将是非法的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (client.call(srv))</span><br></pre></td></tr></table></figure>

<p>还是老规矩，三个terminal启动，注意刷新，注意客户端需要传参</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> roscore</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun beginner_tutorials add_two_ints_server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun beginner_tutorials add_two_ints_client 1 3</span></span><br></pre></td></tr></table></figure>

<p>服务器窗口：</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190910160813.png" alt="img" style="zoom: 67%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/18/ROS%E5%9F%BA%E7%A1%80/" data-id="ck4o2turs000wu4vybvgf2y1i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/12/19/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%931-%E4%BA%8C%E5%88%86%E6%B3%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Leetcode题目总结1-二分法
        
      </div>
    </a>
  
  
    <a href="/2019/12/18/SVD%E8%A7%A3%E8%B6%85%E5%AE%9A%E6%96%B9%E7%A8%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">SVD解超定方程</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程4-可变参数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B3-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0/">CPP泛型编程3-非类型的模板参数</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B2-%E7%B1%BB%E6%A8%A1%E6%9D%BF/">CPP泛型编程2-类模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程1-函数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/">CPP多线程总结4-并发数据结构设计实例</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>