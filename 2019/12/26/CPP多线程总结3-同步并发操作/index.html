<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>CPP多线程总结3-并发操作 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. 条件等待1.1 达成等待条件C++标准库对条件变量有两套实现：std::condition_variable和std::condition_variable_any。两者都需要与一个互斥量一起才能工作(互斥量是为了同步)；前者仅限于与std::mutex一起工作，而后者可以和任何满足最低标准的互斥量一起工作。一般默认使用前者。 下面展示了等待唤醒机制的使用： 1234567891011121">
<meta property="og:type" content="article">
<meta property="og:title" content="CPP多线程总结3-并发操作">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;26&#x2F;CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. 条件等待1.1 达成等待条件C++标准库对条件变量有两套实现：std::condition_variable和std::condition_variable_any。两者都需要与一个互斥量一起才能工作(互斥量是为了同步)；前者仅限于与std::mutex一起工作，而后者可以和任何满足最低标准的互斥量一起工作。一般默认使用前者。 下面展示了等待唤醒机制的使用： 1234567891011121">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191116132353.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191116132408.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191117101811.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191117101934.png">
<meta property="article:published_time" content="2019-12-26T15:35:10.000Z">
<meta property="article:modified_time" content="2019-12-26T15:40:26.877Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191116132353.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-CPP多线程总结3-同步并发操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2019-12-26T15:35:10.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      CPP多线程总结3-并发操作
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-条件等待"><a href="#1-条件等待" class="headerlink" title="1. 条件等待"></a>1. 条件等待</h1><h2 id="1-1-达成等待条件"><a href="#1-1-达成等待条件" class="headerlink" title="1.1 达成等待条件"></a>1.1 达成等待条件</h2><p>C++标准库对条件变量有两套实现：<code>std::condition_variable</code>和<code>std::condition_variable_any</code>。两者都需要与一个互斥量一起才能工作(互斥量是为了同步)；前者仅限于与<code>std::mutex</code>一起工作，而后者可以和任何满足最低标准的互斥量一起工作。一般默认使用前者。</p>
<p>下面展示了<strong>等待唤醒机制</strong>的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue;  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(more_data_to_prepare())</span><br><span class="line">  &#123;</span><br><span class="line">    data_chunk <span class="keyword">const</span> data=prepare_data();</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    data_queue.push(data);  <span class="comment">// 2</span></span><br><span class="line">    data_cond.notify_one();  <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);  <span class="comment">// 4</span></span><br><span class="line">    data_cond.wait(</span><br><span class="line">         lk,[]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;);  <span class="comment">// 5</span></span><br><span class="line">    data_chunk data=data_queue.front();</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    lk.unlock();  <span class="comment">// 6</span></span><br><span class="line">    process(data);</span><br><span class="line">    <span class="keyword">if</span>(is_last_chunk(data))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码使用一个队列在两个线程间传递数据。</p>
<p>在<code>void data_processing_thread()</code>中，我们要从队列中读取数据，首先4锁住互斥量；5在<code>wait()</code>函数中传递锁和lambda表达式，当判断结果为空时，线程<strong>休眠</strong>。</p>
<p>在<code>void data_preparation_thread()</code>中，2准备好数据后，先锁住互斥量，然后压入队列中；3通过<code>notify_one()</code>函数唤醒，结束后自动析构。</p>
<p>回到<code>void data_processing_thread()</code>中，由于唤醒消息的到来，这个函数重新启动，从头开始上锁、检查。</p>
<h2 id="1-2-实战示例：使用等待条件构建线程安全队列"><a href="#1-2-实战示例：使用等待条件构建线程安全队列" class="headerlink" title="1.2 实战示例：使用等待条件构建线程安全队列"></a>1.2 实战示例：使用等待条件构建线程安全队列</h2><p>我们模仿第二篇讲到的线程安全栈，构建一个线程安全的队列。所谓线程安全就是要像栈那样将<code>top</code>和<code>pop</code>合并。这里提供<code>pop()</code>函数的两个变种：<code>try_pop()</code>和<code>wait_and_pop()</code>。<code>try_pop()</code> ，尝试从队列中弹出数据，即使为空也会直接返回；<code>wait_and_pop()</code>，将会等待有值可检索的时候才返回。接口就可能会是下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue();</span><br><span class="line">  threadsafe_queue(<span class="keyword">const</span> threadsafe_queue&amp;);</span><br><span class="line">  threadsafe_queue&amp; <span class="keyword">operator</span>=(</span><br><span class="line">      <span class="keyword">const</span> threadsafe_queue&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 不允许简单的赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span>;  <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; try_pop();  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; wait_and_pop();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和之前一样，也需要提供两个版本的<code>try_pop()</code>和<code>wait_for_pop()</code>。第一个重载的<code>try_pop()</code>①在引用变量中存储着检索值，所以它可以用来返回队列中值的状态；当检索到一个变量时，他将返回true，否则将返回false。第二个重载②就不能做这样了，因为它是用来直接返回检索值的。当没有值可检索时，这个函数可以返回<code>NULL</code>指针。</p>
<p>完整版如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mut;  <span class="comment">// 1 互斥量必须是可变的 </span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt; data_queue;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue()</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  threadsafe_queue(threadsafe_queue <span class="keyword">const</span>&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(other.mut);</span><br><span class="line">    data_queue=other.data_queue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    data_queue.push(new_value);</span><br><span class="line">    data_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;);</span><br><span class="line">    value=data_queue.front();</span><br><span class="line">    data_queue.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; wait_and_pop()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_queue.front()));</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    value=data_queue.front();</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; try_pop()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty())</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_queue.front()));</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    <span class="keyword">return</span> data_queue.empty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当新的数据准备完成，调用<code>notify_one()</code>将会触发<strong>一个</strong>正在执行<code>wait()</code>的线程，去检查条件和<code>wait()</code>函数的返回状态。 这里不保证线程一定会被通知到，即使只有一个等待线程收到通知，所有处理线程也有可能仍然在处理数据，而忽略了这个通知。</p>
<p>在<strong>定期重新初始化(periodic reinitialization)</strong>情况下，线程准备数据数据时，就会通过条件变量调用<code>notify_all()</code>成员函数，而非直接调用<code>notify_one()</code>函数。顾名思义，这就是<strong>全部线程</strong>在都去执行<code>wait()</code>(检查他们等待的条件是否满足)的原因。</p>
<h1 id="2-期望等待"><a href="#2-期望等待" class="headerlink" title="2. 期望等待"></a>2. 期望等待</h1><p>条件等待是指<strong>某个条件满足后，线程被激活</strong>，这是一个可重复利用的过程，流程是：条件不足—休眠—条件满足—激活—条件不足—休眠….</p>
<p>而期望模型(future)则是对某一<strong>一次性特定事件</strong>的等待。某种程度上来说就需要知道这个事件在未来的期望结果，之后这个线程<strong>会在短周期内等待或检查</strong>，<strong>期间也会执行其他任务</strong>。</p>
<p>C++标准库中，有两种期望值，使用两种类型模板实现，声明在<future>头文件中： <strong>唯一期望值(unique futures)(<code>std::future&lt;&gt;</code>)和共享期望值(shared futures)(<code>std::shared_future&lt;&gt;</code>)</strong>。仿照了<code>std::unique_ptr</code>和<code>std::shared_ptr</code>。<code>std::future</code>的实例只能与一个指定事件相关联，而<code>std::shared_future</code>的实例就能关联多个事件</p>
<h2 id="2-1-std-async"><a href="#2-1-std-async" class="headerlink" title="2.1 std::async"></a>2.1 std::async</h2><p>有的时候我们需要一个长时间计算的结果，但却并不急着需要它，所以我们使用<code>std::async</code>函数模板。当不着急要任务结果时，可以使用<code>std::async</code>启动一个异步任务。与<code>std::thread</code>对象等待的方式不同，<code>std::async</code>会<strong>返回一个<code>std::future</code>对象，这个对象持有最终计算出来的结果</strong>。当需要这个值时，只需要调用这个对象的get()成员函数，<strong>会阻塞线程直到期望值状态为就绪为止</strong>；之后，返回计算结果。</p>
<p>下面举一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> maxnum = <span class="number">10000</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hello;</span><br><span class="line">    <span class="keyword">auto</span> fun = [maxnum  = maxnum , &amp;hello]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxnum; i++)</span><br><span class="line">            hello.push_back(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::accumulate(hello.begin(), hello.end(), <span class="number">0</span>);    </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> the_answer = <span class="built_in">std</span>::async(fun);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; the_answer.get()&lt;&lt;<span class="string">" "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 49995000 6 ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>与<code>std::thread</code> 做的方式一样，<code>std::async</code>允许你通过添加额外的调用参数，向函数传递额外的参数。当第一个参数是一个指向成员函数的指针，第二个参数提供有这个函数成员类的具体对象(不是直接的，就是通过指针，还可以包装在<code>std::ref</code>中)，剩余的参数可作为成员函数的参数传入。</p>
<p>在函数调用之前向<code>std::async</code>传递一个额外参数，这个参数的类型是<code>std::launch</code>，还可以是<code>std::launch::defered</code>，表明函数调用被延迟到<code>wait()</code>或<code>get()</code>函数调用时才执行，<code>std::launch::async</code> 表明函数必须在其所在的独立线程上执行，并且立即执行，<code>std::launch::deferred | std::launch::async</code>表明实现可以选择这两种方式的一种。</p>
<h2 id="2-2-std-packaged-task-lt-gt"><a href="#2-2-std-packaged-task-lt-gt" class="headerlink" title="2.2 std::packaged_task&lt;&gt;"></a>2.2 std::packaged_task&lt;&gt;</h2><p><code>std::packaged_task&lt;&gt;</code><strong>包装任何可调用 (Callable) 目标</strong>，包括函数、 lambda 表达式、 bind 表达式或其他函数对象，使得能异步调用它，其返回值或所抛异常被存储于能通过 std::future 对象访问的共享状态中。简言之，将一个<strong>普通的可调用函数对象转换为异步执行的任务</strong>。</p>
<p>模板参数是一个函数签名，比如<code>void()</code>就是一个没有参数也没有返回值的函数，或<code>int(std::string&amp;, double*)</code>就是有一个非<code>const</code>引用的<code>std::string</code>和一个指向<code>double</code>类型的指针，并且返回类型是<code>int</code>。</p>
<p>下面给出它的使用范例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.包装lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;<span class="keyword">return</span> a &lt; b; &#125;;</span><br><span class="line">packaged_task&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; task(cmp);</span><br><span class="line"><span class="comment">//仿函数形式启动任务</span></span><br><span class="line">task(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//获取共享状态中的值,直到ready才能返回结果或者异常</span></span><br><span class="line"><span class="keyword">auto</span> res = task.get_future();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;boolalpha&lt;&lt; res.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.包装普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; task(cmp);</span><br><span class="line">task(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> res = task.get_future();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; res.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.通过线程启动</span></span><br><span class="line">task.reset();</span><br><span class="line">res = task.get_future();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过线程启动任务</span></span><br><span class="line"><span class="function">thread <span class="title">td</span><span class="params">(move(task), <span class="number">2</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">td.join();</span><br><span class="line"><span class="comment">//获取执行结果</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"task_thread :"</span> &lt;&lt; res.get() &lt;&lt; <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-std-promise-lt-gt"><a href="#2-3-std-promise-lt-gt" class="headerlink" title="2.3 std::promise&lt;&gt;"></a>2.3 std::promise&lt;&gt;</h2><p>顾名思义，就是承诺的意思。承诺和期望是好朋友，先申明一个承诺，再获得期望结果。<code>std::packaged_task</code>是他更高级的抽象。通过<code>set_value</code>将结果转化为指定值，从而实现他的承诺。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; accumulate_promise)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">std</span>::accumulate(first, last, <span class="number">0</span>);</span><br><span class="line">    accumulate_promise.set_value(sum);  <span class="comment">// 提醒 future</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示用 promise&lt;int&gt; 在线程间传递结果。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; accumulate_promise;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; accumulate_future = accumulate_promise.get_future();</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">work_thread</span><span class="params">(accumulate, numbers.begin(), numbers.end(),</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="built_in">std</span>::move(accumulate_promise))</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result="</span> &lt;&lt; accumulate_future.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">work_thread.join();</span><br></pre></td></tr></table></figure>

<h2 id="2-4-std-shared-future"><a href="#2-4-std-shared-future" class="headerlink" title="2.4 std::shared_future"></a>2.4 std::shared_future</h2><p>虽然<code>std::future</code>可以处理所有在线程间数据转移的同步，但他是一个<strong>独享变量</strong>，换句话说，当一个线程取得他以后，他就变成一个空壳，其他线程就无法共享这个数据。所以有了可以共享的期望<code>std::shared_future</code>。</p>
<p><code>std::future</code>是只移动的，所以其所有权可以在不同的实例中互相传递，但是只有一个实例可以获得特定的同步结果，而<code>std::shared_future</code>实例是可拷贝的，所以多个对象可以引用同一关联期望值的结果。</p>
<p>每一个<code>std::shared_future</code>的独立对象上，成员函数调用返回的结果还是不同步的，所以为了在多个线程访问一个独立对象时避免数据竞争，必须<strong>使用锁来对访问进行保护</strong>。优先使用的办法：为了替代只有一个拷贝对象的情况，可以<strong>让每个线程都拥有自己对应的拷贝对象</strong>。这样，当每个线程都通过自己拥有的<code>std::shared_future</code>对象获取结果，那么多个线程访问共享同步结果就是安全的。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191116132353.png" alt="img" style="zoom:67%;" />

<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191116132408.png" alt="img" style="zoom:67%;" />

<p>下面展示了他的使用过程：可以想象为两个选手的赛跑比赛，<code>std::async</code>作用是让两个选手上跑道准备就绪，选手准备好后就等待<code>ready_future</code>的信号。<code>ready_promise.set_value();</code>发令枪响，开始计时，两个选手开始。跑完后结果存在<code>result1,result2</code>中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">void</span>&gt; ready_promise;</span><br><span class="line">    <span class="built_in">std</span>::shared_future&lt;<span class="keyword">void</span>&gt; ready_future(ready_promise.get_future());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::chrono::time_point&lt;<span class="built_in">std</span>::chrono::high_resolution_clock&gt; start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fun1 = [&amp;, ready_future]() -&gt; <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fun1_future = ready_future;</span><br><span class="line">        fun1_future.wait(); <span class="comment">// 等待来自 main() 的信号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::chrono::high_resolution_clock::now() - start;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fun2 = [&amp;, ready_future]() -&gt; <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fun2_future = ready_future;</span><br><span class="line">        fun2_future.wait(); <span class="comment">// 等待来自 main() 的信号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::chrono::high_resolution_clock::now() - start;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> result1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, fun1);</span><br><span class="line">    <span class="keyword">auto</span> result2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, fun2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向线程发信使之运行</span></span><br><span class="line">    ready_promise.set_value();</span><br><span class="line">    <span class="comment">// 线程已就绪，开始时钟</span></span><br><span class="line">    start = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread 1 received the signal "</span></span><br><span class="line">        &lt;&lt; result1.get().count() &lt;&lt; <span class="string">" ms after start\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"Thread 2 received the signal "</span></span><br><span class="line">        &lt;&lt; result2.get().count() &lt;&lt; <span class="string">" ms after start\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-等待时间"><a href="#3-等待时间" class="headerlink" title="3. 等待时间"></a>3. 等待时间</h1><h2 id="3-1-时钟"><a href="#3-1-时钟" class="headerlink" title="3.1 时钟"></a>3.1 时钟</h2><p>对于C++标准库来说，时钟就是时间信息源。并且，时钟是一个类，提供了四种不同的信息：</p>
<ul>
<li>当前时间</li>
<li>时间类型</li>
<li>时钟节拍</li>
<li>通过时钟节拍的分布，判断时钟是否稳定</li>
</ul>
<p>当前时间可以通过调用静态成员函数<code>now()</code>从时钟类中获取；例如，<code>std::chrono::system_clock::now()</code>是将返回系统时钟的当前时间。</p>
<p>时钟节拍被指定为1/x(x在不同硬件上有不同的值)秒，这是由时间周期所决定——一个时钟一秒有25个节拍，因此一个周期为<code>std::ratio&lt;1, 25&gt;</code>，当一个时钟的时钟节拍每2.5秒一次，周期就可以表示为<code>std::ratio&lt;5, 2&gt;</code>。</p>
<p>当时钟节拍均匀分布(无论是否与周期匹配)，并且不可调整，这种时钟就称为稳定时钟。当<code>is_steady</code>静态数据成员为<code>true</code>时，表明这个时钟就是稳定的；否则，就是不稳定的。通常情况下，<code>std::chrono::system_clock</code>是不稳定的，因为时钟是可调的，即是这种是完全自动适应本地账户的调节。稳定闹钟对于超时的计算很重要，所以C++标准库提供一个稳定时钟<code>std::chrono::steady_clock</code>。</p>
<h2 id="3-2-时延"><a href="#3-2-时延" class="headerlink" title="3.2 时延"></a>3.2 时延</h2><p><code>std::chrono::duration&lt;&gt;</code>函数模板能够创建一段时延，比如<code>std::chrono::duration&gt;</code>时间为60秒，<code>std::chrono::duration&gt;</code>时间为1毫秒。</p>
<p>标准库在<code>std::chrono</code>命名空间内，为延时变量提供一系列预定义类型：nanoseconds[纳秒] , microseconds[微秒] , milliseconds[毫秒] , seconds[秒] , minutes[分]和hours[时]。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">ms</span><span class="params">(<span class="number">54802</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>方便起见，C++14中<code>std::chrono_literals</code>命名空间中，有许多预定义的后缀操作符用来表示时长。下面简单的代码就是使用硬编码的方式赋予具体的时长值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono_literals;</span><br><span class="line"><span class="keyword">auto</span> one_day=<span class="number">24</span>h;</span><br><span class="line"><span class="keyword">auto</span> half_an_hour=<span class="number">30</span>min;</span><br><span class="line"><span class="keyword">auto</span> max_time_between_messages=<span class="number">30</span>ms;</span><br></pre></td></tr></table></figure>

<p>基于时延的等待可由<code>std::chrono::duration&lt;&gt;</code>来完成，例如：等待期望值状态变为就绪已经35毫秒：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; f=<span class="built_in">std</span>::async(some_task);</span><br><span class="line"><span class="keyword">if</span>(f.wait_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">35</span>))==<span class="built_in">std</span>::future_status::ready)</span><br><span class="line">  do_something_with(f.get());</span><br></pre></td></tr></table></figure>

<p>等待函数会返回一个状态值，表示是等待是超时，还是继续等待。这里可以等待期望值，所以当函数等待超时时，会返回<code>std::future_status::timeout</code>；当期望值状态改变，函数会返回<code>std::future_status::ready</code>；当与期望值相关的任务延迟了，函数会返回<code>std::future_status::deferred</code>。</p>
<h2 id="3-3-时间点"><a href="#3-3-时间点" class="headerlink" title="3.3 时间点"></a>3.3 时间点</h2><p>时间点可以用<code>std::chrono::time_point&lt;&gt;</code>类型模板来表示，实例的第一个参数用来指定所要使用的时钟，第二个函数参数用来表示时间的计量单位(特化的<code>std::chrono::duration&lt;&gt;</code>)，比如说<code>std::chrono::time_point</code>。</p>
<p>可以通过<code>std::chrono::time_point&lt;&gt;</code>实例来加/减时延，来获得一个新的时间点，所以<code>std::chrono::hight_resolution_clock::now() + std::chrono::nanoseconds(500)</code>将得到500纳秒后的时间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start=<span class="built_in">std</span>::chrono::high_resolution_clock::now()+<span class="built_in">std</span>::chrono::nanoseconds(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>我们可以通过做减法来计算时间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start=<span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">do_something();</span><br><span class="line"><span class="keyword">auto</span> stop=<span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;”do_something() took “</span><br><span class="line">  &lt;&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>,<span class="built_in">std</span>::chrono::seconds&gt;(stop-start).count()</span><br><span class="line">  &lt;&lt;” seconds”&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以利用时间点做超时等待的工作，如果下面的代码换成<code>wait_for()</code>以时延为基础做判断的话，可能<strong>引发重复等待</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="keyword">bool</span> done;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait_loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> timeout= <span class="built_in">std</span>::chrono::steady_clock::now()+</span><br><span class="line">      <span class="built_in">std</span>::chrono::milliseconds(<span class="number">500</span>);</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(m);</span><br><span class="line">  <span class="keyword">while</span>(!done)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(cv.wait_until(lk,timeout)==<span class="built_in">std</span>::cv_status::timeout)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-使用同步操作简化代码"><a href="#4-使用同步操作简化代码" class="headerlink" title="4. 使用同步操作简化代码"></a>4. 使用同步操作简化代码</h1><h2 id="4-1-期望的函数化编程"><a href="#4-1-期望的函数化编程" class="headerlink" title="4.1 期望的函数化编程"></a>4.1 期望的函数化编程</h2><p>所谓的<strong>函数式编程(functional programming)</strong>是一种编程方式，这种方式中函数结果只依赖于传入函数的参数，并不依赖外部状态，就像f(x)=cosx+exf(x)=cos⁡x+ex一样，输出的结果仅仅取决于输入的参数。我们以快排为例介绍如何使用<strong>函数式并发</strong>：</p>
<p><strong>（1）快速排序FP模式版</strong></p>
<p>下面的代码与<code>std::sort()</code>不同，<code>std::sort()</code>是无返回值的，因为参数接收的是迭代器，所以其可以对原始列表直进行修改与排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; sequential_quiksort(<span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; input)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (input.empty()) <span class="keyword">return</span> input;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; res;</span><br><span class="line">    res.splice(res.begin(), input, input.begin());</span><br><span class="line">    <span class="keyword">const</span> T&amp; pivot = *res.begin();</span><br><span class="line">    <span class="keyword">auto</span> divided_point = <span class="built_in">std</span>::partition(input.begin(),</span><br><span class="line">        input.end(), [pivot = pivot](<span class="keyword">auto</span>&amp; t) &#123;<span class="keyword">return</span> t &lt; pivot; &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.splice(lower_part.begin(), input, input.begin(),</span><br><span class="line">        divided_point);</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_lower</span><span class="params">(sequential_quiksort(<span class="built_in">std</span>::move(lower_part)))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(sequential_quiksort(<span class="built_in">std</span>::move(input)))</span></span>;</span><br><span class="line">    res.splice(res.begin(), new_lower);</span><br><span class="line">    res.splice(res.end(), new_higher);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要介绍一下里面用到的STL库函数：</p>
<ul>
<li><p><code>std::splice</code>移动拼接</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191117101811.png" alt="img"></p>
</li>
<li><p><code>std::partition</code>分离(predicate 谓语，这里指lambda表达式)</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191117101934.png" alt="img"></p>
</li>
</ul>
<p><strong>（2）快速排序FP并发版</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; parallel_quick_sort(<span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; input)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(input.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; result;</span><br><span class="line">  result.splice(result.begin(),input,input.begin());</span><br><span class="line">  T <span class="keyword">const</span>&amp; pivot=*result.begin();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> divide_point=<span class="built_in">std</span>::partition(input.begin(),input.end(),</span><br><span class="line">                [&amp;](T <span class="keyword">const</span>&amp; t)&#123;<span class="keyword">return</span> t&lt;pivot;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; lower_part;</span><br><span class="line">  lower_part.splice(lower_part.end(),input,input.begin(),</span><br><span class="line">                divide_point);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; &gt; new_lower(  <span class="comment">// 1</span></span><br><span class="line">                <span class="built_in">std</span>::async(&amp;parallel_quick_sort&lt;T&gt;,<span class="built_in">std</span>::move(lower_part)));</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                parallel_quick_sort(<span class="built_in">std</span>::move(input)))</span></span>;  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">  result.splice(result.end(),new_higher);  <span class="comment">// 3</span></span><br><span class="line">  result.splice(result.begin(),new_lower.get());  <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前线程不对小于“中间”值部分的列表进行排序，使用<code>std::async()</code>①在另一线程对其进行排序。大于部分列表，如同之前一样，使用递归的方式进行排序②。如果开启线程过多，运行库会自动裁剪线程。</p>
<p>因避开了共享可变数据，函数化编程可算作是并发编程的范型，并且也是<strong>通讯顺序进程(CSP，Communicating Sequential Processer)</strong>的范型。</p>
<h2 id="4-2-持续性并发"><a href="#4-2-持续性并发" class="headerlink" title="4.2 持续性并发"></a>4.2 持续性并发</h2><p>这里主要介绍<code>std::experimental::future</code>的特性：持续性。</p>
<p>与<code>std::future</code>类似 , <code>std::experimental::future</code>存储值也只能检索一次。如果期望值正处于持续使用状态，那这个期望值就不能被其他代码所访问。因此，使用<code>fut.then()</code>为<code>fut</code>期望值添加持续性后，对原始期望值<code>fut</code>的操作就是非法的。另外，调用<code>fut.then()</code>会返回一个新期望值，这个新期望值会持有持续性调用的结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::experimental::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; find_the_answer;</span><br><span class="line"><span class="keyword">auto</span> fut=find_the_answer();</span><br><span class="line"><span class="keyword">auto</span> fut2=fut.then(find_the_question);</span><br><span class="line">assert(!fut.valid());</span><br><span class="line">assert(fut2.valid());</span><br></pre></td></tr></table></figure>

<p>与直接调用<code>std::async</code>或<code>std::thread</code>不同，<strong>持续性函数不需要传入参</strong>数，因为运行库已经为其定义好了参数——会传入一个就绪态持续性期望值，这个期望值保存了持续性触发后的结果。假设<code>find_the_answer</code>返回类型为<code>int</code>，<code>find_the_question</code>函数根据之前的例子将会传入一个<code>std::experimental::future</code>作为唯一参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">find_the_question</span><span class="params">(<span class="built_in">std</span>::experimental::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; the_answer)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面举一个利用持续性的例子：</p>
<p>假如用户要登录你的应用，输入账号密码后，将账号送达后台获取ID，然后根据ID检查密码，通过后将信息显示出来。如果我们采用串行执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_login</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; username, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    user_id <span class="keyword">const</span> id = backend.authenticate_user(username, password);</span><br><span class="line">    user_data <span class="keyword">const</span> info_to_display = backend.request_current_info(id);</span><br><span class="line">    update_display(info_to_display);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::exception&amp; e)&#123;</span><br><span class="line">    display_error(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>串行可能会阻塞UI线程，如果我们采用<code>async</code>的方式将他们放到其他线程上，依旧会阻塞UI：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">void</span>&gt; process_login(</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; username, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; password)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,[=]()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      user_id consst id = backend.authenticate_user(username, password);</span><br><span class="line">      user_data <span class="keyword">const</span> info_to_display = </span><br><span class="line">        backend.request_current_info(id);</span><br><span class="line">      update_display(info_to_display);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::exception&amp; e)&#123;</span><br><span class="line">      display_error(e);</span><br><span class="line">    &#125;      </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免阻塞相应线程，需要有机制<strong>对每个完成的任务进行连接</strong>：持续性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::experimental::<span class="built_in">future</span>&lt;<span class="keyword">void</span>&gt; process_login(</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; username, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; password)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> backend.async_authenticate_user(username, password).then(</span><br><span class="line">    [](<span class="built_in">std</span>::experimental::<span class="built_in">future</span>&lt;user_id&gt; id)&#123;</span><br><span class="line">      <span class="keyword">return</span> backend.async_request_current_info(id.get());      </span><br><span class="line">    &#125;).then([](<span class="built_in">std</span>::experimental::<span class="built_in">future</span>&lt;user_data&gt; info_to_display)&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        update_display(info_to_display.get());  </span><br><span class="line">      &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::exception&amp; e)&#123;</span><br><span class="line">        display_error(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/" data-id="ck4o2tuqx0003u4vyetc32he1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          CPP多线程总结4-并发数据结构设计实例
        
      </div>
    </a>
  
  
    <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%932-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">CPP多线程总结2-线程间共享数据</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程4-可变参数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B3-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0/">CPP泛型编程3-非类型的模板参数</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B2-%E7%B1%BB%E6%A8%A1%E6%9D%BF/">CPP泛型编程2-类模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程1-函数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/">CPP多线程总结4-并发数据结构设计实例</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>