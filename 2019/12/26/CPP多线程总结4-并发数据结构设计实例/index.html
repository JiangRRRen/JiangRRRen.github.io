<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>CPP多线程总结4-并发数据结构设计实例 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="着重介绍基于锁的结构设计，包括queue，map和list。同时稍微讲了一些原子操作的内容。由于原子操作内容过于复杂，我就只涉及了一些皮毛。 设计并发数据结构意味着，多个线程可以并发的访问这个数据结构，线程可对这个数据结构做相同或不同的操作，并且每一个线程都能在自己域中看到该数据结构。多线程环境下，无数据丢失和损毁，所有的数据需要维持原样，且无条件竞争，这样的数据结构称之为线程安全。 在第二篇中，">
<meta property="og:type" content="article">
<meta property="og:title" content="CPP多线程总结4-并发数据结构设计实例">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;26&#x2F;CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="着重介绍基于锁的结构设计，包括queue，map和list。同时稍微讲了一些原子操作的内容。由于原子操作内容过于复杂，我就只涉及了一些皮毛。 设计并发数据结构意味着，多个线程可以并发的访问这个数据结构，线程可对这个数据结构做相同或不同的操作，并且每一个线程都能在自己域中看到该数据结构。多线程环境下，无数据丢失和损毁，所有的数据需要维持原样，且无条件竞争，这样的数据结构称之为线程安全。 在第二篇中，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191119123129.png">
<meta property="article:published_time" content="2019-12-26T15:40:49.000Z">
<meta property="article:modified_time" content="2019-12-26T15:52:17.138Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191119123129.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-CPP多线程总结4-并发数据结构设计实例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/" class="article-date">
  <time datetime="2019-12-26T15:40:49.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      CPP多线程总结4-并发数据结构设计实例
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>着重介绍基于锁的结构设计，包括queue，map和list。同时稍微讲了一些原子操作的内容。由于原子操作内容过于复杂，我就只涉及了一些皮毛。</p>
<p>设计并发数据结构意味着，<strong>多个线程可以并发的访问这个数据结构</strong>，线程可对这个数据结构做相同或不同的操作，并且每一个线程都能在自己域中看到该数据结构。<strong>多线程环境下，无数据丢失和损毁，所有的数据需要维持原样，且无条件竞争</strong>，这样的数据结构称之为<strong>线程安全</strong>。</p>
<p>在第二篇中，我们介绍了互斥量，但是本质上：在互斥量的保护下，同一时间内只有一个线程可以获取互斥锁。<strong>互斥量为了保护数据，显式的阻止了线程对数据结构的并发访问</strong>。这中行为称之为<strong>串行化(serialization)</strong>：线程轮流访问被保护的数据。这是对数据进行串行的访问，而非并发。当然我们可以减少保护区域，减少序列化操作，就能提升并发访问的能力。</p>
<h1 id="1-基于锁的并发数据结构设计"><a href="#1-基于锁的并发数据结构设计" class="headerlink" title="1. 基于锁的并发数据结构设计"></a>1. 基于锁的并发数据结构设计</h1><p>前面在第二篇介绍了<strong>基于锁的线程安全栈</strong>和第三篇<strong>基于锁和条件变量的线程安全队列</strong>，接下来我们再看一些精妙的设计实例。</p>
<h2 id="1-1-基于细粒度锁和条件变量的线程安全队列"><a href="#1-1-基于细粒度锁和条件变量的线程安全队列" class="headerlink" title="1.1 基于细粒度锁和条件变量的线程安全队列"></a>1.1 基于细粒度锁和条件变量的线程安全队列</h2><p><strong>（1）单线程版本</strong></p>
<p>我们首先来实现一个单线程版本的队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        T data;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next;</span><br><span class="line">        node(T data_):data(<span class="built_in">std</span>::move(data_)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; head;</span><br><span class="line">    node* tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">queue</span>(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">queue</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; try_pop()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res&#123; make_shared&lt;T&gt;(move(head-&gt;data)) &#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head = move(head);</span><br><span class="line">        head = move(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; p(<span class="keyword">new</span> node(<span class="built_in">std</span>::move(new_value)) );<span class="comment">//**</span></span><br><span class="line">        <span class="keyword">if</span> (!tail)</span><br><span class="line">            head = <span class="built_in">std</span>::move(p);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tail-&gt;next = move(p);</span><br><span class="line">        tail = p.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意几个点：</p>
<ul>
<li>使用了<code>std::unique_ptr</code>来管理节点，因为其能保证节点(其引用数据的值)在删除时候，不需要使用delete操作显式删除。</li>
<li>使用<code>std::shared_ptr</code>来返回被弹出值，这样可以保证结果能够被多次调用</li>
<li>要注意考虑<code>head</code>为空的时候的push情况</li>
<li>注意星号处创建node指针的办法</li>
<li><code>p.get()</code>能提取被<code>unique_ptr</code>包裹的指针，这样他就是一个正常的指针了。</li>
</ul>
<p><strong>（2）通过分离数据实现并发</strong></p>
<p>单线程版本移植到并发版本时有一个很大的问题，<strong><code>push</code>和<code>pop</code>既访问<code>head</code>又访问<code>tail</code></strong>，当我们的队列只有一个元素时<code>head==tail</code>，如果对两个对象上锁就是<strong>上的同一把锁</strong>。这是我们就需要请出在leetcode刷题中非常非常常见的虚拟节点了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> //1</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;T&gt; data;</span><br><span class="line">        <span class="built_in">unique_ptr</span>&lt;node&gt; next;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;node&gt; head;</span><br><span class="line">    node* tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>() :head(<span class="keyword">new</span> node), tail(head.get()) &#123;&#125; <span class="comment">//2</span></span><br><span class="line">    <span class="built_in">queue</span>(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">queue</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;T&gt; try_pop()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.get() == tail) <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;T&gt; res(head-&gt;data);</span><br><span class="line">        <span class="built_in">unique_ptr</span>&lt;node&gt; old_head(move(head));</span><br><span class="line">        head = move(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T value)</span> <span class="comment">//4</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;T&gt; packed_data(make_shared&lt;T&gt;(move(value)));</span><br><span class="line">        <span class="built_in">unique_ptr</span>&lt;node&gt; tmp_node(<span class="keyword">new</span> node);</span><br><span class="line">        node* new_tail = tmp_node.get();</span><br><span class="line"></span><br><span class="line">        tail-&gt;data = packed_data;</span><br><span class="line">        tail-&gt;next = move(tmp_node);</span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先来谈谈它和（1）有什么区别：</p>
<ol>
<li>结构不一样了，对暴露的data进行了进一步封装，取消了构造函数，因为我们不需要初始化一个节点了。</li>
<li>默认构造函数不一样了，默认创建一个head和tail，第一个默认构造没有初始化任何东西，所以我们在push和pop时要判断是否为空，现在修改结构以后我们不判断了，所以必须要在这里初始化。</li>
<li>承接上条，由于我们现在默认构造时都会为head和tail赋予意义，所以需要以这样的方式判断。</li>
<li>push的方法很不同，data的结构变了，不再是T，所以要先包装data，把它送到tail指向的地方。然后让tail往后移动一个位置，同时新node指向新tail。</li>
</ol>
<p>由于分离了<code>head</code>和<code>tail</code>现在它变成了线程安全的队列，并且<strong>现在的<code>push()</code>只能访问<code>tail</code>，而不能访问<code>head</code>。</strong>现在的问题是我们在哪里加锁，而且我们需要上锁的事件尽可能的少。</p>
<p>对push的上锁是简单的，如前面所说现在只能访问<code>tail</code>把他用到的地方锁上即可。而<code>try_pop</code>就很麻烦了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::mutex head_mutex;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; head;</span><br><span class="line">    <span class="built_in">std</span>::mutex tail_mutex;</span><br><span class="line">    node* tail;</span><br><span class="line"></span><br><span class="line">    <span class="function">node* <span class="title">get_tail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; tail_lock(tail_mutex);</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; pop_head()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; head_lock(head_mutex);</span><br><span class="line">        <span class="keyword">if</span> (head.get() == get_tail())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head = <span class="built_in">std</span>::move(head);</span><br><span class="line">        head = <span class="built_in">std</span>::move(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> old_head;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    threadsafe_queue() :</span><br><span class="line">        head(<span class="keyword">new</span> node), tail(head.get())</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    threadsafe_queue(<span class="keyword">const</span> threadsafe_queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsafe_queue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; try_pop()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head = pop_head();</span><br><span class="line">        <span class="keyword">return</span> old_head ? old_head-&gt;data : <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; new_data(</span><br><span class="line">            <span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::move(new_value)));</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; p(<span class="keyword">new</span> node);</span><br><span class="line">        node* <span class="keyword">const</span> new_tail = p.get();</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; tail_lock(tail_mutex);</span><br><span class="line">        tail-&gt;data = new_data;</span><br><span class="line">        tail-&gt;next = <span class="built_in">std</span>::move(p);</span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于<code>guard_lock</code>的局限性，所以我们不得不将<code>try_pop</code>封装成几个函数来实现细粒度锁。需要用到哪个锁，就把这段代码封装为函数。比如，最开始需要比较<code>head</code>和<code>tail</code>就把<code>tail</code>封装起来，相较于直接将两个同时锁住，<code>tail</code>受影响的时间就会小得多。</p>
<p>下面这段代码是个反例，这显然不是线程安全的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; pop_head() <span class="comment">// 这是个有缺陷的实现</span></span><br><span class="line">&#123;</span><br><span class="line">  node* <span class="keyword">const</span> old_tail=get_tail();  <span class="comment">// 1 在head_mutex范围外获取旧尾节点的值</span></span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; head_lock(head_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(head.get()==old_tail)  <span class="comment">// 2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head=<span class="built_in">std</span>::move(head);</span><br><span class="line">  head=<span class="built_in">std</span>::move(old_head-&gt;next);  <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">return</span> old_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-基于锁的线程安全查询表"><a href="#1-2-基于锁的线程安全查询表" class="headerlink" title="1.2 基于锁的线程安全查询表"></a>1.2 基于锁的线程安全查询表</h2><p>本例的目的是构建一个线程安全的哈希表，这里哈希表是通过”桶”实现的，或者也叫链地址法。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191119123129.png" alt="img"></p>
<p>图中所示的链表就可以具象的理解为一个一个的桶，这些<strong>桶合在一起构成了一个桶组</strong>。因此我们设计这个哈希表应该围绕桶组构成。想要顺利使用桶，我们需要<strong>定义桶，定义桶组，定义搜索桶位置的函数</strong>。</p>
<p>他的源码有点错误，2那个位置函数签名中的const应该去除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value,<span class="keyword">typename</span> Hash=hash&lt;Key&gt;&gt;</span><br><span class="line">class threadsafe_lookup_table</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    class bucket_type</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;Key, Value&gt; bucket_value;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;bucket_value&gt; bucket_data;</span><br><span class="line">        <span class="keyword">using</span> bucket_iterator = <span class="keyword">typename</span> bucket_data::iterator;</span><br><span class="line">        bucket_data thisbucket;</span><br><span class="line">        <span class="keyword">mutable</span> <span class="built_in">std</span>::shared_mutex mutex;</span><br><span class="line">        bucket_iterator a;</span><br><span class="line">        <span class="function">bucket_iterator <span class="title">find_entry_for</span><span class="params">(Key <span class="keyword">const</span>&amp; key)</span>  <span class="comment">// 2</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> m =  <span class="built_in">std</span>::find_if(thisbucket.begin(), thisbucket.end(),</span><br><span class="line">                [&amp;](bucket_value <span class="keyword">const</span>&amp; item)</span><br><span class="line">                &#123;<span class="keyword">return</span> item.first == key; &#125;);</span><br><span class="line">            bucket_iterator b;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="keyword">const</span>&amp; key, Value <span class="keyword">const</span>&amp; default_value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; lock(mutex);</span><br><span class="line">            <span class="keyword">auto</span> found_entry = find_entry_for(key);</span><br><span class="line">            <span class="keyword">return</span> (found_entry == thisbucket.end()) ?</span><br><span class="line">                default_value : found_entry-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="keyword">const</span>&amp; key, Value <span class="keyword">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; lock(mutex);</span><br><span class="line">            <span class="keyword">auto</span> found_entry = find_entry_for(key);</span><br><span class="line">            <span class="keyword">if</span> (found_entry == thisbucket.end())</span><br><span class="line">                thisbucket.push_back(bucket_value(key, value));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                 found_entry-&gt;second = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="keyword">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; lock(mutex);</span><br><span class="line">            <span class="keyword">auto</span> found_entry = find_entry_for(key);</span><br><span class="line">            <span class="keyword">if</span> (found_entry != thisbucket.end())</span><br><span class="line">                thisbucket.erase(found_entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;bucket_type&gt;&gt; buckets;</span><br><span class="line">    Hash hasher;</span><br><span class="line">    <span class="function">bucket_type&amp; <span class="title">get_bucket_entry</span><span class="params">(Key <span class="keyword">const</span>&amp; key)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> bucket_index = hasher(key) % buckets.size();</span><br><span class="line">        <span class="keyword">return</span> *buckets[bucket_index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value mapped_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> Hash hash_type;</span><br><span class="line">    threadsafe_lookup_table(</span><br><span class="line">        <span class="keyword">unsigned</span> num_buckets = <span class="number">19</span>, Hash <span class="keyword">const</span>&amp; hasher_ = Hash()) :</span><br><span class="line">        buckets(num_buckets), hasher(hasher_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; num_buckets; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            buckets[i].reset(<span class="keyword">new</span> bucket_type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_lookup_table(threadsafe_lookup_table <span class="keyword">const</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsafe_lookup_table&amp; <span class="keyword">operator</span>=(threadsafe_lookup_table <span class="keyword">const</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="keyword">const</span>&amp; key, Value <span class="keyword">const</span>&amp; default_value = Value())</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get_bucket_entry(key).value_for(key, default_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="keyword">const</span>&amp; key, Value <span class="keyword">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        get_bucket_entry(key).add_or_update_mapping(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="keyword">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        get_bucket_entry(key).remove_mapping(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-支持迭代器的线程安全链表"><a href="#1-3-支持迭代器的线程安全链表" class="headerlink" title="1.3 支持迭代器的线程安全链表"></a>1.3 支持迭代器的线程安全链表</h2><p>代码易懂，有几点很值得学习:</p>
<ol>
<li><code>node</code>成员的创建方式，分为可共享和不可共享</li>
<li>新节点的<code>new</code>创建方式</li>
<li><code>new_node</code>是指针指向地址，所以需要用箭头，而<code>head</code>是一个实例，可以用点操作符。</li>
<li>函数模板</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::mutex m;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data;<span class="comment">//1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next;</span><br><span class="line">        node() :next() &#123;&#125;</span><br><span class="line">        node(T <span class="keyword">const</span>&amp; value) :data(make_shared&lt;T&gt;(value)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    threadsafe_list() &#123;&#125;</span><br><span class="line">    threadsafe_list(threadsafe_list <span class="keyword">const</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsafe_list&amp; <span class="keyword">operator</span>=(threadsafe_list <span class="keyword">const</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(T <span class="keyword">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; new_node(<span class="keyword">new</span> node(value));<span class="comment">//2</span></span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;mutex&gt; lk(head.m);</span><br><span class="line">        <span class="comment">// head为虚拟节点，无具体值</span></span><br><span class="line">        new_node-&gt;next = move(head.next);<span class="comment">//3</span></span><br><span class="line">        head.next = move(new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;<span class="comment">//4</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">for_each</span><span class="params">(Function f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> current = &amp;head; </span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;mutex&gt; lk(head.m);</span><br><span class="line">        <span class="keyword">while</span> (current-&gt;next.get() != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = current-&gt;next.get();</span><br><span class="line">            <span class="built_in">std</span>::unique_lock&lt;mutex&gt; next_lk(next-&gt;m);</span><br><span class="line">            lk.unlock();</span><br><span class="line">            f(*next-&gt;data);<span class="comment">//5</span></span><br><span class="line">            current = next;</span><br><span class="line">            lk = move(next_lk);<span class="comment">//6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;T&gt; find_first_if(Function f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> current = &amp;head;</span><br><span class="line">        unique_lock&lt;mutex&gt; lk(head.m);</span><br><span class="line">        <span class="keyword">while</span> (current-&gt;next.get() != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            unique_lock&lt;mutex&gt; next_lk(next-&gt;m);</span><br><span class="line">            lk.unlock();</span><br><span class="line">            <span class="keyword">if</span> (fun(*next-&gt;data))</span><br><span class="line">                <span class="keyword">return</span> next-&gt;data;</span><br><span class="line">            current = next;</span><br><span class="line">            lk = <span class="built_in">std</span>::move(next_lk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_if</span><span class="params">(Function f)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node* current = &amp;head;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(head.m);</span><br><span class="line">        <span class="keyword">while</span> (node* <span class="keyword">const</span> next = current-&gt;next.get())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; next_lk(next-&gt;m);</span><br><span class="line">            <span class="keyword">if</span> (f(*next-&gt;data)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_next = <span class="built_in">std</span>::move(current-&gt;next);</span><br><span class="line">                current-&gt;next = <span class="built_in">std</span>::move(next-&gt;next);</span><br><span class="line">                next_lk.unlock();</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                lk.unlock();  </span><br><span class="line">                current = next;</span><br><span class="line">                lk = <span class="built_in">std</span>::move(next_lk);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重点讲讲56。</p>
<p>首先来说6，指针和引用是个老大难的问题，这里做一下梳理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; new_node(<span class="keyword">new</span> node(<span class="number">5</span>)); <span class="comment">//被unique_ptr封装好的具有GC机制的指针</span></span><br><span class="line"><span class="keyword">auto</span> m =new_node.get(); <span class="comment">//能用的普通指针，指向node的地址</span></span><br><span class="line"><span class="keyword">auto</span> x = *m-&gt;data; <span class="comment">//*m 解引用，指向node，x=5</span></span><br><span class="line"><span class="keyword">auto</span> y = new_node-&gt;data; <span class="comment">//由于data被std::shared_ptr&lt;T&gt;封装，相当于做了一个指针拷贝</span></span><br><span class="line"><span class="keyword">auto</span> z = y.get(); <span class="comment">//从shared_ptr&lt;T&gt;抽取的data指针，解引用*z后等于5</span></span><br></pre></td></tr></table></figure>

<p>再来说说6，这个操作很精妙。整个操作中需要用到的是当前节点<code>current</code>和下一个节点<code>next</code>，采用滑动锁的形式，以<code>lk</code>为基准，向后滑动，同时创建<code>lk_next</code>锁住<code>next</code></p>
<h1 id="2-无锁数据结构设计"><a href="#2-无锁数据结构设计" class="headerlink" title="2. 无锁数据结构设计"></a>2. 无锁数据结构设计</h1><h2 id="2-1-前言—原子操作"><a href="#2-1-前言—原子操作" class="headerlink" title="2.1 前言—原子操作"></a>2.1 前言—原子操作</h2><p>原子操作指的是不可分割的操作，这种操作要么做了要么没做，不可能观察到做一半的这种状态。原子操作的关键就是<strong>使用一种同步操作方式</strong>，来替换使用互斥量的同步方式。</p>
<p><strong>（1）std::atomic</strong></p>
<p>最基本的原子整型类型就是<code>std::atomic</code>。可以<strong>使用非原子的bool类型进行构造</strong>，所以可以被初始化为true或false。</p>
<p>下面这段代码完成：</p>
<ul>
<li>创建原子变量b</li>
<li>创建一个普通bool变量x，加载进入原子变量b</li>
<li>b中的值存储为true</li>
<li>读取原子变量存储的值，修改为false，再存入(<strong>读-改-写</strong>)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; b;</span><br><span class="line"><span class="keyword">bool</span> x=b.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">b.store(<span class="literal">true</span>);</span><br><span class="line">x=b.exchange(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_acq_rel);</span><br></pre></td></tr></table></figure>

<p>读改写操作是原子变量中非常常见且重要的操作，除了<code>exchange()</code>外还有<strong>比较\交换</strong>操作，对应的函数时<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>成员函数。它比较原子变量的当前值和一个期望值，<strong>当两值相等时，存储所提供的值；当两值不等，期望值就会被更新为原子变量中的值</strong>。</p>
<p><code>compare_exchange_weak()</code>可以<strong>伪失败</strong>（由于某些计算机本身的特性，导致当前线程不能很好完成这个操作，需要调用其他线程来替代工作，造成这种情况主要是时间不够而不是变量本身的问题），所以我们需要用一个循环来保证。<code>b.compare_exchange_weak(expected,true)</code>返回true时就是成功的时候。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> expected=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">extern</span> atomic&lt;<span class="keyword">bool</span>&gt; b; <span class="comment">// 设置些什么</span></span><br><span class="line"><span class="keyword">while</span>(!b.compare_exchange_weak(expected,<span class="literal">true</span>) &amp;&amp; !expected);</span><br></pre></td></tr></table></figure>

<p><strong>（2）<code>std::atomic</code>指针运算</strong></p>
<p>和<code>atomic</code>一样，<code>std::atomic</code>也有<code>load()</code>, <code>store()</code>, <code>exchange()</code>, <code>compare_exchange_weak()</code>和<code>compare_exchage_strong()</code>成员函数，与<code>std::atomic</code>的语义相同，<strong>获取与返回的类型都是`T*</strong><code>，而不是</code>bool`。</p>
<p><code>std::atomic</code>为指针运算提供新的操作。基本操作有<code>fetch_add()</code>和<code>fetch_sub()</code>提供，它们在存储地址上做原子加法和减法，为+=, -=, ++和—提供简易的封装。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>*&gt; p(&amp;a[<span class="number">0</span>]); <span class="comment">//p以int指针形式，指向1</span></span><br><span class="line"><span class="keyword">auto</span> m = p.fetch_add(<span class="number">2</span>); <span class="comment">//p右移两个单位，指向3，返回它的原始值（指向1的时）</span></span><br><span class="line"><span class="keyword">auto</span> n = (p -= <span class="number">1</span>); <span class="comment">//p左移一个单位，指向2，返回原始值（指向3时）</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-无锁的线程安全栈"><a href="#2-2-无锁的线程安全栈" class="headerlink" title="2.2 无锁的线程安全栈"></a>2.2 无锁的线程安全栈</h2><p>栈是先进后出，我们需要一个head一个tail，放的时候放入head，那么head就是我们需要保护的对象了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        T data;</span><br><span class="line">        node* next;</span><br><span class="line">        node(T <span class="keyword">const</span>&amp; data) :data(data_) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;node*&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node* <span class="keyword">const</span> new_node = <span class="keyword">new</span> node(data);</span><br><span class="line">        new_node-&gt;next = head.load();</span><br><span class="line">        <span class="keyword">while</span> (!head.compare_exchange_weak(new_node-&gt;next, new_node));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>head是一个原子变量的<code>node*</code>指针，指向栈的头部。<code>push</code>的时候将head指针装载到新节点的next，然后再用新节点去替代head，他自己就成了head。和之前一样需要用循环的办法避免伪失败。</p>
<p>下面我们来完成pop的操作。我们需要确保当head为空时，程序不会报错，所以要先检查一下。注意，<strong>结构是无锁的，但并不是无等待的</strong>，因为在<code>push()</code>和<code>pop()</code>函数中都有while循环，当<code>compare_exchange_weak()</code>总是失败的时候，循环将会持续下去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        T data;</span><br><span class="line">        node* next;</span><br><span class="line">        node(T <span class="keyword">const</span>&amp; data) :data(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;node*&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node* <span class="keyword">const</span> new_node = <span class="keyword">new</span> node(data);</span><br><span class="line">        new_node-&gt;next = head.load();</span><br><span class="line">        <span class="keyword">while</span> (!head.compare_exchange_weak(new_node-&gt;next, new_node));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; pop()</span><br><span class="line">    &#123;</span><br><span class="line">        node* old_head = head.load();</span><br><span class="line">        <span class="keyword">while</span> (old_head &amp;&amp; !head.compare_exchange_weak</span><br><span class="line">        (old_head, old_head-&gt;next));</span><br><span class="line">        <span class="keyword">return</span> old_head ? old_head-&gt;data : <span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/" data-id="ck4o2tur30009u4vy2ubh67vz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          CPP泛型编程1-函数模板
        
      </div>
    </a>
  
  
    <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">CPP多线程总结3-并发操作</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程4-可变参数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B3-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0/">CPP泛型编程3-非类型的模板参数</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B2-%E7%B1%BB%E6%A8%A1%E6%9D%BF/">CPP泛型编程2-类模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程1-函数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/">CPP多线程总结4-并发数据结构设计实例</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>