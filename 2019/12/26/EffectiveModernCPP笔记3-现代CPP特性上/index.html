<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>EffectiveModernCPP笔记3-现代CPP特性上 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要介绍C++11&#x2F;14里面的新东西，分为12两个篇章，这一篇章介绍五个特性：初始化方式，nullptr，别名using，限定域枚举，deleted函数 Item 7:Distinguish between () and {} when creating objects大体上来说，C++的初始化方式分为三种： 123int x(0);int y &#x3D; 0;int z&amp;#123;0&amp;#125;; &#x2F;&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="EffectiveModernCPP笔记3-现代CPP特性上">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;26&#x2F;EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8A&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="主要介绍C++11&#x2F;14里面的新东西，分为12两个篇章，这一篇章介绍五个特性：初始化方式，nullptr，别名using，限定域枚举，deleted函数 Item 7:Distinguish between () and {} when creating objects大体上来说，C++的初始化方式分为三种： 123int x(0);int y &#x3D; 0;int z&amp;#123;0&amp;#125;; &#x2F;&#x2F;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191104144642.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191104144832.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191104145308.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191104151009.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191106103715.png">
<meta property="article:published_time" content="2019-12-26T09:51:22.000Z">
<meta property="article:modified_time" content="2019-12-26T10:41:31.537Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191104144642.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-EffectiveModernCPP笔记3-现代CPP特性上" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8A/" class="article-date">
  <time datetime="2019-12-26T09:51:22.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      EffectiveModernCPP笔记3-现代CPP特性上
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>主要介绍C++11/14里面的新东西，分为12两个篇章，这一篇章介绍五个特性：初始化方式，nullptr，别名using，限定域枚举，deleted函数</p>
<h1 id="Item-7-Distinguish-between-and-when-creating-objects"><a href="#Item-7-Distinguish-between-and-when-creating-objects" class="headerlink" title="Item 7:Distinguish between () and {} when creating objects"></a>Item 7:Distinguish between () and {} when creating objects</h1><p>大体上来说，C++的初始化方式分为三种：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> z&#123;<span class="number">0</span>&#125;; <span class="comment">//等价于int c=&#123;0&#125;;</span></span><br></pre></td></tr></table></figure>

<p>对于<code>int</code>这种内置类型来说，他们的区别并没有太大的意义，而对于用户自定义的类型而言，区别赋值运算符和初始化就非常重要了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;              <span class="comment">//调用默认构造函数</span></span><br><span class="line">Widget w2 = w1;         <span class="comment">//不是赋值运算符，调用拷贝构造函数</span></span><br><span class="line">w1 = w2;                <span class="comment">//是一个赋值运算符，调用operator=函数</span></span><br></pre></td></tr></table></figure>

<p>为了整合这些混乱的初始化方式，C++11引入了<strong>统一初始化(uniform initialization)</strong>，实现的办法是使用花括号！具体来说<strong>有四个好处：</strong></p>
<p><strong>（1）类中非静态成员指定默认初始值</strong></p>
<p>括号初始化也能被用于为非静态数据成员指定默认初始值。C++11允许”=”初始化也拥有这种能力：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">0</span>&#125;;       <span class="comment">//没问题，x初始值为0</span></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;      <span class="comment">//同上</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>;       <span class="comment">//错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）用于不可拷贝对象初始化</strong></p>
<p><code>std::atomic</code>(原子化操作)是不可拷贝对象，所以不能用<code>=</code>初始化！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ai1&#123;<span class="number">0</span>&#125;;    <span class="comment">//没问题，x初始值为0</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ai2(<span class="number">0</span>);    <span class="comment">//没问题</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ai3 = <span class="number">0</span>;   <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）避免变窄转换(narrowing conversion)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x,y,z; </span><br><span class="line"><span class="keyword">int</span> sum1&#123;x+y+z&#125;;             <span class="comment">//错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum2</span><span class="params">(x + y +z)</span></span>;         <span class="comment">//可以（表达式的值被截为int）,损失精度</span></span><br><span class="line"><span class="keyword">int</span> sum3 = x + y + z;       <span class="comment">//同上，损失精度</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）避免语法解析歧义</strong></p>
<p>尝试使用一个没有参数的构造函数构造对象，它就会变成函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>; <span class="comment">//最令人头疼的解析！声明一个函数w2，返回Widget</span></span><br></pre></td></tr></table></figure>

<p>由于函数声明中形参列表不能使用花括号，所以使用花括号初始化就可以消除这种歧义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w3&#123;&#125;;<span class="comment">//调用没有参数的构造函数构造对象</span></span><br></pre></td></tr></table></figure>

<hr>
<p>但是使用花括号统一初始化一个大毛病！<strong><code>std::initializer_list</code>误匹配！</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">int</span> i,<span class="keyword">bool</span> b);</span><br><span class="line">    Widget(<span class="keyword">int</span> i,<span class="keyword">double</span> b);</span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; il);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget(<span class="number">10</span>,<span class="literal">true</span>);    <span class="comment">//调用的是第一个构造函数，</span></span><br><span class="line">Widget&#123;<span class="number">10</span>,<span class="literal">true</span>&#125;;    <span class="comment">//按理应该是调用第一个构造函数，但是现在却调用了带初始化列表的构造函数</span></span><br></pre></td></tr></table></figure>

<p>这是因为<strong>编译器热衷于把花括号初始化与使<code>std::initializer_list</code>构造函数匹配，</strong>热衷程度甚至超过了最佳匹配。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">bool</span> b);</span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">double</span> d);                         </span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">bool</span>&gt; il);                           </span><br><span class="line">  …                                   </span><br><span class="line">&#125;;                                      </span><br><span class="line">Widget w&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;;      <span class="comment">//错误！要求变窄转换</span></span><br></pre></td></tr></table></figure>

<p>当然出现这样的问题主要还是因为<strong>统一初始化是允许宽化转换的</strong>，所以上面的上面<code>10</code>和<code>true</code>都转换成<code>long double</code>了。而上面那个<code>10</code>和<code>5.0</code>转化到<code>bool</code>是<strong>窄式转化</strong>，这是不允许的！</p>
<p>只有当没办法把括号初始化中实参的类型转化为<code>std::initializer_list</code>时，编译器才会回到正常的函数决议流程中。比如下面的<code>string</code>就是如此。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">bool</span> b);              </span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">double</span> d);           </span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; il); </span><br><span class="line">     …         </span><br><span class="line">&#125;;                                   </span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>;<span class="comment">// 使用小括号初始化，调用第一个构造函数</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;;<span class="comment">// 使用花括号初始化，调用第一个构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>;<span class="comment">// 使用小括号初始化，调用第二个构造函数</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;;<span class="comment">// 使用花括号初始化，调用第二个构造函数</span></span><br></pre></td></tr></table></figure>

<p>这个毛病会造成某些时候<strong>括号和花括号不同语义</strong>。<code>std::vector</code>有一个非<code>std::initializer_list</code>构造函数允许你去指定容器的初始大小，以及使用一个值填满你的容器。但它也有一个<code>std::initializer_list</code>构造函数允许你使用花括号里面的值初始化容器。令人头疼！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>, <span class="number">20</span>);    <span class="comment">//使用非std::initializer_list</span></span><br><span class="line">                                <span class="comment">//构造函数创建一个包含10个元素</span></span><br><span class="line">                                <span class="comment">//所有的元素的值都是20</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;    <span class="comment">//使用std::initializer_list</span></span><br><span class="line">                                <span class="comment">//构造函数创建包含两个元素的std::vector</span></span><br><span class="line">                                <span class="comment">//元素的值为10和20</span></span><br></pre></td></tr></table></figure>

<p>总的来说，为了避免这些问题，那么作为库的开发者你应该<strong>把你的构造函数设计为不管用户是小括号还是使用花括号进行初始化都不会有什么影响</strong>（避免vector设计的睿智操作）；作为库的使用者必须<strong>认真的在花括号和小括号之间选择一个来创建对象</strong>。大多数开发者都使用其中一种作为默认情况，只有当他们不能使用这种的时候才会考虑另一种。</p>
<h1 id="Item-8-Prefer-nullptr-to-0-and-NULL"><a href="#Item-8-Prefer-nullptr-to-0-and-NULL" class="headerlink" title="Item 8: Prefer nullptr to 0 and NULL."></a>Item 8: Prefer nullptr to 0 and NULL.</h1><p>废话不多说，直接说好处：</p>
<p><strong>（1）使用nullptr*代替0和NULL可以避开那些烦人的函数重载决议</strong></p>
<p><code>NULL</code>最大的问题在于它没有明确的类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;        <span class="comment">//三个f的重载函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line">f(<span class="literal">NULL</span>);            <span class="comment">//可能会不通过，也可能会调用int,但不会调用void*</span></span><br></pre></td></tr></table></figure>

<p><code>f(NULL)</code>的不确定性是由于<code>NULL</code>的实现不同造成的，在我的编译环境下(Visual Studio 2019)，<code>NULL</code>被划定为<code>int</code>型。这样的话，调用就具有<strong>二义性</strong>！</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191104144642.png" alt="img" style="zoom:67%;" />

<p>现在做一个实验：注释掉<code>int</code>的重载类型，发现</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191104144832.png" alt="img" style="zoom: 80%;" />

<p>这是因为缺失了<code>int</code>类型的重载，它会开始转化，而<strong>从<code>int</code>到<code>long, bool, void\*</code>的转换都会被考虑。</strong>同理，<strong>调用<code>f(0)</code>也会出现这样的状况</strong>。</p>
<p><strong>为了避免二义性，准确地定位到<code>void\*</code>，推荐使用<code>nullptr</code></strong>！</p>
<p><code>nullptr</code>的类型是<code>std::nullptr_t</code>，这种类型的特点是可以<strong>转换为指向任何内置类型的指针</strong>，这也是为什么把它叫做<strong>通用类型的指针</strong>。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191104145308.png" alt="img" style="zoom:80%;" />

<p><strong>（2）和auto共用时，让代码更加明确</strong></p>
<p>如果你不知道<code>findRecord</code>返回了什么（或者不能轻易的找出），那么你就不太清楚到底result是一个指针类型还是一个整型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = findRecord( <span class="comment">/* arguments */</span> );</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们最好改为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = findRecord( <span class="comment">/* arguments */</span> );</span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">nullptr</span>) &#123;  </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）模板中有更好兼容性</strong></p>
<p>假如有一些函数只能被合适的已锁互斥量调用。每个函数都有一个不同类型的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">f1</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw)</span></span>;  <span class="comment">// 只能被合适的已锁互斥量调用</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; upw)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">bool</span>   <span class="title">f3</span><span class="params">(Widget* pw)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们用模板：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FuncType,<span class="keyword">typename</span> MuxType,<span class="keyword">typename</span> PtrType&gt; </span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) lockAndCall(FuncType func,                 </span><br><span class="line">                MuxType&amp; mutex,                 </span><br><span class="line">                PtrType ptr) &#123; </span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(mutex)</span></span>;  </span><br><span class="line">    <span class="keyword">return</span> func(ptr); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以写这样的代码调用<strong>lockAndCall</strong>模板:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result1 = lockAndCall(f1, f1m, <span class="number">0</span>);          <span class="comment">// 错误！</span></span><br><span class="line"><span class="keyword">auto</span> result2 = lockAndCall(f2, f2m, <span class="literal">NULL</span>);       <span class="comment">// 错误！</span></span><br><span class="line"><span class="keyword">auto</span> result3 = lockAndCall(f3, f3m, <span class="literal">nullptr</span>);    <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>为什么会出现错误呢？还是老毛病：0和NULL都是<code>int</code>型（至少在我的编译环境下是），但我们期待的参数是<code>std::shared_ptr</code>，所以推导的过程中就会发生错误。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191104151009.png" alt="img" style="zoom:80%;" />

<h1 id="Item-9-Prefer-alias-declarations-to-typedefs"><a href="#Item-9-Prefer-alias-declarations-to-typedefs" class="headerlink" title="Item 9:Prefer alias declarations to typedefs"></a>Item 9:Prefer alias declarations to typedefs</h1><p>C++常常为复杂的类型做一个重定义，方式有两种：<code>typedef</code>和<code>using</code>使用别名。前者是98的东西，后者是11提供的新东西。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;  UPtrMapSS; </span><br><span class="line"><span class="keyword">using</span> UPtrMapSS =  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>具体来说使用<code>using</code>别名有这么几个好处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FP是一个指向函数的指针的同义词，它指向的函数带有int和const std::string&amp;形参，不返回任何东西</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FP)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;      <span class="comment">// typedef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="keyword">using</span> FP = <span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);     <span class="comment">// 别名声明</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）方便使用模板</strong></p>
<p><code>typedef</code><strong>没有办法在模板声明的作用域中做类型重定义</strong>，必须放在一个自定义类型作用域内，而using没有这个限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                     </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyAllocList</span> &#123;</span>                    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt; type;  </span><br><span class="line">&#125;;                                      </span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw;</span><br></pre></td></tr></table></figure>

<p>而using没有这个限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyAllocList = <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T,MyAlloc&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt; lw;</span><br></pre></td></tr></table></figure>

<p><strong>对于嵌套类型</strong>来说，<code>typedef</code>需要使用<code>typename</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                     </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyAllocList</span> &#123;</span>                    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt; type;  </span><br><span class="line">&#125;;                                      </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>                     </span><br><span class="line"><span class="keyword">private</span>:                               </span><br><span class="line">    <span class="keyword">typename</span> MyAllocList&lt;T&gt;::type <span class="built_in">list</span>;    </span><br><span class="line">    … </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于<code>MyAllocList::type</code>使用了一个类型，它依赖于模板参数T，因此它是一个依赖类型，<strong>依赖类型就必须在前面加上<code>typename</code></strong>。</p>
<p>相反，使用<code>using</code>就不会有问题。对你来说，<code>MyAllocList</code>（使用了模板别名声明的版本）可能看起来和<code>MyAllocList::type</code>（使用<code>typedef</code>的版本）一样都应该依赖模板参数<code>T</code>，但编译器和你想的不同。</p>
<p>当编译器处理<code>MyAllocList</code>（使用模板别名声明的版本），<strong>它们知道<code>MyAllocList</code>是一个类型名</strong>，它一定是一个类型名。因此<code>MyAllocList</code>就是一个非依赖类型，就不要求必须使用<code>typename</code>。</p>
<h1 id="Item-10-Prefer-scoped-enums-to-unscoped-enums"><a href="#Item-10-Prefer-scoped-enums-to-unscoped-enums" class="headerlink" title="Item 10:Prefer scoped enums to unscoped enums."></a>Item 10:Prefer scoped enums to unscoped enums.</h1><p>首先介绍一下枚举：</p>
<blockquote>
<p>打开一个文件可能有三种状态：input, output和append. 典型做法是，对应定义3个常数，即：<br><code>const int input = 1;</code><br><code>const int output = 2;</code><br><code>const int append = 3;</code><br>然后，调用以下函数：<br><code>bool open_file(string file_name, int open_mode);</code></p>
<p>问题是可能用户手贱输了一个4进去，超出范围，这就很麻烦了，而且纯数字也不好记忆和分辩。通过枚举可以解决这个问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">enum</span> open_modes &#123;input = <span class="number">1</span>, output, append&#125;;</span><br><span class="line">&gt;open_file(<span class="string">"Phenix_and_the_Crane"</span>, append);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>C++的枚举分为两种：<strong>有限定域</strong>的枚举和<strong>无限定域</strong>枚举，前者是11的新特性，后者是98的特性。推荐使用有限定域的枚举，理由如下：</p>
<p><strong>（1）防止污染命名空间</strong></p>
<p>通常来说我们在花括号中定义的名称其作用域就在花括号中，但是<strong>C++98</strong>的枚举类型的声明却不遵从这个规则。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;black,white,red&#125;;</span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;   <span class="comment">//编译出错white已经声明了</span></span><br></pre></td></tr></table></figure>

<p>在11中，我们通过使用<strong>enum class</strong>关键词就可以声明限定域枚举，避免泄露枚举名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span> black, white, red &#125;; <span class="comment">// black, white, red</span></span><br><span class="line">                                          <span class="comment">// 限制在Color域内</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;                     <span class="comment">// 没问题，同样域内没有这个名字</span></span><br><span class="line"></span><br><span class="line">Color c = white;                        <span class="comment">// 错误，这个域中没有white</span></span><br><span class="line"></span><br><span class="line">Color c = Color::white;                 <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">auto</span> c = Color::white;                  <span class="comment">// 也没问题（也符合条款5的建议）</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）避免隐式转化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primeFactors</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> x)</span> </span>&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color &#123; black, white, red &#125;;       <span class="comment">// 未限域枚举</span></span><br><span class="line">Color c = red;</span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">3.5</span>) &#123; <span class="comment">//int和double比较，玩蛇？</span></span><br><span class="line">    primeFactors(c); <span class="comment">// int强转编程size_t，终极玩蛇？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这些操作在玩蛇，但编译器依然将他们通过，这可能会造成不好的结果，所以我们倾向于使用限域枚举，上面的玩蛇操作都不会通过编译！如果真的很想进行转化，<strong>使用强转符号</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(c) &lt; <span class="number">14.5</span>) &#123; <span class="comment">// 奇怪的代码，但是有效</span></span><br><span class="line">    <span class="keyword">auto</span> factors =primeFactors(<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(c)); <span class="comment">// 能通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）支持前项声明</strong></p>
<p>先解释一下前项声明：</p>
<blockquote>
<p><strong>前向声明</strong>（<strong>Forward Declaration</strong>）是指声明标识符(表示编程的实体，如数据类型、变量、函数)时还没有给出完整的定义。下面就是一个函数前向声明的例子。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printThisInteger</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printThisInteger</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用未限定域枚举前向声明会发生错误:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color;         <span class="comment">// 错误！</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span>;</span>   <span class="comment">// 没问题</span></span><br></pre></td></tr></table></figure>

<p>原因是<strong>unscoped</strong>枚举类型的<strong>实际类型并不是<code>enum</code>，它有一个底层存储类型。而这个底层存储类型是编译器在编译的时候决策的，根据你的取值范围来定义你的底层存储类型</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; black, white, red &#125;; <span class="comment">//编译器选择char型，因为只有三个值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Status &#123; good = <span class="number">0</span>, <span class="comment">//编译器选择int或long，因为范围比较大</span></span><br><span class="line">                failed = <span class="number">1</span>,</span><br><span class="line">                incomplete = <span class="number">100</span>,</span><br><span class="line">                corrupt = <span class="number">200</span>,</span><br><span class="line">                indeterminate = <span class="number">0xFFFFFFFF</span></span><br><span class="line">                &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，由于类型未定，所以不能前置声明，这就带来一个问题：<strong>编译依赖过强</strong>！换句话说，整个枚举类作用于整个系统，我<strong>新添加一个成员，就会导致全部重新编译</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>;</span> <span class="comment">// forward declaration</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">continueProcessing</span><span class="params">(Status s)</span></span>; <span class="comment">// use of fwd-declared enum</span></span><br></pre></td></tr></table></figure>

<p>即使<code>Status</code>的定义发生改变，包含这些声明的头文件也不会重新编译，如果它只是添加一个枚举名。<code>continueProcessing</code>也不会受影响，因为他不涉及新添加的枚举。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(Color c)</span></span>;</span><br><span class="line"><span class="comment">//修改成员后，上面的部分都不用管</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span>red,black&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(Color red)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Color r = Color::red;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo(r) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，<strong>使用限定域枚举有的时候反而会加大工作量！</strong></p>
<p>比如在社交网站中，假设我们有一个<code>tuple</code>保存了用户的名字，email地址，声望点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UserInfo = <span class="comment">// 类型别名，参见Item 9</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="comment">// 名字</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="comment">// email地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; ; <span class="comment">// 声望</span></span><br><span class="line"></span><br><span class="line">UserInfo uInfo; <span class="comment">// tuple对象</span></span><br><span class="line"><span class="keyword">auto</span> val = <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(uInfo); <span class="comment">// 获取第一个字段</span></span><br></pre></td></tr></table></figure>

<p>这里先说明一下tuple：</p>
<blockquote>
<p><code>std::tuple</code>是类似<code>pair</code>的模板。每个<code>pair</code>的成员类型都不相同，但每个<code>pair</code>都恰好有两个成员。不同<code>std::tuple</code>类型的成员类型也不相同，但一个<code>std::tuple</code>可以有任意数量的成员。</p>
<p>要访问一个<code>tuple</code>的成员，就要使用一个名为<code>get</code>的标准库函数模板。<code>get</code>尖括号中的值必须是一个整型常量表达式。与往常一样，我们从0开始计数，意味着<code>get&lt;0&gt;</code>是第一个成员。</p>
</blockquote>
<p>虽然注释说明了tuple各个字段对应的意思，但还是要记住第一个字段代表用户的email地址，这让人很不爽。我们可以使用非限定域枚举将名字和字段编号关联起来解决这个问题。</p>
<p>之所以它能正常工作是因为<code>UserInfoFields</code>中的枚举名隐式转换成<code>std::size_t</code>了,其中<strong><code>std::size_t</code>是<code>std::get</code>模板实参所需的</strong>。</p>
<p>对应的限域枚举版本就很啰嗦了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoFields</span> &#123;</span> uiName, uiEmail, uiReputation &#125;;</span><br><span class="line">UserInfo uInfo; <span class="comment">// as before</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> val =</span><br><span class="line"><span class="built_in">std</span>::get&lt;<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;</span><br><span class="line">(uInfo);</span><br></pre></td></tr></table></figure>

<h1 id="Item-11-Prefer-deleted-functions-to-private-undefined-ones"><a href="#Item-11-Prefer-deleted-functions-to-private-undefined-ones" class="headerlink" title="Item 11:Prefer deleted functions to private undefined ones."></a>Item 11:Prefer deleted functions to private undefined ones.</h1><p>我们都知道，如果你写的代码不想别人使用，你可以将它声明为private，但在C++11以后，建议使用<code>delete</code>而不是<code>private</code>。<code>delete</code>的用法有三类：</p>
<p><strong>（1）在类中防止某些函数调用</strong></p>
<p>比如说，我们要防止拷贝<code>istream</code>和<code>ostream</code>。因为要进行哪些操作是模棱两可的。比如一个<code>istream</code>对象，代表一个输入值的流，流中有一些已经被读取，有一些可能马上要被读取。解决这个问题最好的方法是不定义这个操作。直接禁止拷贝流。</p>
<p>在98中是这样写的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span> = <span class="title">char_traits</span>&lt;charT&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">basic_ios</span> :</span> <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    basic_ios(<span class="keyword">const</span> basic_ios&amp; ); <span class="comment">// not defined</span></span><br><span class="line">    basic_ios&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> basic_ios&amp;); <span class="comment">// not defined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在11中可以改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span> = <span class="title">char_traits</span>&lt;charT&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">basic_ios</span> :</span> <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    basic_ios(<span class="keyword">const</span> basic_ios&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">    basic_ios&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>deleted</code>函数不能以任何方式被调用，即使你<strong>在成员函数或者友元函数里面调用<code>deleted</code>函数也不能通过编译</strong>。</p>
<p>需要注意的是：<strong><code>deleted</code>函数被声明为<code>public</code>而不是<code>private</code></strong>。这也是有原因的。当客户端代码试图调用成员函数，C++会在检查<code>deleted</code>状态前检查它的访问性。当客户端代码调用一个私有的<code>deleted</code>函数，一些编译器只会给出该函数是<code>private</code>的错误。</p>
<p><strong>（2）作用于非成员函数禁止调用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br></pre></td></tr></table></figure>

<p>C++有沉重的C包袱，使得含糊的、能被视作数值的任何类型都能隐式转换为<code>int</code>，但是有一些调用可能是没有意义的：</p>
<p>如果我们想幸运数必须是整数，就应该禁止通过这些编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">int</span> number)</span></span>; <span class="comment">// 原始版本</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">char</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 拒绝char</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">bool</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 拒绝bool</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">double</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 拒绝float和double</span></span><br></pre></td></tr></table></figure>

<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191106103715.png" alt="img" style="zoom:80%;" />

<p><strong>（3）禁止一些模板实例化</strong></p>
<p>在指针的世界里有两种特殊情况。一是<code>void*</code>指针，因为没办法对它们进行解引用，或者加加减减等。另一种指针是<code>char*</code>，因为它们通常代表C风格的字符串，而不是正常意义下指向单个字符的指针。这两种情况要特殊处理，在<code>processPointer</code>模板里面，我们假设<strong>正确的函数应该拒绝这些类型</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> processPointer&lt;<span class="keyword">void</span>&gt;(<span class="keyword">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> processPointer&lt;<span class="keyword">char</span>&gt;(<span class="keyword">char</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8A/" data-id="ck4o2tur4000au4vyhzy09b3h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          EffectiveModernCPP笔记3-现代CPP特性下
        
      </div>
    </a>
  
  
    <a href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B02-auto%E7%9A%84%E4%BD%BF%E7%94%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">EffectiveModernCPP笔记2-auto的使用</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程4-可变参数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B3-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0/">CPP泛型编程3-非类型的模板参数</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B2-%E7%B1%BB%E6%A8%A1%E6%9D%BF/">CPP泛型编程2-类模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程1-函数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/">CPP多线程总结4-并发数据结构设计实例</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>