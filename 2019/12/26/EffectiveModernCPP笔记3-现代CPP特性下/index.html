<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>EffectiveModernCPP笔记3-现代CPP特性下 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="介绍六个特性：overriding，const_iterator，noexcept，constexpr，const线程安全，类的特殊成员函数 Item 12:Declare overriding functions override.在派生和继承中，常常涉及虚函数的使用。  C++多态(polymorphism)是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖">
<meta property="og:type" content="article">
<meta property="og:title" content="EffectiveModernCPP笔记3-现代CPP特性下">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;26&#x2F;EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8B&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="介绍六个特性：overriding，const_iterator，noexcept，constexpr，const线程安全，类的特殊成员函数 Item 12:Declare overriding functions override.在派生和继承中，常常涉及虚函数的使用。  C++多态(polymorphism)是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191106111508.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191106114436.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191106135004.png">
<meta property="og:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191107125425.png">
<meta property="article:published_time" content="2019-12-26T09:51:27.000Z">
<meta property="article:modified_time" content="2019-12-26T11:34:24.783Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;bucket-1259555870.cos.ap-chengdu.myqcloud.com&#x2F;20191106111508.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-EffectiveModernCPP笔记3-现代CPP特性下" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8B/" class="article-date">
  <time datetime="2019-12-26T09:51:27.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      EffectiveModernCPP笔记3-现代CPP特性下
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>介绍六个特性：overriding，const_iterator，noexcept，constexpr，const线程安全，类的特殊成员函数</p>
<h1 id="Item-12-Declare-overriding-functions-override"><a href="#Item-12-Declare-overriding-functions-override" class="headerlink" title="Item 12:Declare overriding functions override."></a>Item 12:Declare overriding functions override.</h1><p>在派生和继承中，常常涉及虚函数的使用。</p>
<blockquote>
<p>C++多态(polymorphism)是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。</p>
</blockquote>
<p>然而虚函数能够重写的条件很苛刻，他需要满足很多条件，我们编程时很容易搞错。他需要满足以下要求：</p>
<ul>
<li>基类函数必须是<code>virtual</code></li>
<li>基类和派生类函数名必须完全一样</li>
<li>基类和派生类函数参数必须完全一样</li>
<li>基类和派生类函数常量性(constness)必须完全一样</li>
<li>基类和派生类函数的返回值和异常说明(exception specifications)必须兼容</li>
<li>基类和派生类函数的引用限定符（reference qualifiers）必须完全一样。</li>
</ul>
<p>下面的代码展示了这些错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最可气的是，编译器根本不会报错，最多只是给个warning，但编译时根本不会重写，所以我们需要将它<strong>显式声明</strong>为<code>override</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp; <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>; <span class="comment">// 可以添加virtual，但不是必要</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比起让编译器通过warnings告诉你重写实际不会重写，不如给你的派生类成员函数全都加上<code>override</code>。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191106111508.png" alt="img" style="zoom:80%;" />

<h1 id="Item-13-Prefer-const-iterators-to-iterators"><a href="#Item-13-Prefer-const-iterators-to-iterators" class="headerlink" title="Item 13:Prefer const_iterators to iterators."></a>Item 13:Prefer const_iterators to iterators.</h1><p>在STL中<code>const_iterator</code>等价于常量指针，他们<strong>指向不能被修改的值</strong>。C98中支持得不是很好，而在11中：<code>const_iterator</code>即容易获取又容易使用。容器的成员函数<code>cbegin</code>和<code>cend</code>产出<code>const_iterator</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> ci = <span class="built_in">std</span>::find(values.cbegin(), values.cend(), <span class="number">3</span>);</span><br><span class="line">*ci = <span class="number">10</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>这其中，<code>ci</code>就直接被划定为<code>const_iterator</code>，所以就不能做修改</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191106114436.png" alt="img"></p>
<h1 id="Item-14-Declare-functions-noexcept-if-they-won’t-emit-exceptions"><a href="#Item-14-Declare-functions-noexcept-if-they-won’t-emit-exceptions" class="headerlink" title="Item 14:Declare functions noexcept if they won’t emit exceptions."></a>Item 14:Declare functions noexcept if they won’t emit exceptions.</h1><p>在C++中人们认为异常信息最有用的在于：<strong>一个函数是否会抛出异常</strong>，这是一个二元性判断，即会和不会。就其本身而言，函数是否为<strong>noexcept</strong>和成员函数是否<strong>const</strong>一样重要。这个可以影响到调用代码的异常安全性和效率。原因如下：</p>
<p><strong>1）避免运行时栈展开</strong></p>
<p>C++98和11有不同的不抛出异常声明方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// C++98风格</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// C++11风格</span></span><br></pre></td></tr></table></figure>

<p>他们最大的不同在于：在C++98的异常说明中，调用栈<strong>会展开</strong>至<code>f</code>的调用者，一些不合适的动作比如程序终止也会发生。C++11异常说明的运行时行为明显不同：调用栈<strong>只是可能</strong>在程序终止前展开。一个必然一个可能，这两者会对代码生成产生巨大的影响。<strong>在一个<code>noexcept</code>函数中，当异常传播到函数外，优化器不需要保证运行时栈的可展开状态，也不需要保证<code>noexcept</code>函数中的对象按照构造的反序析构。</strong>而<code>throw()</code>标注的异常声明缺少这样的优化灵活性，它和没加一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="keyword">noexcept</span></span>;   <span class="comment">// 极尽所能优化</span></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="title">throw</span><span class="params">()</span></span>;    <span class="comment">// 较少优化</span></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span></span>;            <span class="comment">// 较少优化</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）保证移动语义能充分发挥作用</strong></p>
<p>当新元素添加到<code>std::vector</code>，<code>std::vector</code>可能没地方放它，这时候，<code>std::vector</code>会分配一片的新的大块内存用于存放，然后将元素从已经存在的内存移动到新内存。在C++98中，移动是<strong>通过复制</strong>老内存区的每一个元素到新内存区完成的，然后<strong>老内存区的每个元素发生析构</strong>。<br>这种方法使得<code>push_back</code>可以提供很强的异常安全保证：<strong>如果在复制元素期间抛出异常，<code>std::vector</code>状态保持不变，因为老内存元素析构必须建立在它们已经成功复制到新内存的前提下。</strong></p>
<p>在C++11中，一个很自然的优化就是将上述复制操作<strong>替换为移动操作</strong>。但是很不幸，破坏了<code>push_back</code>的异常安全。如果异常在移动中抛出，那么<code>push_back</code>操作就不能完成。但是原始的<code>std::vector</code>已经被修改。</p>
<p>因此容器们演化出了一种策略：<strong>如果可以就移动，如果必要则复制</strong>，比如说<code>std::vector::push_back</code>，<code>std::vector::reverse</code>，<code>std:;deque::insert</code>等等。而判断可不可以移动的关键就在于，<strong>移动中是否可能产生异常</strong>！如何判断？<strong>检查是否声明noexcept</strong></p>
<p><strong>那么哪些函数可以写为noexcept呢？</strong></p>
<p>具体来说，<strong>移动操作和swap</strong>可以写为不抛出异常，有助于程序优化。宽泛点来说，我们需要讨论<strong>宽泛契约(wild contracts)和严格契约(narrow contracts)函数</strong></p>
<blockquote>
<p>有宽泛契约的函数没有前置条件。这种函数<strong>不管程序状态如何都能调用</strong>，<strong>它对调用者传来的实参不设约束</strong>。反之，没有宽泛契约的函数就有严格契约。对于这些函数，如果违反<strong>前置条件</strong>，结果将会是未定义的。</p>
</blockquote>
<p>假如现在有一个函数，我想在里面加一个前置条件冲突检查<code>s.size()&lt;32</code>，那么我就不能声明为<code>noexcept</code>，我需要在里面写一个异常抛出函数，抛出<code>&quot;precondition was violated&quot;</code>异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="Item-15-Use-constexpr-whenever-possible"><a href="#Item-15-Use-constexpr-whenever-possible" class="headerlink" title="Item 15:Use constexpr whenever possible."></a>Item 15:Use constexpr whenever possible.</h1><p><code>const</code>是一个古老的关键词，他从C++诞生之日就存在，在漫长的岁月中它承担了很多很多功能，在11中，人们觉得<code>const</code>干太多活，让它太难顶了，于是搞了一个<code>constexpr</code>来帮他分担一些工作，并且使得一些功能更加明确。</p>
<p>总的来说<code>constexpr</code>就是指<strong>编译期可知</strong>，潜台词是：告诉编译器我可以是编译期间可知的，尽情的优化我吧。而<code>const</code><strong>专门用来声明不变量</strong>，潜台词是：告诉程序员没人动得了我，放心的把我传出去；或者放心的把变量交给我，我啥也不动就瞅瞅。</p>
<p><strong>（1）关于常量</strong></p>
<p>这一部分比较简单，往往用于C++要求出现整数常量表达式（ <strong>integral constant expression</strong> ）的上下文。这类上下文包括<strong>数组大小，整数模板参数（包括<code>std::array</code>对象的长度），枚举量，对齐修饰符</strong>（<a href="https://en.cppreference.com/w/cpp/language/alignas" target="_blank" rel="noopener"><code>alignas(val)</code></a>），等等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sz;                             <span class="comment">// 非constexpr变量</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize1 = sz;     <span class="comment">// 错误! sz的值在编译期不可知</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, sz&gt; data1;          <span class="comment">// 错误!一样的问题</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize2 = <span class="number">10</span>;     <span class="comment">// 没问题，10是编译期可知常量</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, arraySize2&gt; data2;  <span class="comment">// 没问题, arraySize2是constexpr</span></span><br></pre></td></tr></table></figure>

<p>注意const不提供constexpr所能保证之事，因为const对象不需要在编译期初始化它的值。简而言之，<strong>所有constexpr对象都是const，但不是所有const对象都是constexpr。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sz;                            <span class="comment">// 和之前一样</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> arraySize = sz;         <span class="comment">// 没问题，arraySize是sz的常量复制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, arraySize&gt; data;   <span class="comment">// 错误，arraySize值在编译期不可知</span></span><br></pre></td></tr></table></figure>

<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191106135004.png" alt="img" style="zoom:67%;" />

<p><strong>（2）关于函数</strong></p>
<p><strong>如果实参是编译期常量，它们将产出编译期值；如果是运行时值，它们就将产出运行时值</strong>。</p>
<p>如果传给constexpr函数的实参是在编译期可知的，结果就将在编译期计算完成。如果不可知，函数就不理你。</p>
<p>换句话说，当一个constexpr函数被一个或者多个编译期不可知值调用时，它就像普通函数一样，运行时计算它的结果。<strong>这意味着你不需要两个函数</strong>，一个用于编译期计算，一个用于运行时计算。</p>
<p><strong>例子1：</strong>假如我来测量电位，把他们的结果评估为高、中、低三种情况，现在我测量了n组样本，那么得到的组合就是<code>3^n</code>。我们需要一个方法在编译期计算<code>3^n</code>。C++标准库提供了<code>std::pow</code>，这里还有两个问题。</p>
<ul>
<li>第一，<code>std::pow</code>是为浮点类型设计的 我们需要整型结果。</li>
<li>第二，<code>std::pow</code>不是constexpr。因此我们需要自己来写：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> <span class="keyword">noexcept</span> <span class="comment">// C++11</span></span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="params">(<span class="built_in">exp</span> == <span class="number">0</span> ? <span class="number">1</span> : base * <span class="built_in">pow</span>(base, <span class="built_in">exp</span> - <span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> <span class="keyword">noexcept</span>  <span class="comment">// C++14</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">exp</span>; ++i) result *= base;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为11的要求是<strong>constexpr函数的代码不超过一行语句</strong>，所以需要采用三目运算符加递归的方式，非常麻烦，所幸14中得到了解决。</p>
<p><strong>例子2：</strong>构建一个点类</p>
<p>在C++11中，除了void外的所有内置类型可以是<strong>constexpr</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    constexpr Point(double xVal = 0, double yVal = 0) noexcept : x(xVal), y(yVal)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">xValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> x; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">yValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Point的构造函数被声明为constexpr，因为如果传入的参数在编译期可知，Point的数据成员也能在编译器可知。因此Point就能被初始化为constexpr：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>; <span class="comment">// 没问题，构造函数会在编译期“运行”</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>; <span class="comment">// 也没问题</span></span><br></pre></td></tr></table></figure>

<p>类似的，<code>xValue</code>和<code>yValu</code>的<code>getter</code>函数也能是<code>constexpr</code>，这使得我们可以写一个constexpr函数里面调用Point的getter并初始化constexpr的对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">midpoint</span><span class="params">(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; (p1.xValue() + p2.xValue()) / <span class="number">2</span>, </span><br><span class="line">             (p1.yValue() + p2.yValue()) / <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = midpoint(p1, p2);</span><br></pre></td></tr></table></figure>

<p>这就很给力了，因为：</p>
<ul>
<li>mid对象通过调用构造函数，getter和成员函数就能在只读内存中创建！</li>
<li>你可以在模板或者需要枚举量的表达式里面使用像<code>mid.xValue()*10</code>的表达式！</li>
<li>以前相对严格的某一行代码只能用于编译期，某一行代码只能用于运行时的界限变得模糊，一些运行时的普通计算能并入编译时。越多这样的代码并入，你的程序就越快。（当然，编译会花费更长时间）</li>
</ul>
<p>在14中，放开了对void的限制，现在你可以：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也能写这样的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">reflection</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point result; </span><br><span class="line">    result.setX(-p.xValue());</span><br><span class="line">    result.setY(-p.yValue()); </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在客户端就能写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = midpoint(p1, p2);</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> reflectedMid =  reflection(mid);</span><br></pre></td></tr></table></figure>

<h1 id="Item-16-Make-const-member-functions-thread-safe"><a href="#Item-16-Make-const-member-functions-thread-safe" class="headerlink" title="Item 16:Make const member functions thread safe"></a>Item 16:Make const member functions thread safe</h1><p>本文解决以下问题：</p>
<ul>
<li>是什么导致const成员函数变成了非线程安全</li>
<li>如何避免非线程安全问题</li>
</ul>
<p><strong>什么导致const成员函数变成了非线程安全</strong>？</p>
<p>首先<strong><code>const</code>的成员函数的线程是绝对安全的</strong>，因为它不允许对类的成员变量进行修改操作，只能读取。<strong>让它变得不安全的是<code>mutable</code>关键词</strong></p>
<blockquote>
<p><code>mutable</code> 只能用来修饰类的数据成员；而被 <code>mutable</code> 修饰的数据成员，可以在 <code>const</code> 成员函数中修改。</p>
</blockquote>
<p>下面这段代码展示了<code>mutable</code>的作用和为什么线程不安全。<code>roots</code>本身是一个<code>const</code>成员函数，每次返回<code>rootVals</code>，而这个值只有在第一次的时候才需要计算，此后只需要直接返回即可，所以这就<strong>有了一个<code>rootsAreValid</code>来表明这个值是否是已经计算</strong>。</p>
<p>此时如果有两个线程同时执行<code>roots</code>，第一个线程发现<code>rootsAreValid</code>是<code>false</code>，开始计算<code>rootVals</code>，在计算的过程中，第二个线程开始执行，发现<code>rootsAreValid</code>也是<code>false</code>，也开始计算<code>rootvals</code>，这就会出错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polynomial</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!rootsAreValid) &#123;</span><br><span class="line">        ....</span><br><span class="line">        rootsAreValid = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> rootVals;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> rootsAreValid &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootVals&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>如何避免这个问题？</strong></p>
<p><strong>（1）使用互斥锁</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polynomial</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; g(m);        <span class="comment">// lock mutex</span></span><br><span class="line">        <span class="keyword">if</span> (!rootsAreVaild) &#123;                    <span class="comment">// 如果缓存无效</span></span><br><span class="line">            rootsAreVaild = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootsVals;</span><br><span class="line">    &#125;                                            <span class="comment">// unlock mutex</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> rootsAreVaild &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootsVals &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码中引入了一个<code>mutable</code>的<code>mutex</code>，因为加锁和解锁本身是会对mutex本身有改动，所以是<code>mutable</code>，但这就带来两个问题：</p>
<ul>
<li>开销变大了，后面<strong>每次都要</strong>加锁获取<code>rootVals</code>，但是其实<strong>只有第一次是可读可写的，非线程安全的，后面就变成只读的了是线程安全的</strong></li>
<li><code>mutex</code>本身其实是一个<strong>只具备移动语义的类</strong>，这导致<code>Polynomial</code>类相应也变成了只具备移动语义的类了，限制了<code>Polynomial</code>类的使用范围。</li>
</ul>
<p><strong>（2）使用原子变量</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span>                                    <span class="comment">// 2D point</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ++callCount;                            <span class="comment">// 原子的递增</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>((x * x) + (y * y));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">unsigned</span>&gt; callCount&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用<code>atomic</code>确保修饰的counter，<strong>保证其他线程视这个操作为不可分割的</strong>。与<code>std::mutex</code>一样，<code>std::atomic</code>是<code>move-only</code>类型，所以在<code>Point</code>中调用<code>Count</code>的意思就是<code>Point</code>也是<code>move-only</code>的。因为<strong>对<code>std::atomic</code>变量的操作通常比互斥量的获取和释放的消耗更小</strong>，所以可能更倾向与依赖<code>std::atomic</code>。但他也有一个很大的问题：</p>
<p>下面的代码的问题是：</p>
<ul>
<li>一个线程调用<code>Widget::magicValue</code>，将<code>cacheValid</code>视为<code>false</code>，执行这两个昂贵的计算，并将它们的和分配给<code>cachedValue</code>。</li>
<li>此时，第二个线程调用<code>Widget::magicValue</code>，也将<code>cacheValid</code>视为<code>false</code>，因此执行刚才完成的第一个线程相同的计算。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">magicValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheVaild) <span class="keyword">return</span> cachedValue;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> val1 = expensiveComputation1();</span><br><span class="line">            <span class="keyword">auto</span> val2 = expensiveComputation2();</span><br><span class="line">            cachedValue = val1 + val2;                <span class="comment">// 第一步</span></span><br><span class="line">            cacheVaild = <span class="literal">true</span>;                        <span class="comment">// 第二步</span></span><br><span class="line">            <span class="keyword">return</span> cachedVaild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; cacheVaild&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; cachedValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以<strong>原子操作只适合于单变量的情况，如果是多变量或多内存位置应使用互斥锁。</strong></p>
<h1 id="Item-17-Understand-special-member-function-generation"><a href="#Item-17-Understand-special-member-function-generation" class="headerlink" title="Item 17:Understand special member function generation"></a>Item 17:Understand special member function generation</h1><p>在C++术语中，特殊成员函数是指C++自己生成的函数。C++98有四个：<strong>默认构造函数函数，析构函数，拷贝构造函数，拷贝赋值运算符</strong>。这些函数仅在需要的时候才生成。</p>
<ul>
<li>class没有任何的<code>constructor</code>，但它内含<code>member object</code>，而后者有默认的构造函数。</li>
<li>class没有任何的<code>constructor</code>，但是它派生自一个带有默认构造函数的基类。</li>
<li>带有虚函数的类</li>
<li>继承自带有虚函数的基类</li>
</ul>
<p>只有在满足上述情况下，编译期才会帮我们生成默认的构造函数，帮我们调用成员变量的构造函数进行初始化，或者是创建虚函数表，调用基类的构造函数，初始化基类等工作。下面的代码就不会产生默认构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">simple</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除此以外，11还产生了两个新的特殊成员函数：<strong>移动构造函数，移动赋值操作符</strong>，其声明方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    .....</span><br><span class="line">    Widget(Widget&amp;&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(widget&amp;&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>移动构造函数的生成规则类似于拷贝构造函数，仅仅当编译器需要的时候才会生成，要求<strong>其每一个非<code>static</code>的成员都具有移动语义</strong>。下面给出一个例子，<strong>Private类型不具有移动语义</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    test() &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    test(<span class="keyword">const</span> test&amp; other) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test t;</span><br><span class="line">    <span class="function">test <span class="title">c</span><span class="params">(<span class="built_in">std</span>::move(t))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>当执行<code>test t</code>时，调用默认构造函数，将<code>p</code>赋值为<code>a</code>。执行<code>test c(std::move(t));</code>时，由于成员不具有移动语义，所以并不能移动构造，只能调用拷贝构造函数，输出<code>&quot;copy construct&quot;</code>，同时<code>p</code>也没有赋值，依然是nullptr。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191107125425.png" alt="img" style="zoom:67%;" />

<p>因此当我们将成员变量改为公有类型，去掉拷贝构造函数，就能使这个类具有移动语义特性时，它就能正确执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  test() &#123;</span><br><span class="line">    str = <span class="string">"test"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  test t;</span><br><span class="line">  <span class="function">test <span class="title">c</span><span class="params">(<span class="built_in">std</span>::move(t))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果给上面的代码加一个拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="keyword">const</span> test&amp; other) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果会调用拷贝构造函数，而不是使用移动构造</strong>。所以我们可以总结得到，造成不能移动构造的<strong>罪魁祸首</strong>是<code>test(const test&amp; other)</code>和<code>char* p = nullptr;</code></p>
<p><strong>那么为什么会这样呢？6个特殊函数的关系如何呢？</strong></p>
<ul>
<li><strong>默认构造函数</strong>，在用户没有声明自定义的构造函数的时候并且编译期需要的时候生成</li>
<li><strong>默认析构函数</strong>，销毁对象时，没有自定义的析构函数就会生成</li>
<li><strong>拷贝构造函数和拷贝赋值操作符</strong>，用户自定义了移动操作会导致不生成默认的拷贝构造函数，其他和上面写的C98的四条原则一样</li>
<li><strong>移动构造函数和移动赋值操作符</strong>，仅仅在没有用户自定义的拷贝操作，移动操作和析构操作的时候才会生成</li>
</ul>
<p>那么如何在自定义能有效使用默认移动构造函数呢？<strong>使用<code>default</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    test() &#123;</span><br><span class="line">        str = <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test(<span class="keyword">const</span> test&amp; other) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test(test&amp;&amp;) = <span class="keyword">default</span>; <span class="comment">//显示的声明默认的移动构造函数</span></span><br><span class="line">    test&amp; <span class="keyword">operator</span>=(test&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8B/" data-id="ck4o2tur8000cu4vyhcn34xv1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B05-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          EffectiveModernCPP笔记5-智能指针
        
      </div>
    </a>
  
  
    <a href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8A/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">EffectiveModernCPP笔记3-现代CPP特性上</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程4-可变参数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B3-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0/">CPP泛型编程3-非类型的模板参数</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B2-%E7%B1%BB%E6%A8%A1%E6%9D%BF/">CPP泛型编程2-类模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程1-函数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/">CPP多线程总结4-并发数据结构设计实例</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>