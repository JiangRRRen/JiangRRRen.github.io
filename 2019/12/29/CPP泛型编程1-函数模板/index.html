<!DOCTYPE html>
<html>
<head>
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'true', 'auto');
ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!-- End Google Analytics -->


    

    



    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="google-site-verification=6xKBD4e783W5YvEkBJE-d7v5QxyEqF7MRInlhMNq8YU">
    
    
    
    
    <title>CPP泛型编程1-函数模板 | JR&#39;s Blog | 直挂云帆济沧海</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="C++,读书笔记">
    <meta name="description" content="泛型编程中，对函数使用模板。">
<meta property="og:type" content="article">
<meta property="og:title" content="CPP泛型编程1-函数模板">
<meta property="og:url" content="jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">
<meta property="og:site_name" content="JR&#39;s Blog">
<meta property="og:description" content="泛型编程中，对函数使用模板。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191227101000.png">
<meta property="article:published_time" content="2019-12-29T01:57:34.000Z">
<meta property="article:modified_time" content="2019-12-30T21:24:05.000Z">
<meta property="article:author" content="Jiang Ren">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191227101000.png">
    
        <link rel="alternate" type="application/atom+xml" title="JR&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <link rel="stylesheet" href="/css/prism/prism-tomorrow-night.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-list-ul"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/MapleStory.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/fong.jpg" style="max-width: 100%;">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Jiang Ren</h5>
          <a href="mailto:jiangren@whu.edu.cn" title="jiangren@whu.edu.cn" class="mail">jiangren@whu.edu.cn</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives/"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/JiangRRRen" target="_blank" rel="noopener"  >
                <i class="icon icon-lg icon-github"></i>
                代码
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">CPP泛型编程1-函数模板</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">CPP泛型编程1-函数模板</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-12-29T01:57:34.000Z" itemprop="datePublished" class="page-time">
  2019-12-29
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-基本概念"><span class="post-toc-text">1. 基本概念</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-参数推断"><span class="post-toc-text">2. 参数推断</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-多模板参数"><span class="post-toc-text">3. 多模板参数</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-函数模板的重载"><span class="post-toc-text">4. 函数模板的重载</span></a></li></ol>
        </nav>
    </aside>


<article id="post-CPP泛型编程1-函数模板"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">CPP泛型编程1-函数模板</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-12-29 09:57:34" datetime="2019-12-29T01:57:34.000Z"  itemprop="datePublished">2019-12-29</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>泛型编程中，对函数使用模板。<a id="more"></a></p>
<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><p>函数模板的格式如下所示：</p>
<pre><code class="lang-cpp">template&lt;typename T&gt; 
T max (T a, T b) 
{     
    return b &lt; a ? a : b; 
}
</code></pre>
<p>含义是一目了然的事情，但是需要注意：</p>
<ul>
<li>传入的ab必须支持运算符&lt;</li>
<li>ab必须是可以拷贝的，否则没法返回</li>
</ul>
<p>具体的使用实例如下：</p>
<pre><code class="lang-cpp">template&lt;typename T&gt;
T max (T a, T b)
{
    return b &lt; a ? a : b;
}

int main()
{
    int i = 42;
    std::cout &lt;&lt; ::max(1, i) &lt;&lt; &#39;\n&#39;;
    double f1 = 3.14;
    double f2 = -3.14;
    std::cout &lt;&lt; ::max(f1, f2) &lt;&lt; &#39;\n&#39;;
    std::string s1 = &quot;mathematics&quot;;
    std::string s2 = &quot;math&quot;;
    std::cout &lt;&lt; ::max(s1, s2) &lt;&lt; &#39;\n&#39;;
}
</code></pre>
<p>需要注意两点：</p>
<ul>
<li>传入的参数类型必须一致，否则会报错，比如<code>::max(5.5,1)</code>，<strong>解决这个问题可以用<code>::max(5.5,1)</code>进行隐式转化</strong></li>
<li>最好使用<code>::</code>标识符，确保函数<code>max()</code>是属于全局空间，避免和<code>std::max()</code>混淆</li>
</ul>
<hr>
<p>我们在编译时，把模板<code>T</code>推导为<code>int</code>的过程叫做<strong>实例化(instantiation)</strong>，而<code>int</code>这个具体的类型就叫做<strong>模板的实例(instance)</strong>。</p>
<p>同时需要注意<strong>void也是合法的模板参数</strong>之一！</p>
<pre><code class="lang-cpp">template&lt;typename T&gt; 
T foo(T*) { } 
void* vp = nullptr; 
foo(vp);     // OK: deduces void 
foo(void*)
</code></pre>
<hr>
<p>另外一个很重要的点是模板的<strong>双重编译(Two-phase Translation)</strong>，实际上模板在编译检查时经历了两个阶段：</p>
<ol>
<li>在没有实例化时，称为<strong>定义时(definition time)</strong>。这时编译器会主要检查语法错误，未定义行为，静态声明等等问题。</li>
<li><strong>实例化时(instantiation time)</strong>，编译器会将模板实例带入重新检查一遍是否合法。</li>
</ol>
<h1 id="2-参数推断"><a href="#2-参数推断" class="headerlink" title="2. 参数推断"></a>2. 参数推断</h1><p>这一部分原书讲的比较简单，其实”Effective Modern C++”讲的挺好的，我之前也做了笔记，这里我直接照搬那本书上的内容。</p>
<p>在做之前我们先明确几个术语，下面的示范代码包含了：</p>
<ul>
<li>param，形参</li>
<li>paramtype，形参的类型，这里是const T&amp;</li>
<li>expr，实参，expression的缩写</li>
<li>CV符，const，volatile</li>
<li>引用符，&amp;</li>
</ul>
<pre><code class="lang-cpp">template&lt;typename T&gt; 
void f(const T&amp; param);  

int expr = 0;
f(expr); // call f with an int
</code></pre>
<p>然后我们分几种情况讨论：</p>
<p><strong>（1）左值引用</strong></p>
<p>步骤：</p>
<ol>
<li>忽略expr中paramtype包含的部分得到T</li>
<li>将T与paramtype配对的到param</li>
</ol>
<pre><code class="lang-CPP">template&lt;typename T&gt; void f(T&amp; param);       // param is a reference

int x = 27;             // x is an int 
const int cx = x;       // cx is a const int 
const int&amp; rx = x;      // rx is a reference to x as a const int

f(x);     // T is int, param&#39;s type is int&amp;
f(cx);    // T is const int,                     
        // param&#39;s type is const int&amp;
f(rx);    // T is const int,                     
        // param&#39;s type is const int&amp;

//////////////////////////////
template&lt;typename T&gt; void f(const T&amp; param);  // param is now a ref-to-const
int x = 27;              // as before 
const int cx = x;        // as before 
const int&amp; rx = x;       // as before
f(x);     // T is int, param&#39;s type is const int&amp;
f(cx);     // T is int, param&#39;s type is const int&amp;
f(rx);     // T is int, param&#39;s type is const int&amp;

////////////////////////////////////
//指针也适用这个原则
template&lt;typename T&gt; void f(T* param);        
// param is now a pointer
int x = 27;                 // as before 
const int *px = &amp;x;         // px is a ptr to x as a const int
f(&amp;x);    // T is int, param&#39;s type is int*
f(px);  // T is const int,               
        // param&#39;s type is const int*
</code></pre>
<p><strong>（2）右值引用</strong></p>
<p>步骤：</p>
<ol>
<li>如果expr是左值，T和param都被推为<strong>左值并加上引用</strong>(不管有没有统统加上引用符)</li>
<li>如果是右值，T不变，<code>param</code>加上&amp;&amp;。</li>
</ol>
<p>示例：</p>
<pre><code class="lang-cpp">template&lt;typename T&gt; void f(T&amp;&amp; param);      
int x = 27;              // as before 
const int cx = x;        // as before 
const int&amp; rx = x;       // as before
f(x);                   // x is lvalue, so T is int&amp;, 
                        // param&#39;s type is also int&amp;
f(cx);                  // cx is lvalue, so T is const int&amp;,   
                        // param&#39;s type is also const int&amp;
f(rx);                  // rx is lvalue, so T is const int&amp;,   
                        // param&#39;s type is also const int&amp;
f(27);                  // 27 is rvalue, so T is int,           
                        // param&#39;s type is therefore int&amp;&amp;
</code></pre>
<p><strong>（3）值传递</strong></p>
<p>这就是最基本的值传递。意味着，<code>param</code>复制了一个传入的参数。他的哲学就是忽略忽略再忽略：</p>
<ul>
<li><strong>如果<code>expr</code>是引用</strong>，忽略引用的部分</li>
<li><strong>如果忽略引用后</strong>，<code>expr</code>是<code>const</code>类型或<code>volatile</code>类型，忽略。</li>
</ul>
<pre><code class="lang-cpp">template&lt;typename T&gt; void 
f(T param);         // param is now passed by value 

int x = 27;          // as before 
const int cx = x;    // as before 
const int&amp; rx = x;   // as before
f(x);                // T&#39;s and param&#39;s types are both int
f(cx);               // T&#39;s and param&#39;s types are again both int
f(rx);               // T&#39;s and param&#39;s types are still both int
</code></pre>
<p>注意：<strong>只是忽略引用，指针还是不变</strong>。</p>
<pre><code class="lang-cpp">template&lt;typename T&gt; void f(T param);         
// param is still passed by value
const char* const ptr =&quot;Fun with pointers&quot;;  
// ptr is const pointer to const object  
f(ptr);
//T is const char* const
</code></pre>
<p><strong>（4）退化</strong></p>
<p><strong>数组类型和指针类型是完全不一样的</strong>(虽然他们在使用时可以混用)。由于C语言老祖宗的继承关系，C++依然保留了这些特性，导致很多人误以为数组和指针参数是一样的。在传递过程中，<strong>数组会退化为它第一个元素的指针</strong>。</p>
<pre><code class="lang-cpp">template&lt;typename T&gt; void f(T param);
const char name[] = &quot;J. P. Briggs&quot;;  // name&#39;s type is const char[13]
const char * ptrToName = name;       // array decays to pointer

f(name); // name is array, but T deduced as const char*
</code></pre>
<p>这种退化导致有用的信息(数组长度)丢失<strong>。然而声明引用，可以使得模板推断保留成数组的形式</strong>：</p>
<pre><code class="lang-cpp">template&lt;typename T&gt;
void f(T&amp; param);
f(name);  //deduce to const char[13]
</code></pre>
<p>在这个例子中<code>T</code>被推导为<strong>const char[13]</strong>，<code>param</code>则被推导为<strong>const char(&amp;)[13]</strong>。<strong>如果改为<code>T&amp;&amp;</code>，</strong>则<code>T</code>和<code>param</code>都被推为<code>const char(&amp;)[13]</code></p>
<p>讲完数组，再来讲讲函数。在C++中不止是数组会退化为指针，函数类型也会<strong>退化为一个函数指针</strong>，我们对于数组的全部讨论都可以应用到函数来：</p>
<pre><code class="lang-cpp">void someFunc(int, double);  // someFunc is a function;
                             // type is void(int, double)
template&lt;typename T&gt; void f1(T param);     // in f1, param passed by value
template&lt;typename T&gt; void f2(T&amp; param);    // in f2, param passed by ref
f1(someFunc);               // param deduced as ptr-to-func;
                            // type is void (*)(int, double)
f2(someFunc);               // param deduced as ref-to-func;
                            // type is void (&amp;)(int, double)
</code></pre>
<h1 id="3-多模板参数"><a href="#3-多模板参数" class="headerlink" title="3. 多模板参数"></a>3. 多模板参数</h1><p>多模板参数的形式是简单的，但细节需要考究。</p>
<pre><code class="lang-cpp">template&lt;typename T1, typename T2&gt;
T1 max (T1 a, T2 b)
{
    return b &lt; a ? a : b;
}

auto m = ::max(1, 3.14); // 返回类型由第一个实参决定
</code></pre>
<p>上面的例子如果改为单模板参数则无法成功匹配。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191227101000.png"  style="zoom:67%;display: block; margin: 0px auto; vertical-align: middle;"></p>
<p>而如果改为多模板参数，则<strong>调用过程发生了隐式转化，返回类型由第一个参数决定</strong>。如果我们把1和3.14调换位置，则返回的是double类型而不是int。</p>
<p>我们可以通过<strong>指定返回参数模板</strong>来解决这个问题。这段代码我们用尖括号指定模板类型，对应的位置就是RT，这样我们就能顺利返回我们想要的类型了。</p>
<pre><code class="lang-cpp">template&lt;typename RT, typename T1, typename T2&gt;
RT max (T1 a, T2 b);
{
    return b &lt; a ? a : b;
}

::max&lt;double&gt;(1, 3.14); // 返回类型为double, T1和T2被推断
</code></pre>
<hr>
<p>在现代CPP体系中，我们可以自动推导返回类型。下面这段代码展示了11和14的一些区别。当我们调用<code>::max(5, 1.2)</code>的时候，5被隐式转化为double类型，返回的结果也是double类型。</p>
<pre><code class="lang-cpp">template&lt;typename T1, typename T2&gt;
// FOR c++14
auto max (T1 a, T2 b)
{
    return b &lt; a ? a : b;
}
//FOR c++11
template&lt;typename T1, typename T2&gt;
auto max (T1 a, T2 b) -&gt; decltype(b &lt; a ? a : b)
{
    return b &lt; a ? a : b;
}
</code></pre>
<p>但是，有时候这有可能会<strong>导致返回引用类型</strong>，因为paramtype可能就写为引用类型，我们需要调用<code>decayed</code>去除引用符号（需要头文件<type_trait>）</p>
<pre><code class="lang-cpp">template&lt;typename T1, typename T2&gt;
auto max(T1 a, T2 b) -&gt; typename std::decay&lt;decltype(true ? a : b)&gt;::type
{
    return b &lt; a ? a : b;
}
</code></pre>
<hr>
<p>现代CPP中引入了Common Type这一概念，相当于最大兼容。</p>
<pre><code class="lang-c">common_type&lt;int, float&gt;::type // float，因为int可以转换成float
common_type&lt;int, float, double&gt;::type // double，因为int, float都可以转换成double
</code></pre>
<p>利用这个特性，我们能够进一步改造模板。（注意一下14那个有_t，11那个没有）</p>
<pre><code class="lang-cpp">// for C++14
std::common_type_t&lt;T1,T2&gt; max(T1 a,T2 b)
{
    return a&gt;b?a:b;
}
// for C++11
std::common_type&lt;T1,T2&gt;::type max(T1 a,T2 b)
{
    return a&gt;b?a:b;
}
</code></pre>
<h1 id="4-函数模板的重载"><a href="#4-函数模板的重载" class="headerlink" title="4. 函数模板的重载"></a>4. 函数模板的重载</h1><p><strong>具有相同名称的非函数模板可以和函数模板共存</strong>，利用这个特性我们能实现模板函数的重载。</p>
<pre><code class="lang-cpp">int max (int a, int b)
{
    return b &lt; a ? a : b;
}

template&lt;typename T&gt; //共存
T max (T a, T b)
{
    return b &lt; a ? a : b;
}
int main()
{
    ::max(1, 42); // 调用非模板的函数
    ::max(1.0, 3.14); // 通过推断调用max&lt;double&gt;
    ::max(&#39;a&#39;, &#39;b&#39;); // 通过推断调用max&lt;char&gt;
    ::max&lt;&gt;(1, 42); // 通过推断调用max&lt;int&gt;
    ::max&lt;double&gt;(1, 42); // 调用max&lt;double&gt;，不推断
}
</code></pre>
<p>上面的代码展示了编译器的特性：<strong>选择最优匹配的函数</strong>。</p>
<p>重载模板的原则是需要保证<strong>只有一个合理匹配</strong>，否则会造成歧义，导致无法通过编译。下面的代码中，由于double可以被隐式转化为int，所以会导致歧义。</p>
<pre><code class="lang-cpp">template&lt;typename T1, typename T2&gt;
auto max (T1 a, T2 b){return b &lt; a ? a : b;}

template&lt;typename RT, typename T1, typename T2&gt;
RT max (T1 a, T2 b){return b &lt; a ? a : b;}

auto a = ::max(1, 3.14); // 调用第一个模板
auto b = ::max&lt;long double&gt;(3.14, 1); // 调用第二个模板
auto c = ::max&lt;int&gt;(1, 3.14); // 错误：两个模板都匹配
</code></pre>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        

        
        文章发布地址：<a href="/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/" target="_blank" rel="external">jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</a>
        
    </div>
    
    <footer>
        <a href="jiangren.work">
            <img src="/img/fong.jpg" alt="Jiang Ren">
            Jiang Ren
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/&title=《CPP泛型编程1-函数模板》 — JR's Blog&pic=jiangren.work/img/fong.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/&title=《CPP泛型编程1-函数模板》 — JR's Blog&source=泛型编程中，对函数使用模板。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《CPP泛型编程1-函数模板》 — JR's Blog&url=jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/&via=jiangren.work" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/12/29/EffectiveModernCPP%E7%AC%94%E8%AE%B08-%E5%B9%B6%E5%8F%91API/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">EffectiveModernCPP笔记8-并发API</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/12/28/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">CPP多线程总结4-并发数据结构设计实例</h4>
      </a>
    </div>
  
</nav>



    





















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持！
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/true" alt="打赏二维码">
        </div>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


            <p>
                
                    <span>
                        <a href="/atom.xml" target="_blank" class="rss" title="rss">
                            <i class="icon icon-lg icon-rss"></i>
                        </a>
                    </span>
                    
                        <span>
                            博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
                        </span>
            </p>
    </div>
    <div class="bottom">
        <p>
            <span>
                Jiang Ren &copy;
                    
                        2019 -
                            
                                2020
            </span>
            <span>
                
                        Power by
                        <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
                        <a href="https://github.com/abelsu7/hexo-theme-indigo-plus" target="_blank">indigo plus</a>
                        <p>Hosted by <a href="https://pages.github.com" target="_blank" style="font-weight: bold">Github Pages</a></p>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>
<a href="javascript:;" id="gobottom" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-comments"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/&title=《CPP泛型编程1-函数模板》 — JR's Blog&pic=jiangren.work/img/fong.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/&title=《CPP泛型编程1-函数模板》 — JR's Blog&source=泛型编程中，对函数使用模板。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《CPP泛型编程1-函数模板》 — JR's Blog&url=jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/&via=jiangren.work" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/" alt="微信分享二维码">
</div>




    <script src="//cdn.jsdelivr.net/npm/node-waves@0.7.6/src/js/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<!-- <script async src="//cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script> -->
<!-- <script async src="//cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script> -->




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="/js/prism.min.js?v=1.7.2"></script>
<script src="/js/prism-vim.min.js?v=1.7.2"></script>
</body>
</html>
