<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-CPP泛型编程4-可变参数模板" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/" class="article-date">
  <time datetime="2019-12-27T09:58:06.000Z" itemprop="datePublished">2019-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程4-可变参数模板</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-可变参数模板示例"><a href="#1-可变参数模板示例" class="headerlink" title="1. 可变参数模板示例"></a>1. 可变参数模板示例</h1><p>在C++11以后，模板可以接收任意数量的参数，因此被称作可变参数的模板(variadic templates).</p>
<p>下面展示一段非常精妙的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">()</span> </span>&#123;&#125; <span class="comment">// 没有参数时将调用此函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(T firstArg, Types... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="string">' '</span>;  <span class="comment">// 打印第一个实参</span></span><br><span class="line">    print(args...); <span class="comment">// 调用print()打印其余实参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line">    print(<span class="number">3.14</span>, <span class="string">"hello"</span>, s); <span class="comment">// 3.14 hello world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码采用了递归的办法进行打印，每次递归都会减少参数个数。需要注意</p>
<ul>
<li><code>Types... args</code>必须在三点后面打空格，有点类似于CV符，引用的那种感觉。</li>
<li><code>args...</code>可以被视为一个打包的参数</li>
<li>每次进入print函数，都会将<code>args...</code>分为一个单一的<code>firstArg</code>和一个新的打包参数<code>args...</code></li>
<li>必须要准备一个空函数以<strong>防止没有参数时将调用此函数</strong></li>
</ul>
<hr>
<p>上例也可以如下实现，<strong>如果两个函数模板只有尾置参数包不同，会优先匹配没有尾置参数包的版本</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(T firstArg, Types... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(firstArg);</span><br><span class="line">    print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-sizeof…"><a href="#3-sizeof…" class="headerlink" title="3. sizeof…"></a>3. sizeof…</h1><p>在C++11中，引入了一个新的<code>sizeof...</code>运算符来应对可变参数，它的形式非常有趣：这是一个<strong>由标点符号和字符共同组建的一个运算符</strong>，它的作用就是<strong>算出可变参数的数量</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(T firstArg, Types... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// print number of remaining args</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会想到利用这个特性来处理前面的例子中比较麻烦的递归结尾，但这样会报错：<strong>实例化后的代码是否能发挥作用是在运行时决定，而实例化的调用是否合法是编译时决定</strong>。听起来有点绕，简单来说就是模板编译时，会<strong>无视if里面的判断条件</strong>，实例化print，直到出现print( )里面为空的情况。然后就是报错。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191123145523.png" alt="img" style="zoom:80%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(T firstArg, Types... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>...(args) &gt; <span class="number">0</span>) &#123; <span class="comment">// sizeof...(args)==0时会出错</span></span><br><span class="line">        print(args...); <span class="comment">// 因为print(args...)仍将被初始化，而此时没有实参</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-折叠表达式"><a href="#4-折叠表达式" class="headerlink" title="4. 折叠表达式"></a>4. 折叠表达式</h1><p>C++17新引入的语法糖，非常有用，值得学习！</p>
<p>折叠表达式的作用就是：<strong>使用二元运算符计算剩余参数包里面的参数</strong>。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foldSum</span> <span class="params">(T... s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... + s);   <span class="comment">// ((s1 + s2) + s3) ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意一下如果参数包为空，则表达式会被判定为非法。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191123151624.png" alt="img" style="zoom:67%;" />

<p>折叠表达式的运算规则如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foldSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 假如实参是12345</span></span><br><span class="line">(... + s)：((((<span class="number">1</span> + <span class="number">2</span>) + <span class="number">3</span>) + <span class="number">4</span>) + <span class="number">5</span>)</span><br><span class="line">(s + ...)：(<span class="number">1</span> + (<span class="number">2</span> + (<span class="number">3</span> + (<span class="number">4</span> + <span class="number">5</span>))))</span><br><span class="line">(<span class="number">0</span> + ... + s)：(((((<span class="number">0</span> + <span class="number">1</span>) + <span class="number">2</span>) + <span class="number">3</span>) + <span class="number">4</span>) + <span class="number">5</span>)</span><br><span class="line">(s + ... + <span class="number">0</span>)：(<span class="number">1</span> + (<span class="number">2</span> + (<span class="number">3</span> + (<span class="number">4</span> + (<span class="number">5</span> + <span class="number">0</span>)))))</span><br></pre></td></tr></table></figure>

<p>除了上面的求和，求累积外，还有其他用法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node(<span class="keyword">int</span> i = <span class="number">0</span>) : val(i), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function">Node* <span class="title">traverse</span><span class="params">(T root, Ts... paths)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (root -&gt;* ... -&gt;* paths); <span class="comment">// root -&gt;* paths1 -&gt;* paths2 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* node2 = traverse(root, left, right);</span><br><span class="line">    <span class="comment">//左子节点，左子节点的右子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）使用折叠表达式简化打印所有参数的可变参数模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Ts&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想用空格分隔参数包元素，需要使用一个包裹类来提供此功能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddSpace</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; ref; <span class="comment">// 构造函数中的实参的引用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AddSpace(<span class="keyword">const</span> T&amp; r): ref(r) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream&amp; os, AddSpace&lt;T&gt; s) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; s.ref &lt;&lt; <span class="string">' '</span>;   <span class="comment">// 输出传递的实参和一个空格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ... &lt;&lt; AddSpace(args)) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-可变参数表达式"><a href="#5-可变参数表达式" class="headerlink" title="5. 可变参数表达式"></a>5. 可变参数表达式</h1><p>前面说到可变参数的本质也是参数，既然如此我们就可以针对他进行相关的运算。</p>
<p>比如比如让每个元素翻倍后传递给再打印：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Args&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ... &lt;&lt; args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDoubled</span> <span class="params">(<span class="keyword">const</span> T&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print (args + args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意参数包的省略号不能直接接在数值字面值后:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">(<span class="keyword">const</span> T&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print (args + <span class="number">1.</span>..); <span class="comment">// 错误 1...是带多个小数点的字面值，不合法</span></span><br><span class="line">    print (args + <span class="number">1</span> ...); <span class="comment">// OK</span></span><br><span class="line">    print ((args + <span class="number">1</span>)...); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-可变参数索引"><a href="#6-可变参数索引" class="headerlink" title="6. 可变参数索引"></a>6. 可变参数索引</h1><p>以索引形式访问：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Args&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ... &lt;&lt; args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span>… Idx&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printElems</span> <span class="params">(C <span class="keyword">const</span>&amp; coll, Idx… idx)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    print (coll[idx]…); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v&#123; <span class="string">"good"</span>, <span class="string">"times"</span>, <span class="string">"say"</span>, <span class="string">"bye"</span> &#125;;</span><br><span class="line">    printElems(v, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">// say good bye：等价于print(v[2], v[0], v[3]);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非类型模板参数也可以声明为参数包:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>... N, <span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIdx</span><span class="params">(<span class="keyword">const</span> C&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(c[N]...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v&#123; <span class="string">"good"</span>, <span class="string">"times"</span>, <span class="string">"say"</span>, <span class="string">"bye"</span> &#125;;</span><br><span class="line">printIdx&lt;<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&gt;(v);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/" data-id="ck4o2tuqz0005u4vy71pza4qa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CPP泛型编程3-非类型的模板类参数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B3-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0/" class="article-date">
  <time datetime="2019-12-27T09:57:58.000Z" itemprop="datePublished">2019-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B3-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0/">CPP泛型编程3-非类型的模板参数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-非类型的类模板参数"><a href="#1-非类型的类模板参数" class="headerlink" title="1. 非类型的类模板参数"></a>1. 非类型的类模板参数</h1><p>在类的模板参数列表中，<strong>不一定是都是类型</strong>，或者适配器<strong>，也可以是一个数</strong>。</p>
<p>我们可以通过非类型的类模板<strong>指定固定长度的栈</strong>，这样做的好处是避免动态的内存管理。下面的代码中，我们通过指定<code>Maxsize</code>来创建<code>array</code>从而进一步固化内存，<strong>限制栈的长度</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;T, Maxsize&gt; v;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">Stack&lt;<span class="keyword">int</span>, <span class="number">20</span>&gt; intStack; <span class="comment">// 20个int的Stack</span></span><br></pre></td></tr></table></figure>

<p>当我们在使用的时候，需要针对<code>Maxsize</code>来做一些改善，比如在push时，就需要考虑上限问题，同时也要更新参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T, Maxsize&gt;::push(<span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    assert(n &lt; Maxsize); <span class="comment">// 确定Stack未满</span></span><br><span class="line">    v[n] = x;</span><br><span class="line">    ++n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-非类型的函数模板参数"><a href="#2-非类型的函数模板参数" class="headerlink" title="2. 非类型的函数模板参数"></a>2. 非类型的函数模板参数</h1><p>你也可以在函数模板中直接定义参数，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> val, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">addvalue</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+Val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用来作函数的谓语，和lambda表达式一样（虽然我觉得并没有lambda好用）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">std</span>::transform(v.begin(), v.end(), v2.begin(), addValue&lt;<span class="number">1</span>, <span class="keyword">int</span>&gt;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : v2) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x; <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>在C++17中允许将非类型模板参数定义为auto，以接收任何<strong>允许作为非类型模板参数</strong>的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">emplate&lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> Maxsize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;T, Maxsize&gt; v;</span><br><span class="line">    size_type n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="keyword">decltype</span>(Maxsize);</span><br><span class="line">    Stack();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++14中允许auto作为返回类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果在类外定义size成员函数要写为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">typename</span> Stack&lt;T, Maxsize&gt;::size_type Stack&lt;T, Maxsize&gt;::size() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14中可写为</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">auto</span> Stack&lt;T, Maxsize&gt;::size() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B3-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0/" data-id="ck4o2tur20008u4vyctgd42w8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CPP泛型编程2-类模板" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B2-%E7%B1%BB%E6%A8%A1%E6%9D%BF/" class="article-date">
  <time datetime="2019-12-27T09:57:46.000Z" itemprop="datePublished">2019-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B2-%E7%B1%BB%E6%A8%A1%E6%9D%BF/">CPP泛型编程2-类模板</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-简单使用类模板"><a href="#1-简单使用类模板" class="headerlink" title="1. 简单使用类模板"></a>1. 简单使用类模板</h1><p>以stack为例，展示类模板的特性，先写出一个stack的样例。与函数模板一样，类模板也需要在前面加上模板声明。需要注意的是，类的成员函数的实现可以不放在类中，<strong>放在外面也需要加上模板声明</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; elems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> elems.empty()&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">stack</span>&lt;T&gt;::push(T <span class="keyword">const</span>&amp; elem)</span><br><span class="line">&#123;</span><br><span class="line">    elems.push_back(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">stack</span>&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!elems.empty());</span><br><span class="line">    elems.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T <span class="keyword">const</span>&amp; <span class="built_in">stack</span>&lt;T&gt;::top()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!elems.empty());</span><br><span class="line">    <span class="keyword">return</span> elems.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以继续为其添加拷贝构造函数和赋值运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>(<span class="built_in">stack</span>&lt;T&gt; <span class="keyword">const</span>&amp;);</span><br><span class="line"><span class="built_in">stack</span>&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="built_in">stack</span>&lt;T&gt; <span class="keyword">const</span>&amp;);</span><br></pre></td></tr></table></figure>

<hr>
<p>通过上面这个例子，我们熟悉类类模板的一些特性。使用类模板时必须要 <strong>显式地特化模板参数</strong>(specify the template arguments explictly)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt; <span class="keyword">int</span>&gt;    intStack;<span class="comment">// stack of ints</span></span><br><span class="line">Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; stringStack;  <span class="comment">// stack of string</span></span><br></pre></td></tr></table></figure>

<p>当然也可以使用<code>using</code>或<code>typedef</code>来简化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> IntStack = Stack&lt;<span class="keyword">int</span>&gt;; </span><br><span class="line"><span class="keyword">typedef</span> Stack&lt;<span class="keyword">int</span>&gt; IntStack</span><br></pre></td></tr></table></figure>

<p>类模板可以实现<strong>部分使用(partial usage)</strong>，这意味着模板参数只需要提供必要的操作，而不是所有。下面这个例子中模板类<code>stack</code>中包含了一个<code>printOn</code>函数，而<code>pair</code>类型不能与<code>printOn</code>相适应，但我们依然可以创建并执行一些必要的操作，但不能使用<code>printOn</code>.（因为无法使用操作符<code>&lt;&lt;</code>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printOn</span><span class="params">(<span class="built_in">std</span>::ostream&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::printOn(<span class="built_in">std</span>::ostream&amp; os) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> T&amp; x : v) os &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; s; <span class="comment">// std::pair没有定义operator&lt;&lt;</span></span><br><span class="line">s.push(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">s.push(&#123;<span class="number">3</span>, <span class="number">4</span>&#125;); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.top().first &lt;&lt; s.top().second; <span class="comment">// 34</span></span><br><span class="line">s.printOn(<span class="built_in">std</span>::<span class="built_in">cout</span>); <span class="comment">// 错误：元素类型不支持operator&lt;&lt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>类模板也可以使用<strong>默认实参</strong>。当然这并不意味着传入的参数被强制规定为<code>std::vector</code>，而是作为一种选择，<code>&lt;Stack&gt; doubleStack;</code>这样依然是ok的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;</span><br><span class="line">class Stack &#123; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Cont v;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-友元"><a href="#2-友元" class="headerlink" title="2. 友元"></a>2. 友元</h1><p>假设我们重载&lt;&lt;运算符来替代<code>printOn</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printOn</span><span class="params">(<span class="built_in">std</span>::ostream&amp; os)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> T&amp; x : v) os &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> Stack&lt;T&gt;&amp; <span class="built_in">stack</span>) &#123;</span><br><span class="line">        <span class="built_in">stack</span>.printOn(os); </span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是，如果<strong>将友元的定义和实现放在类外就会出一些问题</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Stack&lt;T&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os,</span><br><span class="line">    <span class="keyword">const</span> Stack&lt;T&gt;&amp; <span class="built_in">stack</span>) <span class="comment">// 错误：类模板参数T不可见</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>.printOn(os);</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于友元并不属于这个类，所以没法享受到类型推导的成果，自然就会报错。这个问题的解决方案有很多，我挑选了一种我认为比较好的办法：<strong>隐式声明一个新的函数模板，并使用不同的模板参数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    … </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; </span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Stack&lt;U&gt;&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> Stack&lt;U&gt;&amp; <span class="built_in">stack</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>.printOn(os);</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-特化与偏特化"><a href="#3-特化与偏特化" class="headerlink" title="3. 特化与偏特化"></a>3. 特化与偏特化</h1><p><strong>特化(specify)</strong>，可以<strong>直接指定模板的类型</strong>，标志是<code>template&lt;&gt;</code>。由于是直接指定的方式，所以声明模板类型时就不必要再添东西了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;std::string&gt; &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::push(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    v.emplace_back(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们直接指定stack为string类型。注意在类外定义的时候，也必须带上string。</p>
<hr>
<p><strong>偏特化(partial specify)</strong>，在已经声明某一个模板的前提下，再对他进行声明。</p>
<p><strong>（1）指定指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack1.h"</span> <span class="comment">//非常重要</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;T*&gt; &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T*&gt; v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T*)</span></span>;</span><br><span class="line">    <span class="function">T* <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T* <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T*&gt;::push(T* x)</span><br><span class="line">&#123;</span><br><span class="line">    v.emplace_back(x);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Stack&lt; <span class="keyword">int</span>*&gt; ptrStack; <span class="comment">//用法展示</span></span><br><span class="line">ptrStack.push(<span class="keyword">new</span> <span class="keyword">int</span>&#123;<span class="number">42</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>必须要在<code>stack1.h</code>中声明成如下形式，否则无法通过编译。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> M&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（2）指定部分模板参数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化：两个模板参数有相同类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;T, T&gt;</span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化：第二个模板参数类型为int</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;T, int&gt;</span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化：两个模板参数都是指针类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;T1*, T2*&gt;</span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">A&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; a; <span class="comment">// A&lt;T1, T2&gt;</span></span><br><span class="line">A&lt;<span class="keyword">double</span>, <span class="keyword">float</span>&gt; b; <span class="comment">// A&lt;T, T&gt;</span></span><br><span class="line">A&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; c; <span class="comment">// A&lt;T, int&gt;</span></span><br><span class="line">A&lt;<span class="keyword">int</span>*, <span class="keyword">double</span>*&gt; d; <span class="comment">// A&lt;T1*, T2*&gt;</span></span><br></pre></td></tr></table></figure>

<p>要注意避免歧义性错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; e; <span class="comment">// 错误：同时匹配A&lt;T, T&gt;和A&lt;T, int&gt;</span></span><br><span class="line">A&lt;<span class="keyword">int</span>*, <span class="keyword">int</span>*&gt; f; <span class="comment">// 错误：同时匹配A&lt;T, T&gt;和A&lt;T1*, T2*&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="4-模板化聚合"><a href="#4-模板化聚合" class="headerlink" title="4. 模板化聚合"></a>4. 模板化聚合</h1><p>当一个类的对象拥有另一个类的对象时就发生类聚合。这种聚合不依赖与继承、友元等关系存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">double</span> b;</span><br><span class="line">  C c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>事实上，聚合类也能作为模板存在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    T x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样可以为了参数化值而定义一个聚合:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">a.x = <span class="number">42</span>;</span><br><span class="line">a.s = <span class="string">"initial value"</span>;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B2-%E7%B1%BB%E6%A8%A1%E6%9D%BF/" data-id="ck4o2tuqy0004u4vy61s4gd3t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CPP泛型编程1-函数模板" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/" class="article-date">
  <time datetime="2019-12-27T09:57:34.000Z" itemprop="datePublished">2019-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程1-函数模板</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><p>函数模板的格式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>含义是一目了然的事情，但是需要注意：</p>
<ul>
<li>传入的ab必须支持运算符&lt;</li>
<li>ab必须是可以拷贝的，否则没法返回</li>
</ul>
<p>具体的使用实例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::max(<span class="number">1</span>, i) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">double</span> f1 = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">double</span> f2 = <span class="number">-3.14</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::max(f1, f2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">"mathematics"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">"math"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::max(s1, s2) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意两点：</p>
<ul>
<li>传入的参数类型必须一致，否则会报错，比如<code>::max(5.5,1)</code>，<strong>解决这个问题可以用<code>::max(5.5,1)</code>进行隐式转化</strong></li>
<li>最好使用<code>::</code>标识符，确保函数<code>max()</code>是属于全局空间，避免和<code>std::max()</code>混淆</li>
</ul>
<hr>
<p>我们在编译时，把模板<code>T</code>推导为<code>int</code>的过程叫做<strong>实例化(instantiation)</strong>，而<code>int</code>这个具体的类型就叫做<strong>模板的实例(instance)</strong>。</p>
<p>同时需要注意<strong>void也是合法的模板参数</strong>之一！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T*)</span> </span>&#123; &#125; </span><br><span class="line"><span class="keyword">void</span>* vp = <span class="literal">nullptr</span>; </span><br><span class="line">foo(vp);     <span class="comment">// OK: deduces void </span></span><br><span class="line">foo(<span class="keyword">void</span>*)</span><br></pre></td></tr></table></figure>

<hr>
<p>另外一个很重要的点是模板的<strong>双重编译(Two-phase Translation)</strong>，实际上模板在编译检查时经历了两个阶段：</p>
<ol>
<li>在没有实例化时，称为<strong>定义时(definition time)</strong>。这时编译器会主要检查语法错误，未定义行为，静态声明等等问题。</li>
<li><strong>实例化时(instantiation time)</strong>，编译器会将模板实例带入重新检查一遍是否合法。</li>
</ol>
<h1 id="2-参数推断"><a href="#2-参数推断" class="headerlink" title="2. 参数推断"></a>2. 参数推断</h1><p>这一部分原书讲的比较简单，其实”Effective Modern C++”讲的挺好的，我之前也做了笔记，这里我直接照搬那本书上的内容。</p>
<p>在做之前我们先明确几个术语，下面的示范代码包含了：</p>
<ul>
<li>param，形参</li>
<li>paramtype，形参的类型，这里是const T&amp;</li>
<li>expr，实参，expression的缩写</li>
<li>CV符，const，volatile</li>
<li>引用符，&amp;</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> expr = <span class="number">0</span>;</span><br><span class="line">f(expr); <span class="comment">// call f with an int</span></span><br></pre></td></tr></table></figure>

<p>然后我们分几种情况讨论：</p>
<p><strong>（1）左值引用</strong></p>
<p>步骤：</p>
<ol>
<li>忽略expr中paramtype包含的部分得到T</li>
<li>将T与paramtype配对的到param</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;       <span class="comment">// param is a reference</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;             <span class="comment">// x is an int </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;       <span class="comment">// cx is a const int </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;      <span class="comment">// rx is a reference to x as a const int</span></span><br><span class="line"></span><br><span class="line">f(x);     <span class="comment">// T is int, param's type is int&amp;</span></span><br><span class="line">f(cx);    <span class="comment">// T is const int,                     </span></span><br><span class="line">        <span class="comment">// param's type is const int&amp;</span></span><br><span class="line">f(rx);    <span class="comment">// T is const int,                     </span></span><br><span class="line">        <span class="comment">// param's type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;  <span class="comment">// param is now a ref-to-const</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;              <span class="comment">// as before </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;        <span class="comment">// as before </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;       <span class="comment">// as before</span></span><br><span class="line">f(x);     <span class="comment">// T is int, param's type is const int&amp;</span></span><br><span class="line">f(cx);     <span class="comment">// T is int, param's type is const int&amp;</span></span><br><span class="line">f(rx);     <span class="comment">// T is int, param's type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////</span></span><br><span class="line"><span class="comment">//指针也适用这个原则</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;        </span><br><span class="line"><span class="comment">// param is now a pointer</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;                 <span class="comment">// as before </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *px = &amp;x;         <span class="comment">// px is a ptr to x as a const int</span></span><br><span class="line">f(&amp;x);    <span class="comment">// T is int, param's type is int*</span></span><br><span class="line">f(px);  <span class="comment">// T is const int,               </span></span><br><span class="line">        <span class="comment">// param's type is const int*</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）右值引用</strong></p>
<p>步骤：</p>
<ol>
<li>如果expr是左值，T和param都被推为<strong>左值并加上引用</strong>(不管有没有统统加上引用符)</li>
<li>如果是右值，T不变，<code>param</code>加上&amp;&amp;。</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;      </span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;              <span class="comment">// as before </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;        <span class="comment">// as before </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;       <span class="comment">// as before</span></span><br><span class="line">f(x);                   <span class="comment">// x is lvalue, so T is int&amp;, </span></span><br><span class="line">                        <span class="comment">// param's type is also int&amp;</span></span><br><span class="line">f(cx);                  <span class="comment">// cx is lvalue, so T is const int&amp;,   </span></span><br><span class="line">                        <span class="comment">// param's type is also const int&amp;</span></span><br><span class="line">f(rx);                  <span class="comment">// rx is lvalue, so T is const int&amp;,   </span></span><br><span class="line">                        <span class="comment">// param's type is also const int&amp;</span></span><br><span class="line">f(<span class="number">27</span>);                  <span class="comment">// 27 is rvalue, so T is int,           </span></span><br><span class="line">                        <span class="comment">// param's type is therefore int&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）值传递</strong></p>
<p>这就是最基本的值传递。意味着，<code>param</code>复制了一个传入的参数。他的哲学就是忽略忽略再忽略：</p>
<ul>
<li><strong>如果<code>expr</code>是引用</strong>，忽略引用的部分</li>
<li><strong>如果忽略引用后</strong>，<code>expr</code>是<code>const</code>类型或<code>volatile</code>类型，忽略。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> </span><br><span class="line">f(T param);         <span class="comment">// param is now passed by value </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;          <span class="comment">// as before </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;    <span class="comment">// as before </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;   <span class="comment">// as before</span></span><br><span class="line">f(x);                <span class="comment">// T's and param's types are both int</span></span><br><span class="line">f(cx);               <span class="comment">// T's and param's types are again both int</span></span><br><span class="line">f(rx);               <span class="comment">// T's and param's types are still both int</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>只是忽略引用，指针还是不变</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;         </span><br><span class="line"><span class="comment">// param is still passed by value</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> ptr =<span class="string">"Fun with pointers"</span>;  </span><br><span class="line"><span class="comment">// ptr is const pointer to const object  </span></span><br><span class="line">f(ptr);</span><br><span class="line"><span class="comment">//T is const char* const</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）退化</strong></p>
<p><strong>数组类型和指针类型是完全不一样的</strong>(虽然他们在使用时可以混用)。由于C语言老祖宗的继承关系，C++依然保留了这些特性，导致很多人误以为数组和指针参数是一样的。在传递过程中，<strong>数组会退化为它第一个元素的指针</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">"J. P. Briggs"</span>;  <span class="comment">// name's type is const char[13]</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ptrToName = name;       <span class="comment">// array decays to pointer</span></span><br><span class="line"></span><br><span class="line">f(name); <span class="comment">// name is array, but T deduced as const char*</span></span><br></pre></td></tr></table></figure>

<p>这种退化导致有用的信息(数组长度)丢失<strong>。然而声明引用，可以使得模板推断保留成数组的形式</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line">f(name);  <span class="comment">//deduce to const char[13]</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中<code>T</code>被推导为<strong>const char[13]</strong>，<code>param</code>则被推导为<strong>const char(&amp;)[13]</strong>。<strong>如果改为<code>T&amp;&amp;</code>，</strong>则<code>T</code>和<code>param</code>都被推为<code>const char(&amp;)[13]</code></p>
<p>讲完数组，再来讲讲函数。在C++中不止是数组会退化为指针，函数类型也会<strong>退化为一个函数指针</strong>，我们对于数组的全部讨论都可以应用到函数来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;  <span class="comment">// someFunc is a function;</span></span><br><span class="line">                             <span class="comment">// type is void(int, double)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;     <span class="comment">// in f1, param passed by value</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;    <span class="comment">// in f2, param passed by ref</span></span><br><span class="line">f1(someFunc);               <span class="comment">// param deduced as ptr-to-func;</span></span><br><span class="line">                            <span class="comment">// type is void (*)(int, double)</span></span><br><span class="line">f2(someFunc);               <span class="comment">// param deduced as ref-to-func;</span></span><br><span class="line">                            <span class="comment">// type is void (&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>

<h1 id="3-多模板参数"><a href="#3-多模板参数" class="headerlink" title="3. 多模板参数"></a>3. 多模板参数</h1><p>多模板参数的形式是简单的，但细节需要考究。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">T1 <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> m = ::max(<span class="number">1</span>, <span class="number">3.14</span>); <span class="comment">// 返回类型由第一个实参决定</span></span><br></pre></td></tr></table></figure>

<p>上面的例子如果改为单模板参数则无法成功匹配。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191227101000.png" style="zoom: 67%;" />

<p>而如果改为多模板参数，则<strong>调用过程发生了隐式转化，返回类型由第一个参数决定</strong>。如果我们把1和3.14调换位置，则返回的是double类型而不是int。</p>
<p>我们可以通过<strong>指定返回参数模板</strong>来解决这个问题。这段代码我们用尖括号指定模板类型，对应的位置就是RT，这样我们就能顺利返回我们想要的类型了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::max&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">3.14</span>); <span class="comment">// 返回类型为double, T1和T2被推断</span></span><br></pre></td></tr></table></figure>

<hr>
<p>在现代CPP体系中，我们可以自动推导返回类型。下面这段代码展示了11和14的一些区别。当我们调用<code>::max(5, 1.2)</code>的时候，5被隐式转化为double类型，返回的结果也是double类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="comment">// FOR c++14</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FOR c++11</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto max (T1 a, T2 b) -&gt; decltype(b &lt; a ? a : b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，有时候这有可能会<strong>导致返回引用类型</strong>，因为paramtype可能就写为引用类型，我们需要调用<code>decayed</code>去除引用符号（需要头文件<type_trait>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto max(T1 a, T2 b) -&gt; typename std::decay&lt;decltype(true ? a : b)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>现代CPP中引入了Common Type这一概念，相当于最大兼容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">common_type&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt;::type <span class="comment">// float，因为int可以转换成float</span></span><br><span class="line">common_type&lt;<span class="keyword">int</span>, <span class="keyword">float</span>, <span class="keyword">double</span>&gt;::type <span class="comment">// double，因为int, float都可以转换成double</span></span><br></pre></td></tr></table></figure>

<p>利用这个特性，我们能够进一步改造模板。（注意一下14那个有_t，11那个没有）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for C++14</span></span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">common_type_t</span>&lt;T1,T2&gt; max(T1 a,T2 b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for C++11</span></span><br><span class="line"><span class="built_in">std</span>::common_type&lt;T1,T2&gt;::<span class="function">type <span class="title">max</span><span class="params">(T1 a,T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-函数模板的重载"><a href="#4-函数模板的重载" class="headerlink" title="4. 函数模板的重载"></a>4. 函数模板的重载</h1><p><strong>具有相同名称的非函数模板可以和函数模板共存</strong>，利用这个特性我们能实现模板函数的重载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//共存</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ::max(<span class="number">1</span>, <span class="number">42</span>); <span class="comment">// 调用非模板的函数</span></span><br><span class="line">    ::max(<span class="number">1.0</span>, <span class="number">3.14</span>); <span class="comment">// 通过推断调用max&lt;double&gt;</span></span><br><span class="line">    ::max(<span class="string">'a'</span>, <span class="string">'b'</span>); <span class="comment">// 通过推断调用max&lt;char&gt;</span></span><br><span class="line">    ::max&lt;&gt;(<span class="number">1</span>, <span class="number">42</span>); <span class="comment">// 通过推断调用max&lt;int&gt;</span></span><br><span class="line">    ::max&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">42</span>); <span class="comment">// 调用max&lt;double&gt;，不推断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码展示了编译器的特性：<strong>选择最优匹配的函数</strong>。</p>
<p>重载模板的原则是需要保证<strong>只有一个合理匹配</strong>，否则会造成歧义，导致无法通过编译。下面的代码中，由于double可以被隐式转化为int，所以会导致歧义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span>&#123;<span class="keyword">return</span> b &lt; a ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span>&#123;<span class="keyword">return</span> b &lt; a ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = ::max(<span class="number">1</span>, <span class="number">3.14</span>); <span class="comment">// 调用第一个模板</span></span><br><span class="line"><span class="keyword">auto</span> b = ::max&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt;(<span class="number">3.14</span>, <span class="number">1</span>); <span class="comment">// 调用第二个模板</span></span><br><span class="line"><span class="keyword">auto</span> c = ::max&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">3.14</span>); <span class="comment">// 错误：两个模板都匹配</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/" data-id="ck4o2tuql0000u4vyah2qf5pv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CPP多线程总结4-并发数据结构设计实例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/" class="article-date">
  <time datetime="2019-12-26T15:40:49.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/">CPP多线程总结4-并发数据结构设计实例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>着重介绍基于锁的结构设计，包括queue，map和list。同时稍微讲了一些原子操作的内容。由于原子操作内容过于复杂，我就只涉及了一些皮毛。</p>
<p>设计并发数据结构意味着，<strong>多个线程可以并发的访问这个数据结构</strong>，线程可对这个数据结构做相同或不同的操作，并且每一个线程都能在自己域中看到该数据结构。<strong>多线程环境下，无数据丢失和损毁，所有的数据需要维持原样，且无条件竞争</strong>，这样的数据结构称之为<strong>线程安全</strong>。</p>
<p>在第二篇中，我们介绍了互斥量，但是本质上：在互斥量的保护下，同一时间内只有一个线程可以获取互斥锁。<strong>互斥量为了保护数据，显式的阻止了线程对数据结构的并发访问</strong>。这中行为称之为<strong>串行化(serialization)</strong>：线程轮流访问被保护的数据。这是对数据进行串行的访问，而非并发。当然我们可以减少保护区域，减少序列化操作，就能提升并发访问的能力。</p>
<h1 id="1-基于锁的并发数据结构设计"><a href="#1-基于锁的并发数据结构设计" class="headerlink" title="1. 基于锁的并发数据结构设计"></a>1. 基于锁的并发数据结构设计</h1><p>前面在第二篇介绍了<strong>基于锁的线程安全栈</strong>和第三篇<strong>基于锁和条件变量的线程安全队列</strong>，接下来我们再看一些精妙的设计实例。</p>
<h2 id="1-1-基于细粒度锁和条件变量的线程安全队列"><a href="#1-1-基于细粒度锁和条件变量的线程安全队列" class="headerlink" title="1.1 基于细粒度锁和条件变量的线程安全队列"></a>1.1 基于细粒度锁和条件变量的线程安全队列</h2><p><strong>（1）单线程版本</strong></p>
<p>我们首先来实现一个单线程版本的队列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        T data;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next;</span><br><span class="line">        node(T data_):data(<span class="built_in">std</span>::move(data_)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; head;</span><br><span class="line">    node* tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">queue</span>(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">queue</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; try_pop()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res&#123; make_shared&lt;T&gt;(move(head-&gt;data)) &#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head = move(head);</span><br><span class="line">        head = move(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; p(<span class="keyword">new</span> node(<span class="built_in">std</span>::move(new_value)) );<span class="comment">//**</span></span><br><span class="line">        <span class="keyword">if</span> (!tail)</span><br><span class="line">            head = <span class="built_in">std</span>::move(p);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tail-&gt;next = move(p);</span><br><span class="line">        tail = p.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意几个点：</p>
<ul>
<li>使用了<code>std::unique_ptr</code>来管理节点，因为其能保证节点(其引用数据的值)在删除时候，不需要使用delete操作显式删除。</li>
<li>使用<code>std::shared_ptr</code>来返回被弹出值，这样可以保证结果能够被多次调用</li>
<li>要注意考虑<code>head</code>为空的时候的push情况</li>
<li>注意星号处创建node指针的办法</li>
<li><code>p.get()</code>能提取被<code>unique_ptr</code>包裹的指针，这样他就是一个正常的指针了。</li>
</ul>
<p><strong>（2）通过分离数据实现并发</strong></p>
<p>单线程版本移植到并发版本时有一个很大的问题，<strong><code>push</code>和<code>pop</code>既访问<code>head</code>又访问<code>tail</code></strong>，当我们的队列只有一个元素时<code>head==tail</code>，如果对两个对象上锁就是<strong>上的同一把锁</strong>。这是我们就需要请出在leetcode刷题中非常非常常见的虚拟节点了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> //1</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;T&gt; data;</span><br><span class="line">        <span class="built_in">unique_ptr</span>&lt;node&gt; next;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;node&gt; head;</span><br><span class="line">    node* tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>() :head(<span class="keyword">new</span> node), tail(head.get()) &#123;&#125; <span class="comment">//2</span></span><br><span class="line">    <span class="built_in">queue</span>(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">queue</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;T&gt; try_pop()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.get() == tail) <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;T&gt; res(head-&gt;data);</span><br><span class="line">        <span class="built_in">unique_ptr</span>&lt;node&gt; old_head(move(head));</span><br><span class="line">        head = move(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T value)</span> <span class="comment">//4</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">shared_ptr</span>&lt;T&gt; packed_data(make_shared&lt;T&gt;(move(value)));</span><br><span class="line">        <span class="built_in">unique_ptr</span>&lt;node&gt; tmp_node(<span class="keyword">new</span> node);</span><br><span class="line">        node* new_tail = tmp_node.get();</span><br><span class="line"></span><br><span class="line">        tail-&gt;data = packed_data;</span><br><span class="line">        tail-&gt;next = move(tmp_node);</span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先来谈谈它和（1）有什么区别：</p>
<ol>
<li>结构不一样了，对暴露的data进行了进一步封装，取消了构造函数，因为我们不需要初始化一个节点了。</li>
<li>默认构造函数不一样了，默认创建一个head和tail，第一个默认构造没有初始化任何东西，所以我们在push和pop时要判断是否为空，现在修改结构以后我们不判断了，所以必须要在这里初始化。</li>
<li>承接上条，由于我们现在默认构造时都会为head和tail赋予意义，所以需要以这样的方式判断。</li>
<li>push的方法很不同，data的结构变了，不再是T，所以要先包装data，把它送到tail指向的地方。然后让tail往后移动一个位置，同时新node指向新tail。</li>
</ol>
<p>由于分离了<code>head</code>和<code>tail</code>现在它变成了线程安全的队列，并且<strong>现在的<code>push()</code>只能访问<code>tail</code>，而不能访问<code>head</code>。</strong>现在的问题是我们在哪里加锁，而且我们需要上锁的事件尽可能的少。</p>
<p>对push的上锁是简单的，如前面所说现在只能访问<code>tail</code>把他用到的地方锁上即可。而<code>try_pop</code>就很麻烦了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::mutex head_mutex;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; head;</span><br><span class="line">    <span class="built_in">std</span>::mutex tail_mutex;</span><br><span class="line">    node* tail;</span><br><span class="line"></span><br><span class="line">    <span class="function">node* <span class="title">get_tail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; tail_lock(tail_mutex);</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; pop_head()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; head_lock(head_mutex);</span><br><span class="line">        <span class="keyword">if</span> (head.get() == get_tail())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head = <span class="built_in">std</span>::move(head);</span><br><span class="line">        head = <span class="built_in">std</span>::move(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> old_head;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    threadsafe_queue() :</span><br><span class="line">        head(<span class="keyword">new</span> node), tail(head.get())</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    threadsafe_queue(<span class="keyword">const</span> threadsafe_queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsafe_queue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; try_pop()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head = pop_head();</span><br><span class="line">        <span class="keyword">return</span> old_head ? old_head-&gt;data : <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; new_data(</span><br><span class="line">            <span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::move(new_value)));</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; p(<span class="keyword">new</span> node);</span><br><span class="line">        node* <span class="keyword">const</span> new_tail = p.get();</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; tail_lock(tail_mutex);</span><br><span class="line">        tail-&gt;data = new_data;</span><br><span class="line">        tail-&gt;next = <span class="built_in">std</span>::move(p);</span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于<code>guard_lock</code>的局限性，所以我们不得不将<code>try_pop</code>封装成几个函数来实现细粒度锁。需要用到哪个锁，就把这段代码封装为函数。比如，最开始需要比较<code>head</code>和<code>tail</code>就把<code>tail</code>封装起来，相较于直接将两个同时锁住，<code>tail</code>受影响的时间就会小得多。</p>
<p>下面这段代码是个反例，这显然不是线程安全的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; pop_head() <span class="comment">// 这是个有缺陷的实现</span></span><br><span class="line">&#123;</span><br><span class="line">  node* <span class="keyword">const</span> old_tail=get_tail();  <span class="comment">// 1 在head_mutex范围外获取旧尾节点的值</span></span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; head_lock(head_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(head.get()==old_tail)  <span class="comment">// 2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_head=<span class="built_in">std</span>::move(head);</span><br><span class="line">  head=<span class="built_in">std</span>::move(old_head-&gt;next);  <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">return</span> old_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-基于锁的线程安全查询表"><a href="#1-2-基于锁的线程安全查询表" class="headerlink" title="1.2 基于锁的线程安全查询表"></a>1.2 基于锁的线程安全查询表</h2><p>本例的目的是构建一个线程安全的哈希表，这里哈希表是通过”桶”实现的，或者也叫链地址法。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191119123129.png" alt="img"></p>
<p>图中所示的链表就可以具象的理解为一个一个的桶，这些<strong>桶合在一起构成了一个桶组</strong>。因此我们设计这个哈希表应该围绕桶组构成。想要顺利使用桶，我们需要<strong>定义桶，定义桶组，定义搜索桶位置的函数</strong>。</p>
<p>他的源码有点错误，2那个位置函数签名中的const应该去除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value,<span class="keyword">typename</span> Hash=hash&lt;Key&gt;&gt;</span><br><span class="line">class threadsafe_lookup_table</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    class bucket_type</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;Key, Value&gt; bucket_value;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;bucket_value&gt; bucket_data;</span><br><span class="line">        <span class="keyword">using</span> bucket_iterator = <span class="keyword">typename</span> bucket_data::iterator;</span><br><span class="line">        bucket_data thisbucket;</span><br><span class="line">        <span class="keyword">mutable</span> <span class="built_in">std</span>::shared_mutex mutex;</span><br><span class="line">        bucket_iterator a;</span><br><span class="line">        <span class="function">bucket_iterator <span class="title">find_entry_for</span><span class="params">(Key <span class="keyword">const</span>&amp; key)</span>  <span class="comment">// 2</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> m =  <span class="built_in">std</span>::find_if(thisbucket.begin(), thisbucket.end(),</span><br><span class="line">                [&amp;](bucket_value <span class="keyword">const</span>&amp; item)</span><br><span class="line">                &#123;<span class="keyword">return</span> item.first == key; &#125;);</span><br><span class="line">            bucket_iterator b;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="keyword">const</span>&amp; key, Value <span class="keyword">const</span>&amp; default_value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; lock(mutex);</span><br><span class="line">            <span class="keyword">auto</span> found_entry = find_entry_for(key);</span><br><span class="line">            <span class="keyword">return</span> (found_entry == thisbucket.end()) ?</span><br><span class="line">                default_value : found_entry-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="keyword">const</span>&amp; key, Value <span class="keyword">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; lock(mutex);</span><br><span class="line">            <span class="keyword">auto</span> found_entry = find_entry_for(key);</span><br><span class="line">            <span class="keyword">if</span> (found_entry == thisbucket.end())</span><br><span class="line">                thisbucket.push_back(bucket_value(key, value));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                 found_entry-&gt;second = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="keyword">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; lock(mutex);</span><br><span class="line">            <span class="keyword">auto</span> found_entry = find_entry_for(key);</span><br><span class="line">            <span class="keyword">if</span> (found_entry != thisbucket.end())</span><br><span class="line">                thisbucket.erase(found_entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;bucket_type&gt;&gt; buckets;</span><br><span class="line">    Hash hasher;</span><br><span class="line">    <span class="function">bucket_type&amp; <span class="title">get_bucket_entry</span><span class="params">(Key <span class="keyword">const</span>&amp; key)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> bucket_index = hasher(key) % buckets.size();</span><br><span class="line">        <span class="keyword">return</span> *buckets[bucket_index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value mapped_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> Hash hash_type;</span><br><span class="line">    threadsafe_lookup_table(</span><br><span class="line">        <span class="keyword">unsigned</span> num_buckets = <span class="number">19</span>, Hash <span class="keyword">const</span>&amp; hasher_ = Hash()) :</span><br><span class="line">        buckets(num_buckets), hasher(hasher_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; num_buckets; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            buckets[i].reset(<span class="keyword">new</span> bucket_type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_lookup_table(threadsafe_lookup_table <span class="keyword">const</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsafe_lookup_table&amp; <span class="keyword">operator</span>=(threadsafe_lookup_table <span class="keyword">const</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="keyword">const</span>&amp; key, Value <span class="keyword">const</span>&amp; default_value = Value())</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get_bucket_entry(key).value_for(key, default_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="keyword">const</span>&amp; key, Value <span class="keyword">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        get_bucket_entry(key).add_or_update_mapping(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="keyword">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        get_bucket_entry(key).remove_mapping(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-支持迭代器的线程安全链表"><a href="#1-3-支持迭代器的线程安全链表" class="headerlink" title="1.3 支持迭代器的线程安全链表"></a>1.3 支持迭代器的线程安全链表</h2><p>代码易懂，有几点很值得学习:</p>
<ol>
<li><code>node</code>成员的创建方式，分为可共享和不可共享</li>
<li>新节点的<code>new</code>创建方式</li>
<li><code>new_node</code>是指针指向地址，所以需要用箭头，而<code>head</code>是一个实例，可以用点操作符。</li>
<li>函数模板</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::mutex m;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; data;<span class="comment">//1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next;</span><br><span class="line">        node() :next() &#123;&#125;</span><br><span class="line">        node(T <span class="keyword">const</span>&amp; value) :data(make_shared&lt;T&gt;(value)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    threadsafe_list() &#123;&#125;</span><br><span class="line">    threadsafe_list(threadsafe_list <span class="keyword">const</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsafe_list&amp; <span class="keyword">operator</span>=(threadsafe_list <span class="keyword">const</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(T <span class="keyword">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; new_node(<span class="keyword">new</span> node(value));<span class="comment">//2</span></span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;mutex&gt; lk(head.m);</span><br><span class="line">        <span class="comment">// head为虚拟节点，无具体值</span></span><br><span class="line">        new_node-&gt;next = move(head.next);<span class="comment">//3</span></span><br><span class="line">        head.next = move(new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;<span class="comment">//4</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">for_each</span><span class="params">(Function f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> current = &amp;head; </span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;mutex&gt; lk(head.m);</span><br><span class="line">        <span class="keyword">while</span> (current-&gt;next.get() != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = current-&gt;next.get();</span><br><span class="line">            <span class="built_in">std</span>::unique_lock&lt;mutex&gt; next_lk(next-&gt;m);</span><br><span class="line">            lk.unlock();</span><br><span class="line">            f(*next-&gt;data);<span class="comment">//5</span></span><br><span class="line">            current = next;</span><br><span class="line">            lk = move(next_lk);<span class="comment">//6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;T&gt; find_first_if(Function f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> current = &amp;head;</span><br><span class="line">        unique_lock&lt;mutex&gt; lk(head.m);</span><br><span class="line">        <span class="keyword">while</span> (current-&gt;next.get() != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            unique_lock&lt;mutex&gt; next_lk(next-&gt;m);</span><br><span class="line">            lk.unlock();</span><br><span class="line">            <span class="keyword">if</span> (fun(*next-&gt;data))</span><br><span class="line">                <span class="keyword">return</span> next-&gt;data;</span><br><span class="line">            current = next;</span><br><span class="line">            lk = <span class="built_in">std</span>::move(next_lk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_if</span><span class="params">(Function f)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node* current = &amp;head;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(head.m);</span><br><span class="line">        <span class="keyword">while</span> (node* <span class="keyword">const</span> next = current-&gt;next.get())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; next_lk(next-&gt;m);</span><br><span class="line">            <span class="keyword">if</span> (f(*next-&gt;data)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; old_next = <span class="built_in">std</span>::move(current-&gt;next);</span><br><span class="line">                current-&gt;next = <span class="built_in">std</span>::move(next-&gt;next);</span><br><span class="line">                next_lk.unlock();</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                lk.unlock();  </span><br><span class="line">                current = next;</span><br><span class="line">                lk = <span class="built_in">std</span>::move(next_lk);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重点讲讲56。</p>
<p>首先来说6，指针和引用是个老大难的问题，这里做一下梳理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; new_node(<span class="keyword">new</span> node(<span class="number">5</span>)); <span class="comment">//被unique_ptr封装好的具有GC机制的指针</span></span><br><span class="line"><span class="keyword">auto</span> m =new_node.get(); <span class="comment">//能用的普通指针，指向node的地址</span></span><br><span class="line"><span class="keyword">auto</span> x = *m-&gt;data; <span class="comment">//*m 解引用，指向node，x=5</span></span><br><span class="line"><span class="keyword">auto</span> y = new_node-&gt;data; <span class="comment">//由于data被std::shared_ptr&lt;T&gt;封装，相当于做了一个指针拷贝</span></span><br><span class="line"><span class="keyword">auto</span> z = y.get(); <span class="comment">//从shared_ptr&lt;T&gt;抽取的data指针，解引用*z后等于5</span></span><br></pre></td></tr></table></figure>

<p>再来说说6，这个操作很精妙。整个操作中需要用到的是当前节点<code>current</code>和下一个节点<code>next</code>，采用滑动锁的形式，以<code>lk</code>为基准，向后滑动，同时创建<code>lk_next</code>锁住<code>next</code></p>
<h1 id="2-无锁数据结构设计"><a href="#2-无锁数据结构设计" class="headerlink" title="2. 无锁数据结构设计"></a>2. 无锁数据结构设计</h1><h2 id="2-1-前言—原子操作"><a href="#2-1-前言—原子操作" class="headerlink" title="2.1 前言—原子操作"></a>2.1 前言—原子操作</h2><p>原子操作指的是不可分割的操作，这种操作要么做了要么没做，不可能观察到做一半的这种状态。原子操作的关键就是<strong>使用一种同步操作方式</strong>，来替换使用互斥量的同步方式。</p>
<p><strong>（1）std::atomic</strong></p>
<p>最基本的原子整型类型就是<code>std::atomic</code>。可以<strong>使用非原子的bool类型进行构造</strong>，所以可以被初始化为true或false。</p>
<p>下面这段代码完成：</p>
<ul>
<li>创建原子变量b</li>
<li>创建一个普通bool变量x，加载进入原子变量b</li>
<li>b中的值存储为true</li>
<li>读取原子变量存储的值，修改为false，再存入(<strong>读-改-写</strong>)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; b;</span><br><span class="line"><span class="keyword">bool</span> x=b.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">b.store(<span class="literal">true</span>);</span><br><span class="line">x=b.exchange(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_acq_rel);</span><br></pre></td></tr></table></figure>

<p>读改写操作是原子变量中非常常见且重要的操作，除了<code>exchange()</code>外还有<strong>比较\交换</strong>操作，对应的函数时<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>成员函数。它比较原子变量的当前值和一个期望值，<strong>当两值相等时，存储所提供的值；当两值不等，期望值就会被更新为原子变量中的值</strong>。</p>
<p><code>compare_exchange_weak()</code>可以<strong>伪失败</strong>（由于某些计算机本身的特性，导致当前线程不能很好完成这个操作，需要调用其他线程来替代工作，造成这种情况主要是时间不够而不是变量本身的问题），所以我们需要用一个循环来保证。<code>b.compare_exchange_weak(expected,true)</code>返回true时就是成功的时候。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> expected=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">extern</span> atomic&lt;<span class="keyword">bool</span>&gt; b; <span class="comment">// 设置些什么</span></span><br><span class="line"><span class="keyword">while</span>(!b.compare_exchange_weak(expected,<span class="literal">true</span>) &amp;&amp; !expected);</span><br></pre></td></tr></table></figure>

<p><strong>（2）<code>std::atomic</code>指针运算</strong></p>
<p>和<code>atomic</code>一样，<code>std::atomic</code>也有<code>load()</code>, <code>store()</code>, <code>exchange()</code>, <code>compare_exchange_weak()</code>和<code>compare_exchage_strong()</code>成员函数，与<code>std::atomic</code>的语义相同，<strong>获取与返回的类型都是`T*</strong><code>，而不是</code>bool`。</p>
<p><code>std::atomic</code>为指针运算提供新的操作。基本操作有<code>fetch_add()</code>和<code>fetch_sub()</code>提供，它们在存储地址上做原子加法和减法，为+=, -=, ++和—提供简易的封装。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>*&gt; p(&amp;a[<span class="number">0</span>]); <span class="comment">//p以int指针形式，指向1</span></span><br><span class="line"><span class="keyword">auto</span> m = p.fetch_add(<span class="number">2</span>); <span class="comment">//p右移两个单位，指向3，返回它的原始值（指向1的时）</span></span><br><span class="line"><span class="keyword">auto</span> n = (p -= <span class="number">1</span>); <span class="comment">//p左移一个单位，指向2，返回原始值（指向3时）</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-无锁的线程安全栈"><a href="#2-2-无锁的线程安全栈" class="headerlink" title="2.2 无锁的线程安全栈"></a>2.2 无锁的线程安全栈</h2><p>栈是先进后出，我们需要一个head一个tail，放的时候放入head，那么head就是我们需要保护的对象了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        T data;</span><br><span class="line">        node* next;</span><br><span class="line">        node(T <span class="keyword">const</span>&amp; data) :data(data_) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;node*&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node* <span class="keyword">const</span> new_node = <span class="keyword">new</span> node(data);</span><br><span class="line">        new_node-&gt;next = head.load();</span><br><span class="line">        <span class="keyword">while</span> (!head.compare_exchange_weak(new_node-&gt;next, new_node));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>head是一个原子变量的<code>node*</code>指针，指向栈的头部。<code>push</code>的时候将head指针装载到新节点的next，然后再用新节点去替代head，他自己就成了head。和之前一样需要用循环的办法避免伪失败。</p>
<p>下面我们来完成pop的操作。我们需要确保当head为空时，程序不会报错，所以要先检查一下。注意，<strong>结构是无锁的，但并不是无等待的</strong>，因为在<code>push()</code>和<code>pop()</code>函数中都有while循环，当<code>compare_exchange_weak()</code>总是失败的时候，循环将会持续下去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock_free_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        T data;</span><br><span class="line">        node* next;</span><br><span class="line">        node(T <span class="keyword">const</span>&amp; data) :data(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;node*&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node* <span class="keyword">const</span> new_node = <span class="keyword">new</span> node(data);</span><br><span class="line">        new_node-&gt;next = head.load();</span><br><span class="line">        <span class="keyword">while</span> (!head.compare_exchange_weak(new_node-&gt;next, new_node));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; pop()</span><br><span class="line">    &#123;</span><br><span class="line">        node* old_head = head.load();</span><br><span class="line">        <span class="keyword">while</span> (old_head &amp;&amp; !head.compare_exchange_weak</span><br><span class="line">        (old_head, old_head-&gt;next));</span><br><span class="line">        <span class="keyword">return</span> old_head ? old_head-&gt;data : <span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/" data-id="ck4o2tur30009u4vy2ubh67vz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CPP多线程总结3-同步并发操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2019-12-26T15:35:10.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/">CPP多线程总结3-并发操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-条件等待"><a href="#1-条件等待" class="headerlink" title="1. 条件等待"></a>1. 条件等待</h1><h2 id="1-1-达成等待条件"><a href="#1-1-达成等待条件" class="headerlink" title="1.1 达成等待条件"></a>1.1 达成等待条件</h2><p>C++标准库对条件变量有两套实现：<code>std::condition_variable</code>和<code>std::condition_variable_any</code>。两者都需要与一个互斥量一起才能工作(互斥量是为了同步)；前者仅限于与<code>std::mutex</code>一起工作，而后者可以和任何满足最低标准的互斥量一起工作。一般默认使用前者。</p>
<p>下面展示了<strong>等待唤醒机制</strong>的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue;  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(more_data_to_prepare())</span><br><span class="line">  &#123;</span><br><span class="line">    data_chunk <span class="keyword">const</span> data=prepare_data();</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    data_queue.push(data);  <span class="comment">// 2</span></span><br><span class="line">    data_cond.notify_one();  <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);  <span class="comment">// 4</span></span><br><span class="line">    data_cond.wait(</span><br><span class="line">         lk,[]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;);  <span class="comment">// 5</span></span><br><span class="line">    data_chunk data=data_queue.front();</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    lk.unlock();  <span class="comment">// 6</span></span><br><span class="line">    process(data);</span><br><span class="line">    <span class="keyword">if</span>(is_last_chunk(data))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码使用一个队列在两个线程间传递数据。</p>
<p>在<code>void data_processing_thread()</code>中，我们要从队列中读取数据，首先4锁住互斥量；5在<code>wait()</code>函数中传递锁和lambda表达式，当判断结果为空时，线程<strong>休眠</strong>。</p>
<p>在<code>void data_preparation_thread()</code>中，2准备好数据后，先锁住互斥量，然后压入队列中；3通过<code>notify_one()</code>函数唤醒，结束后自动析构。</p>
<p>回到<code>void data_processing_thread()</code>中，由于唤醒消息的到来，这个函数重新启动，从头开始上锁、检查。</p>
<h2 id="1-2-实战示例：使用等待条件构建线程安全队列"><a href="#1-2-实战示例：使用等待条件构建线程安全队列" class="headerlink" title="1.2 实战示例：使用等待条件构建线程安全队列"></a>1.2 实战示例：使用等待条件构建线程安全队列</h2><p>我们模仿第二篇讲到的线程安全栈，构建一个线程安全的队列。所谓线程安全就是要像栈那样将<code>top</code>和<code>pop</code>合并。这里提供<code>pop()</code>函数的两个变种：<code>try_pop()</code>和<code>wait_and_pop()</code>。<code>try_pop()</code> ，尝试从队列中弹出数据，即使为空也会直接返回；<code>wait_and_pop()</code>，将会等待有值可检索的时候才返回。接口就可能会是下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue();</span><br><span class="line">  threadsafe_queue(<span class="keyword">const</span> threadsafe_queue&amp;);</span><br><span class="line">  threadsafe_queue&amp; <span class="keyword">operator</span>=(</span><br><span class="line">      <span class="keyword">const</span> threadsafe_queue&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 不允许简单的赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span>;  <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; try_pop();  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; wait_and_pop();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和之前一样，也需要提供两个版本的<code>try_pop()</code>和<code>wait_for_pop()</code>。第一个重载的<code>try_pop()</code>①在引用变量中存储着检索值，所以它可以用来返回队列中值的状态；当检索到一个变量时，他将返回true，否则将返回false。第二个重载②就不能做这样了，因为它是用来直接返回检索值的。当没有值可检索时，这个函数可以返回<code>NULL</code>指针。</p>
<p>完整版如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mut;  <span class="comment">// 1 互斥量必须是可变的 </span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt; data_queue;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_queue()</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  threadsafe_queue(threadsafe_queue <span class="keyword">const</span>&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(other.mut);</span><br><span class="line">    data_queue=other.data_queue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    data_queue.push(new_value);</span><br><span class="line">    data_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;);</span><br><span class="line">    value=data_queue.front();</span><br><span class="line">    data_queue.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; wait_and_pop()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_queue.front()));</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    value=data_queue.front();</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; try_pop()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    <span class="keyword">if</span>(data_queue.empty())</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_queue.front()));</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    <span class="keyword">return</span> data_queue.empty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当新的数据准备完成，调用<code>notify_one()</code>将会触发<strong>一个</strong>正在执行<code>wait()</code>的线程，去检查条件和<code>wait()</code>函数的返回状态。 这里不保证线程一定会被通知到，即使只有一个等待线程收到通知，所有处理线程也有可能仍然在处理数据，而忽略了这个通知。</p>
<p>在<strong>定期重新初始化(periodic reinitialization)</strong>情况下，线程准备数据数据时，就会通过条件变量调用<code>notify_all()</code>成员函数，而非直接调用<code>notify_one()</code>函数。顾名思义，这就是<strong>全部线程</strong>在都去执行<code>wait()</code>(检查他们等待的条件是否满足)的原因。</p>
<h1 id="2-期望等待"><a href="#2-期望等待" class="headerlink" title="2. 期望等待"></a>2. 期望等待</h1><p>条件等待是指<strong>某个条件满足后，线程被激活</strong>，这是一个可重复利用的过程，流程是：条件不足—休眠—条件满足—激活—条件不足—休眠….</p>
<p>而期望模型(future)则是对某一<strong>一次性特定事件</strong>的等待。某种程度上来说就需要知道这个事件在未来的期望结果，之后这个线程<strong>会在短周期内等待或检查</strong>，<strong>期间也会执行其他任务</strong>。</p>
<p>C++标准库中，有两种期望值，使用两种类型模板实现，声明在<future>头文件中： <strong>唯一期望值(unique futures)(<code>std::future&lt;&gt;</code>)和共享期望值(shared futures)(<code>std::shared_future&lt;&gt;</code>)</strong>。仿照了<code>std::unique_ptr</code>和<code>std::shared_ptr</code>。<code>std::future</code>的实例只能与一个指定事件相关联，而<code>std::shared_future</code>的实例就能关联多个事件</p>
<h2 id="2-1-std-async"><a href="#2-1-std-async" class="headerlink" title="2.1 std::async"></a>2.1 std::async</h2><p>有的时候我们需要一个长时间计算的结果，但却并不急着需要它，所以我们使用<code>std::async</code>函数模板。当不着急要任务结果时，可以使用<code>std::async</code>启动一个异步任务。与<code>std::thread</code>对象等待的方式不同，<code>std::async</code>会<strong>返回一个<code>std::future</code>对象，这个对象持有最终计算出来的结果</strong>。当需要这个值时，只需要调用这个对象的get()成员函数，<strong>会阻塞线程直到期望值状态为就绪为止</strong>；之后，返回计算结果。</p>
<p>下面举一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> maxnum = <span class="number">10000</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hello;</span><br><span class="line">    <span class="keyword">auto</span> fun = [maxnum  = maxnum , &amp;hello]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxnum; i++)</span><br><span class="line">            hello.push_back(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::accumulate(hello.begin(), hello.end(), <span class="number">0</span>);    </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> the_answer = <span class="built_in">std</span>::async(fun);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; the_answer.get()&lt;&lt;<span class="string">" "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 49995000 6 ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>与<code>std::thread</code> 做的方式一样，<code>std::async</code>允许你通过添加额外的调用参数，向函数传递额外的参数。当第一个参数是一个指向成员函数的指针，第二个参数提供有这个函数成员类的具体对象(不是直接的，就是通过指针，还可以包装在<code>std::ref</code>中)，剩余的参数可作为成员函数的参数传入。</p>
<p>在函数调用之前向<code>std::async</code>传递一个额外参数，这个参数的类型是<code>std::launch</code>，还可以是<code>std::launch::defered</code>，表明函数调用被延迟到<code>wait()</code>或<code>get()</code>函数调用时才执行，<code>std::launch::async</code> 表明函数必须在其所在的独立线程上执行，并且立即执行，<code>std::launch::deferred | std::launch::async</code>表明实现可以选择这两种方式的一种。</p>
<h2 id="2-2-std-packaged-task-lt-gt"><a href="#2-2-std-packaged-task-lt-gt" class="headerlink" title="2.2 std::packaged_task&lt;&gt;"></a>2.2 std::packaged_task&lt;&gt;</h2><p><code>std::packaged_task&lt;&gt;</code><strong>包装任何可调用 (Callable) 目标</strong>，包括函数、 lambda 表达式、 bind 表达式或其他函数对象，使得能异步调用它，其返回值或所抛异常被存储于能通过 std::future 对象访问的共享状态中。简言之，将一个<strong>普通的可调用函数对象转换为异步执行的任务</strong>。</p>
<p>模板参数是一个函数签名，比如<code>void()</code>就是一个没有参数也没有返回值的函数，或<code>int(std::string&amp;, double*)</code>就是有一个非<code>const</code>引用的<code>std::string</code>和一个指向<code>double</code>类型的指针，并且返回类型是<code>int</code>。</p>
<p>下面给出它的使用范例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.包装lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;<span class="keyword">return</span> a &lt; b; &#125;;</span><br><span class="line">packaged_task&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; task(cmp);</span><br><span class="line"><span class="comment">//仿函数形式启动任务</span></span><br><span class="line">task(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//获取共享状态中的值,直到ready才能返回结果或者异常</span></span><br><span class="line"><span class="keyword">auto</span> res = task.get_future();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;boolalpha&lt;&lt; res.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.包装普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; task(cmp);</span><br><span class="line">task(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> res = task.get_future();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; res.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.通过线程启动</span></span><br><span class="line">task.reset();</span><br><span class="line">res = task.get_future();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过线程启动任务</span></span><br><span class="line"><span class="function">thread <span class="title">td</span><span class="params">(move(task), <span class="number">2</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">td.join();</span><br><span class="line"><span class="comment">//获取执行结果</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"task_thread :"</span> &lt;&lt; res.get() &lt;&lt; <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-std-promise-lt-gt"><a href="#2-3-std-promise-lt-gt" class="headerlink" title="2.3 std::promise&lt;&gt;"></a>2.3 std::promise&lt;&gt;</h2><p>顾名思义，就是承诺的意思。承诺和期望是好朋友，先申明一个承诺，再获得期望结果。<code>std::packaged_task</code>是他更高级的抽象。通过<code>set_value</code>将结果转化为指定值，从而实现他的承诺。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; accumulate_promise)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">std</span>::accumulate(first, last, <span class="number">0</span>);</span><br><span class="line">    accumulate_promise.set_value(sum);  <span class="comment">// 提醒 future</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示用 promise&lt;int&gt; 在线程间传递结果。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; accumulate_promise;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; accumulate_future = accumulate_promise.get_future();</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">work_thread</span><span class="params">(accumulate, numbers.begin(), numbers.end(),</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="built_in">std</span>::move(accumulate_promise))</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result="</span> &lt;&lt; accumulate_future.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">work_thread.join();</span><br></pre></td></tr></table></figure>

<h2 id="2-4-std-shared-future"><a href="#2-4-std-shared-future" class="headerlink" title="2.4 std::shared_future"></a>2.4 std::shared_future</h2><p>虽然<code>std::future</code>可以处理所有在线程间数据转移的同步，但他是一个<strong>独享变量</strong>，换句话说，当一个线程取得他以后，他就变成一个空壳，其他线程就无法共享这个数据。所以有了可以共享的期望<code>std::shared_future</code>。</p>
<p><code>std::future</code>是只移动的，所以其所有权可以在不同的实例中互相传递，但是只有一个实例可以获得特定的同步结果，而<code>std::shared_future</code>实例是可拷贝的，所以多个对象可以引用同一关联期望值的结果。</p>
<p>每一个<code>std::shared_future</code>的独立对象上，成员函数调用返回的结果还是不同步的，所以为了在多个线程访问一个独立对象时避免数据竞争，必须<strong>使用锁来对访问进行保护</strong>。优先使用的办法：为了替代只有一个拷贝对象的情况，可以<strong>让每个线程都拥有自己对应的拷贝对象</strong>。这样，当每个线程都通过自己拥有的<code>std::shared_future</code>对象获取结果，那么多个线程访问共享同步结果就是安全的。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191116132353.png" alt="img" style="zoom:67%;" />

<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191116132408.png" alt="img" style="zoom:67%;" />

<p>下面展示了他的使用过程：可以想象为两个选手的赛跑比赛，<code>std::async</code>作用是让两个选手上跑道准备就绪，选手准备好后就等待<code>ready_future</code>的信号。<code>ready_promise.set_value();</code>发令枪响，开始计时，两个选手开始。跑完后结果存在<code>result1,result2</code>中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">void</span>&gt; ready_promise;</span><br><span class="line">    <span class="built_in">std</span>::shared_future&lt;<span class="keyword">void</span>&gt; ready_future(ready_promise.get_future());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::chrono::time_point&lt;<span class="built_in">std</span>::chrono::high_resolution_clock&gt; start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fun1 = [&amp;, ready_future]() -&gt; <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fun1_future = ready_future;</span><br><span class="line">        fun1_future.wait(); <span class="comment">// 等待来自 main() 的信号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::chrono::high_resolution_clock::now() - start;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fun2 = [&amp;, ready_future]() -&gt; <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> fun2_future = ready_future;</span><br><span class="line">        fun2_future.wait(); <span class="comment">// 等待来自 main() 的信号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::chrono::high_resolution_clock::now() - start;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> result1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, fun1);</span><br><span class="line">    <span class="keyword">auto</span> result2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, fun2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向线程发信使之运行</span></span><br><span class="line">    ready_promise.set_value();</span><br><span class="line">    <span class="comment">// 线程已就绪，开始时钟</span></span><br><span class="line">    start = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread 1 received the signal "</span></span><br><span class="line">        &lt;&lt; result1.get().count() &lt;&lt; <span class="string">" ms after start\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"Thread 2 received the signal "</span></span><br><span class="line">        &lt;&lt; result2.get().count() &lt;&lt; <span class="string">" ms after start\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-等待时间"><a href="#3-等待时间" class="headerlink" title="3. 等待时间"></a>3. 等待时间</h1><h2 id="3-1-时钟"><a href="#3-1-时钟" class="headerlink" title="3.1 时钟"></a>3.1 时钟</h2><p>对于C++标准库来说，时钟就是时间信息源。并且，时钟是一个类，提供了四种不同的信息：</p>
<ul>
<li>当前时间</li>
<li>时间类型</li>
<li>时钟节拍</li>
<li>通过时钟节拍的分布，判断时钟是否稳定</li>
</ul>
<p>当前时间可以通过调用静态成员函数<code>now()</code>从时钟类中获取；例如，<code>std::chrono::system_clock::now()</code>是将返回系统时钟的当前时间。</p>
<p>时钟节拍被指定为1/x(x在不同硬件上有不同的值)秒，这是由时间周期所决定——一个时钟一秒有25个节拍，因此一个周期为<code>std::ratio&lt;1, 25&gt;</code>，当一个时钟的时钟节拍每2.5秒一次，周期就可以表示为<code>std::ratio&lt;5, 2&gt;</code>。</p>
<p>当时钟节拍均匀分布(无论是否与周期匹配)，并且不可调整，这种时钟就称为稳定时钟。当<code>is_steady</code>静态数据成员为<code>true</code>时，表明这个时钟就是稳定的；否则，就是不稳定的。通常情况下，<code>std::chrono::system_clock</code>是不稳定的，因为时钟是可调的，即是这种是完全自动适应本地账户的调节。稳定闹钟对于超时的计算很重要，所以C++标准库提供一个稳定时钟<code>std::chrono::steady_clock</code>。</p>
<h2 id="3-2-时延"><a href="#3-2-时延" class="headerlink" title="3.2 时延"></a>3.2 时延</h2><p><code>std::chrono::duration&lt;&gt;</code>函数模板能够创建一段时延，比如<code>std::chrono::duration&gt;</code>时间为60秒，<code>std::chrono::duration&gt;</code>时间为1毫秒。</p>
<p>标准库在<code>std::chrono</code>命名空间内，为延时变量提供一系列预定义类型：nanoseconds[纳秒] , microseconds[微秒] , milliseconds[毫秒] , seconds[秒] , minutes[分]和hours[时]。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">ms</span><span class="params">(<span class="number">54802</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>方便起见，C++14中<code>std::chrono_literals</code>命名空间中，有许多预定义的后缀操作符用来表示时长。下面简单的代码就是使用硬编码的方式赋予具体的时长值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono_literals;</span><br><span class="line"><span class="keyword">auto</span> one_day=<span class="number">24</span>h;</span><br><span class="line"><span class="keyword">auto</span> half_an_hour=<span class="number">30</span>min;</span><br><span class="line"><span class="keyword">auto</span> max_time_between_messages=<span class="number">30</span>ms;</span><br></pre></td></tr></table></figure>

<p>基于时延的等待可由<code>std::chrono::duration&lt;&gt;</code>来完成，例如：等待期望值状态变为就绪已经35毫秒：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; f=<span class="built_in">std</span>::async(some_task);</span><br><span class="line"><span class="keyword">if</span>(f.wait_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">35</span>))==<span class="built_in">std</span>::future_status::ready)</span><br><span class="line">  do_something_with(f.get());</span><br></pre></td></tr></table></figure>

<p>等待函数会返回一个状态值，表示是等待是超时，还是继续等待。这里可以等待期望值，所以当函数等待超时时，会返回<code>std::future_status::timeout</code>；当期望值状态改变，函数会返回<code>std::future_status::ready</code>；当与期望值相关的任务延迟了，函数会返回<code>std::future_status::deferred</code>。</p>
<h2 id="3-3-时间点"><a href="#3-3-时间点" class="headerlink" title="3.3 时间点"></a>3.3 时间点</h2><p>时间点可以用<code>std::chrono::time_point&lt;&gt;</code>类型模板来表示，实例的第一个参数用来指定所要使用的时钟，第二个函数参数用来表示时间的计量单位(特化的<code>std::chrono::duration&lt;&gt;</code>)，比如说<code>std::chrono::time_point</code>。</p>
<p>可以通过<code>std::chrono::time_point&lt;&gt;</code>实例来加/减时延，来获得一个新的时间点，所以<code>std::chrono::hight_resolution_clock::now() + std::chrono::nanoseconds(500)</code>将得到500纳秒后的时间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start=<span class="built_in">std</span>::chrono::high_resolution_clock::now()+<span class="built_in">std</span>::chrono::nanoseconds(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>我们可以通过做减法来计算时间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start=<span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">do_something();</span><br><span class="line"><span class="keyword">auto</span> stop=<span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;”do_something() took “</span><br><span class="line">  &lt;&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>,<span class="built_in">std</span>::chrono::seconds&gt;(stop-start).count()</span><br><span class="line">  &lt;&lt;” seconds”&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以利用时间点做超时等待的工作，如果下面的代码换成<code>wait_for()</code>以时延为基础做判断的话，可能<strong>引发重复等待</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="keyword">bool</span> done;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait_loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> timeout= <span class="built_in">std</span>::chrono::steady_clock::now()+</span><br><span class="line">      <span class="built_in">std</span>::chrono::milliseconds(<span class="number">500</span>);</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(m);</span><br><span class="line">  <span class="keyword">while</span>(!done)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(cv.wait_until(lk,timeout)==<span class="built_in">std</span>::cv_status::timeout)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-使用同步操作简化代码"><a href="#4-使用同步操作简化代码" class="headerlink" title="4. 使用同步操作简化代码"></a>4. 使用同步操作简化代码</h1><h2 id="4-1-期望的函数化编程"><a href="#4-1-期望的函数化编程" class="headerlink" title="4.1 期望的函数化编程"></a>4.1 期望的函数化编程</h2><p>所谓的<strong>函数式编程(functional programming)</strong>是一种编程方式，这种方式中函数结果只依赖于传入函数的参数，并不依赖外部状态，就像f(x)=cosx+exf(x)=cos⁡x+ex一样，输出的结果仅仅取决于输入的参数。我们以快排为例介绍如何使用<strong>函数式并发</strong>：</p>
<p><strong>（1）快速排序FP模式版</strong></p>
<p>下面的代码与<code>std::sort()</code>不同，<code>std::sort()</code>是无返回值的，因为参数接收的是迭代器，所以其可以对原始列表直进行修改与排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; sequential_quiksort(<span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; input)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (input.empty()) <span class="keyword">return</span> input;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; res;</span><br><span class="line">    res.splice(res.begin(), input, input.begin());</span><br><span class="line">    <span class="keyword">const</span> T&amp; pivot = *res.begin();</span><br><span class="line">    <span class="keyword">auto</span> divided_point = <span class="built_in">std</span>::partition(input.begin(),</span><br><span class="line">        input.end(), [pivot = pivot](<span class="keyword">auto</span>&amp; t) &#123;<span class="keyword">return</span> t &lt; pivot; &#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.splice(lower_part.begin(), input, input.begin(),</span><br><span class="line">        divided_point);</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_lower</span><span class="params">(sequential_quiksort(<span class="built_in">std</span>::move(lower_part)))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(sequential_quiksort(<span class="built_in">std</span>::move(input)))</span></span>;</span><br><span class="line">    res.splice(res.begin(), new_lower);</span><br><span class="line">    res.splice(res.end(), new_higher);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要介绍一下里面用到的STL库函数：</p>
<ul>
<li><p><code>std::splice</code>移动拼接</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191117101811.png" alt="img"></p>
</li>
<li><p><code>std::partition</code>分离(predicate 谓语，这里指lambda表达式)</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191117101934.png" alt="img"></p>
</li>
</ul>
<p><strong>（2）快速排序FP并发版</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; parallel_quick_sort(<span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; input)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(input.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; result;</span><br><span class="line">  result.splice(result.begin(),input,input.begin());</span><br><span class="line">  T <span class="keyword">const</span>&amp; pivot=*result.begin();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> divide_point=<span class="built_in">std</span>::partition(input.begin(),input.end(),</span><br><span class="line">                [&amp;](T <span class="keyword">const</span>&amp; t)&#123;<span class="keyword">return</span> t&lt;pivot;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; lower_part;</span><br><span class="line">  lower_part.splice(lower_part.end(),input,input.begin(),</span><br><span class="line">                divide_point);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; &gt; new_lower(  <span class="comment">// 1</span></span><br><span class="line">                <span class="built_in">std</span>::async(&amp;parallel_quick_sort&lt;T&gt;,<span class="built_in">std</span>::move(lower_part)));</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                parallel_quick_sort(<span class="built_in">std</span>::move(input)))</span></span>;  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">  result.splice(result.end(),new_higher);  <span class="comment">// 3</span></span><br><span class="line">  result.splice(result.begin(),new_lower.get());  <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前线程不对小于“中间”值部分的列表进行排序，使用<code>std::async()</code>①在另一线程对其进行排序。大于部分列表，如同之前一样，使用递归的方式进行排序②。如果开启线程过多，运行库会自动裁剪线程。</p>
<p>因避开了共享可变数据，函数化编程可算作是并发编程的范型，并且也是<strong>通讯顺序进程(CSP，Communicating Sequential Processer)</strong>的范型。</p>
<h2 id="4-2-持续性并发"><a href="#4-2-持续性并发" class="headerlink" title="4.2 持续性并发"></a>4.2 持续性并发</h2><p>这里主要介绍<code>std::experimental::future</code>的特性：持续性。</p>
<p>与<code>std::future</code>类似 , <code>std::experimental::future</code>存储值也只能检索一次。如果期望值正处于持续使用状态，那这个期望值就不能被其他代码所访问。因此，使用<code>fut.then()</code>为<code>fut</code>期望值添加持续性后，对原始期望值<code>fut</code>的操作就是非法的。另外，调用<code>fut.then()</code>会返回一个新期望值，这个新期望值会持有持续性调用的结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::experimental::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; find_the_answer;</span><br><span class="line"><span class="keyword">auto</span> fut=find_the_answer();</span><br><span class="line"><span class="keyword">auto</span> fut2=fut.then(find_the_question);</span><br><span class="line">assert(!fut.valid());</span><br><span class="line">assert(fut2.valid());</span><br></pre></td></tr></table></figure>

<p>与直接调用<code>std::async</code>或<code>std::thread</code>不同，<strong>持续性函数不需要传入参</strong>数，因为运行库已经为其定义好了参数——会传入一个就绪态持续性期望值，这个期望值保存了持续性触发后的结果。假设<code>find_the_answer</code>返回类型为<code>int</code>，<code>find_the_question</code>函数根据之前的例子将会传入一个<code>std::experimental::future</code>作为唯一参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">find_the_question</span><span class="params">(<span class="built_in">std</span>::experimental::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; the_answer)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面举一个利用持续性的例子：</p>
<p>假如用户要登录你的应用，输入账号密码后，将账号送达后台获取ID，然后根据ID检查密码，通过后将信息显示出来。如果我们采用串行执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_login</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; username, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    user_id <span class="keyword">const</span> id = backend.authenticate_user(username, password);</span><br><span class="line">    user_data <span class="keyword">const</span> info_to_display = backend.request_current_info(id);</span><br><span class="line">    update_display(info_to_display);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::exception&amp; e)&#123;</span><br><span class="line">    display_error(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>串行可能会阻塞UI线程，如果我们采用<code>async</code>的方式将他们放到其他线程上，依旧会阻塞UI：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">void</span>&gt; process_login(</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; username, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; password)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async,[=]()&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      user_id consst id = backend.authenticate_user(username, password);</span><br><span class="line">      user_data <span class="keyword">const</span> info_to_display = </span><br><span class="line">        backend.request_current_info(id);</span><br><span class="line">      update_display(info_to_display);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::exception&amp; e)&#123;</span><br><span class="line">      display_error(e);</span><br><span class="line">    &#125;      </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免阻塞相应线程，需要有机制<strong>对每个完成的任务进行连接</strong>：持续性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::experimental::<span class="built_in">future</span>&lt;<span class="keyword">void</span>&gt; process_login(</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; username, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; password)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> backend.async_authenticate_user(username, password).then(</span><br><span class="line">    [](<span class="built_in">std</span>::experimental::<span class="built_in">future</span>&lt;user_id&gt; id)&#123;</span><br><span class="line">      <span class="keyword">return</span> backend.async_request_current_info(id.get());      </span><br><span class="line">    &#125;).then([](<span class="built_in">std</span>::experimental::<span class="built_in">future</span>&lt;user_data&gt; info_to_display)&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        update_display(info_to_display.get());  </span><br><span class="line">      &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::exception&amp; e)&#123;</span><br><span class="line">        display_error(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/" data-id="ck4o2tuqx0003u4vyetc32he1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CPP多线程总结2-线程间共享数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%932-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/" class="article-date">
  <time datetime="2019-12-26T14:51:09.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%932-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/">CPP多线程总结2-线程间共享数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本章着重讲述如何处理线程间的共享数据，内容包括：<code>mutex</code>, <code>lock</code>, <code>unique_lock</code>, <code>call_once</code>,<code>shared_lock</code></p>
<h1 id="1-使用互斥量保护共享数据"><a href="#1-使用互斥量保护共享数据" class="headerlink" title="1. 使用互斥量保护共享数据"></a>1. 使用互斥量保护共享数据</h1><h2 id="1-1-以RAII的方式使用互斥量"><a href="#1-1-以RAII的方式使用互斥量" class="headerlink" title="1.1 以RAII的方式使用互斥量"></a>1.1 以RAII的方式使用互斥量</h2><p>在 C++ 中，标准库提供的互斥量是 <code>std::mutex</code>，它被定义在 <code>mutex</code> 这个头文件中。互斥量是锁的一种，它也是一种<strong>资源</strong>，必须<strong>保证资源被正确释放</strong>（正确使用互斥量的条件之一）。这就像内存需要delete一样，互斥量在<code>lock()</code>以后必须<code>unlock()</code>解除。</p>
<p>实际上并不推荐这么做，C++标准库为互斥量提供了一个RAII语法的模板类<code>std::lock_guard</code>，在构造时就能提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁互斥量能被正确解锁。</p>
<blockquote>
<p>RAII要求，资源的有效期与持有资源的<a href="https://zh.wikipedia.org/w/index.php?title=对象的生命期&action=edit&redlink=1" target="_blank" rel="noopener">对象的生命期</a>严格绑定，即由对象的<a href="https://zh.wikipedia.org/wiki/构造函数" target="_blank" rel="noopener">构造函数</a>完成<a href="https://zh.wikipedia.org/w/index.php?title=资源的分配&action=edit&redlink=1" target="_blank" rel="noopener">资源的分配</a>（获取），同时由<a href="https://zh.wikipedia.org/wiki/析构函数" target="_blank" rel="noopener">析构函数</a>完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现<a href="https://zh.wikipedia.org/w/index.php?title=资源泄露&action=edit&redlink=1" target="_blank" rel="noopener">资源泄露</a>问题。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; some_list;    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">std</span>::mutex some_mutex;    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span><span class="params">(<span class="keyword">int</span> new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(some_mutex);    <span class="comment">// 3</span></span><br><span class="line">  some_list.push_back(new_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">list_contains</span><span class="params">(<span class="keyword">int</span> value_to_find)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(some_mutex);    <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个全局变量①，这个全局变量被一个全局的互斥量保护②。<code>add_to_list()</code>③和<code>list_contains()</code>④函数中使用<code>std::lock_guard</code>，使得这两个函数中对数据的访问是互斥的：<code>list_contains()</code>不可能看到正在被<code>add_to_list()</code>修改的列表</p>
<p>简单理解：<strong>被声明guard的地方在析构前都是被保护的</strong>。</p>
<p>在C++17中新添加了一个特性，称之为模板类参数推导，这样类似<code>std::locak_guard</code>这样简单的模板类型的模板参数列表可以省略。③和④的代码可以简化成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">lock_guard <span class="title">guard</span><span class="params">(some_mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-限制被保护数据的使用范围"><a href="#1-2-限制被保护数据的使用范围" class="headerlink" title="1.2 限制被保护数据的使用范围"></a>1.2 限制被保护数据的使用范围</h2><p>这一节讨论正确使用互斥锁的一个重要前提：必须限制被保护数据的使用范围。简单来说，就是<strong>不要</strong>将被保护数据的<strong>指针或引用</strong>通过返回值、函数参数的方式，传到无法控制的范围内。</p>
<p>举一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">data_wrapper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_data data;</span><br><span class="line">  <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">(Function func)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; l(m);</span><br><span class="line">    func(data);    <span class="comment">// 1 传递“保护”数据给用户函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">some_data* unprotected;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">malicious_function</span><span class="params">(some_data&amp; protected_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  unprotected=&amp;protected_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data_wrapper x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.process_data(malicious_function);    <span class="comment">// 2 传递一个恶意函数</span></span><br><span class="line">  unprotected-&gt;do_something();    <span class="comment">// 3 在无保护的情况下访问保护数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子中<code>process_data</code>看起来没有任何问题，<code>std::lock_guard</code>对数据做了很好的保护，但调用用户提供的函数<code>func</code>①，就意味着foo能够绕过保护机制将函数<code>malicious_function</code>传递进去②，在没有锁定互斥量的情况下调用<code>do_something()</code>。</p>
<p>这段代码的问题在于根本没有保护，只是将所有可访问的数据结构代码标记为互斥。函数<code>foo()</code>中调用<code>unprotected-&gt;do_something()</code>的代码未能被标记为互斥。</p>
<p>所以，<strong>不能将被保护数据的指针或引用以函数返回值的形式，返回或传递给外部不可控的调用者</strong>。</p>
<h2 id="1-3-定位接口间的条件竞争"><a href="#1-3-定位接口间的条件竞争" class="headerlink" title="1.3 定位接口间的条件竞争"></a>1.3 定位接口间的条件竞争</h2><p>以<code>std::stack</code>为例，讲解接口设计缺陷导致的条件竞争。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! s.empty())&#123;    <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> value = s.top();    <span class="comment">// 2</span></span><br><span class="line">  s.pop();    <span class="comment">// 3</span></span><br><span class="line">  do_something(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是一套很常规的操作，存在两个竞争：</p>
<p>有可能线程A判断不为空后，放心的去执行2，但在步骤1和2之间，线程B插了进来弹出了最后一个元素，此时线程A执行步骤2就会发生异常。即使我们使用了互斥量也不能保证，这就是接口本身的问题。解决问题的最简单办法就是在<code>if (! s.empty())</code>之后，再加一个<code>try/catch</code>抛出异常，但这样<code>empty</code>就成了摆设。</p>
<p><strong>（2）调用<code>top()</code>和<code>pop()</code>之间</strong></p>
<p>上图是可能的操作顺序，很有可能两个线程<strong>都取了相同的值</strong>，这种条件竞争，然其结果依赖于<code>do_something()</code>的结果，但因为看起来没有任何错误，就会让这个Bug很难定位。</p>
<br>

<p>那么为什么STL的设计者还要这样设计接口呢？如果我们<code>auto val = stk.pop()</code>既完成取栈顶的工作，又执行弹出的操作，就会发生一个问题：传值的办法是通过拷贝，如果这里的<code>val</code>是一个<code>vector</code>类似的容器，它的拷贝需要时间，<strong>这时如果出现了异常抛出的情况，原来的值就被丢掉了</strong>——它既不存在于栈，也不存在于其他变量。</p>
<p>下面是解决的办法，也是一段非常经典的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">empty_stack</span>:</span> <span class="built_in">std</span>::exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"empty stack!"</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; data;</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  threadsafe_stack()</span><br><span class="line">    : data(<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt;())&#123;&#125;</span><br><span class="line"></span><br><span class="line">  threadsafe_stack(<span class="keyword">const</span> threadsafe_stack&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(other.m);</span><br><span class="line">    data = other.data; <span class="comment">// 1 在构造函数体中的执行拷贝</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m);</span><br><span class="line">    data.push(new_value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; pop()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m);</span><br><span class="line">    <span class="keyword">if</span>(data.empty()) <span class="keyword">throw</span> empty_stack(); <span class="comment">// 在调用pop前，检查栈是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="function"><span class="keyword">const</span> <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(data.top()))</span></span>; <span class="comment">// 在修改堆栈前，分配出返回值</span></span><br><span class="line">    data.pop();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m);</span><br><span class="line">    <span class="keyword">if</span>(data.empty()) <span class="keyword">throw</span> empty_stack();</span><br><span class="line"></span><br><span class="line">    value=data.top();</span><br><span class="line">    data.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m);</span><br><span class="line">    <span class="keyword">return</span> data.empty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这段程序中，我们重载了两个pop版本，一个是原始版本（返回void），另一个是pop和top结合版本（返回值）。为了避免之前提到的数据丢失问题，我们采用返回指针的办法。</p>
<h1 id="2-避免死锁"><a href="#2-避免死锁" class="headerlink" title="2. 避免死锁"></a>2. 避免死锁</h1><p>通俗来说，假如有两个线程分别有互斥量AB，两个线程都在等待对方解锁，这样两个锁AB就会形成死锁。<strong>死锁往往是由于不同线程之间不当交互所导致的</strong>。</p>
<p>从原理上来说，避免死锁的办法是<strong>两个互斥量总以相同的顺序上锁解锁</strong>：先锁住A，锁住B，先解锁A再解锁B。如果反过来，锁住AB，以BA的形式解锁，就会导致死锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex1.lock();</span><br><span class="line">    mutex2.lock();</span><br><span class="line">    doSomething();</span><br><span class="line">    mutex2.unlock();</span><br><span class="line">    mutex1.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex2.lock();</span><br><span class="line">    mutex1.lock();</span><br><span class="line">    doSomething();</span><br><span class="line">    mutex1.unlock();</span><br><span class="line">    mutex2.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中假设函数a先锁住了1，b同时锁住了2，这样a要去锁2时需要等待2解锁，b要去锁1时要等待1解锁，这样就凉了。</p>
<p>然而即使我们按顺序上锁，在一些交换操作中，交换了两个锁保护的两个实例，这下就又会发生死锁。因此我们研究几个有效避免死锁的办法：</p>
<h2 id="2-1-std-lock函数"><a href="#2-1-std-lock函数" class="headerlink" title="2.1 std::lock函数"></a>2.1 <code>std::lock</code>函数</h2><p><code>std::lock</code>——可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)，下面给出了一个很好的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object some_detail;</span><br><span class="line">  <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  X(some_big_object <span class="keyword">const</span>&amp; sd):some_detail(sd)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs) <span class="comment">//一定要引用，判断地址是否相同而不是值</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">std</span>::lock(lhs.m,rhs.m); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock_a(lhs.m,<span class="built_in">std</span>::adopt_lock); <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock_b(rhs.m,<span class="built_in">std</span>::adopt_lock); <span class="comment">// 3</span></span><br><span class="line">    swap(lhs.some_detail,rhs.some_detail);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>着重看一下这个友元函数。<strong>首先需要判断两个对象是否相同，避免被同时上锁两次。</strong>然后，调用<code>std::lock()</code>①锁住两个互斥量，并且两个<code>std:lock_guard</code>实例已经创建好②③。提供<code>std::adopt_lock</code>参数除了表示<code>std::lock_guard</code>对象可获取锁之外，还将锁交由<code>std::lock_guard</code>对象管理，而不需要<code>std::lock_guard</code>对象再去构建新的锁。在退出时，互斥量能被正确解锁。</p>
<h2 id="2-2-std-scoped-lock函数"><a href="#2-2-std-scoped-lock函数" class="headerlink" title="2.2 std::scoped_lock函数"></a>2.2 <code>std::scoped_lock</code>函数</h2><p>这是C++17中的新函数，一种新的RAII类型模板类型，与<code>std::lock_guard&lt;&gt;</code>的功能等价，这个新类型能<strong>接受不定数量的互斥量类型作为模板参数</strong>，以及相应的互斥量(数量和类型)作为构造参数。<strong>互斥量支持构造即上锁</strong>，与<code>std::lock</code>的用法相同，其解锁阶段是在析构中进行。（注意请确保你的编译器支持17，如果是使用visual studio，需要手动设置语言版本为17）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">scoped_lock <span class="title">guard</span><span class="params">(lhs.m,rhs.m)</span></span>; <span class="comment">// 1</span></span><br><span class="line">  swap(lhs.some_detail,rhs.some_detail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了C++17的另一个特性：<strong>自动推导模板参数</strong>。C++17可以通过隐式参数模板类型推导机制， 通过传递的对形象类型来构造实例1。其等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::scoped_lock&lt;<span class="built_in">std</span>::mutex,<span class="built_in">std</span>::mutex&gt; guard(lhs.m,rhs.m);</span><br></pre></td></tr></table></figure>

<h1 id="3-std-unique-lock"><a href="#3-std-unique-lock" class="headerlink" title="3. std::unique_lock"></a>3. std::unique_lock</h1><h2 id="3-1-独占锁的基本用法"><a href="#3-1-独占锁的基本用法" class="headerlink" title="3.1 独占锁的基本用法"></a>3.1 独占锁的基本用法</h2><p><code>std::unique_lock</code>不是一种锁而是一种锁的超集，是在11中引入的锁工具的复合体。</p>
<p><code>std::unique_lock</code>的构造函数，支持三种加锁模式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_lock( mutex_type&amp; m, <span class="built_in">std</span>::<span class="keyword">defer_lock_t</span> t );  　<span class="comment">//延迟加锁</span></span><br><span class="line">unique_lock( mutex_type&amp; m, <span class="built_in">std</span>::<span class="keyword">try_to_lock_t</span> t );　<span class="comment">//尝试加锁</span></span><br><span class="line">unique_lock( mutex_type&amp; m, <span class="built_in">std</span>::<span class="keyword">adopt_lock_t</span> t );  　<span class="comment">//马上加锁</span></span><br></pre></td></tr></table></figure>

<p>有丰富的操作函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock()　　　　     <span class="comment">//阻塞等待加锁</span></span><br><span class="line">try_lock()　　      <span class="comment">// 非阻塞等待加锁</span></span><br><span class="line">try_lock_for()　　<span class="comment">//在一段时间内尝试加锁</span></span><br><span class="line">try_lock_until()　  <span class="comment">//在某个时间点之前尝试加锁</span></span><br><span class="line">unlock()             <span class="comment">//临时解锁</span></span><br></pre></td></tr></table></figure>

<p><code>std::lock_guard</code>只有在析构时才会解锁，它自己本身没有加锁解锁的接口。而<code>std::unique_lock</code>可以在任意时间临时加锁解锁，在析构时也会自动解锁。下面举一个例子：</p>
<p>使用<code>std::lock_guard</code>我们需要生成两个锁来保护，当然可以用一个锁同时保护123，但这样锁的粒度太大，效率不行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shared_print</span><span class="params">(<span class="built_in">string</span> msg, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(_mu);</span><br><span class="line">        <span class="comment">//do something 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//do something 2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(_mu);</span><br><span class="line">        <span class="comment">// do something 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们改为独占锁，可以通过临时上锁解锁，实现精细化的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shared_print</span><span class="params">(<span class="built_in">string</span> msg, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard(_mu);</span><br><span class="line">    <span class="comment">//do something 1</span></span><br><span class="line">    guard.unlock(); <span class="comment">//临时解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//do something 2</span></span><br><span class="line"></span><br><span class="line">    guard.lock(); <span class="comment">//继续上锁</span></span><br><span class="line">    <span class="comment">// do something 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们甚至可以使用<code>std::defer_lock</code>设置初始化的时候不进行默认的上锁操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shared_print</span><span class="params">(<span class="built_in">string</span> msg, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard(_mu, <span class="built_in">std</span>::defer_lock);</span><br><span class="line">    <span class="comment">//do something 1</span></span><br><span class="line"></span><br><span class="line">    guard.lock();</span><br><span class="line">    <span class="comment">// do something protected</span></span><br><span class="line">    guard.unlock(); <span class="comment">//临时解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//do something 2</span></span><br><span class="line"></span><br><span class="line">    guard.lock(); <span class="comment">//继续上锁</span></span><br><span class="line">    <span class="comment">// do something 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，独占锁和<code>unique_ptr</code>一样不能复制，但可以移动！而<code>lock_guard</code>两个都不行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unique_lock 可以移动，不能复制</span></span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard1(_mu);</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard2 = guard1;  <span class="comment">// error</span></span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard2 = <span class="built_in">std</span>::move(guard1); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>下面的示例展示了所有权的传递应用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; get_lock()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="built_in">std</span>::mutex some_mutex;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(some_mutex);</span><br><span class="line">  prepare_data();</span><br><span class="line">  <span class="keyword">return</span> lk;  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(get_lock());  <span class="comment">// 2</span></span><br><span class="line">  do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造时，拷贝构造函数是<code>delete</code>，调用移动构造函数，所以不需要<code>std::move</code>。</p>
<h1 id="4-保护共享数据的其他方式"><a href="#4-保护共享数据的其他方式" class="headerlink" title="4. 保护共享数据的其他方式"></a>4. 保护共享数据的其他方式</h1><h2 id="4-1-保护共享数据的初始化过程"><a href="#4-1-保护共享数据的初始化过程" class="headerlink" title="4.1 保护共享数据的初始化过程"></a>4.1 保护共享数据的初始化过程</h2><p><strong>延迟初始化(Lazy initialization)</strong>在单线程代码很常见——每一个操作都需要先对源进行检查，为了了解数据是否被初始化，然后在其使用前决定，数据是否需要初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr)</span><br><span class="line">  &#123;</span><br><span class="line">    resource_ptr.reset(<span class="keyword">new</span> some_resource);  <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转为多线程代码时，只有①处需要保护，这样共享数据对于并发访问就是安全的，我们尝试使用锁来进行保护时会出现一些问题：由于每次我们调用<code>foo()</code>都会检查是否初始化，这样每次都会创建锁，非常影响代码的正常运行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="built_in">std</span>::mutex resource_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(resource_mutex);  <span class="comment">// 所有线程在此序列化 </span></span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr)</span><br><span class="line">  &#123;</span><br><span class="line">    resource_ptr.reset(<span class="keyword">new</span> some_resource);  <span class="comment">// 只有初始化过程需要保护 </span></span><br><span class="line">  &#125;</span><br><span class="line">  lk.unlock();</span><br><span class="line">  resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是有人针对这种情况提出了<strong>双重检查锁模式</strong>。由于<strong>条件判断1并没有与被锁保护的3同步</strong>，这样又会引入新<strong>条件的竞争</strong>：线程A进入了步骤3，由于C++在new一个对象时，首先会把指针指向分配的那块空间，然后在初始化该空间。此时线程B兴奋得知，<code>resource_ptr</code>不为空了，赶紧执行4，然而事实却是：指针只是指向了某个地方，指向的对象并没有完全初始化完成！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">undefined_behaviour_with_double_checked_locking</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr)  <span class="comment">// 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(resource_mutex);</span><br><span class="line">    <span class="keyword">if</span>(!resource_ptr)  <span class="comment">// 2</span></span><br><span class="line">    &#123;</span><br><span class="line">      resource_ptr.reset(<span class="keyword">new</span> some_resource);  <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  resource_ptr-&gt;do_something();  <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免这些情况，C++标准委员会建议我们使用<code>std::call_once</code>函数。这个函数能保证我们在多线程中，某个函数只会被调用一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::once_flag flag1;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_do_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(flag1, []() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Simple example: called once\n"</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">st1</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">st2</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    st1.join();</span><br><span class="line">    st2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面展示了使用<code>std::call_once</code>作为类成员的延迟初始化(线程安全)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> connection_handle;</span><br><span class="line">    <span class="built_in">std</span>::once_flag connection_init_flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open_connection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        connection_handle = <span class="string">"4396"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::call_once(connection_init_flag, &amp;X::open_connection, <span class="keyword">this</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Connectiong handle is "</span> &lt;&lt; connection_handle &lt;&lt; <span class="string">" send data: "</span> &lt;&lt;i&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::call_once(connection_init_flag, &amp;X::open_connection, <span class="keyword">this</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Connectiong handle is "</span> &lt;&lt; connection_handle &lt;&lt; <span class="string">" recieve data: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-保护不常更新的数据结构"><a href="#4-2-保护不常更新的数据结构" class="headerlink" title="4.2 保护不常更新的数据结构"></a>4.2 保护不常更新的数据结构</h2><p>有的数据比如DNS，我们很少去改改动他，平常更多的是去读取访问，但偶尔也会对他进行修改。因此我们可以使用读写锁<code>std::shared_lock</code>去管理。所谓「读写锁」，就是同时可以被多个读者拥有，但是只能被一个写者拥有的锁。而所谓「多个读者、单个写者」，并非指程序中只有一个写者（线程），而是说不能有多个写者同时去写。</p>
<p><code>std::shared_lock</code>往往和<code>shared_mutex</code>搭配使用，下面给一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeCounter</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ThreadSafeCounter() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 多个线程/读者能同时读计数器的值。</span></span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; lock(mutex_);</span><br><span class="line">    <span class="keyword">return</span> value_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有一个线程/写者能增加/写线程的值。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; lock(mutex_);</span><br><span class="line">    value_++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有一个线程/写者能重置/写线程的值。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; lock(mutex_);</span><br><span class="line">    value_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::shared_mutex mutex_;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> value_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%932-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/" data-id="ck4o2tuqu0001u4vy3n4496jt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CPP多线程总结1-线程管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%931-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2019-12-26T14:25:02.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%931-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/">CPP多线程总结1-线程管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>包含了线程创建的基本操作和注意事项，如何向线程传递参数，以及线程管理的高级操作：转移所有权和动态数量</p>
<h1 id="1-创建与启动线程"><a href="#1-创建与启动线程" class="headerlink" title="1. 创建与启动线程"></a>1. 创建与启动线程</h1><h2 id="1-1-线程与进程"><a href="#1-1-线程与进程" class="headerlink" title="1.1 线程与进程"></a>1.1 线程与进程</h2><p>线程与进程的区别，这个问题真的是老生常谈了，在开始之前最好还是复习一遍：</p>
<p>对于操作系统来说，<strong>一个任务就是一个进程(Process)</strong>，比如打开浏览器，使用word。而一个进程可能不只干一件事（比如word既要打字又要检查拼写），这种<strong>进程内的多个子任务就是线程</strong>（Thread）。</p>
<p>具体来说：</p>
<ul>
<li>进程是操作系统分配资源的单位，而线程是进程的一个实体，是CPU调度和分派的基本单位。</li>
<li>线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
</ul>
<p><strong>多进程与多线程：</strong>现代操作系统一般都是多进程的，他可以同时运行多个任务，一般来说一个CPU核对应一个进程，如果开启的进程比较多就需要使用<strong>时间片轮转进程调度算法</strong>。它的思想简单介绍如下：在操作系统的管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，这样用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。</p>
<p><strong>引入线程的好处：</strong></p>
<ul>
<li>在进程内创建、终止线程比创建、终止进程要快；</li>
<li>同一进程内的线程间切换比进程间的切换要快。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>一个程序至少有一个进程,一个进程至少有一个线程。</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高（多个计算同时执行）。</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>虽然线程拥有单独的程序运行入口，出口，但不能独立执行。</li>
<li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。<strong>这就是进程和线程的重要区别。</strong></li>
</ul>
<h2 id="1-2-启动线程"><a href="#1-2-启动线程" class="headerlink" title="1.2 启动线程"></a>1.2 启动线程</h2><p>在C++11的标准库中，将<strong>创建线程和创建实例</strong>两个动作统一起来，对于人们来说来说，线程就变成了如内存、文件一样的资源，由 C++ 提供统一的接口进行管理。同时，我们也已知晓，<strong>创建线程需指定线程函数</strong>。那么，根据线程函数的不同，在 C++ 中使用 <code>std::thread</code> 直接创建线程，大致有三种不同的方式。</p>
<p><strong>1）使用函数指针创建</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_some_work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">std</span>::thread wk_thread&#123;do_some_work&#125;;</span><br></pre></td></tr></table></figure>

<p>这就是最基本的方式，当然也可以显示的传入<code>&amp;do_some_work</code>当做构造参数，或者利用<code>auto</code>进行构造：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread function excuting"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun1 = thread_function;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">wk_thread</span><span class="params">(fun1)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>（2）可调用类型创建</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayThread</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Display Thread Excecuting"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::thread wk_thread&#123;DisplayThread&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>若是在创建线程的时候，传入的是临时构造的实例，需要注意 C++ 的语法解析规则。这种情况下，推荐使用 C++ 的列表初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">wk_thread</span><span class="params">(ThreadTask())</span></span>;    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">std</span>::thread wk_thread&#123;ThreadTask&#123;&#125;&#125;;    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>1可能会被理解为一个函数声明：参数是函数指针<code>ThreadTask</code>，返回类型是<code>thread</code>。所以这种情况下最好用花括号初始化。</p>
<p><strong>（3）Lambda表达式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">1</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> dosomething = [a=a,b=b]() &#123;<span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">wk_thread</span><span class="params">(dosomething)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-线程控制"><a href="#1-3-线程控制" class="headerlink" title="1.3 线程控制"></a>1.3 线程控制</h2><p>正如申请了内存，必须主动释放一样，对线程的管理也讲究有始有终。当线程启动之后，我们可以在 <code>std::thread</code> 实例销毁之前，<strong>显式地说明我们希望如何处理实例对应线程的结束状</strong>态。如果上述实例销毁之时，程序员尚未显式说明如何处理对应线程的结束状态，那么在上述实例的析构函数中，会调用 <code>std::terminate()</code> 函数，终止整个程序。</p>
<p>在主线程中，我们可以选择「挂起 (join)」或者「分离 (detach)」产生的子线程。具体来说，就是对 <code>std::thread</code> 实例调用 <code>join()</code> 或者 <code>detach()</code> 成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">std</span>::thread join_me&#123;do_something&#125;;</span><br><span class="line"><span class="built_in">std</span>::thread detach_me&#123;do_something&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (join_me.joinable()) &#123;       <span class="comment">// 1</span></span><br><span class="line">    join_me.join();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (detach_me.joinable()) &#123;     <span class="comment">// 1</span></span><br><span class="line">    detach_me.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果选择挂起子线程，则<strong>主线程会被阻塞</strong>，直到子线程退出为止。如果选择分离子线程，则<strong>主线程对子线程的控制权丢失</strong>，将控制权转交给C++库。这会导致几个问题：</p>
<ul>
<li>主线程结束之后，子线程可能仍在运行（因而可以作为守护线程）</li>
<li>主线程结束伴随着资源销毁，需要保证子线程没有引用这些资源。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span>&amp; i_ = <span class="number">0</span>;</span><br><span class="line">    func(<span class="keyword">int</span>&amp; i): i_(i) &#123;&#125;      <span class="comment">// 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j&#123;<span class="number">0</span>&#125;; j!= <span class="number">1000000</span>; ++j) &#123;</span><br><span class="line">            do_something(i);    <span class="comment">// 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad_reference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> working&#123;<span class="number">42</span>&#125;;</span><br><span class="line">    func wk_func&#123;working&#125;;</span><br><span class="line">    <span class="built_in">std</span>::thread wk_thread&#123;wk_func&#125;;</span><br><span class="line">    wk_thread.detach();         <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span>;                     <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们定义了一个可调用的类。在循环内，我们不断尝试对外部传来的引用 (1) 进行一些操作 (2)。然而，在分离子线程之后 (3)，子线程所依赖的外部引用，随着函数的退出而销毁 (4)。这样，子线程后续使用该引用 (2) 的行为就是未定义的了，这是非常危险的。</p>
<p>事实上这段程序根本不会通过编译，因为根据C++11的新特性：向thread传引用必须使用<code>std::ref(params)</code>或者使用移动语义<code>std::move(params)</code>，前者相当于复制了一个资源进入线程。</p>
<p>对于可能发生资源泄漏的情况，下面介绍两种应对策略：<strong>异常抛出和RAII</strong>。</p>
<p><strong>（1）RAII策略（Resource Acquisition Is Initialization）</strong></p>
<p>将资源封装在一个 handle 或者 guard 当中，从而防止资源泄漏。同时，前文也提到，<strong>线程也是一种资源</strong>。因此，我们可以考虑构造一个 <code>ThreadGuard</code> 来处理这种异常安全的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadGuard</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::thread&amp; t_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit ThreadGuard(std::thread&amp; t) :t_(t) &#123;&#125;</span><br><span class="line">    ~ThreadGuard()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;t_.joinable())</span><br><span class="line">            <span class="keyword">this</span>-&gt;t_.join();</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadGuard(<span class="keyword">const</span> ThreadGuard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ThreadGuard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ThreadGuard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread mythread&#123; myfun &#125;;</span><br><span class="line">    ThreadGuard g&#123; mythread &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不添加线程守护，则主程序结束后，线程资源并没有得到释放，会引起内存出错。加了以后，会一直等待子线程跑完，主线程才会彻底结束。</p>
<p><strong>（2）try-catch策略</strong></p>
<p>通过异常抛出的办法保护子线程的正常工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span> <span class="comment">// 定义在清单2.1中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    do_something_in_current_thread();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(...)</span><br><span class="line">  &#123;</span><br><span class="line">    t.join();  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t.join();  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try/catch</code>块确保访问本地状态的线程退出后，函数才结束。当函数正常退出时，会执行到②处；当函数执行过程中抛出异常，程序会执行到①处。<code>try/catch</code>块能轻易的捕获轻量级错误。</p>
<h1 id="2-向线程传递参数"><a href="#2-向线程传递参数" class="headerlink" title="2. 向线程传递参数"></a>2. 向线程传递参数</h1><h2 id="2-1-确保预先转换格式"><a href="#2-1-确保预先转换格式" class="headerlink" title="2.1 确保预先转换格式"></a>2.1 确保预先转换格式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad_buffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">2014</span>];                  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">"%i"</span>, param);</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">wk_t</span><span class="params">(demo, <span class="number">42</span>, buffer)</span></span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">wk_t</span>.detach();</span><br><span class="line">    <span class="keyword">return</span>;                             <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入<code>thread</code>的是一个<code>int</code>，一个<code>char*</code>，而<code>char*</code>需要隐式转化为<code>const string&amp;</code>，如果在转化的过程中发生了函数退出(3)，则会产生一个未定义行为，这是非常危险的。</p>
<p>因此，关于线程函数传参的铁律是：<strong>必须在参数传递给线程构造之前，就转换好格式</strong>。</p>
<h2 id="2-2-确保引用和右值的可行性"><a href="#2-2-确保引用和右值的可行性" class="headerlink" title="2.2 确保引用和右值的可行性"></a>2.2 确保引用和右值的可行性</h2><p>对于引用类型，如前面提到的必须使用<code>std::ref()</code>进行转化转化为<code>std::reference_wrapper</code>类型。</p>
<p>首先介绍一下<code>ref</code>和<code>std::reference_wrapper</code>。简单来说就是<strong>让按值传参的模板可以接受一个引用作为参数</strong>。如下代码所示，由于模板是按值传递，T会被推导为<code>int</code>类型，所以引用无效。所以为了使得引用生效，我们必须转化为<code>std::reference_wrapper</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functest</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">    ++a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b=a;</span><br><span class="line">functest(a);</span><br><span class="line">functest(ref(a));</span><br></pre></td></tr></table></figure>

<p><code>ref()</code>返回一个<code>reference_wrapper</code>对象，事实上，<code>ref()</code>就是用<code>reference wrapper</code>来包裹对象的一个简化写法。</p>
<p>下面展示了<code>ref()</code>的一个用例，<code>stl</code>容器提供的是value语义而不是reference语义，所以容器不支持元素为引用，而用reference_wrapper可以实现。所以vector和list能实现<strong>同步更新</strong>（不支持添加，删除操作！）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l1(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::reference_wrapper&lt;<span class="keyword">int</span>&gt;&gt; v(l1.begin(), l1.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : l1)</span><br><span class="line">    x = x * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<hr>
<p>讲完引用，下面来讲下移动语义。由于thread支持普适引用<code>T&amp;&amp;</code>，所以<code>move</code>操作可以放心执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">wk_t</span><span class="params">(demo, <span class="number">42</span>, <span class="built_in">std</span>::<span class="built_in">move</span>(params))</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-非静态成员函数作为线程函数"><a href="#2-3-非静态成员函数作为线程函数" class="headerlink" title="2.3 非静态成员函数作为线程函数"></a>2.3 非静态成员函数作为线程函数</h2><p>类的非静态成员函数也是函数，因而也可以作为线程函数使用。不过，相比一般的函数（包括静态成员函数），将其作为线程函数使用时，有两个特殊之处。</p>
<ul>
<li>必须显式地使用<strong>函数指针</strong>，作为 <code>std::thread</code> 构造函数的第一个参数（换句话说，必须使用引用的形式）；</li>
<li>非静态成员函数的第一个参数，实际上是<strong>类实例的指针</strong>，在创建线程时，需要显式地填入这个参数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo baz;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="keyword">temp_t</span>&#123;&amp;Foo::bar, &amp;baz&#125;;</span><br><span class="line">    <span class="keyword">temp_t</span>.join();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，必须说明的是，脱离了实例的非静态成员函数是没有意义的。因此，在将非静态成员函数作为线程函数时，必须保证对应的实例可用。</p>
<h1 id="3-转移线程所有权"><a href="#3-转移线程所有权" class="headerlink" title="3. 转移线程所有权"></a>3. 转移线程所有权</h1><p>线程这种资源<strong>可转移但不可复制</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(some_function)</span></span>;            <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">std</span>::thread t2=<span class="built_in">std</span>::move(t1);            <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">t1=<span class="built_in">std</span>::thread(some_other_function);    <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">std</span>::thread t3;                            <span class="comment">// 4</span></span><br><span class="line">t3=<span class="built_in">std</span>::move(t2);                        <span class="comment">// 5</span></span><br><span class="line">t1=<span class="built_in">std</span>::move(t3);                        <span class="comment">// 6 赋值操作将使程序崩溃</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，我们先创建了一个线程t1，然后将结果移动到t2，现在t1这个变量依然存在，只是不包含任何内容。</p>
<p>操作3-6则<strong>尝试将一个线程赋给一个非空线程</strong>，将some_function线程的所有权转移⑥给t1。不过，t1已经有了一个关联的线程(执行some_other_function的线程)，所以这里系统直接调用<code>std::terminate()</code>终止程序继续运行。这样做（<strong>不抛出异常</strong>，<code>std::terminate()</code>是noexcept函数，是为了保证与<code>std::thread</code>的析构函数的行为一致。</p>
<p><code>std::thread</code>支持移动，就意味着线程的所有权可以在函数外进行转移，或者作为参数传递进入函数中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::thread t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">  f(<span class="built_in">std</span>::thread(some_function));</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(some_function)</span></span>;</span><br><span class="line">  f(<span class="built_in">std</span>::move(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移动操作也可能引出一些问题：<strong>当某个对象转移了线程的所有权后，它就不能对线程进行加入或分离</strong>。为了<strong>确保线程程序退出前完成</strong>，下面的代码里定义了<code>scoped_thread</code>类。它的思路和我们之前写的<code>ThreadGuard</code>比较相似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scoped_thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="built_in">std</span>::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  explicit scoped_thread(std::thread t_):                 // 1</span><br><span class="line">    t(<span class="built_in">std</span>::move(t_))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!t.joinable())                                     <span class="comment">// 2</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(“No thread”);</span><br><span class="line">  &#125;</span><br><span class="line">  ~scoped_thread()</span><br><span class="line">  &#123;</span><br><span class="line">    t.join();                                            <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">  scoped_thread(scoped_thread <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">  scoped_thread&amp; <span class="keyword">operator</span>=(scoped_thread <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span> <span class="comment">// 定义在清单2.1中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state;</span><br><span class="line">  <span class="function">scoped_thread <span class="title">t</span><span class="params">(<span class="built_in">std</span>::thread(func(some_local_state)))</span></span>;    <span class="comment">// 4</span></span><br><span class="line">  do_something_in_current_thread();</span><br><span class="line">&#125;                                                        <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>与<code>ThreadGuard</code>相似，不过新线程直接传递到<code>scoped_thread</code>中④，而非创建一个独立变量。当主线程到达<code>f()</code>函数末尾时⑤，<code>scoped_thread</code>对象就会销毁，然后加入③到的构造函数①创建的线程对象中去。在清单2.3中的<code>thread_guard</code>类，需要在析构中检查线程是否”可加入”。<strong>这里把检查放在了构造函数</strong>中②，并且当线程不可加入时，抛出异常。</p>
<h1 id="4-运时决定线程数量"><a href="#4-运时决定线程数量" class="headerlink" title="4. 运时决定线程数量"></a>4. 运时决定线程数量</h1><p>对于那些支持移动操作的容器，我们可以将线程放入这些容器中，产生<strong>量产线程</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(<span class="keyword">unsigned</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    threads.emplace_back(do_work,i); <span class="comment">// 产生线程</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : threads) <span class="comment">// 对每个线程调用 join()</span></span><br><span class="line">    entry.join();       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给出一个很棒的实战demo，我们仔细来分析一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">accumulate_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first,Iterator last,T&amp; result)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    result=<span class="built_in">std</span>::accumulate(first,last,result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first,Iterator last,T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> length=<span class="built_in">std</span>::distance(first,last);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!length) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> min_per_thread=<span class="number">25</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> max_threads=</span><br><span class="line">      (length+min_per_thread<span class="number">-1</span>)/min_per_thread; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hardware_threads=</span><br><span class="line">      <span class="built_in">std</span>::thread::hardware_concurrency();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> num_threads=  <span class="comment">// 3</span></span><br><span class="line">      <span class="built_in">std</span>::min(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> block_size=length/num_threads; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; results(num_threads);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads(num_threads<span class="number">-1</span>);  <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">  Iterator block_start=first;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> i=<span class="number">0</span>; i &lt; (num_threads<span class="number">-1</span>); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    Iterator block_end=block_start;</span><br><span class="line">    <span class="built_in">std</span>::advance(block_end,block_size);  <span class="comment">// 6</span></span><br><span class="line">    threads[i]=<span class="built_in">std</span>::thread(     <span class="comment">// 7</span></span><br><span class="line">        accumulate_block&lt;Iterator,T&gt;(),</span><br><span class="line">        block_start,block_end,<span class="built_in">std</span>::ref(results[i]));</span><br><span class="line">    block_start=block_end;  <span class="comment">// #8</span></span><br><span class="line">  &#125;</span><br><span class="line">  accumulate_block&lt;Iterator,T&gt;()(</span><br><span class="line">      block_start,last,results[num_threads<span class="number">-1</span>]); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::for_each(threads.begin(),threads.end(),</span><br><span class="line">        <span class="built_in">std</span>::mem_fn(&amp;<span class="built_in">std</span>::thread::join)); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::accumulate(results.begin(),results.end(),init); <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::accumulate</code>函数的作用是：累加容器中begin到end的所有数，再加上init。下面我们按标号一一解释：</p>
<ol>
<li>此处避免输入迭代器起始位置都相同，浪费计算</li>
<li><code>min_per_thread</code>表示每个线程的最小计算数，如果输入长度较小的情况下，避免产生过多线程。</li>
<li><code>std::thread::hardware_concurrency()</code>返回当前计算机核心数，如果没有顺利取得，就返回0，此时我们默认设为2核。</li>
<li>每个线程分到的计算任务量大小</li>
<li>创建线程容器</li>
<li><code>block_end</code>迭代器指向当前块的末尾</li>
<li>启动一个新线程为当前块累加结果</li>
<li>当迭代器指向当前块的末尾时，启动下一个块</li>
<li>启动所有线程后，线程会处理最终块的结果。由于不一定分配均匀，所以需要一个来收尾。</li>
<li>将所有线程挂起，<code>mem_fn</code>表示每个容器的元素都执行这个函数。</li>
<li>返回所有结果的累加和。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%931-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/" data-id="ck4o2tuqw0002u4vy9tmdb6nf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-EffectiveModernCPP笔记8-并发API" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B08-%E5%B9%B6%E5%8F%91API/" class="article-date">
  <time datetime="2019-12-26T13:47:47.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B08-%E5%B9%B6%E5%8F%91API/">EffectiveModernCPP笔记8-并发API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h1><p><strong>什么是同步函数与异步函数？</strong></p>
<ul>
<li>同步函数：当一个函数是同步执行时，那么当该函数被调用时不会立即返回，直到该函数所要做的事情全都做完了才返回。</li>
<li>异步函数：如果一个异步函数被调用时，该函数会立即返回尽管该函数规定的操作任务还没有完成。</li>
</ul>
<p>具体来说，当一个线程调用同步函数时（例如读文件），如果函数没有完成操作，则此<strong>线程会被挂起</strong>，直到该函数完成了规定的操作，这个线程才会被重新调度。</p>
<p>相反，当一个线程调用异步函数时，该<strong>函数会立即返回</strong>，即使当前的任务并没有完成，这样线程就会<strong>执行此异步函数之后的下一条语句</strong>。<strong>异步函数没做完的工作会通过另一个线程完成</strong>（可能是异步函数中新创建的，也可能是系统中已经准备好的）</p>
<p><strong>异步函数执行完毕后，如何通知线程？</strong></p>
<p>调用线程需要使用<strong>等待函数</strong>来确定异步函数何时完成了任务。因此在线程调用异步函数之后立即调用一个“等待函数”挂起调用线程，一直等到异步函数执行完其所有的操作之后，再执行线程中的下一条指令。</p>
<p><strong>异步调用与多线程的关系？</strong></p>
<p>操作系统把 CPU 处理时间划分成许多短暂时间片，在时间 T1 执行一个线程的指令，到时间 T2 又执行下一线程的指令，<strong>各线程轮流执行</strong>，结果好象是所有线程在并肩前进。这样，编程时可以创建多个线程，在同一期间执行，各线程可以“并行”完成不同的任务。</p>
<p>有了多线程的支持，可以采用异步调用，调用方和被调方可以属于两个不同的线程，<strong>调用方启动被调方线程后，不等对方返回结果就继续执行后续代码</strong>。被调方执行完毕后，通过某种手段通知调用方：结果已经出来，请酌情处理。</p>
<h1 id="Item-35-Prefer-task-based-programming-to-thread-based"><a href="#Item-35-Prefer-task-based-programming-to-thread-based" class="headerlink" title="Item 35:Prefer task-based programming to thread based."></a>Item 35:Prefer task-based programming to thread based.</h1><p>通常来说要执行异步函数有两种选择：</p>
<ul>
<li><p>创建一个thread</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doAsyncWork</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(doAsyncWork)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个task</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(doAsyncWork); <span class="comment">// "fut" for "future"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>task通常要比thread好，原因如下：</p>
<ol>
<li>基于task的代码往往更少。</li>
<li>基于task更容易得到函数的返回值：调用future的get方法。</li>
<li>future的get方法还能拿到函数抛出的异常，而thread中如果函数抛了异常，进程就挂掉了。</li>
<li>易于实现调度均衡</li>
</ol>
<p>通常来说，task好处的前三点比较好理解，第四点怎么理解呢？</p>
<p>首先我们要搞清楚它们之间更本质的差别在于，基于task的方法有着更高的抽象层次，而无需关心底层的线程管理。下面是C++中”线程”的三种不同层次的概念：</p>
<ul>
<li>硬件线程：真正的运算线程，目前每个CPU核可以提供一个或多个线程。比如，因特尔i7-8550U就是4核8线程架构。</li>
<li>软件线程（OS线程）：OS提供的线程，OS会负责管理和调度这些线程。通常OS线程可以远多于硬件线程。</li>
<li><code>std::thread</code>：C++标准库提供的线程类，底层对应一个OS线程。这些情况下<code>std::thread</code>没有对应的OS线程：刚刚构造好时；已经调用过<code>join</code>；已经调用过<code>detach</code>。</li>
</ul>
<p><strong>创建过多的OS线程会导致系统过载，大量资源消耗在线程调度和切换上</strong>。避免系统过载是一件困难的事情，我们很难知道OS线程和硬件线程之间的合适比例。如果我们基于task来开发，<strong>把这些问题丢给task，丢给C++标准库</strong>，这样就能更好解决问题。</p>
<p>当然，<code>std::async</code>没办法解决GUI线程的问题，因为调度器不知道你的哪个线程对响应时间的要求最低。此时你可以<strong>指定<code>std::launch::async</code>来确保你的函数运行在另一个线程中</strong>。</p>
<h1 id="Item-36-Specify-std-launch-async-if-asynchronicity-is-essential"><a href="#Item-36-Specify-std-launch-async-if-asynchronicity-is-essential" class="headerlink" title="Item 36:Specify std::launch::async if asynchronicity is essential."></a>Item 36:Specify std::launch::async if asynchronicity is essential.</h1><p><code>std::async</code>有三种模式：</p>
<ul>
<li><code>std::launch::async</code>：<code>f</code>必须异步执行，比如在另一个线程。写为<code>std::async(std::launch::async,f)</code></li>
<li><code>std::launch::deferred</code>：<code>f</code>只在对应的future的<code>get</code>或<code>wait</code>被调用时才执行，且是同步执行。如果没有人调用对应的<code>get</code>或<code>wait</code>。</li>
<li><code>std::launch::async|std::launch::defered</code>: 也可以写为<code>std::async(f)</code>。这是默认策略，有调度器自动决定是异步还是同步。</li>
</ul>
<p>默认策略的问题在于：</p>
<ul>
<li>无法预测<code>f</code>是否与当前线程并发执行，因为调度器有可能选择<code>std::launch::deferred</code>。</li>
<li>无法预测<code>f</code>是否在调用<code>get</code>或<code>wait</code>的另一个线程执行。</li>
<li>可能无法预测<code>f</code>是否会执行。</li>
</ul>
<p>下面的代码可能会出现问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">1</span>s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(f);</span><br><span class="line"><span class="keyword">while</span> (fut.wait_for(<span class="number">100</span>ms) != <span class="built_in">std</span>::future_status::ready) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果f在另一个线程运行，则没有问题。如果f是<code>deferred</code>状态，则<code>fut.wait_for</code>就会一直返回<code>std::future_status::deferred</code>，导致循环永不结束。因为我们无法掌握调度器的状况，导致它有可能把它定为<code>lauch</code>或者<code>deferred</code>。</p>
<p>为了解决这个问题，最好检查future是不是deferred，如果是，就不进循环。但我们没办法直接询问future是不是deferred，需要用<code>wait_for</code>来绕一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(f);</span><br><span class="line"><span class="keyword">if</span> (fut.wait_for(<span class="number">0</span>s) == <span class="built_in">std</span>::future_status::deferred) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (fut.wait_for(<span class="number">100</span>ms) != <span class="built_in">std</span>::future_status::ready) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述场景的要点在于，当满足以下条件时，使用<code>std::async</code>的默认策略才是好的：</p>
<ul>
<li>task不需要与调用<code>get</code>或<code>wait</code>的线程并发执行。</li>
<li>无所谓访问哪个局部线程变量（TLS）。</li>
<li>要么能确保有人会调用future的<code>get</code>或<code>wait</code>，要么<code>f</code>执不执行都可以。</li>
<li>调用了<code>wait_for</code>或<code>wait_until</code>的代码要保证能处理deferred。</li>
</ul>
<p>如果没办法保证以上几点，你需要确保你的task运行在另一个线程中，就指定<code>std::launch::async</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, f);</span><br></pre></td></tr></table></figure>

<h1 id="Item-37-Make-std-threads-unjoin-able-on-all-paths"><a href="#Item-37-Make-std-threads-unjoin-able-on-all-paths" class="headerlink" title="Item 37:Make std::threads unjoin able on all paths"></a>Item 37:Make std::threads unjoin able on all paths</h1><p>每个<code>std::thread</code>对象都处于两种状态下：可join、不可join。可join的<code>std::thread</code>对应一个可运行或运行中的底层线程，例如被阻塞、未调度或已运行完成的线程都是可join的。我们可以通过线程的成员函数<code>joinable()</code>来判断。这些情况下都是不可以join的：</p>
<ul>
<li>默认构造状态的<code>std::thread</code>：不对应底层线程。</li>
<li>被移动过的<code>std::thread</code>：底层线程现在由其它<code>std::thread</code>管理。</li>
<li>已调用过<code>join</code>的<code>std::thread</code>：底层线程已结束。</li>
<li>已调用过<code>detach</code>的<code>std::thread</code>：<code>detach</code>会切断<code>std::thread</code>和底层线程的联系。</li>
</ul>
<p>下面给一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> tenMillion = <span class="number">10'000'000</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">doWork</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; filter, <span class="keyword">int</span> maxVal = tenMillion)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; goodVals;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">([&amp;filter, maxVal, &amp;goodVals] &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= maxVal; ++i) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">if</span> (filter(i)) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                goodVals.push_back(i);</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> nh = t.native_handle();              <span class="comment">// use t's native handle to set t's priority</span></span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (conditionsAreSatisfied()) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">            performComputation(goodVals);         <span class="comment">// computation was performed</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;                             <span class="comment">// computation was not performed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码我们用一个过滤器过滤一下容器，然后送入<code>performComputation</code>计算，由于我们<strong>需要取得线程的底层句柄来设置优先级</strong>，因此我们用thread而不是async。</p>
<p>上面这段代码，如果最后走到了<code>false</code>分支，或中间抛了异常，就会遇到构造了一个可join的<code>std::thread</code>的问题，程序就会终止。可以<strong>改进的一点是在开始设置<code>t</code>为暂停状态</strong>。</p>
<p>我们可以通过包装一个RAII类来实现所有情况下的<code>std::thread</code>都不可join。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadRAII</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">DtorAction</span> &#123;</span>join, detach&#125;;</span><br><span class="line"></span><br><span class="line">    ThreadRAII(<span class="built_in">std</span>::thread&amp;&amp; t, DtorAction a)</span><br><span class="line">        : action(a), t(<span class="built_in">std</span>::move(t)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~ThreadRAII() &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.joinable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == DtorAction::join) &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.detach();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread&amp; <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DtorAction action;</span><br><span class="line">    <span class="built_in">std</span>::thread t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意：</p>
<ul>
<li>构造函数只接受<code>std::thread</code>的右值，因为<code>std::thread</code>只能移动不能复制。</li>
<li>在<code>ThreadRAII</code>的析构函数中，在调用<code>t.join()</code>或<code>t.detach()</code>前，需要先调用<code>t.joinable()</code>，因为有可能<code>t</code>已经被移动过了。</li>
</ul>
<p>应用<code>ThreadRAII</code>到我们前面的代码中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">doWork</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>)&gt; filter, <span class="keyword">int</span> maxVal = tenMillion)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; goodVals;</span><br><span class="line">    <span class="function">ThreadRAII <span class="title">t</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">std</span>::thread([&amp;filter, maxVal, &amp;goodVals] &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= maxVals; ++i) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">if</span> (filter(i)) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    goodVals.push_back(i);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;),</span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadRAII::DtorAction::join</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> nh = t.get().native_handle();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (conditionsAreSatisfied()) &#123;</span><br><span class="line">        t.get().join();</span><br><span class="line">        performComputation(goodVals);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B08-%E5%B9%B6%E5%8F%91API/" data-id="ck4o2turd000hu4vy0mqd3znb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-EffectiveModernCPP笔记7-Lambda表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B07-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time datetime="2019-12-26T13:27:58.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B07-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">EffectiveModernCPP笔记7-Lambda表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>介绍Lambda表达式中的一些细节：避免隐式捕获、最好通过初始化（移动）进行捕获、如何处理右值。</p>
<p>首先先澄清一些术语：</p>
<ul>
<li><p>lambda表达式就是一个表达式，如下面代码花括号部分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::find_if(container.begin(), container.end(), </span><br><span class="line">             &#123; <span class="keyword">return</span> <span class="number">0</span> &lt; val &amp;&amp; val &lt; <span class="number">10</span>; &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>closure闭包是通过lambda表达式创建的对象，闭包持有被捕获的拷贝和引用。<strong>lambda通常用于一次使用的场景。但closure通常是可复制的</strong>，因此一个lambda表达式可能会对应着多个closure。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> c1 = [x](<span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x * y &gt; <span class="number">55</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> c2 = c1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>closure class闭包类是一个闭包的实现。编译器会为每个lambda表达式生成一个唯一的closure class，lambda表达式中的代码会成为这个类的成员函数的可执行代码。</p>
</li>
</ul>
<h1 id="Item-31-Avoid-default-capture-modes"><a href="#Item-31-Avoid-default-capture-modes" class="headerlink" title="Item 31:Avoid default capture modes."></a>Item 31:Avoid default capture modes.</h1><p>先介绍一些基础知识。Lambda表达式的完整声明格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>

<p>各项含义如下：</p>
<ul>
<li>capture list：捕获外部变量列表</li>
<li>params list：形参列表</li>
<li>mutable指示符：用来说用是否可以修改捕获的变量</li>
<li>exception：异常设定</li>
<li>return type：返回类型</li>
<li>function body：函数体</li>
</ul>
<p>明确几个捕获类型：</p>
<ul>
<li><p>值捕获</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [a] &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用捕获</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;a] &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式捕获</p>
<p>隐式捕获有两种方式，分别是[=]和[&amp;]。[=]表示以值捕获的方式捕获外部变量，[&amp;]表示以引用捕获的方式捕获外部变量。可以让编译器根据函数体中的代码来推断需要捕获哪些变量。</p>
</li>
</ul>
<p><strong>那么为什么要避免使用隐式捕获呢？</strong></p>
<p>如果一个<strong>由lambda创建的闭包的生命期超过了局部变量或者形参的生命期，那么闭包的引用将会空悬。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> calc1 = computeSomeValue1();</span><br><span class="line">    <span class="keyword">auto</span> calc2 = computeSomeValue2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> divisor = computeDivisor(calc1, calc2);</span><br><span class="line"></span><br><span class="line">    filters.emplace_back(</span><br><span class="line">      [&amp;](<span class="keyword">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;   <span class="comment">// 危险！对divisor的引用会空悬</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这代码有个定时炸弹。lambda引用了局部变量<code>divisor</code>， 但是局部变量的生命期在<code>addDivisorFilter</code>返回时终止，也就是在<code>filters.emplace_back</code>返回之后。<strong>由于<code>filters</code>容器不属于这个局部，</strong>我们采用的是引用的形式，当本体作为局部变量被销毁后，就会变为未定义行为。</p>
<p>即使我们加上显示引用捕获<code>divisor</code>，会存在着同样的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filters.emplace(</span><br><span class="line">  [&amp;divisor](<span class="keyword">int</span> value)          <span class="comment">// 危险！对divisor的引用依然会空悬</span></span><br><span class="line">  &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>虽然依然存在问题，但我们可以从中看到lambda的活性依赖于<code>divisor</code>的生命期，显示地写出能够提醒我们要确保<code>divisor</code>的生命期至少和lambda闭包一样长。即使是我们知道一个closure只在<strong>当前作用域范围内使用</strong>（不同于上面的<code>filters</code>），不会传播出去，使用隐式捕获依然可能出现一些问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithContainer</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> calc1 = computeSomeValue1();</span><br><span class="line">    <span class="keyword">auto</span> calc2 = computeSomeValue2();</span><br><span class="line">    <span class="keyword">auto</span> divisor = computeDivisor(calc1, calc2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ContElemT = <span class="keyword">typename</span> C::value_type;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::begin;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::all_of(</span><br><span class="line">        begin(container), end(container),</span><br><span class="line">        [&amp;](<span class="keyword">const</span> ContElemT&amp; value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    ) <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c++14 auto can be used in params type</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::all_of(</span><br><span class="line">    begin(container), end(container),</span><br><span class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;))</span><br></pre></td></tr></table></figure>

<p>这段代码本身没什么问题，但你没办法保证不会有人把这段代码拷贝到其它地方，没注意这里有个默认的引用捕获，结果出现孤悬引用。</p>
<p>为了解决这个问题，人们提出了几种可能的解决方案：</p>
<p><strong>（1）默认的值捕获</strong> 可行，但不能捕获指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filters.emplace_back([=](<span class="keyword">int</span> value) </span><br><span class="line">                     &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）拷贝一份成员变量，再捕获</strong> 可行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFilter</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> divisor;</span><br><span class="line"><span class="keyword">void</span> Widget::addFilter() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> divisorCopy = divisor;</span><br><span class="line">    filters.emplace_back([divisorCopy] (<span class="keyword">int</span> value) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> value % divisorCopy == <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（3）初始化捕获</strong>作用于14</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Widget::addFilter() <span class="keyword">const</span> &#123;</span><br><span class="line">    filters.emplace_back(</span><br><span class="line">        [divisor = divisor] (<span class="keyword">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">return</span> value % divisor == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Item-32-Use-init-capture-to-move-objects-into-closures"><a href="#Item-32-Use-init-capture-to-move-objects-into-closures" class="headerlink" title="Item 32:Use init capture to move objects into closures."></a>Item 32:Use init capture to move objects into closures.</h1><p>有时候我们想把一个对象移动到closure中，比如一个只能移动的对象（<code>std::unique_ptr</code>或<code>std::future</code>），或是移动的代价远小于复制的对象（比如大多数的STL容器），这个时候默认的引用捕获和值捕获都无法做到。C++14提供了一种方式，叫“<strong>初始化捕获</strong>”，能满足这一需求。C++11无法直接实现，但后面会介绍一种间接实现的方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> pw = <span class="built_in">std</span>::make_unique&lt;Widget&gt;();</span><br><span class="line">...                                     <span class="comment">// confiture *pw</span></span><br><span class="line"><span class="keyword">auto</span> func = [pw = <span class="built_in">std</span>::move(pw)] &#123; <span class="keyword">return</span> pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived(); &#125;;</span><br></pre></td></tr></table></figure>

<p><code>pw = std::move(pw)</code>中，<code>=</code>左边的是数据成员的名字，它的<strong>作用域就是这个closure</strong>；右边是它的初始化式，它的<strong>作用域就是closure所在的作用域</strong>。</p>
<p>举个更简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> testNumber = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> divisor = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pw = make_unique&lt;<span class="keyword">int</span>&gt;(divisor);</span><br><span class="line"><span class="keyword">auto</span> fun = [pw = <span class="built_in">std</span>::move(pw)](<span class="keyword">auto</span>&amp; divided)&#123; <span class="keyword">return</span> divided / *pw; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fun(testNumber) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// result is 3</span></span><br></pre></td></tr></table></figure>

<p><strong>C++11实现</strong></p>
<p>先介绍一下<code>std::bind</code>，上代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">auto</span> fun = [](<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> num)&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; num)  </span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; ends;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;  </span><br><span class="line">    <span class="comment">//_1，_2 是占位符  </span></span><br><span class="line">    <span class="keyword">auto</span> fun1 = bind(fun, _1, _2, <span class="number">5</span>);  </span><br><span class="line">    <span class="comment">//等价于调用fun(array, sizeof(array) / sizeof(*array), 5);  </span></span><br><span class="line">    fun1(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(*<span class="built_in">array</span>));  </span><br><span class="line">    <span class="built_in">cin</span>.get();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fun1</code>函数由闭包转化而来，bind就是用于这种捆绑转化，它通过占位符汲取了闭包的第一、二个参数，然后将第三个参数置为5。这样就形成了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; <span class="number">5</span>)  </span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; ends;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在C++11中我们可以用bind+lambda实现14中的移动捕获</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; data;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> func = <span class="built_in">std</span>::bind(</span><br><span class="line">    [](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; data) &#123;...&#125;,</span><br><span class="line">    <span class="built_in">std</span>::move(data)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>默认情况下closure class的<code>operator()</code>会被认为是const，因此我们在lambda中无法修改捕获的对象。这时我们可以给lambda添加上<code>mutable</code>标识符，令它可以修改捕获的对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = <span class="built_in">std</span>::bind(</span><br><span class="line">    [](<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; data) <span class="keyword">mutable</span> &#123;...&#125;,</span><br><span class="line">    <span class="built_in">std</span>::move(data)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="Item-33-Use-decltype-on-auto-amp-amp-parameters-to-std-forward-them"><a href="#Item-33-Use-decltype-on-auto-amp-amp-parameters-to-std-forward-them" class="headerlink" title="Item 33:Use decltype on auto&amp;&amp; parameters to std::forward them."></a>Item 33:Use decltype on auto&amp;&amp; parameters to std::forward them.</h1><p>C++14的一项引入注目的新功能就是泛型lambda，即lambda的参数可以用<code>auto</code>来修饰。</p>
<p>它的实现很直接：closure class的<code>operator()</code>是个模板函数。给定下面的lambda：···</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x) &#123;<span class="keyword">return</span> normalize(x);&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// closure class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClosureClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> normalize(x);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，如果<code>normalize</code>处理左值参数和右值参数的方式上有区别，那么我们写的还不算对，应该用上完美转发。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; x) </span><br><span class="line">&#123; <span class="keyword">return</span> normalize(<span class="built_in">std</span>::forward&lt;???&gt;(x)); &#125;;</span><br></pre></td></tr></table></figure>

<p>但问题是<code>std::forward</code>的实例化类型是什么。通常的完美转发我们能有一个模板参数<code>T</code>，但在泛型lambda中我们只有<code>auto</code>。closure class的模板函数中有这个<code>T</code>，但我们没办法用上它。<strong>用<code>decltype</code>可以解决这个问题！</strong></p>
<p>我们在Item3学到过：通过<code>decltype</code>保证返回变量的本来类型这一特性，保证不丢失<code>CV</code>限制符，和引用等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; x) &#123;</span><br><span class="line">    <span class="keyword">return</span> normalize(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(x)&gt;(x));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>甚至还支持变量个数可变的泛型lambda：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp;... xs) &#123;</span><br><span class="line">    <span class="keyword">return</span> normalize(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(xs)&gt;(xs)...);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B07-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-id="ck4o2tura000eu4vyd1yz80ki" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程4-可变参数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B3-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0/">CPP泛型编程3-非类型的模板参数</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B2-%E7%B1%BB%E6%A8%A1%E6%9D%BF/">CPP泛型编程2-类模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程1-函数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/">CPP多线程总结4-并发数据结构设计实例</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>