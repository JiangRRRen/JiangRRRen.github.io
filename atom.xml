<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JR&#39;s Blog</title>
  
  <subtitle>直挂云帆济沧海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="jiangren.work/"/>
  <updated>2020-03-31T06:20:48.000Z</updated>
  <id>jiangren.work/</id>
  
  <author>
    <name>Jiang Ren</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Untitled</title>
    <link href="jiangren.work/2020/03/31/Untitled/"/>
    <id>jiangren.work/2020/03/31/Untitled/</id>
    <published>2020-03-31T06:20:48.000Z</published>
    <updated>2020-03-31T06:20:48.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GoWeb实战2-并发处理马赛克图片</title>
    <link href="jiangren.work/2020/03/02/GoWeb%E5%AE%9E%E6%88%982-%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E9%A9%AC%E8%B5%9B%E5%85%8B%E5%9B%BE%E7%89%87/"/>
    <id>jiangren.work/2020/03/02/GoWeb%E5%AE%9E%E6%88%982-%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E9%A9%AC%E8%B5%9B%E5%85%8B%E5%9B%BE%E7%89%87/</id>
    <published>2020-03-02T05:18:48.000Z</published>
    <updated>2020-03-02T20:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个项目的任务是在Web中将用户上传的图片马赛克化，为了提升速度，采用并发模式进行。<a id="more"></a></p><h1 id="1-马赛克处理函数"><a href="#1-马赛克处理函数" class="headerlink" title="1. 马赛克处理函数"></a>1. 马赛克处理函数</h1><p>马赛克意思是：指定文件夹内有数百张图片，用户上传一张图片后，根据相应的条件，将这数百张图片以方块形式映射到用于上传的图片上，形成马赛克效果。</p><p>马赛克处理函数分为以下几块：</p><ul><li>马赛克图片数据库的构建<ol><li>图片RGB通道均值计算函数</li><li>缩放函数</li><li>图片扫描建档函数</li></ol></li><li>映射<ol><li>计算欧式距离</li><li>寻找最近图片</li><li>克隆映射</li></ol></li></ul><h2 id="1-1-马赛克图片数据库的构建"><a href="#1-1-马赛克图片数据库的构建" class="headerlink" title="1.1 马赛克图片数据库的构建"></a>1.1 马赛克图片数据库的构建</h2><p>RGB均值计算函数如下，返回一个三元数组：</p><pre><code class="lang-go">func averageColor(img image.Image) [3]float64{    bounds:=img.Bounds()    r,g,b :=0.0,0.0,0.0    for y:=bounds.Min.Y;y&lt;bounds.Max.Y;y++{        for x:=bounds.Min.X; x&lt;bounds.Max.X;x++{            r1,g1,b1,_:=img.At(x,y).RGBA()            r,g,b = r+float64(r1),g+float64(g1),b+float64(b1)        }    }    totalPixels:=float64(bounds.Max.X * bounds.Max.Y)    return [3]float64{r/totalPixels,g/totalPixels,b/totalPixels}}</code></pre><p>接下来是图片缩放函数，将指定文件夹内的图片资料缩放：</p><pre><code class="lang-go">func resize(in image.Image,newWidth int) image.NRGBA{    bounds:=in.Bounds()    ratio := bounds.Dx()/newWidth    out := image.NewNRGBA(image.Rect(bounds.Min.X/ratio, bounds.Min.X/ratio,        bounds.Max.X/ratio, bounds.Max.Y/ratio))    for y,j := bounds.Min.Y,bounds.Min.Y;y&lt;bounds.Max.Y;y,j = y+ratio,j+1{        for x, i := bounds.Min.X, bounds.Min.X; x &lt; bounds.Max.X; x, i =x+ratio, i+1 {            r,g,b,a := in.At(x,y).RGBA()            out.SetNRGBA(i,j,color.NRGBA{uint8(r&gt;&gt;8), uint8(g&gt;&gt;8), uint8(b&gt;&gt;8), uint8(a&gt;&gt;8)})        }    }        return *out}</code></pre><p>然后是图片扫描建档函数，<strong>注意包必须引入<code>import _ &quot;image/jpeg&quot;</code>否则无法解析</strong>：</p><pre><code class="lang-go">func tilesDB() map[string][3]float64{    fmt.Println(&quot;Start populating tiles db ...&quot;)    db := make(map[string][3]float64)    files,_ := ioutil.ReadDir(&quot;tiles&quot;)    for _,f:=range files{        name := &quot;tiles/&quot; + f.Name()        file,_:=os.Open(name)        img,_,_:=image.Decode(file)        db[name]=averageColor(img)        file.Close()    }    fmt.Println(&quot;Finished populating tiles db.&quot;)    return db}</code></pre><h2 id="1-2-映射"><a href="#1-2-映射" class="headerlink" title="1.2 映射"></a>1.2 映射</h2><p>首先是计算欧式距离，计算两张图片平均RGB之间的距离：</p><pre><code class="lang-go">func distance(p1 [3]float64,p2 [3]float64) float64{    r2:=(p2[0]-p1[0])*(p2[0]-p1[0])    g2:=(p2[1]-p1[1])*(p2[1]-p1[1])    b2:=(p2[2]-p1[2])*(p2[2]-p1[2])    return math.Sqrt(r2+g2+b2)}</code></pre><p>然后需要在资料库中找到最相似的一张图片，找到以后需要在资料库中删除，以防止重复：</p><pre><code class="lang-go">func nearest(target [3]float64, db *map[string][3]float64) string{    var filename string    smallest := 1000000.0    for k,v := range *db{        dist:=distance(target,v)        if dist&lt;smallest{            filename,smallest = k,dist        }    }    delete(*db,filename)    return filename}</code></pre><p>因为需要删除，所以每次生成图片时我们还需要克隆一份资料库，不然下一次资料库就没了。</p><pre><code class="lang-go">var TILESDB map[string][3]float64func cloneTilesDB() map[string][3]float64{    db := make(map[string][3]float64)    for k,v:=range TILESDB{        db[k]=v    }    return db}</code></pre><h1 id="2-Web应用"><a href="#2-Web应用" class="headerlink" title="2. Web应用"></a>2. Web应用</h1><p>Web应用可以分为两部分：上传和结果显示。</p><h2 id="2-1-上传"><a href="#2-1-上传" class="headerlink" title="2.1 上传"></a>2.1 上传</h2><p>上传部分比较简单，将模板解析后，执行相应的请求即可。</p><pre><code class="lang-go">func upload(w http.ResponseWriter, r *http.Request){    t,_:=template.ParseFiles(&quot;upload.html&quot;)    t.Execute(w,nil)}</code></pre><h2 id="2-2-显示"><a href="#2-2-显示" class="headerlink" title="2.2 显示"></a>2.2 显示</h2><p>显示部分很复杂，代码如下：</p><pre><code class="lang-go">func mosaic(w http.ResponseWriter, r *http.Request){    t0:=time.Now()    r.ParseMultipartForm(10*1024*1024)    file,_,_:=r.FormFile(&quot;image&quot;)    //FormFile returns the first file for the provided form key.    defer file.Close()    tileSize, _:=strconv.Atoi(r.FormValue(&quot;tile_size&quot;))    original,_,_:=image.Decode(file)//文件解码    bounds:=original.Bounds()    newimage:=image.NewNRGBA(image.Rect(bounds.Min.X, bounds.Min.X,        bounds.Max.X, bounds.Max.Y))    db:=cloneTilesDB()    sp:=image.Point{0,0}    for y:=bounds.Min.Y;y&lt;bounds.Max.Y;y=y+tileSize{        for x:=bounds.Min.X;x&lt;bounds.Max.X;x=x+tileSize{            r,g,b,_:=original.At(x,y).RGBA()            color:=[3]float64{float64(r),float64(g),float64(b)}            nearest:=nearest(color,&amp;db)            file,err := os.Open(nearest)            if err!=nil{                fmt.Println(&quot;error:&quot;,err,nearest)            }            img,_,err:=image.Decode(file)            t:=resize(img,tileSize)            tile:=t.SubImage(t.Bounds())            tileBounds := image.Rect(x, y, x+tileSize, y+tileSize)            draw.Draw(newimage,tileBounds,tile,sp,draw.Src)            file.Close()        }    }    buf1 := new(bytes.Buffer)    jpeg.Encode(buf1,original,nil)    originalStr:=base64.StdEncoding.EncodeToString(buf1.Bytes())    buf2:=new(bytes.Buffer)    jpeg.Encode(buf2,newimage,nil)    mosaic:=base64.StdEncoding.EncodeToString(buf2.Bytes())    t1 := time.Now()    images:=map[string]string{        &quot;original&quot;:originalStr,        &quot;mosaic&quot;:mosaic,        &quot;duration&quot;:fmt.Sprintf(&quot;%v&quot;,t1.Sub(t0)),    }    t,_:=template.ParseFiles(&quot;results.html&quot;)    t.Execute(w,images)}</code></pre><p>大体上分为三部分：</p><ol><li>提取上传文件内容</li><li>执行马赛克化</li><li>将结果重新编码，送入结果模板</li></ol><p><strong>（1）提取上传内容</strong></p><pre><code class="lang-go">r.ParseMultipartForm(10*1024*1024)    file,_,_:=r.FormFile(&quot;image&quot;)    //FormFile returns the first file for the provided form key.    defer file.Close()    tileSize, _:=strconv.Atoi(r.FormValue(&quot;tile_size&quot;))    original,_,_:=image.Decode(file)//文件解码</code></pre><p>上传内容以请求的形式放在了<code>http.request</code>中，前面提到过<code>ParseMultipartForm</code>专门用于解析文件，参数是文件的大小限制（这里限制到10MB）。接着从Form中<strong>提取图片文件和马赛克大小</strong>。然后将文件解码形成图片。</p><p><code>image.Decode</code>函数第二个返回对象是图片的后缀格式，一个字符串。</p><p><strong>（2）执行马赛克化</strong></p><pre><code class="lang-go">bounds:=original.Bounds()newimage:=image.NewNRGBA(image.Rect(bounds.Min.X, bounds.Min.X,                                    bounds.Max.X, bounds.Max.Y))db:=cloneTilesDB()sp:=image.Point{0,0}for y:=bounds.Min.Y;y&lt;bounds.Max.Y;y=y+tileSize{    for x:=bounds.Min.X;x&lt;bounds.Max.X;x=x+tileSize{        r,g,b,_:=original.At(x,y).RGBA()        color:=[3]float64{float64(r),float64(g),float64(b)}        nearest:=nearest(color,&amp;db)        file,err := os.Open(nearest)        if err!=nil{            fmt.Println(&quot;error:&quot;,err,nearest)        }        img,_,err:=image.Decode(file)        t:=resize(img,tileSize)        tile:=t.SubImage(t.Bounds())        tileBounds := image.Rect(x, y, x+tileSize, y+tileSize)        draw.Draw(newimage,tileBounds,tile,sp,draw.Src)        file.Close()    }}</code></pre><p>首先要做准备工作：以原图片为基准，新建一个图片容器，同时克隆一份资料库。然后在循环中找到最佳图片，经过大小缩放，裁剪以后，放到新图片中去。</p><p><strong>（3）重新编码</strong></p><pre><code class="lang-go">    buf1 := new(bytes.Buffer)    jpeg.Encode(buf1,original,nil)    originalStr:=base64.StdEncoding.EncodeToString(buf1.Bytes())    buf2:=new(bytes.Buffer)    jpeg.Encode(buf2,newimage,nil)    mosaic:=base64.StdEncoding.EncodeToString(buf2.Bytes())    t1 := time.Now()    images:=map[string]string{        &quot;original&quot;:originalStr,        &quot;mosaic&quot;:mosaic,        &quot;duration&quot;:fmt.Sprintf(&quot;%v&quot;,t1.Sub(t0)),    }    t,_:=template.ParseFiles(&quot;results.html&quot;)    t.Execute(w,images)</code></pre><p>这一步就是将图片重新编码为二进制字符串，然后送入模板中解析。</p><h1 id="3-并发化"><a href="#3-并发化" class="headerlink" title="3. 并发化"></a>3. 并发化</h1><p>并发的思路很简单：将图片分割为4份，分别执行。但注意，这里存在竞争，因为大家在访问资料库时，每次都会删除，所以我们需要用锁锁起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个项目的任务是在Web中将用户上传的图片马赛克化，为了提升速度，采用并发模式进行。
    
    </summary>
    
    
      <category term="go" scheme="jiangren.work/categories/go/"/>
    
    
      <category term="计算机网络" scheme="jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="go" scheme="jiangren.work/tags/go/"/>
    
      <category term="并发" scheme="jiangren.work/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>GoWeb实战1-数据库与服务器的结合应用</title>
    <link href="jiangren.work/2020/03/01/GoWeb%E5%AE%9E%E6%88%981-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%93%E5%90%88%E5%BA%94%E7%94%A8/"/>
    <id>jiangren.work/2020/03/01/GoWeb%E5%AE%9E%E6%88%981-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%93%E5%90%88%E5%BA%94%E7%94%A8/</id>
    <published>2020-03-01T07:29:27.000Z</published>
    <updated>2020-03-02T20:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节是针对前面学到的数据库操作和Web编程的综合应用。<a id="more"></a></p><h1 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1. 数据库操作"></a>1. 数据库操作</h1><p>用mysql进行测试，测试用数据源如下，其中<code>order_num</code>作为主键。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200127153214.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="1-1-连接初始化"><a href="#1-1-连接初始化" class="headerlink" title="1.1 连接初始化"></a>1.1 连接初始化</h2><p>连接初始化我们需要4块代码：</p><ul><li>连接信息</li><li>全局变量：指向数据库的指针</li><li>初始化函数</li><li>一个结构变量，作为数据载体</li></ul><p>首先是连接信息：</p><pre><code class="lang-go">const(    userName =&quot;test&quot;    password = &quot;asdfg12345&quot;    ip =&quot;cdb-axt937vt.gz.tencentcdb.com&quot;    port=&quot;10059&quot;    dbName = &quot;test&quot;)</code></pre><p>关键词<code>const</code>加上括号，有两个作用：</p><ul><li>变量值自增，类似于C++的枚举（这里用不到）</li><li>全部设置为常量类型，比较方便</li></ul><hr><p>之后我们需要声明一个全局变量<code>DB</code>，作为数据库的指针。</p><pre><code class="lang-go">var DB *sql.DB</code></pre><hr><p>然后重点就是初始化连接函数：</p><pre><code class="lang-go">func init(){    connectInfo:=[]string{userName,&quot;:&quot;,password,&quot;@tcp(&quot;,ip,&quot;:&quot;,port,&quot;)/&quot;, dbName, &quot;?charset=utf8&quot;}    path := strings.Join(connectInfo,&quot;&quot;)    DB,_=sql.Open(&quot;mysql&quot;,path)    if err:=DB.Ping(); err !=nil{        fmt.Println(&quot;open database fail!&quot;)        return    }    fmt.Println(&quot;connect success&quot;)}</code></pre><p>必须声明为<code>init()</code>，这个函数就会在主函数之前调用。这个函数首先<strong>将零散的连接信息拼接成一个字符切片。</strong><code>strings.Join</code>方法将切片的字符串元素拼接起来，比如：</p><pre><code class="lang-go">string [] tmpStr={abc,def,ghi};string jn = string.Join(tmpStr，&quot;-&quot;);//jn=&quot;abc-def-ghi&quot;</code></pre><p>我们之前已经通过如下语句引入了Mysql驱动：</p><pre><code class="lang-go">import _&quot;github.com/Go-SQL-Driver/MySQL&quot;</code></pre><p>所以<code>DB,_=sql.Open(&quot;mysql&quot;,path)</code>可以直接连接mysql。链结构，还要利用<code>ping</code>来检测连接是否成功。</p><hr><p>之后，我们需要针对特定的数据指定相应的结构体来承载数据：</p><pre><code class="lang-go">type Orders struct{    Order_num int `json:&quot;order_num&quot;`    Order_date string `json:&quot;order_date&quot;`    Cust_id int `json:&quot;cust_id&quot;`}</code></pre><h2 id="1-2-查询"><a href="#1-2-查询" class="headerlink" title="1.2 查询"></a>1.2 查询</h2><p>查询我们分为两类：</p><ul><li>单行查询，指定主键，查询内容</li><li>多行查询，返回所有内容</li></ul><p>单行查询非常简单，思路是：<strong>传入查询的主键，返回查询结果（order结构）和错误</strong>。具体步骤是：</p><ol><li>新建一个order结构，<strong>不要使用<code>:=</code></strong>。</li><li>调用查询语句</li><li>将查询结果扫描进order结构，同时赋值错误，<strong>不要使用<code>：=</code></strong></li></ol><pre><code class="lang-go">func QueryOne(id int)(order Orders,err error){    order = Orders{}    row := DB.QueryRow(&quot;SELECT order_num, order_date,cust_id FROM orders WHERE order_num=?&quot;,id)    err = row.Scan(&amp;order.Order_num,&amp;order.Order_date,&amp;order.Cust_id)    return}</code></pre><p>主要需要关注查询语句，可以通过<code>order_num=?</code>向其中填值。</p><hr><p>多行查询比较特殊，我们调用查询语句后返回的一个特殊的数据结构<code>database/sql.Rows</code></p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200127155739.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>结构体的<code>Next()</code>函数能够判断，是否存在下一行，因此我们需要循环读取，<strong>每次扫描都会清除一行</strong>：</p><pre><code class="lang-go">func QueryMulti()(orders[] Orders,err error){    orders =[]Orders{}    rows,err:=DB.Query(&quot;SELECT * FROM orders&quot;)    if err!=nil{        fmt.Printf(&quot;Query failed,err:%v\n&quot;, err)        return    }    i:=0    for rows.Next(){        orders=append(orders, Orders{})        newerr := rows.Scan(&amp;orders[i].Order_num,&amp;orders[i].Order_date,&amp;orders[i].Cust_id)        if newerr != nil {            fmt.Printf(&quot;Scan failed,err:%v\n&quot;, err)        }        i++    }    return}</code></pre><p>另一个重点是<strong>改用切片的形式返回数据</strong>，在next循环中切片需要用<code>append</code>添加！</p><h2 id="1-2-修改数据"><a href="#1-2-修改数据" class="headerlink" title="1.2 修改数据"></a>1.2 修改数据</h2><p>改动数据有三种方式：增加、删除、更新，这三种方法其实大同小异。这里我们需要<strong>使用事务来保证原子性</strong>，防止并发时的资源竞争。</p><p>一般查询使用的是db对象的方法，事务则是使用另外一个对象。sql.Tx对象。使用db的Begin方法可以创建tx对象。</p><p>创建Tx对象的时候，会从连接池中取出连接。事务的连接生命周期从Beigin函数调用起，直到Commit和Rollback函数的调用结束。事务也提供了prepare语句的使用方式，但是需要使用Tx.Stmt方法创建。<strong>所以在事务开启过程中，是不能使用DB的方法的！</strong></p><pre><code class="lang-go">tx, err := db.Begin()db.Exec(query1) //wrong!tx.Exec(query2)tx.commit()</code></pre><pre><code class="lang-go">func Insert(order Orders)(err error){    tx,err := DB.Begin()    if err != nil{        fmt.Println(&quot;tx fail&quot;)        return    }    stmt,err := tx.Prepare(&quot;INSERT INTO orders (`order_num`,`order_date`,`cust_id`) VALUES(?,?,?)&quot;)    if err != nil{        fmt.Println(&quot;Prepare fail&quot;)        return    }    res,err:=stmt.Exec(order.Order_num,order.Order_date,order.Cust_id)    if err != nil{        fmt.Println(&quot;Exec fail&quot;)        return    }    tx.Commit()    fmt.Println(res.LastInsertId())    return}func Delete(id int) (err error){    tx,err := DB.Begin()    if err != nil{        fmt.Println(&quot;tx fail&quot;)        return    }    stmt,err := tx.Prepare(&quot;DELETE FROM orders WHERE order_num = ?&quot;)    if err != nil{        fmt.Println(&quot;Prepare fail&quot;)        return    }    res,err:=stmt.Exec(id)    if err != nil{        fmt.Println(&quot;Exec fail&quot;)        return    }    tx.Commit()    fmt.Println(res.LastInsertId())    return}</code></pre><h1 id="2-服务端操作"><a href="#2-服务端操作" class="headerlink" title="2. 服务端操作"></a>2. 服务端操作</h1><p>服务端操作我们遵从REST原理：设计那些<strong>通过标准的几个动作来操纵资源</strong>。假设我们需要三个操作：</p><ul><li>获取单行数据GET</li><li>获取全部数据MULTIGET</li><li>插入数据INSERT</li><li>删除数据DELETE</li></ul><p>首先是主程序：</p><pre><code class="lang-go">func main(){    server := http.Server{        Addr:&quot;127.0.0.1:8080&quot;,    }    http.HandleFunc(&quot;/order/&quot;,handleRequest)    server.ListenAndServe()}</code></pre><p>这里使用了<strong>多路复用器handleRequest</strong>，多路复用器会根据请求使用的HTTP方法，把请求转发给相应的CRUD(create, read, update, delete)处理器函数。</p><pre><code class="lang-go">func handleRequest(w http.ResponseWriter, r *http.Request){    var err error    switch r.Method{    case &quot;GET&quot;:        err = handleGet(w,r)    case &quot;MULTIGET&quot;:        err = handleMultiGet(w,r)    case &quot;INSERT&quot;:        err = handleInsert(w,r)    case &quot;DELETE&quot;:        err = handleDelete(w,r)    }    if err!=nil{        http.Error(w, err.Error(), http.StatusInternalServerError)        return    }}</code></pre><p>下面就是多路复用器CRUD函数的实现：</p><h2 id="2-1-查询数据"><a href="#2-1-查询数据" class="headerlink" title="2.1 查询数据"></a>2.1 查询数据</h2><p>这一类操作，我们只需要发送相应的主键ID，即可操作数据。由于查询结果需要通过响应包返回，所以我们还需要将其转化为JSON格式，完整步骤如下：</p><ol><li>从URL中解析出想要查询的主键ID</li><li>调用数据库查询函数获取查询结果（order结构体）</li><li>将结果转化为JSON格式</li><li>封装响应包（头，主体，状态码）</li></ol><pre><code class="lang-go">func handleGet(w http.ResponseWriter, r *http.Request) (err error){    id, err :=strconv.Atoi(path.Base(r.URL.Path))    if err!=nil{        return    }    order, err := QueryOne(id)    if err!=nil{        return    }    output, err := json.MarshalIndent(&amp;order, &quot;&quot;, &quot;\t\t&quot;)    if err != nil {        return    }    w.Header().Set(&quot;Content-Type&quot;,&quot;application/json&quot;)    w.Write(output)    w.WriteHeader(200)    return}</code></pre><p>在命令行输入：</p><pre><code>curl -i -X GET http://127.0.0.1:8080/order/20011</code></pre><p>即可查询主键为20011的数据</p><hr><p>集体查询不需要解析URL，</p><pre><code class="lang-go">func handleMultiGet(w http.ResponseWriter, r *http.Request)(err error){    //_, err =strconv.Atoi(path.Base(r.URL.Path))    if err!=nil{        return    }    orders, err := QueryMulti()    if err!=nil{        return    }    output, err := json.MarshalIndent(&amp;orders, &quot;&quot;, &quot;\t\t&quot;)    if err != nil {        return    }    w.Header().Set(&quot;Content-Type&quot;,&quot;application/json&quot;)    w.Write(output)    w.WriteHeader(200)    return}</code></pre><p>在命令行输入：</p><pre><code>curl -i -X MULTIGET http://127.0.0.1:8080/order/</code></pre><p>即可查询所有数据。</p><h2 id="2-2-删除数据"><a href="#2-2-删除数据" class="headerlink" title="2.2 删除数据"></a>2.2 删除数据</h2><p>删除数据不需要返回内容，所以更简单：</p><pre><code class="lang-go">func handleDelete(w http.ResponseWriter, r *http.Request)(err error) {    id,err:=strconv.Atoi(path.Base(r.URL.Path))    if err!=nil{        return    }    err = Delete(id)    if err != nil {        return    }    w.WriteHeader(200)    return}</code></pre><p>使用方法集体查询一样，只是将指令MULTIGET换成DELETE。</p><h2 id="2-3-插入数据"><a href="#2-3-插入数据" class="headerlink" title="2.3 插入数据"></a>2.3 插入数据</h2><p>插入数据有点像查询数据的逆过程：</p><ol><li>解析URL，读取JSON数据</li><li>解析JSON数据，形成order结构体</li><li>调用数据库插入函数</li></ol><pre><code class="lang-go">func handleInsert(w http.ResponseWriter, r *http.Request)(err error){    len := r.ContentLength    body := make([]byte,len)    r.Body.Read(body)    var order Orders    json.Unmarshal(body,&amp;order)    err = Insert(order)    if err!=nil{        return    }    w.WriteHeader(200)    return}</code></pre><p>请求包的主体BODY是一个二进制数据，所以我们需要创建一个二进制切片来存储。</p><p>在命令行输入：</p><pre><code>curl -i -X INSERT -H &quot;Content-Type: application/json&quot;      -d &#39;{&quot;order_date&quot;:&quot;2020-01-01 00:00:00&quot;,&quot;cust_id&quot;:&quot;10086&quot;}&#39; http://127.0.0.1:8080/order/</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节是针对前面学到的数据库操作和Web编程的综合应用。
    
    </summary>
    
    
      <category term="go" scheme="jiangren.work/categories/go/"/>
    
    
      <category term="计算机网络" scheme="jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="go" scheme="jiangren.work/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>CPP面试题目汇总</title>
    <link href="jiangren.work/2020/02/23/CPP%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    <id>jiangren.work/2020/02/23/CPP%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</id>
    <published>2020-02-23T05:55:39.000Z</published>
    <updated>2020-03-26T12:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>cpp的内容整理。<a id="more"></a></p><h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><h2 id="1-1-string和char数组的区别"><a href="#1-1-string和char数组的区别" class="headerlink" title="1.1 string和char数组的区别"></a>1.1 string和char数组的区别</h2><p>string的<strong>字面值</strong>是char数组，可以将string理解为<code>vector&lt;char&gt;</code>。</p><p>字符串字面值不能相加：</p><pre><code class="lang-CPP">string s5 = &quot;hello&quot; + &quot;, &quot;;  // 错误，两个运算对象都不是 stringstring s1=s2+&quot;1&quot;; //ok</code></pre><h2 id="1-2-unsigned类型"><a href="#1-2-unsigned类型" class="headerlink" title="1.2 unsigned类型"></a>1.2 unsigned类型</h2><p><code>unsigned</code>类型是<code>unsigned int</code>的简写。范围0-255，超出结果会wrap around环绕。</p><pre><code class="lang-CPP">int x=1e10; //得到一个随机值unsigned s=257 //得到1</code></pre><p>要小心：</p><pre><code class="lang-CPP">for (unsigned u = 10; u &gt;= 0; --u)        std::cout &lt;&lt; u &lt;&lt; std::endl //死循环</code></pre><h2 id="1-3-变量初始化方法"><a href="#1-3-变量初始化方法" class="headerlink" title="1.3 变量初始化方法"></a>1.3 变量初始化方法</h2><p>初始化的办法有4种：</p><pre><code class="lang-CPP">int a=0;int a={0};int a(0);int a{0};</code></pre><p>花括号初始化成为<strong>list initialization</strong>，编译器能帮助我们阻止信息丢失。</p><pre><code class="lang-CPP">long double pi=3.1415926535;int a{pi}; //errorint a=pi; //ok,but loss information</code></pre><h2 id="1-4-引用和指针"><a href="#1-4-引用和指针" class="headerlink" title="1.4 引用和指针"></a>1.4 引用和指针</h2><p>引用是另一个<strong>变量</strong>的<strong>别名</strong>。只能绑定某个对象，不能绑定字面值或者表达式的结果，<code>int &amp;a=10;</code>就是错的。</p><p>指针是一个复合类型：<strong>改造符*+基本类型</strong>。我们可以使用解引用(derefence)运算符<em>来访问对象。注意：**定义的时候 </em> 是一个modifier，使用的时候是一个 dereference，概念不一样！**</p><p>空指针的意思是：<strong>没有任何一个对象和指针绑定</strong>。<code>void*</code>是一个特殊的指针类型，可以承载任意类型的对象的地址，但类型时未知的。</p><pre><code class="lang-CPP">double dval =3.14;void* pv = &amp;dval;//pv还是 void*类型</code></pre><hr><p>二者区别：</p><p>相同点：</p><ul><li>都是复合类型（基本类型+改造符或声明符）</li><li>都是间接访问</li></ul><p>不同点：</p><ul><li>指针<strong>本身就是一个对象</strong>而引用不是，所以指针<strong>可以被赋值和拷贝</strong>，而引用不能。指针<strong>不需要定义时初始化</strong>。</li><li>一个指针可以指向好几个不同的对象，而引用则被绑死</li></ul><h2 id="1-5-类和结构体的区别"><a href="#1-5-类和结构体的区别" class="headerlink" title="1.5 类和结构体的区别"></a>1.5 类和结构体的区别</h2><p>class</p><ul><li>class 在<strong>堆中分配空间</strong>，栈中保存的只是引用</li><li>默认是private</li></ul><p>struct</p><ul><li>struct 在栈中分配空间</li><li>默认是public</li></ul><h2 id="1-6-IO特性"><a href="#1-6-IO特性" class="headerlink" title="1.6 IO特性"></a>1.6 IO特性</h2><p>我们希望IO以流的形式输入输出数据，所以不希望被干扰，因此IO类没有拷贝和赋值函数。</p><h2 id="1-8-IO刷新缓冲区的原因"><a href="#1-8-IO刷新缓冲区的原因" class="headerlink" title="1.8 IO刷新缓冲区的原因"></a>1.8 IO刷新缓冲区的原因</h2><ul><li>程序跑完，从main中返回</li><li>缓冲区满</li><li>特殊符号endl，flush，ends结尾</li><li>使用unitbuf操作符，默认情况下，unitbuf为cerr默认设置</li></ul><p>前面提到了用endl，flush，ends结尾。我们最常用的endl：结束当前行，刷新缓冲区。flush刷新缓冲区，末尾不添加字符，而ends除了刷新缓冲区外，末尾还会添加一个空字符。</p><p>注意：<strong>程序崩了是不刷新缓冲区的</strong>。</p><h2 id="1-9-全局变量和局部变量有什么区别？编译器是怎么判断的？"><a href="#1-9-全局变量和局部变量有什么区别？编译器是怎么判断的？" class="headerlink" title="1.9 全局变量和局部变量有什么区别？编译器是怎么判断的？"></a>1.9 全局变量和局部变量有什么区别？编译器是怎么判断的？</h2><p>全局变量的生命周期伴随<strong>主程序</strong>（不是主函数）的创建和销毁，局部变量只存在于局部函数内部。</p><p>全局变量分配在<strong>全局数据段</strong>，而局部变量则分配在<strong>堆栈</strong>里面。</p><h2 id="1-10-生成可执行文件的过程"><a href="#1-10-生成可执行文件的过程" class="headerlink" title="1.10 生成可执行文件的过程"></a>1.10 生成可执行文件的过程</h2><ul><li>用编辑器编写源代码，如.c文件。</li><li>用编译器编译代码生成目标文件，如.o。</li><li>用链接器连接目标代码生成可执行文件，如.exe。</li></ul><h2 id="1-11-cmake和makefile区别"><a href="#1-11-cmake和makefile区别" class="headerlink" title="1.11 cmake和makefile区别"></a>1.11 cmake和makefile区别</h2><p>利用make工具可以根据makefile批量处理源文件。而cmake可以读取所有源文件后，自动生成makefile，更加方便。</p><h2 id="1-12-int-s-10-int-表示的是什么？"><a href="#1-12-int-s-10-int-表示的是什么？" class="headerlink" title="1.12 int (*s[10])(int) 表示的是什么？"></a>1.12 int (*s[10])(int) 表示的是什么？</h2><p><code>int (*s[10])(int)</code> 函数指针数组，每个指针指向一个<code>int func(int param)</code>的函数。</p><pre><code class="lang-CPP">int (*fp)(int a);//fp可以指向如下函数int myFunction(int a){...}</code></pre><h2 id="1-13-联合"><a href="#1-13-联合" class="headerlink" title="1.13 联合"></a>1.13 联合</h2><p>一个 union 可以有多个数据成员，但是<strong>在任意时刻只有一个数据成员可以有值</strong>。当某个成员被赋值后其他成员变为未定义状态。</p><pre><code class="lang-CPP">union abc {    int i;    char m;};union abc a;a.i = 10;</code></pre><h1 id="2-关键词和操作符"><a href="#2-关键词和操作符" class="headerlink" title="2. 关键词和操作符"></a>2. 关键词和操作符</h1><h2 id="2-1-extern"><a href="#2-1-extern" class="headerlink" title="2.1 extern"></a>2.1 extern</h2><p>CPP初始化通常分为两个部分：</p><ul><li>声明，让程序知道他的名字</li><li>定义，实现实体。</li></ul><p>用<code>extern</code>关键词来进行声明，这样就<strong>不用进行显示初始化。</strong></p><p>对比：</p><pre><code class="lang-CPP">extern int a;int b;</code></pre><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200223140158.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="2-2-constexpr"><a href="#2-2-constexpr" class="headerlink" title="2.2 constexpr"></a>2.2 constexpr</h2><p>当一个变量声明为const时，我们<strong>并不知道它是编译期可知还是运行期可知。</strong></p><pre><code class="lang-CPP">const int a=10; //constant expressionconst int b=get_size(); //non a constant expression</code></pre><p>关键词<code>constexpr</code>就是指<strong>编译期可知</strong>，潜台词是：告诉编译器我可以是编译期间可知的，尽情的优化我吧。而<code>const</code><strong>专门用来声明不变量</strong>，潜台词是：告诉程序员没人动得了我，放心的把我传出去；或者放心的把变量交给我，我啥也不动就瞅瞅。</p><hr><p>另一个作用是让类的静态成员在类间能够初始化：</p><pre><code class="lang-CPP">class Account { public:        static double rate() { return interestRate; }        static void rate(double); private:        static constexpr int period = 30;// period is a constant}</code></pre><h2 id="2-3-sizeof"><a href="#2-3-sizeof" class="headerlink" title="2.3 sizeof"></a>2.3 sizeof</h2><p>它不是一个关键词，而是一个<strong>运算符</strong>！！！以<strong>位</strong>的形式返回表达式结果的大小。</p><pre><code class="lang-CPP">vector&lt;int&gt; a{1,2,3};auto m = sizeof a; // type is unsigned_int64, m = 32auto n = sizeof a[0]; //type is the same as above, n=4;</code></pre><h2 id="2-4-mutable"><a href="#2-4-mutable" class="headerlink" title="2.4 mutable"></a>2.4 mutable</h2><p><strong>在成员函数参数列表后加上关键字const后，该函数不允许修改类的数据成员。</strong></p><pre><code class="lang-CPP">char Screen::get() const {   return _screen[_cursor];}</code></pre><p>对成员变量加上mutable关键词可以消除const的影响：</p><pre><code class="lang-CPP">class Screen {     public:            void some_member() const;     private:            mutable size_t access_ctr;}void Screen::some_member() const {        ++access_ctr;    }</code></pre><h2 id="2-5-explicit"><a href="#2-5-explicit" class="headerlink" title="2.5 explicit"></a>2.5 explicit</h2><p>使用关键词explicit<strong>抑制隐式转化</strong>：</p><pre><code class="lang-CPP">class A{    public:        explicit A(int size){}        explicit A(const Explicit&amp; ins){}};int main(){    A test0(15);    A test1 = 10;// 无法调用    A test5 = test0;//无法调用    //如果去掉explicit,就都可以调用。}</code></pre><h2 id="2-6-inline"><a href="#2-6-inline" class="headerlink" title="2.6 inline"></a>2.6 inline</h2><p>声明为内联函数，则：</p><ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li></ul><p>优点：<strong>省去了代码展开，提高速度；缺点：代码体积膨胀</strong>。</p><h2 id="2-7-volatile"><a href="#2-7-volatile" class="headerlink" title="2.7 volatile"></a>2.7 volatile</h2><p>作用：<strong>阻止编译器优化，确保编译器总是从内存中读取数据</strong></p><p>原因：因为访问寄存器要比访问内存单元快的多，所以编译器一般优化代码，尽量读取寄存器，但在多线程过程中可能会读脏数据。</p><h2 id="2-8-typedef-struct"><a href="#2-8-typedef-struct" class="headerlink" title="2.8 typedef struct"></a>2.8 typedef struct</h2><pre><code class="lang-CPP">struct Student{    int a;}stu1;//stu1是一个变量typedef struct Student2{    int a;}stu2;//stu2是一个结构体类型auto m = stu1.a; //okauto n = stu2.a; //errorstu2 st;auto n = st.a;//ok</code></pre><h1 id="3-new"><a href="#3-new" class="headerlink" title="3. new"></a>3. new</h1><h2 id="3-1-new和delete的执行过程"><a href="#3-1-new和delete的执行过程" class="headerlink" title="3.1 new和delete的执行过程"></a>3.1 new和delete的执行过程</h2><p>new的步骤：</p><ol><li>分配一块足够大的原始的未命名的内存空间</li><li>调用相应的构造函数构造对象，为其传入初值</li><li>构造结束后返回该对象的指针</li></ol><p>delete步骤：</p><ol><li>调用对象的析构函数</li><li>编译器释放内存空间</li></ol><h2 id="3-2-动态数组"><a href="#3-2-动态数组" class="headerlink" title="3.2 动态数组"></a>3.2 动态数组</h2><p>有的时候编译时并不能确定数组长度，我们需要通过动态方式分配长度。</p><pre><code class="lang-CPP">int* p = new int[obj.getlen()]; // new运算符返回第一个元素的地址。delete [] p;          // 释放整个数组，new如果带[] 则delete也需要带[]</code></pre><p>使用new和delete时，应遵守以下规则</p><ul><li>避免使用delete来释放不是new分配的资源；</li><li>不要对同一资源delete两次</li><li>使用new[]分配资源时，应使用delete[]来释放</li><li>可以对空指针delete</li></ul><h2 id="3-3-智能指针"><a href="#3-3-智能指针" class="headerlink" title="3.3 智能指针"></a>3.3 智能指针</h2><p>使用new关键词分配动态内存会<strong>返回指向对象的指针</strong>。为了避免管理内存的麻烦，引入带有OS机制的智能指针：</p><ul><li>shared_ptr，允许多个指针指向同一个对象</li><li>unique_ptr，对对象拥有唯一所有权，可以移动但不能复制</li><li>weak_ptr，和shared_ptr搭配使用检测他是否空悬，每次使用时不会影响指向对象的引用计数</li></ul><p>这几个指针的使用规则：</p><p><strong>使用shared_ptr:</strong></p><p>初始化时，最好用函数分配内存，也可以传统的new分配</p><pre><code class="lang-CPP">shared_ptr&lt;string&gt; p1=make_shared&lt;string&gt;(&quot;hello&quot;);shared_ptr&lt;int&gt; p2=make_shared&lt;int&gt;();//emptyshared_ptr&lt;int&gt; p3(new int(10));</code></pre><p>reset函数作用</p><pre><code class="lang-CPP">p = std::make_shared&lt;int&gt;(5);p.reset(new int(5));//等价p = nullptr;p.reset();//等价</code></pre><hr><p><strong>使用unique_ptr：</strong></p><p>不像shared_ptr那样有函数可以用，unique_ptr必须要用new分配空间：</p><pre><code class="lang-CP">unique_ptr&lt;int&gt; p2(new int(42));</code></pre><p>它不能被拷贝和赋值：</p><pre><code class="lang-CPP">unique_ptr&lt;int&gt; p1=new int(42);auto p2(p1);//errorauto p3 = p1;//error</code></pre><p>但我们可以用reset和release转移</p><pre><code class="lang-CPP">unique_ptr&lt;int&gt; p1(new int(42));unique_ptr&lt;int&gt; p2(p1.release());unique_ptr&lt;int&gt; p3(new int(10));p3.reset(p2.release);</code></pre><p>使用release的时候要特别小心，<strong>auto会默认推导为普通指针类型</strong>，所以需要手动delete，不然就泄露了。</p><pre><code class="lang-CPP">auto p2(p1.release()); //int*</code></pre><p>在函数中，我们能够将unique_ptr传递出去：</p><pre><code class="lang-CPP">unique_ptr&lt;int&gt; help(A a){    unique_ptr&lt;A&gt; pa(new A(a));    return pa;}</code></pre><h2 id="3-4-new和malloc区别"><a href="#3-4-new和malloc区别" class="headerlink" title="3.4 new和malloc区别"></a>3.4 new和malloc区别</h2><p>总结起来就是<strong>两反，两内，两重（反冲累），狗租户</strong>(返回类型，失败返回，内存位置，内存大小指定，重新分配内存，重载，构造，数组，互相调用)</p><p><strong>1.返回类型</strong></p><p>new操作符分配成功是返回的指针类型和预期结果相同，无序进行转化，而malloc返回为void*，需要强制转化</p><pre><code class="lang-CPP">char* p1=static_cast&lt;char&gt;(malloc(10));</code></pre><p><strong>2.失败返回</strong></p><p>new分配失败时，<strong>抛出</strong>bad_alloc<strong>异常</strong>，而malloc失败时<strong>返回NULL</strong>。</p><p><strong>3.内存位置</strong></p><p>new从<strong>自由内存区</strong>申请(free store)，malloc从堆上申请。自由内存区可以是堆也可以不是，这取决于实现细节，也可以是静态内存区。</p><p><strong>4.是否指定内存大小</strong></p><p>new分配时无须指定内存块的大小，编译器自行计算，而malloc则需要显式指出内存大小。</p><p><strong>5. 是否可以被重载</strong></p><p>new和delete可以，malloc不可以</p><p><strong>6. 重新分配内存</strong></p><p>使用malloc分配的内存后，可以使用realloc函数进行内存重新分配实现内存的扩充。如果原地内存足够则直接扩大，如果不足则重新找一块地方。new不具备重新分配的能力，只能另起炉灶。</p><p><strong>7. 构造函数</strong></p><p>new会调用构造函数和析构函数，而malloc只是分配内存空间。</p><p><strong>8. 处理数组</strong></p><p>C++提供了new[]和delete[]来专门处理数组。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</p><pre><code class="lang-CPP">A * ptr = new A[10];//分配10个A对象delete [] ptr;</code></pre><p>malloc需要手动指定数组大小：</p><pre><code class="lang-CPP">int * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组</code></pre><p><strong>9. 是否可以互相调用</strong></p><p>new可以重载调用malloc，而malloc反过来则不行。</p><h1 id="4-const"><a href="#4-const" class="headerlink" title="4. const"></a>4. const</h1><h2 id="4-1-const和-define相比优点是什么？"><a href="#4-1-const和-define相比优点是什么？" class="headerlink" title="4.1 const和#define相比优点是什么？"></a>4.1 const和#define相比优点是什么？</h2><h1 id="define是宏定义，只是换了一个名字。而使用const时编译器会对const进行类型检查。"><a href="#define是宏定义，只是换了一个名字。而使用const时编译器会对const进行类型检查。" class="headerlink" title="define是宏定义，只是换了一个名字。而使用const时编译器会对const进行类型检查。"></a>define是宏定义，只是换了一个名字。而使用const时编译器会对const进行类型检查。</h1><h2 id="4-2-const用处"><a href="#4-2-const用处" class="headerlink" title="4.2 const用处"></a>4.2 const用处</h2><p><strong>（1）变量被指定为const</strong></p><p>一个变量被指定为const类型后，不能再赋值：</p><pre><code class="lang-CPP">const int bufsize =512;bufsize =100; //error</code></pre><p><strong>（2）引用被指定为const</strong></p><p>对于const变量的引用也不能再赋值：</p><pre><code class="lang-CPP">const int ci=1024;const int &amp;rci = ci;rci =42; //error</code></pre><p>用const引用来引用non-const值，这样可以修改原值，导致cosnt引用的结果也会改变。<strong>但同样的问题，不能修改const引用的结果。</strong></p><pre><code class="lang-CPP">int i=43;const int &amp;ri=i;ri=10; //errori =10; //ok</code></pre><p><strong>（3）指针指定为const</strong></p><p>用法和引用相同，用const指针来指向non-const值，这样可以修改原值：</p><pre><code class="lang-CPP">int m=10;const int* ptr = &amp;m; //ok, const pointer to non-const variblem = 20; //ok</code></pre><h2 id="4-3-为什么要使用常引用？"><a href="#4-3-为什么要使用常引用？" class="headerlink" title="4.3 为什么要使用常引用？"></a>4.3 为什么要使用常引用？</h2><p>如果既要<strong>利用引用提高程序的效率</strong>，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。</p><h2 id="4-4-什么是顶层常量和底层常量？"><a href="#4-4-什么是顶层常量和底层常量？" class="headerlink" title="4.4 什么是顶层常量和底层常量？"></a>4.4 什么是顶层常量和底层常量？</h2><p>使用<code>const</code>修饰指针时，指针的属性有两种状态：<code>const int *</code>,<code>int * const</code>状态很容易混淆。<strong>在复制时，顶层常量可以被忽略，而底层常量会被限制：</strong></p><pre><code class="lang-CPP">int i = 0;int * const p1 = &amp;i;  //顶层constint *x = p1;  // 正确，可以忽略p1的顶层constint n = *p1;  // 正确int i = 0;const int * p1 = &amp;i; //底层constint *x = p1; // 错误，*x不具备底层const资格const int *x2 = p1; // 正确，具备底层const资格</code></pre><h2 id="4-5-类的成员函数使用const"><a href="#4-5-类的成员函数使用const" class="headerlink" title="4.5 类的成员函数使用const"></a>4.5 类的成员函数使用const</h2><p><strong>前面使用const 表示返回值为const；后面加 const表示函数不可以修改class的成员。</strong></p><pre><code class="lang-CPP">const int FunctionConst::getValue(){    return value;//返回值是 const, 使用指针时很有用.}int FunctionConst::getValue2() const{    //此函数不能修改class FunctionConst的成员函数 value    value = 15;//错误的, 因为函数后面加 const    return value;}</code></pre><p>如果返回值是指针时，前面使用const可以防止函数调用表达式作为左值，使得指针的内容被修改。</p><h1 id="5-类与对象"><a href="#5-类与对象" class="headerlink" title="5.类与对象"></a>5.类与对象</h1><h2 id="5-1-类和结构体区别"><a href="#5-1-类和结构体区别" class="headerlink" title="5.1 类和结构体区别"></a>5.1 类和结构体区别</h2><ul><li>class<ul><li>class 是引用类型，它在堆中分配空间，栈中保存的只是引用</li><li>默认是private</li></ul></li><li>struct<ul><li>struct 是值类型，它在栈中分配空间</li><li>默认是public</li></ul></li></ul><h2 id="5-2-构造函数中const和引用的初始化"><a href="#5-2-构造函数中const和引用的初始化" class="headerlink" title="5.2 构造函数中const和引用的初始化"></a>5.2 构造函数中const和引用的初始化</h2><pre><code class="lang-CPP">class A{public:    A(int ii);private:    int i;    const int ci;    int&amp; ri;}A::A(int ii){    i = ii; //ok    ci = ii; //error;    ri = ii; //error}</code></pre><p><strong>const和引用的初始化必须在创建的时候就要完成</strong>，所以我们需要用列表初始化：</p><pre><code class="lang-CPP">A::A(int ii):i(ii),ci(ii),ri(i){}</code></pre><h2 id="5-3-静态成员"><a href="#5-3-静态成员" class="headerlink" title="5.3 静态成员"></a>5.3 静态成员</h2><p>静态成员<strong>不属于任何一个实例化的对象</strong>。假如我们有一个银行账户类，每天的利率是一个统一的数值，我们不需要为每个账户都去设置，只需要设置一个静态成员，让所有账户share就行。</p><p>由于静态成员<strong>独立于实例化对象之外存在</strong>，对于静态成员函数来说，<strong>他们没有this指针</strong>。</p><p>静态成员在类外可以使用两种办法访问：</p><ul><li><p>作用域符， <code>r=Account::rate();</code></p></li><li><p>传统办法（对象，引用，类指针）</p><pre><code class="lang-CPP">Account ac1;Account ac2;r=ac1.rate();r=ac2-&gt;rate();</code></pre></li></ul><p><strong>在类间可以直接访问。</strong></p><hr><p>由于静态成员不属于任何一个对象，所以构造函数对他是无效的，<strong>我们要初始化一个静态成员得通过函数在类外进行初始化。</strong></p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200224100335.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>使用constexpr或者const可以让他在类间初始化：</p><pre><code class="lang-CPP">class Account { public:        static double rate() { return interestRate; }        static void rate(double); private:        static constexpr int period = 30;// period is a constant}</code></pre><h2 id="5-4-类的特殊成员函数"><a href="#5-4-类的特殊成员函数" class="headerlink" title="5.4 类的特殊成员函数"></a>5.4 类的特殊成员函数</h2><p>有5个：<strong>拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数。</strong></p><p>拷贝函数的定义：<strong>第一个参数是类的引用</strong></p><pre><code class="lang-CPP">class Foo{public:    Foo();//default    Foo(Foo const&amp;);//copy}</code></pre><p>拷贝赋值运算符：本质是重载了=运算符，运算符重载可以理解为：<strong>返回类型，函数名称，传入参数</strong>。赋值运算符通常应该<strong>返回一个指向其左侧对象的引用</strong></p><pre><code class="lang-CPP">class Foo{public:    Foo&amp; operator=(Foo const&amp;);}</code></pre><p>析构函数：析构时会先执行函数体，成员销毁时时按照生成时的逆序发生的。<strong>析构时，先调用派生类析构函数，再调用基类</strong>.</p><pre><code class="lang-cpp">class A{public:    int i;    A(int const&amp; _i) :i(_i) {}    ~A(){        cout &lt;&lt; i;    }};//先输出i，再销毁</code></pre><h2 id="5-5-析构函数注意事项"><a href="#5-5-析构函数注意事项" class="headerlink" title="5.5 析构函数注意事项"></a>5.5 析构函数注意事项</h2><p><strong>如果要自定义析构，则必须自定义拷贝和赋值</strong>。主要是针对浅拷贝和深拷贝的问题。</p><pre><code class="lang-CPP">//深拷贝HasPtr&amp; operator=(HasPtr const&amp; rhs){    this-&gt;ps = new size_t[num];    this-&gt;num = rhs.num;    for(int i=0;i&lt;num;i++)        this-&gt;ps[i]=rhs.ps[i];    return this*;}//浅拷贝HasPtr&amp; operator=(HasPtr const&amp; rhs){    this-&gt;num=rhs.num;    this-&gt;ps = rhs.ps;    return this*;}</code></pre><p>由于两个指针指向同一片内存区域，如果其中一个被释放，则另一个变成野指针。用智能指针可以避免：</p><pre><code class="lang-CPP">int* p1 = new int(5);int* p2 = p1;delete p1; //野shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(5);auto p4 = p3;p3.reset();//ok</code></pre><h2 id="5-6-合成构造函数"><a href="#5-6-合成构造函数" class="headerlink" title="5.6 合成构造函数"></a>5.6 合成构造函数</h2><p>当我们只是传入了一个类的对象，编译器会帮助我们利用这个对象进行合成构造，具体如下：</p><pre><code class="lang-CPP">class Sales_data{public:    Sales_data(const Sales_data&amp;);private:    std::string bookNo;    int units_sold = 0;    double revenue = 0.0;};//与Sales_data的合成拷贝构造函数等价Sales_data::Sales_data(const Sales_data &amp;orig) :     bookNo(orig.bookNo), //使用string的拷贝构造函数    units_sold(orig.units_sold),    //拷贝orig.units_sold    revenue(orig.revenue)    //拷贝orig.revenue    {}}</code></pre><h2 id="5-7-default和delete"><a href="#5-7-default和delete" class="headerlink" title="5.7 default和delete"></a>5.7 default和delete</h2><p>使用关键词default以后可以<strong>显示地让编译器生成合成构造函数</strong>。delete可以禁用某些特殊成员函数。</p><p>比如比如Iostream类就不希望有多个对象访问IO相同的IO口。因此我们呢使用<code>=delete</code>禁用拷贝构造和赋值运算符。</p><h2 id="5-8-如何区分移动和拷贝的重载？"><a href="#5-8-如何区分移动和拷贝的重载？" class="headerlink" title="5.8 如何区分移动和拷贝的重载？"></a>5.8 如何区分移动和拷贝的重载？</h2><p>方法1，利用const</p><pre><code class="lang-CPP">void push_back(X const&amp;);void push_back(X&amp;&amp;);</code></pre><p>方法2，<strong>利用引用限定符</strong></p><pre><code class="lang-CPP">class Foo{public:    void sorted()&amp;&amp;    {cout &lt;&lt; &quot;&amp;&amp;&quot;&lt;&lt;endl;}    void sorted()&amp;    {cout &lt;&lt; &quot;&amp;&quot; &lt;&lt; endl;}};Foo&amp;&amp; retVal(){    Foo f;    return std::move(f);}Foo&amp; retFoo(){    Foo f;    return f;}int main(){    retVal().sorted(); //&amp;&amp;    retFoo().sorted(); //&amp;}</code></pre><h2 id="5-9-this指针"><a href="#5-9-this指针" class="headerlink" title="5.9 this指针"></a>5.9 this指针</h2><p>它指向当前对象，通过它可以访问当前对象的所有成员。</p><pre><code class="lang-CPP">void Student::setname(char *name){    this-&gt;name = name;}</code></pre><h2 id="5-10-访问私有成员的办法"><a href="#5-10-访问私有成员的办法" class="headerlink" title="5.10 访问私有成员的办法"></a>5.10 访问私有成员的办法</h2><ul><li>类的成员函数访问</li><li>友元函数</li></ul><h1 id="6-面向对象"><a href="#6-面向对象" class="headerlink" title="6. 面向对象"></a>6. 面向对象</h1><h2 id="6-1-oop特征"><a href="#6-1-oop特征" class="headerlink" title="6.1 oop特征"></a>6.1 oop特征</h2><p>三大特征：封装、继承、多态</p><ul><li>封装：分离接口和实现过程</li><li>继承：应用类之间的相似性</li><li>多态：函数复用</li></ul><h2 id="6-2-虚函数"><a href="#6-2-虚函数" class="headerlink" title="6.2 虚函数"></a>6.2 虚函数</h2><p>虚函数并不是不实现，纯虚函数<code>virtual void foo()=0;</code>才是不实现（比如shape类中，我实在不想写area的表达过程，就让他成为纯虚函数，方便格式统一）。虚函数主要是用来<strong>简便地实现多态的</strong>，<strong>核心理念就是通过基类访问派生类定义的函数</strong>。</p><p>多态分两种：</p><ul><li>编译时多态，重载</li><li>运行时多态，重写（<strong>重写是子类对父类的允许访问的方法的实现过程进行重新编写</strong>）</li></ul><p>当API不会知道实际传进来的指针或引用是哪个类型时，<strong>先用一个基类接一下传进来的指针，在运行时根据类型安排虚函数执行。</strong></p><pre><code class="lang-CPP">class BaseItem {public:    virtual void itemMethod()=0;};class ItemA :public BaseItem { public:void itemMethod() override { cout &lt;&lt; &quot;ItemA&quot;&lt;&lt;endl; } };class ItemB :public BaseItem { public:void itemMethod() override { cout &lt;&lt; &quot;ItemB&quot; &lt;&lt; endl; } };class ItemC :public BaseItem { public:void itemMethod() override { cout &lt;&lt; &quot;ItemC&quot; &lt;&lt; endl; } };int main(){    vector&lt;shared_ptr&lt;BaseItem&gt;&gt; ItemCollection;    shared_ptr&lt;BaseItem&gt; p;    //基类指针指向派生类！    p.reset(new ItemA());     ItemCollection.push_back(p);    p.reset(new ItemB());    ItemCollection.push_back(p);    p.reset(new ItemC());    ItemCollection.push_back(p);    for (auto it : ItemCollection) {        it-&gt;itemMethod();    }}</code></pre><p>C++11中允许使用<strong>override关键词显式注明虚函数的重写</strong>，如果重写失败就报错(不加的话会误以为一个新函数)(<strong>IDE推荐使用override</strong>)</p><pre><code class="lang-CPP">struct B{    virtual void f1(int) const;    virtual void f2();    void f3();};struct D1 : B {    void f1(int) const override;    // ok: f1 matches f1 in the base    void f2(int) override;      // error: B has no f2(int) function    void f3() override;     // error: f3 not virtual}</code></pre><h2 id="6-3-虚函数表"><a href="#6-3-虚函数表" class="headerlink" title="6.3 虚函数表"></a>6.3 虚函数表</h2><p>当上行转换时(从派生类到基类)可以通过隐式转化或<code>static_cast</code>完成，但要完成下行转化就需要借助<code>dynamic_cast</code>。虚函数表的作用就是<strong>完成上下行转换，实现动态绑定</strong>。</p><p><strong>每一个包含虚函数的类（不是对象）都有一个自己的虚表</strong></p><pre><code class="lang-CPP">class A {public:    virtual void vfunc1();    virtual void vfunc2();    void func1();    void func2();private:    int m_data1, m_data2;};</code></pre><p>虚表是一个<strong>指针数组</strong>，其<strong>元素是虚函数的指针</strong>，每一个元素对应一个虚函数（普通函数不需要经过虚表）。</p><p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191214120007.png" style="zoom:60%;" /></p><p><strong>当某个类生成一个对象时，编译器在类中就添加了一个指针<code>*_vptr</code>，指向虚表</strong></p><p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191214120124.png" style="zoom:60%;" /></p><p>虚表是如何实现<strong>动态绑定</strong>的呢？</p><pre><code class="lang-CPP">class A {public:    virtual void vfunc1();    virtual void vfunc2();};class B : public A {public:    virtual void vfunc1();};class C: public B {public:    virtual void vfunc2();};</code></pre><p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191214120452.png" style="zoom: 50%;" /></p><p>当我们调用的时候:</p><pre><code class="lang-CPP">B bObject;A* p = &amp;bObject;p-&gt;vfunc1(); //调用B::vfunc1();</code></pre><p>程序在执行<code>p-&gt;vfunc1();</code>时，我们检查了三大条件：</p><ul><li>对象是指针或引用形式</li><li>静态类型和动态类型不同</li><li>带虚函数的继承体系</li></ul><p>所以现在动态类型现在生效。此时，<strong>并没有将p完全变为A，而是保留了B的虚函数表</strong>，所以我们调用的时候还是按B的虚函数表索引！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cpp的内容整理。
    
    </summary>
    
    
      <category term="C++" scheme="jiangren.work/categories/C/"/>
    
    
      <category term="C++" scheme="jiangren.work/tags/C/"/>
    
      <category term="面试经验" scheme="jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构面试题目汇总</title>
    <link href="jiangren.work/2020/02/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    <id>jiangren.work/2020/02/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</id>
    <published>2020-02-22T05:56:25.000Z</published>
    <updated>2020-03-31T10:42:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇针对的是问答题而不是编程题，所以大部分都是在文字叙述，外加少部分的编程。<a id="more"></a></p><h1 id="1-树"><a href="#1-树" class="headerlink" title="1. 树"></a>1. 树</h1><h2 id="1-1-区分完全二叉树、满二叉树、搜索二叉树"><a href="#1-1-区分完全二叉树、满二叉树、搜索二叉树" class="headerlink" title="1.1 区分完全二叉树、满二叉树、搜索二叉树"></a>1.1 区分完全二叉树、满二叉树、搜索二叉树</h2><p>完全二叉树：假设树有N层，则第1到第N-1层都是满节点</p><p>满二叉树：满足完全二叉树，但第N层没有任何节点</p><p>二叉搜索树：任意节点的左子树不为空，则左子树的所有值均小于根节点；反之右子树大于根节点。</p><h2 id="1-2-什么是平衡二叉树-VAL树-？"><a href="#1-2-什么是平衡二叉树-VAL树-？" class="headerlink" title="1.2 什么是平衡二叉树(VAL树)？"></a>1.2 什么是平衡二叉树(VAL树)？</h2><p>满足三个条件：</p><ul><li>是二叉搜索树</li><li>左右子树深度之差不大于1</li><li>左右子树分别都是平衡二叉树</li></ul><h2 id="1-3-什么是哈夫曼树？"><a href="#1-3-什么是哈夫曼树？" class="headerlink" title="1.3 什么是哈夫曼树？"></a>1.3 什么是哈夫曼树？</h2><p>给定N个权值作为N个<strong>叶子结点</strong>，构造一棵二叉树，<strong>若该树的带权路径长度达到最小</strong>，则称其为最优二叉树，也叫哈夫曼树。特征是<strong>权值较大的结点离根较近</strong>。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200221103817.png"  style="zoom:55%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>构建时，先对叶节点的权值排序，然后合并：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200221104030.png"  style="zoom:45%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="1-4-什么是红黑树？"><a href="#1-4-什么是红黑树？" class="headerlink" title="1.4 什么是红黑树？"></a>1.4 什么是红黑树？</h2><p><strong>特性</strong>：自平衡</p><p><strong>时间复杂度</strong>：普通二叉搜索树的时间复杂度为$O(\lg n)$到$O(n)$，而红黑树能保持在lgn。最极端的情况：最长子树是最短子树的两倍。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200302190509.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p><strong>五大原则</strong>：</p><ol><li>每个节点或者是黑色，或者是红色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。<strong> </strong>[注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]**</li><li>如果一个节点是红色的，则它的子节点必须是黑色的。</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li></ol><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200222105000.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p><strong>维持自平衡的方法</strong>：左旋，右旋，变色</p><h2 id="1-5-什么是红黑树的左旋右旋？"><a href="#1-5-什么是红黑树的左旋右旋？" class="headerlink" title="1.5 什么是红黑树的左旋右旋？"></a>1.5 什么是红黑树的左旋右旋？</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ask.qcloudimg.com/http-save/yehe-2899014/ief9fhcydr.gif" alt="左旋动图" title="">                </div>                <div class="image-caption">左旋动图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ask.qcloudimg.com/http-save/yehe-2899014/7kqfdyv4og.gif" alt="右旋动图" title="">                </div>                <div class="image-caption">右旋动图</div>            </figure><p>代码实现：</p><ol><li>节点左旋必须有右孩子，右旋必须有左孩子。</li><li>如果N经过旋转变成了根节点，一定要记得将RBTree结构体中的根节点指针root指向N，这是容易出错的地方。</li></ol><pre><code class="lang-go">const (    // 左旋    LEFTROTATE bool = true    // 右旋    RIGHTROTATE bool = false)// rotate() true左旋/false右旋// 若有根节点变动则返回根节点func (rbnode *RBNode) rotate(isRotateLeft bool) (*RBNode, error) {    var root *RBNode    if rbnode == nil {        return root, nil    }    if !isRotateLeft &amp;&amp; rbnode.left == nil {        return root, errors.New(&quot;右旋左节点不能为空&quot;)    } else if isRotateLeft &amp;&amp; rbnode.right == nil {        return root, errors.New(&quot;左旋右节点不能为空&quot;)    }    parent := rbnode.parent    var isleft bool    if parent != nil {        isleft = parent.left == rbnode    }    if isRotateLeft {        grandson := rbnode.right.left        rbnode.right.left = rbnode        rbnode.parent = rbnode.right        rbnode.right = grandson    } else {        grandson := rbnode.left.right        rbnode.left.right = rbnode        rbnode.parent = rbnode.left        rbnode.left = grandson    }    // 判断是否换了根节点    if parent == nil {        rbnode.parent.parent = nil        root = rbnode.parent    } else {        if isleft {            parent.left = rbnode.parent        } else {            parent.right = rbnode.parent        }        rbnode.parent.parent = parent    }    return root, nil}</code></pre><h2 id="1-6-红黑树相较于AVL树的优势是什么？"><a href="#1-6-红黑树相较于AVL树的优势是什么？" class="headerlink" title="1.6 红黑树相较于AVL树的优势是什么？"></a>1.6 红黑树相较于AVL树的优势是什么？</h2><p>AVL树是绝对平衡的二叉树，所有子树都<strong>必须满足深度之差为1</strong>的强条件，这会对插入删除带来较大的麻烦。而红黑树可以能<strong>确保树的最长路径不大于两倍的最短路径的长度</strong>(依然可以保证lgn)，虽然查找时性能没有AVL树那么好，但增添和删除更为便捷。</p><h2 id="1-7-红黑树和哈希表二者该如何选择？"><a href="#1-7-红黑树和哈希表二者该如何选择？" class="headerlink" title="1.7 红黑树和哈希表二者该如何选择？"></a>1.7 红黑树和哈希表二者该如何选择？</h2><p>考虑三个方面：</p><ul><li><strong>内存</strong>：如果内存有限制，使用map能节约内存</li><li><strong>数据量</strong>：如果数据量较小，使用map比较好。反之，数据量大，map的层数太多，用哈希表比较好。</li><li><strong>扩展性</strong>：如果数据是静态的，哈希表会比较好。如果需要拓展，则红黑树比较好。</li></ul><h2 id="1-8-红黑树在什么情况下可能发生红黑节点冲突？"><a href="#1-8-红黑树在什么情况下可能发生红黑节点冲突？" class="headerlink" title="1.8 红黑树在什么情况下可能发生红黑节点冲突？"></a>1.8 红黑树在什么情况下可能发生红黑节点冲突？</h2><p>插入操作时，需要解决红红冲突，因为红黑树的一条性质是如果一个节点是红色的，那么其子节点都是黑色的。</p><h2 id="1-9-map和unordered-map的底层实现有什么不同？"><a href="#1-9-map和unordered-map的底层实现有什么不同？" class="headerlink" title="1.9 map和unordered_map的底层实现有什么不同？"></a>1.9 map和unordered_map的底层实现有什么不同？</h2><p>map底层是基于红黑树实现的，因此map内部元素排列是有序的。而unordered_map底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的。</p><h2 id="1-10-什么是B-树"><a href="#1-10-什么是B-树" class="headerlink" title="1.10 什么是B-树"></a>1.10 什么是B-树</h2><p>-是连接符，不读B减，是一种<strong>多路搜索树</strong>。所有的非终端结点中包含下列信息数据：<code>（n，A0，K1，A1，K2，A2，…，Kn，An）；</code></p><p>n 表示结点中包含的关键字的个数，取值范围是：<code>⌈m/2⌉-1≤ n ≤m-1</code>。Ki （i 从 1 到 n）为关键字，且 Ki &lt; Ki+1 ；Ai 代表指向子树根结点的指针，且指针 Ai-1 所指的子树中所有结点的关键字都小于 Ki，An 所指子树中所有的结点的关键字都大于 Kn。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200221131430.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>所示就是一棵 4 阶的 B-树，这棵树的深度为 4：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200221131933.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="1-11-什么是B-树"><a href="#1-11-什么是B-树" class="headerlink" title="1.11 什么是B+树"></a>1.11 什么是B+树</h2><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200221132324.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><ul><li>B+树所有<strong>叶子节点的链表中包含了全部关键字的信息， 及指向含这些关键字记录的指针</strong></li><li>叶子节点的链表是有序的</li><li>非终端节点只是索引的一部分，<strong>节点中仅含有其子树（根节点）中的最大（或最小)关键字</strong></li></ul><h1 id="2-堆栈"><a href="#2-堆栈" class="headerlink" title="2. 堆栈"></a>2. 堆栈</h1><h2 id="2-1-什么时候可能发生栈溢出"><a href="#2-1-什么时候可能发生栈溢出" class="headerlink" title="2.1 什么时候可能发生栈溢出"></a>2.1 什么时候可能发生栈溢出</h2><ul><li><strong>局部数组过大</strong>。解决办法：增大栈空间或者使用动态分配(堆空间)</li><li><strong>递归调用层次太多</strong>。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</li><li><strong>指针或者数组越界</strong>。</li></ul><h2 id="2-2-堆和栈的区别"><a href="#2-2-堆和栈的区别" class="headerlink" title="2.2 堆和栈的区别"></a>2.2 堆和栈的区别</h2><ul><li><strong>地址方向</strong>：堆是由低地址向高地址扩展；栈是由高地址向低地址扩展</li><li><strong>管理方式</strong>：堆中的内存需要手动申请和手动释放；栈中内存是由OS自动申请和自动释放</li><li><strong>使用效率：</strong>堆中频繁调用malloc和free,会产生内存碎片，降低程序效率；而栈由系统分配，不会产生内存碎片</li></ul><h2 id="2-3-什么是小根堆和大根堆？"><a href="#2-3-什么是小根堆和大根堆？" class="headerlink" title="2.3 什么是小根堆和大根堆？"></a>2.3 什么是小根堆和大根堆？</h2><p>小根堆：</p><ul><li>若存在左子节点，则根节点的值小于左子节点</li><li>若存在右子几点，则根节点的值小于左子节点</li></ul><p>大根堆，小于换成大于。</p><h1 id="3-排序"><a href="#3-排序" class="headerlink" title="3. 排序"></a>3. 排序</h1><h2 id="3-1-选择排序"><a href="#3-1-选择排序" class="headerlink" title="3.1 选择排序"></a>3.1 选择排序</h2><p>选择一组数列中最小的一个放到前面去。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200221150141.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><pre><code class="lang-go">func selectSort(b []int) []int {    n:=len(b)    a:=make([]int,n)    copy(a,b)    for i:=0;i&lt;n;i++{        min:=i        for j:=min+1;j&lt;n;j++{            if a[j]&lt;a[min]{                min=j            }        }        swap(a,i,min)    }    return a}</code></pre><hr><p>选择、插入、希尔都是N^2级别的排序，希尔的平均速度要快于前两种。</p><h2 id="3-2-插入排序"><a href="#3-2-插入排序" class="headerlink" title="3.2 插入排序"></a>3.2 插入排序</h2><p>对于某数n来说，前n-1个数已经完成排序，则n要插入到其中正确的位置。编程时双循环，第一个循环表明确定序列的范围，第二个循环则是将n与n-1，n-2…相比较，确定位置（冒泡）</p><pre><code class="lang-go">func insertSort(b []int)[]int{    n:=len(b) //切片传进来都是地址，要拷贝    a:=make([]int,n)    copy(a,b)    for i:=1;i&lt;n;i++{        for j:=i;j&gt;=1;j--{            if a[j-1]&gt;a[j]{ //注意这里的符号                swap(a,j-1,j)            }        }    }    return a}</code></pre><pre><code class="lang-CPP">void inserSort(vector&lt;int&gt;&amp; a) {    int n = a.size();    for (int i = 1; i &lt; n; i++) {        for (int j = i; j &gt;= 1; j--) {            if (a[j - 1] &gt; a[j]) {                swap(a[j - 1], a[j]);            }        }    }}</code></pre><h2 id="3-3-希尔排序"><a href="#3-3-希尔排序" class="headerlink" title="3.3 希尔排序"></a>3.3 希尔排序</h2><p>也就是分组插入排序，编程时三重循环，第一重是步长选择，初始值为length/2，每次迭代都除以2，直到为0；后面两重循环和插入排序一模一样，只不过把i替换为step；比如正常插入排序i=1，把1替换为step即可完成希尔排序。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200221150513.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><pre><code class="lang-go">func shellSort(b []int)[]int{    n:=len(b)    a:=make([]int,n)    copy(a,b)    for step:=n/2;step&gt;=1;step=step/2{ //分组        for i:=step;i&lt;n;i++{ //在不同组内进行            for j:=i;j&gt;=step;j=j-step{                if a[j-step]&gt;a[j] {                    swap(a, j-step, j)                }            }        }    }    return a}</code></pre><pre><code class="lang-CPP">void shellSort(vector&lt;int&gt;&amp; a) {    int n = a.size();    for (int len = n / 2; len &gt;= 1; len = len / 2) {        for (int i = len; i &lt; n; i++) {            for (int j = i; j &gt;= len; j--) {                if (a[j - len] &gt; a[j]) {                    swap(a[j - len], a[j]);                }            }        }    }}</code></pre><h2 id="3-4-归并排序"><a href="#3-4-归并排序" class="headerlink" title="3.4 归并排序"></a>3.4 归并排序</h2><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200221154928.png"/></p><pre><code class="lang-go">func mergeSort(b []int) []int{   n:=len(b)   a:=make([]int,n)   copy(a,b)    //在排序前，先建好临时数组，避免递归中频繁开辟空间   tmp:=make([]int,n)   sort(a,0,n-1,tmp)   return a}func sort(a []int,left int, right int, tmp []int){   if left&lt;right{      mid:=(left+right)/2      sort(a ,left,mid,tmp) //左半边归并      sort(a, mid+1,right,tmp) //右半边归并      merge(a,left,mid,right,tmp)   }}func merge(a []int,left,mid,right int,tmp []int){   i,j,t:=left,mid+1,0   for i&lt;=mid&amp;&amp;j&lt;=right { //融合的前提是左半边和右半边分别有序      if a[i]&lt;=a[j]{         tmp[t]=a[i];t++;i++      }else{         tmp[t]=a[j];t++;j++      }   }   //一边比完后，就把剩下的一边全放进去   for i&lt;=mid{      tmp[t]=a[i];t++;i++   }   for j&lt;=right{      tmp[t]=a[j];t++;j++   }   t=0   for left&lt;=right{//将排好的放回原数组      a[left]=tmp[t];left++;t++ //必须有left！！！！   }}</code></pre><p>大O代表的算法法复杂度一样只是说明随着数据量的增加，<strong>算法时间代价增长的趋势相同</strong>。在公式里各个排序算法的前面都省略了一个c，这个c对于堆排序来说是100，可能对于快速排序来说就是10，但因为是常数级所以不影响大O。</p><p><a href="https://blog.csdn.net/qq_39521554/article/details/79364718" target="_blank" rel="noopener">https://blog.csdn.net/qq_39521554/article/details/79364718</a></p><pre><code class="lang-CPP">void merge(vector&lt;int&gt;&amp; a, int left, int right, int mid) {    vector&lt;int&gt; tmp(right - left+1,0);    int p1 = left, p2 = mid + 1, index = 0;    while (p1 &lt;= mid &amp;&amp; p2 &lt;= right) {        tmp[index++] = a[p1] &gt; a[p2] ? a[p2++] : a[p1++];    }    while (p1 &lt;= mid) {        tmp[index++] = a[p1++];    }    while (p2 &lt;= right) {        tmp[index++] = a[p2++];    }    for (int i = 0; i &lt; tmp.size(); i++) {        a[left + i] = tmp[i];    }}void cut(vector&lt;int&gt;&amp; a, int left, int right) {    if (left &lt; right) {        int mid = (left + right) / 2;        cut(a, left, mid);        cut(a, mid + 1, right);        merge(a, left, right, mid);    }}void mergeSort(vector&lt;int&gt;&amp; a) {    if (a.size() &lt; 2) return;    cut(a, 0, a.size() - 1);}</code></pre><h2 id="3-5-快速排序"><a href="#3-5-快速排序" class="headerlink" title="3.5 快速排序"></a>3.5 快速排序</h2><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200222114044.png"  style="zoom:55%;display: block; margin: 0px auto; vertical-align: middle;"></p><pre><code class="lang-go">func quickSort(a []int,left,right int){    if left&lt;right{        i,j:=left,right        mid:=(left+right)/2        key:=a[(left+right)/2] //取中间作为pivot，效率更高        for i&lt;=j{ //调序，直到满足条件            for a[i]&lt;key{ //到key时一定会停                i++            }            for a[j]&gt;key{                j--            }            if i&lt;=j { //交换之前必须检查                a[i], a[j] = a[j], a[i]                i++;j--            }        }        if left&lt;mid-1{ //满足条件时，i一定大于j            quickSort(a,left,mid-1)        }        if right&gt;mid+1{            quickSort(a,mid+1,right)        }    }}</code></pre><pre><code class="lang-CPP">void quickSort(vector&lt;int&gt;&amp; a, int left, int right) {    if (left &lt; right) {        int i = left, j = right;        int mid = (left + right) / 2;        int pivot = a[mid];        while (i &lt;= j) {            while (a[i] &lt; pivot) {                i++;            }            while (a[j] &gt; pivot) {                j--;            }            if (i &lt;= j) {                swap(a[i], a[j]);                i++, j--;            }        }        if (left &lt; mid - 1) {            quickSort(a, left, mid - 1);        }        if (right &gt; mid + 1) {            quickSort(a, mid + 1, right);        }    }}</code></pre><h2 id="3-6-三项切分快速排序"><a href="#3-6-三项切分快速排序" class="headerlink" title="3.6 三项切分快速排序"></a>3.6 三项切分快速排序</h2><p>采用了三指针，<strong>两个放首尾，<code>index</code>放中间</strong>。要保证<code>index</code>以前的都是有序的，我们构建两个标志<code>zerotail</code>和<code>twohead</code>分别表示<strong>最后一个0的下一个和第一个2的前一个</strong>，比如<code>[0,1,1,2]</code>，<code>zerotail=1</code>，<code>twohead=2</code>。</p><p>注意：当<code>nums[index] == 2</code>交换时，<code>index</code><strong>不能盲目前进</strong>，因为不知道被换过来的是1还是2，需要放到下一轮进行检验。（由于我们保证了index以前都是有序的，所以和0做交换是安全的）</p><p>注意：去重时，必须要判断<code>twohead &gt;= 0</code>和<code>zerotail &lt; nums.size()</code>，不然会溢出。比如<code>[2]</code>，使得<code>twohead=-1</code>，下一次while就会导致<code>nums[twohead]</code>溢出。</p><pre><code class="lang-Cpp">void sortColors(vector&lt;int&gt;&amp; nums) {    int zerotail = 0, twohead = nums.size() - 1;    while (zerotail &lt; nums.size() &amp;&amp; nums[zerotail] == 0) zerotail++;    while (twohead &gt;= 0 &amp;&amp; nums[twohead] == 2) twohead--;    int index = zerotail;    while (index &lt;= twohead)    {        if (nums[index] == 0)            std::swap(nums[zerotail++], nums[index++]);        else if (nums[index] == 2)            std::swap(nums[twohead--], nums[index]);        else            index++;    }}</code></pre><h2 id="3-7-堆排序"><a href="#3-7-堆排序" class="headerlink" title="3.7 堆排序"></a>3.7 堆排序</h2><p>当堆中某个节点的编号为i时，如果这个节点有左右子树，那么左子树的节点编号为<code>2*i</code>,右子树的节点编号为<code>2*i+1</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20171220151228505?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHlsNzcxODU3NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>先用<code>buildMaxHeap</code>将数组构建成最大堆（第i层总是比第i+1层大）。因为数组中最大元素总在根节点A[0]处，每次都取出最大值，然后放入res数组。同时维护被破坏的堆。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20171220153219983?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHlsNzcxODU3NTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><pre><code class="lang-CPP">int nsize;//因为每次移除根节点，size都会变小，所以需要全局变量掌控void maxHeap(vector&lt;int&gt;&amp; a, int n) {    int leftChild, rightChild, largest;    leftChild = 2 * n;    rightChild = 2 * n + 1;    if (leftChild &lt;= nsize &amp;&amp; a[leftChild - 1] &gt; a[n - 1]) {        largest = leftChild;    }    else {        largest = n;    }    if (rightChild &lt;= nsize &amp;&amp; a[rightChild - 1] &gt; a[largest - 1]) {        largest = rightChild;    }    if (largest != n) {        swap(a[n - 1], a[largest - 1]);        maxHeap(a, largest);    }}void buildHeap(vector&lt;int&gt;&amp; a, int n) {    int i = n / 2;    for (; i &gt; 0; i--) {        maxHeap(a, i);    }}void heapSort(vector&lt;int&gt;&amp; a, int n) {    nsize = n;    int i;    buildHeap(a, n);    vector&lt;int&gt; res;    for (i = nsize; i &gt; 0; i--)    {        res.push_back(a[0]);        a.erase(a.begin());        nsize=nsize-1;        maxHeap(a, 1);        for (auto x : res) {            cout &lt;&lt; x &lt;&lt; &quot;,&quot;;        }        cout &lt;&lt; endl;    }}</code></pre><h2 id="3-8-TopK问题"><a href="#3-8-TopK问题" class="headerlink" title="3.8 TopK问题"></a>3.8 TopK问题</h2><p><strong>（1）分治法</strong></p><pre><code class="lang-CPP">/*     * 基于快排Partition函数     * 时间复杂度O（n）空间复杂度O（1）需要改变输入     */vector&lt;int&gt; getTopK(vector&lt;int&gt; nums, int k){    if (nums.empty() || k &gt; nums.size() || k&lt;=0) return {};    vector&lt;int&gt; ret;    int begin = 0, end = nums.size()-1;    int idx = Partition(nums,begin,end);    while (idx != k-1){        if (idx &lt; k-1){            begin = idx + 1;            idx = Partition(nums,begin,end);        }else{            end = idx - 1;            idx = Partition(nums,begin,end);        }    }    for (int i = 0; i &lt; k; ++i) {        ret.push_back(nums[i]);    }    return ret;}// 返回索引值idx，idx前的元素均大于该处的元素值；idx后的元素均小于该处的元素值int Partition(vector&lt;int&gt; &amp;nums, int begin, int end){    if (begin &gt; end) return begin;    int key = nums[begin];    // 取最后一个值为基准值    while (begin &lt; end){        while (nums[end] &lt;= key &amp;&amp; begin &lt; end) --end;        nums[begin] = nums[end];        while (nums[begin] &gt; key &amp;&amp; begin &lt; end) ++ begin;        nums[end] = nums[begin];    }    nums[begin] = key;    return begin;}</code></pre><p><strong>（2）堆排序</strong></p><p>时间复杂度nlg(K)，比分治法n要慢，但是不需要修改输入数据，适用于海量数据。</p><p><code>multiset&lt;T&gt;</code> 容器就像 <code>set&lt;T&gt;</code> 容器，但它可以保存重复的元素，默认用 <code>less&lt;T&gt;</code> 来比较元素，也可以<code>greater&lt;T&gt;</code></p><pre><code class="lang-CPP">vector&lt;int&gt; getTopK(vector&lt;int&gt;&amp; nums, int k){    if (nums.empty() || k &gt; nums.size() || k&lt;1) return {};    vector&lt;int&gt; ret;    multiset&lt;int, less&lt;int&gt;&gt; m; // 最小堆，保存最大的K个数    for (int i = 0; i &lt; nums.size(); ++i) {        if(m.size()&lt;k){            m.insert(nums[i]);        } else{            it = m.begin();            // 如果当前值大于topK的最小元素（最小堆堆顶），替换该值            if (nums[i]&gt; *it){                m.erase(it);                m.insert(nums[i]);            }        }    }    for (auto x : m) {        ret.push_back(x);    }    return ret;}</code></pre><h1 id="4-哈希"><a href="#4-哈希" class="headerlink" title="4. 哈希"></a>4. 哈希</h1><h2 id="4-1-什么是哈希表？"><a href="#4-1-什么是哈希表？" class="headerlink" title="4.1 什么是哈希表？"></a>4.1 什么是哈希表？</h2><p>又称散列表。通过<strong>键-值映射</strong>进行访问的表，<strong>把键映射到数组的某个下标</strong>来加快查找速度。</p><h2 id="4-2-哈希表的定址方法有哪些？"><a href="#4-2-哈希表的定址方法有哪些？" class="headerlink" title="4.2 哈希表的定址方法有哪些？"></a>4.2 哈希表的定址方法有哪些？</h2><ul><li>直接法：key=value+C,C是常量</li><li>取余法：key=value%C</li><li>折叠法：比如value=135790，将value变为13+57+90=160，再去除最高位，得到的60就是key。</li></ul><h2 id="4-3-哈希表解决冲突的办法有哪些？"><a href="#4-3-哈希表解决冲突的办法有哪些？" class="headerlink" title="4.3 哈希表解决冲突的办法有哪些？"></a>4.3 哈希表解决冲突的办法有哪些？</h2><ul><li><p>线性探测：5421 是要插入数据的位置，若被占用就使用5422，以此类推</p></li><li><p>二次探测：防止聚集，线性探测是x+1,x+2，而二次探测就是x+1,x+4,x+9</p></li><li><p>再哈希法：消除原始聚集和二次聚集，把关键字用不同的哈希函数再做一遍哈希化，用这个结果作为<strong>步长</strong></p></li><li><p>链地址法：某个数据项的关键字值还是像通常一样映射到哈希表的单元，而数据项本身插入到这个单元的链表中。其中每一条链子都是一个<strong>桶</strong>。假设桶的个数为17，则将哈希值取17的模即可分配。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200222125649.png"  style="zoom:55%;display: block; margin: 0px auto; vertical-align: middle;"></p></li></ul><h2 id="4-4-为什么哈希表的桶的个数是质数"><a href="#4-4-为什么哈希表的桶的个数是质数" class="headerlink" title="4.4 为什么哈希表的桶的个数是质数"></a>4.4 为什么哈希表的桶的个数是质数</h2><p>取合数会导致某些位失效，比如如果桶的个数是<code>2^3=8</code>，那么第4位就会失效：</p><pre><code>H( 11100 ) = H( 28 ) = 4H( 10100 ) = H( 20 ）= 4</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇针对的是问答题而不是编程题，所以大部分都是在文字叙述，外加少部分的编程。
    
    </summary>
    
    
      <category term="算法" scheme="jiangren.work/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="jiangren.work/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="面试经验" scheme="jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据库面试题目汇总</title>
    <link href="jiangren.work/2020/02/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    <id>jiangren.work/2020/02/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</id>
    <published>2020-02-20T06:44:06.000Z</published>
    <updated>2020-03-26T13:11:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于关系型数据库，尤其是Mysql的面试内容的汇总，最好和Redis那一部分结合来看。<a id="more"></a></p><h1 id="1-数据库基本概念"><a href="#1-数据库基本概念" class="headerlink" title="1. 数据库基本概念"></a>1. 数据库基本概念</h1><h2 id="1-1-三个范式"><a href="#1-1-三个范式" class="headerlink" title="1.1 三个范式"></a>1.1 三个范式</h2><p>范式，即Normal Form，指的是我们在构建数据库所需要遵守的规则和指导方针。</p><ul><li>首先要明确的是：<strong>满足第三范式，那么就一定满足第二范式、满足第二范式就一定满足第一范式</strong></li><li>第一范式：<strong>字段是最小的的单元不可再分</strong>。即<strong>列的原子性</strong>。<ul><li>学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的</li></ul></li><li>第二范式：满足第一范式,<strong>表中的字段必须完全依赖于全部主键而非部分主键。</strong><ul><li>比如一个订单表中有主键（订单id，商品id）和单位价格、折扣、数量、产品名称、产品保质期。保质期只依赖于商品id，不符合第二范式。</li></ul></li><li>第三范式：满足第二范式，<strong>非主键外的所有字段必须互不依赖</strong><ul><li>换句话说：<strong>数据只能存在一个表中</strong>，消除互相依赖</li><li>比如大学学院表中包含了学院id，院领导，院简介，如果在学生信息表中也包括了院领导，院简介这些字段，这就重复了。</li></ul></li></ul><h2 id="1-2-什么是存储过程？"><a href="#1-2-什么是存储过程？" class="headerlink" title="1.2 什么是存储过程？"></a>1.2 什么是存储过程？</h2><p>存储过程就是一段SQL语句的<strong>预编译集合</strong>，<strong>封装了一组sql语句，实现某些操作，类似于函数的功能</strong>。</p><p>好处：</p><ul><li>将代码封装起来，隐藏复杂的商业逻辑</li><li>预编译，执行效率高</li><li>可以接受参数，可以回传值</li></ul><p>坏处：</p><ul><li>针对特定的某种数据库，不兼容，难维护</li></ul><h2 id="1-3-什么是视图"><a href="#1-3-什么是视图" class="headerlink" title="1.3 什么是视图"></a>1.3 什么是视图</h2><p>视图是从一个或多个表导出的<strong>虚拟的表</strong>，具<strong>有普通表的结构，但是不实现数据存储。</strong></p><p>作用：</p><ul><li><strong>直观</strong></li><li><strong>安全</strong>性，暴露出视图，然后把不想让用户看到和修改的内容屏蔽掉</li><li><strong>独立</strong>性，屏蔽了真实表的结构带来的影响。</li></ul><p>缺点：</p><ul><li>性能差：视图是由一个复杂的多表查询所定义</li><li>修改限制： 当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改</li></ul><h2 id="1-4-超键、候选键、主键、外键是什么？"><a href="#1-4-超键、候选键、主键、外键是什么？" class="headerlink" title="1.4 超键、候选键、主键、外键是什么？"></a>1.4 超键、候选键、主键、外键是什么？</h2><p>假设有如下两个表：</p><ul><li><p>学生（学号，姓名，性别，身份证号，班级，教师编号）</p></li><li><p>教师（教师编号，姓名，工资）</p></li></ul><p><strong>超键</strong>：能唯一标识某条数据属性的<strong>集合</strong>。比如(学号)、(学号+姓名)、(身份证号+性别)等等。</p><p><strong>候选键</strong>：最小的超键。比如（学号）、（身份证号）。</p><p><strong>主键</strong>：人为规定的一个候选键，作为数据的身份象征。</p><p><strong>外键</strong>：用于描述两个表的关系，比如学生表中包含了班主任信息(教师编号)，这个就是外键。</p><h2 id="1-5-什么是事务的隔离级别？"><a href="#1-5-什么是事务的隔离级别？" class="headerlink" title="1.5 什么是事务的隔离级别？"></a>1.5 什么是事务的隔离级别？</h2><p><strong>脏读</strong>：一个事务A正在访问并修改数据，他设置了数据但还没有提交，另一个事务B读到了<strong>未提交的数据</strong>。但是A可能发现出错了<strong>回滚</strong>了数据，导致B得到的数据是错的。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200220105505.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p><strong>不可重复读</strong>：一个事务正在访问并修改数据，另一个事务多次读取，前后读取的数据并不相同，导致这种读取结果不可复现。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200220105528.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p><strong>幻读</strong>：事务A正在访问并修改数据，另一个事务B也要读取修改，事务B读取时检查数据不存在符合插入条件，但在B插入之前，A插入了数据，B插入时突然发现有问题了，就像见了鬼一样。幻读侧重<strong>读-写</strong>，不可重复读侧重<strong>读-读</strong></p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200220105559.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>事务隔离级别有四个：</p><div class="table-container"><table><thead><tr><th>脏读</th><th>不可重复读</th><th>幻读</th><th></th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable read</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table></div><ul><li>Read committed要求必须读取已提交的数据。</li><li>Repeatable read要求读取过程中，其他事务不能修改(图中第一次读取第二次读取中间都算读取过程)，然而读取-写入却不算在内，因此依然有幻读风险。</li><li>Serializable要求按串行读取，效率低。</li></ul><h2 id="1-6-MySQL存储引擎有哪些？"><a href="#1-6-MySQL存储引擎有哪些？" class="headerlink" title="1.6 MySQL存储引擎有哪些？"></a>1.6 MySQL存储引擎有哪些？</h2><p>最常见的是InnoDB和MyISAM</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Innodb</th><th style="text-align:center">myisam</th></tr></thead><tbody><tr><td style="text-align:center">事务</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">外键</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td></tr><tr><td style="text-align:center">全文本搜索</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">频繁修改</td><td style="text-align:center">查询和插入为主</td></tr></tbody></table></div><p>另外还有MEMORY，存储在内存中，速度快，安全性不高。</p><h2 id="1-7-关系型数据库和非关系型数据库的区别"><a href="#1-7-关系型数据库和非关系型数据库的区别" class="headerlink" title="1.7 关系型数据库和非关系型数据库的区别"></a>1.7 关系型数据库和非关系型数据库的区别</h2><p>关系型数据库</p><ul><li>优点：易于理解，支持SQL可用于复杂查询</li><li>缺点：读写性能差，高并发能力差</li></ul><p>非关系型数据库NoSQL</p><ul><li>优点：键值对存储，读写性能高；键值对读写，数据没有耦合性，易拓展</li><li>缺点：缺乏sql支持，不适用于复杂查询</li></ul><h1 id="2-SQL语句"><a href="#2-SQL语句" class="headerlink" title="2. SQL语句"></a>2. SQL语句</h1><h2 id="2-1-drop、truncate、delete区别"><a href="#2-1-drop、truncate、delete区别" class="headerlink" title="2.1 drop、truncate、delete区别"></a>2.1 drop、truncate、delete区别</h2><ul><li>不再需要一张表的时候，用drop</li><li>想删除部分数据行时候，用delete，并且带上where子句</li><li><strong>保留表而删除所有数据</strong>的时候用truncate</li></ul><h2 id="2-2-varchar-和-char区别"><a href="#2-2-varchar-和-char区别" class="headerlink" title="2.2 varchar 和 char区别"></a>2.2 varchar 和 char区别</h2><p>前者可变长度，后者固定长度</p><h2 id="2-3-各种join"><a href="#2-3-各种join" class="headerlink" title="2.3 各种join"></a>2.3 各种join</h2><p><strong>left join</strong> 左关联，主表在左边，右边为从表。如果左侧的主表中没有关联字段，会用null 填满。<strong>right join</strong>相反</p><p><strong>inner join</strong> 内关联只会显示主表和从表相关联的字段，不会出现null</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200220142608.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p><strong>cross join</strong>则是将两个表的字段两两组合，比如A表有4个，B表有3个，则crossjoin出来就有12个</p><h2 id="2-4-SQL约束有哪些"><a href="#2-4-SQL约束有哪些" class="headerlink" title="2.4 SQL约束有哪些"></a>2.4 SQL约束有哪些</h2><ul><li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: 设置外键约束，假设表1是主表，表2是附表，学号作为外键。那么，如果表2要插入一条数据，表1必须有个学号；同理，如果表1要删除1条数据，表2必须先删除。</li><li>CHECK: 用于控制字段的值范围。</li></ul><h1 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h1><h2 id="3-1-什么是索引，什么时候使用索引？"><a href="#3-1-什么是索引，什么时候使用索引？" class="headerlink" title="3.1 什么是索引，什么时候使用索引？"></a>3.1 什么是索引，什么时候使用索引？</h2><p>索引本身就是一种<strong>数据结构</strong>，用于加快查找速度，InnoDB和MyISAM都是用的B+树。</p><ul><li>经常需要查询，经常使用SELECT和WHERE操作时，可以使用索引</li><li>经常做表连接</li><li>经常出现在order by、group by、distinct 后面的字段中，可以建立索引</li></ul><p>索引的缺点在于：<strong>增删改浪费时间，构建索引需要占据空间</strong></p><h2 id="3-2-构建索引常用的数据结构有哪些"><a href="#3-2-构建索引常用的数据结构有哪些" class="headerlink" title="3.2 构建索引常用的数据结构有哪些"></a>3.2 构建索引常用的数据结构有哪些</h2><div class="table-container"><table><thead><tr><th>结构</th><th>区别</th></tr></thead><tbody><tr><td>Hash</td><td>只存储对应的哈希值，查找速度快，不能排序,不能进行范围查询</td></tr><tr><td>B+</td><td>数据有序,范围查询</td></tr></tbody></table></div><h2 id="3-3-聚集索引和非聚集索引区别？"><a href="#3-3-聚集索引和非聚集索引区别？" class="headerlink" title="3.3 聚集索引和非聚集索引区别？"></a>3.3 聚集索引和非聚集索引区别？</h2><div class="table-container"><table><thead><tr><th>索引</th><th>区别</th></tr></thead><tbody><tr><td>聚集索引</td><td>数据按索引顺序存储，数据行的物理顺序与列值的<strong>顺序相同</strong></td></tr><tr><td>非聚集索引</td><td>存储指向真正数据行的指针</td></tr></tbody></table></div><p>聚集索引如下</p><div class="table-container"><table><thead><tr><th style="text-align:left">地址</th><th style="text-align:left">id</th><th style="text-align:left">username</th><th style="text-align:left">score</th></tr></thead><tbody><tr><td style="text-align:left">0x01</td><td style="text-align:left">1</td><td style="text-align:left">小明</td><td style="text-align:left">90</td></tr><tr><td style="text-align:left">0x02</td><td style="text-align:left">2</td><td style="text-align:left">小红</td><td style="text-align:left">80</td></tr><tr><td style="text-align:left">0x03</td><td style="text-align:left">3</td><td style="text-align:left">小华</td><td style="text-align:left">92</td></tr></tbody></table></div><p>非聚集索引就不是按照地址存储，每一个都有一个指针，指向不同地方。</p><h2 id="3-4-为什么底层用B-树而不是红黑树？"><a href="#3-4-为什么底层用B-树而不是红黑树？" class="headerlink" title="3.4 为什么底层用B+树而不是红黑树？"></a>3.4 为什么底层用B+树而不是红黑树？</h2><div class="table-container"><table><thead><tr><th style="text-align:center">树</th><th style="text-align:center">区别</th></tr></thead><tbody><tr><td style="text-align:center">红黑树</td><td style="text-align:center">增加，删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间</td></tr><tr><td style="text-align:center">B树也就是B-树</td><td style="text-align:center">B树，查询性能不稳定，查询结果高度不致，每个结点保存指向真实数据的指针，相比B+树每一层每屋存储的元素更多，显得更高一点。</td></tr><tr><td style="text-align:center">B+树</td><td style="text-align:center">B+树相比较于另外两种树,显得更矮更宽，查询层次更浅</td></tr></tbody></table></div><h2 id="3-5-索引失效的条件有哪些？"><a href="#3-5-索引失效的条件有哪些？" class="headerlink" title="3.5 索引失效的条件有哪些？"></a>3.5 索引失效的条件有哪些？</h2><ul><li><p>在where子句中进行null值判断</p><pre><code class="lang-sql">SELECT id FROM table WHERE num is null在建立数据库的时候因尽量为字段设置默认值,如int类型可以使用0,varchar类型使用 &#39;&#39;</code></pre></li><li><p>避免在where子句中使用<code>or</code>来连接条件,<strong>因为如果俩个字段中有一个没有索引的话,引擎会放弃索引而产生全表扫描</strong></p></li><li><p>避免在where子句中使用<code>like</code>模糊查询</p></li></ul><h1 id="4-提高性能的方法"><a href="#4-提高性能的方法" class="headerlink" title="4. 提高性能的方法"></a>4. 提高性能的方法</h1><h2 id="4-1-SQL语句优化的步骤是什么？"><a href="#4-1-SQL语句优化的步骤是什么？" class="headerlink" title="4.1 SQL语句优化的步骤是什么？"></a>4.1 SQL语句优化的步骤是什么？</h2><p><strong>（1）发现有问题的SQL</strong></p><p>读取MYSQL的慢查询日志，记录在MySQL中响应时间超过阈值的语句，可以查询出执行的次数多占用的时间长的SQL。</p><p><strong>（2）通过EXPLAIN关键字分析SQL</strong></p><p>使用 EXPLAIN 关键字可以知道MySQL是如何处理你的SQL语句的</p><p><strong>（3）进行优化</strong></p><h2 id="4-2-优化SQL语句的方法有哪些？"><a href="#4-2-优化SQL语句的方法有哪些？" class="headerlink" title="4.2 优化SQL语句的方法有哪些？"></a>4.2 优化SQL语句的方法有哪些？</h2><p><strong>（1）选择最有效率的表名顺序</strong></p><p>数据库的解析器规则：<strong>FROM子句中写在最后的表将被最先处理</strong>，因此：</p><ul><li>如果是多个表连接查询，将<strong>引用最多</strong>的表放在最后，优先处理可以加快后续的速度。</li></ul><p><strong>（2）where的连接顺序</strong></p><p>自<strong>右而左的顺序解析WHERE子句</strong></p><ul><li>可以过滤掉最大数量记录的条件写在WHERE右边</li></ul><p><strong>（3）多使用内部函数提高SQL效率</strong></p><p>比如，使用mysql的concat()函数会比使用||来进行拼接快，因为concat()函数已经被mysql优化过了。</p><p><strong>（4）建立索引</strong></p><p>建立条件，参看3.1</p><h2 id="4-3-数据库连接池的作用"><a href="#4-3-数据库连接池的作用" class="headerlink" title="4.3 数据库连接池的作用"></a>4.3 数据库连接池的作用</h2><p>维护一定数量的连接，减少重新创建连接的时间</p><h2 id="4-4-什么是MVCC"><a href="#4-4-什么是MVCC" class="headerlink" title="4.4 什么是MVCC"></a>4.4 什么是MVCC</h2><p>MVCC，Multi-Version Concurrency Control，多版本并发控制。</p><p>使用MVCC时，不会直接用新数据覆盖旧数据，而是<strong>将旧数据标记为过时并在别处增加新版本的数据。</strong>允许读者读取在他读之前已经存在的数据，即使这些在读的过程中半路被别人修改、删除了，也对先前正在读的用户没有影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于关系型数据库，尤其是Mysql的面试内容的汇总，最好和Redis那一部分结合来看。
    
    </summary>
    
    
      <category term="数据库" scheme="jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="面试经验" scheme="jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Linux面试题题目汇总</title>
    <link href="jiangren.work/2020/02/19/Linux%E9%9D%A2%E8%AF%95%E9%A2%98%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    <id>jiangren.work/2020/02/19/Linux%E9%9D%A2%E8%AF%95%E9%A2%98%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</id>
    <published>2020-02-19T05:50:18.000Z</published>
    <updated>2020-02-28T16:47:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统中和Linux强相关的部分，被放到这一篇来讲。<a id="more"></a></p><h1 id="1-Linux总体原理"><a href="#1-Linux总体原理" class="headerlink" title="1. Linux总体原理"></a>1. Linux总体原理</h1><h2 id="1-1-如何理解Linux一切皆文件？"><a href="#1-1-如何理解Linux一切皆文件？" class="headerlink" title="1.1 如何理解Linux一切皆文件？"></a>1.1 如何理解Linux一切皆文件？</h2><p>Linux访问设备的方式是<strong>通过文件访问</strong>。在windows中属于文件的东西，在linux中也是文件，在windows中不是文件的东西，比如进程磁盘socket等也被抽象为文件。</p><p>文件这个基本概念包含了两重意思：</p><ul><li><strong>在 Linux 中，一切都是字节流</strong>。意思是：文件只不过是可以读取和写入的普通字节的集合。</li><li><strong>在 Linux 中，文件系统是统一的命名空间</strong>。每个文件都<strong>通过相同的API暴露出来</strong>，用户可以通过使用同一组命令操作这些设备</li></ul><h2 id="1-2-Linux内核中包含了哪些子系统"><a href="#1-2-Linux内核中包含了哪些子系统" class="headerlink" title="1.2 Linux内核中包含了哪些子系统"></a>1.2 Linux内核中包含了哪些子系统</h2><p>进程管理系统、内存管理系统、文件系统、网络系统、进程间通信系统</p><ul><li>进程管理：操作每个子系统的挂起或恢复</li><li>内存管理：负责管理内存资源，提供虚拟内存机制</li><li>文件管理：隐藏了硬件的具体细节，为所有的外部设备提供了统一的操作接口(open、read、write、close)</li><li>网络：负责管理系统的网络设备</li><li>进程间通信系统:包含多种进程间通信的方法，包括：信号量、共享内存、管道等。协助多个进程间的共享资源访问，同步，消息传递等。</li></ul><h2 id="1-3-Linux磁盘是如何划分的"><a href="#1-3-Linux磁盘是如何划分的" class="headerlink" title="1.3 Linux磁盘是如何划分的"></a>1.3 Linux磁盘是如何划分的</h2><p>分为引导块，超级快，i节点表，文件存储区，进程交换区</p><ul><li>引导块：存放引导程序，用于启动操作系统</li><li>超级块：存放的是文件系统本身的结构信息，比如每个区域的大小，未使用的磁盘信息等</li><li>文件存储区：存储文件内容</li><li>进程交换区： 当内存中的进程需要扩大占用的内存空间， 而当前内存空间不足时， 则把某些不常用的进程暂时替换到对换区中，在适用的时候又把他们换进内存，解决内存不足和进程之间对内存的竞争问题。</li></ul><h2 id="1-4-Linux内存是如何划分的？"><a href="#1-4-Linux内存是如何划分的？" class="headerlink" title="1.4 Linux内存是如何划分的？"></a>1.4 Linux内存是如何划分的？</h2><p>分为：代码区、数据区、BSS区、堆区、栈区</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200219142327.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>BSS区用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。</p><h1 id="2-Linux技术细节"><a href="#2-Linux技术细节" class="headerlink" title="2. Linux技术细节"></a>2. Linux技术细节</h1><h2 id="2-1-什么是i节点？"><a href="#2-1-什么是i节点？" class="headerlink" title="2.1 什么是i节点？"></a>2.1 什么是i节点？</h2><p>I的意思是index，i节点也叫<strong>索引节点</strong>。linux中，文件查找不是通过文件名称来查找的，而是通过i节点来实现的。每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><p>Linux查询文件位置的流程是：</p><ol><li>读出这个文件的inode编号</li><li>根据inode编号找到inode信息</li><li>根据信息，读取文件数据所在的block</li></ol><h2 id="2-2-Linux中buffer和cache有何区别？"><a href="#2-2-Linux中buffer和cache有何区别？" class="headerlink" title="2.2 Linux中buffer和cache有何区别？"></a>2.2 Linux中buffer和cache有何区别？</h2><p><strong>cache</strong>：缓存，为了弥补<strong>高速设备和低速设备交换数据的速度不匹配</strong>，引入的一个中间层，<strong>起到加快访问速度的作用</strong>。</p><p><strong>buffer</strong>：缓冲区，目的进行流量整形，把突发的<strong>大数量小规模的 I/O</strong> 整理成平稳的<strong>小数量大规模</strong>的 I/O。比如读写时，不能来一点数据就立马读，可以等积攒到一定程度以后，一起读。</p><h2 id="2-3-Linux开机过程是什么？"><a href="#2-3-Linux开机过程是什么？" class="headerlink" title="2.3 Linux开机过程是什么？"></a>2.3 Linux开机过程是什么？</h2><p>操作系统的启动可以分为：<strong>引导</strong>和<strong>启动</strong></p><ol><li>BIOS上电自检，确认硬件功能正常。（BIOS:basic IO system）</li><li>读取引导文件，加载操作系统内核</li><li>运行第一个进程init</li><li>进入相应的运行级别（关机，单用户模式，多用户模式，图形模式，重启等等）</li><li>进入终端界面，输入账号密码</li></ol><h2 id="2-4-谈谈对fork的理解"><a href="#2-4-谈谈对fork的理解" class="headerlink" title="2.4 谈谈对fork的理解"></a>2.4 谈谈对fork的理解</h2><p>fork函数通过系统调用<strong>创建一个（除了PID以外）与原来进程几乎完全相同的进程</strong>。拷贝的内容包括栈区、堆区、BSS区、数据区、代码区。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200218150340.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>Linux下<strong>init进程是所有进程的爹</strong> 所有进程都是通过init进程fork出来的。</p><p>exec函数的作用就是：<strong>装载一个新的程序</strong>（可执行映像）覆盖<strong>当前进程</strong>内存，<strong>从而执行不同的任务</strong>。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200218151744.png"  style="zoom:55%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>COW是写时复制的意思，由于拷贝完之后，父进程和子进程之间的数据段和堆栈是<strong>相互独立的</strong>，而如果我们想用exec来装载新的程序，复制的这些数据都是没用的。</p><p>因此COW技术允许我们，fork创建出的子进程，<strong>与父进程共享内存空间</strong>。也就是说，如果子进程<strong>不对内存空间进行写入操作的话，内存空间中的数据并不会复制给子进程</strong>。（引用而不是复制）。当父子进程<strong>有内存写入操作时</strong>才进行复制。</p><h2 id="2-5-Malloc底层实现机制是什么？"><a href="#2-5-Malloc底层实现机制是什么？" class="headerlink" title="2.5 Malloc底层实现机制是什么？"></a>2.5 Malloc底层实现机制是什么？</h2><p>Linux将内存划分为5大区，Linux维护一个<strong>break指针</strong>，这个指针指向堆空间的某个地址。break之前的都是已经映射好的地址，之后的是未映射的，如果访问就会出错：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200219124556.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>当我们调用<code>malloc</code>函数时，</p><ol><li>它沿着连接表寻找一个大到足以满足用户请求所需要的内存块，然后<strong>将内存块一分为二</strong>（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）</li><li>一部分传给用户，一部分放回到空闲连接表上</li><li>用户使用free以后，释放的内存返回到空闲连接表上，空闲连接表会被切成小块</li><li>当用户malloc的内存过大，会阻塞，整合空闲连接表形成大块。</li></ol><h2 id="2-6-什么是自旋锁，如何实现？"><a href="#2-6-什么是自旋锁，如何实现？" class="headerlink" title="2.6 什么是自旋锁，如何实现？"></a>2.6 什么是自旋锁，如何实现？</h2><p>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p><p>互斥锁等待时会进入休眠状态，而自旋锁因为循环等待的缘故会一直活跃。</p><p>好处：减少线程切换的消耗；坏处：忙等</p><p>go实现自旋锁：</p><pre><code class="lang-go">type spinLock uint32func (sl *spinLock) Lock() {    for !atomic.CompareAndSwapUint32((*uint32)(sl), 0, 1) {        runtime.Gosched()    }}func (sl *spinLock) Unlock() {    atomic.StoreUint32((*uint32)(sl), 0)}</code></pre><p>抢到锁的gorutine会将sl从0变为1，成功跳过<code>runtime.Gosched()</code>，而没有抢到的则会进入循环，形成自旋。</p><p>CAS算法<code>CompareAndSwapUint32(V,A,B)</code>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作。for就会卡在循环里，直到<code>runtime.Gosched()</code>让出CPU时间轮转片。</p><h1 id="3-Epoll"><a href="#3-Epoll" class="headerlink" title="3. Epoll"></a>3. Epoll</h1><h2 id="3-1-Linux中有哪些事件处理的方式"><a href="#3-1-Linux中有哪些事件处理的方式" class="headerlink" title="3.1 Linux中有哪些事件处理的方式"></a>3.1 Linux中有哪些事件处理的方式</h2><p><strong>阻塞IO</strong>：一个线程只能处理一个流的I/O事件。除非采用多线程，否则效率很低。</p><p><strong>非阻塞忙轮询IO</strong>：即Non-Blocking Busy Polling，等待某个事件的时候，放弃其他事情，休息，专门等待，称之为<strong>阻塞</strong>。<strong>等待过程中不休息，不断询问事件是否完成，称之为非阻塞忙轮询</strong>。可以同时处理多个流，但需要从头到尾轮询，浪费资源。</p><p><strong>Select</strong>：相当于一位代理，帮我们观察流。但这位代理只会告诉我们此刻是否有IO事件发生，我们却不知道是哪些流，只能无差别轮询。</p><p><strong>Epoll</strong>：即event poll，不同于无差别轮询，epoll会把哪个流发生什么样的事情通知我们。</p><h2 id="3-2-Epoll底层实现是什么？"><a href="#3-2-Epoll底层实现是什么？" class="headerlink" title="3.2 Epoll底层实现是什么？"></a>3.2 Epoll底层实现是什么？</h2><ul><li><strong>红黑树的根节点</strong>，存储epoll需要监控的事件</li><li><strong>双链表的头部</strong>，存储<code>epoll_wait</code>返回给用户的满足条件的事件</li></ul><p>当某一进程调用<code>epoll_create</code>方法时，Linux内核会创建一个<code>eventpoll</code>结构体：</p><pre><code class="lang-C">struct eventpoll{    ....    /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/    struct rb_root  rbr;    /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/    struct list_head rdlist;    ....};</code></pre><p>每次调用<code>epoll_create</code>方法都会创建一个epoll对象，每一个对象都有一个独立的<code>eventpoll</code>结构体，用于存放通过<code>epoll_ctl</code>方法向epoll对象中添加进来的事件。在epoll中，<strong>对于每一个事件，都会建立一个<code>epitem</code>结构体</strong>，如下所示：</p><pre><code class="lang-C">struct epitem{    struct rb_node  rbn;//红黑树节点    struct list_head    rdllink;//双向链表节点    struct epoll_filefd  ffd;  //事件句柄信息    struct eventpoll *ep;    //指向其所属的eventpoll对象    struct epoll_event event; //期待发生的事件类型}</code></pre><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200219102946.png"  style="zoom:65%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="3-3-Epoll的优势是什么？"><a href="#3-3-Epoll的优势是什么？" class="headerlink" title="3.3 Epoll的优势是什么？"></a>3.3 Epoll的优势是什么？</h2><p>换句话说select和poll的缺点是什么？</p><ol><li>select单个进程能够监视的文件描述为<strong>最大为1024</strong>，轮询越多，性能越差</li><li>Select需要<strong>复制大量句柄数据结构</strong>，开销巨大。</li><li>Select返回整个句柄数组，<strong>程序需要遍历数组</strong>才能知道哪些句柄发生了什么事件。</li><li>触发方式为<strong>水平触发</strong>，如果程序没有对一个就绪的文件进行IO操作，之后每次Select调用还是会将文件描述符通知给进程。</li></ol><p>Poll<strong>使用链表保存文件，没有1的限制</strong>，但其他三个缺点依然比较明显。</p><h2 id="3-4-水平触发和边缘触发的区别是什么？"><a href="#3-4-水平触发和边缘触发的区别是什么？" class="headerlink" title="3.4 水平触发和边缘触发的区别是什么？"></a>3.4 水平触发和边缘触发的区别是什么？</h2><ul><li><strong>水平触发LT</strong>：默认方式，<strong>支持阻塞和非阻塞</strong>。内核告诉你某个fd就位了，如果你不对这个fd进行IO操作，<strong>内核会一直通知你</strong>。所以这种模式<strong>安全性较高</strong>。</li><li><strong>边缘触发ET</strong>：<strong>只支持非阻塞</strong>，<strong>内核只会通知你一次</strong>，如果你不操作他也不管你了，<strong>速度快</strong></li></ul><h2 id="3-5-谈谈什么是惊群，如何避免？"><a href="#3-5-谈谈什么是惊群，如何避免？" class="headerlink" title="3.5 谈谈什么是惊群，如何避免？"></a>3.5 谈谈什么是惊群，如何避免？</h2><p>多线程在<strong>同时阻塞等待同一个事件</strong>，当事件发生时所有线程同时唤醒，然而<strong>只有一个线程能抢到控制权</strong>，其他的醒了又睡。问题主要有两方面：</p><ul><li>linux内核对线程频繁无效调度，影响性能</li><li>为了确保只有一个线程拿到资源需要加锁，影响性能</li></ul><p>解决方案：</p><ul><li><p>accept：在Linux2.6后，accept函数<strong>加入了一个标志位，只会唤醒等待队列上的第一个进程。</strong></p></li><li><p>epoll：如果<strong>Epoll_create在fork之前创建</strong>依然有惊群现象，因为所有子进程共享epoll_create()创建的epfd，等待同一个文件描述符的所有进程/线程，都将被唤醒。在<a href="https://link.jianshu.com/?t=https://github.com/torvalds/linux/commit/df0108c5da561c66c333bb46bfe3c1fc65905898" target="_blank" rel="noopener">epoll: add EPOLLEXCLUSIVE flag 21 Jan 2016</a>补丁中以accept相同的方式解决了。</p></li></ul><h1 id="4-Linux命令"><a href="#4-Linux命令" class="headerlink" title="4. Linux命令"></a>4. Linux命令</h1><h2 id="1-如何查看Linux系统有几颗物理CPU和每颗CPU的核数？"><a href="#1-如何查看Linux系统有几颗物理CPU和每颗CPU的核数？" class="headerlink" title="1. 如何查看Linux系统有几颗物理CPU和每颗CPU的核数？"></a>1. 如何查看Linux系统有几颗物理CPU和每颗CPU的核数？</h2><pre><code class="lang-bash">cat /proc/cpuinfo|grep -c &#39;physical id&#39;cat /proc/cpuinfo|grep  &#39;cpu cores&#39;|uniq</code></pre><p>cat 命令用于连接文件并打印到标准输出设备上。 <code>|grep</code>是正则符号， -c表示统计数量， 正则匹配<code>physical id</code>。</p><p>当输入<code>cat /proc/cpuinfo</code>时会显示每个CPU的信息</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216150425.png"  style="zoom:55%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>通过统计<code>physical id</code>出现的次数就能知道有多少颗物理CPU</p><h2 id="2-如何查看系统负载？"><a href="#2-如何查看系统负载？" class="headerlink" title="2. 如何查看系统负载？"></a>2. 如何查看系统负载？</h2><p>有两个命令</p><pre><code class="lang-bash">wuptime</code></pre><p>结果如下，其中load average即系统负载，三个数值分别表示一分钟、五分钟、十五分钟内系统的平均负载，即平均任务数。</p><pre><code class="lang-bash">➜  jr w 15:08:58 up 31 min,  1 user,  load average: 0.00, 0.00, 0.00USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHATjr       tty7     :0               14:37   31:28  12.04s  0.25s /sbin/upstart --user</code></pre><h2 id="3-vmstat命令各项含义"><a href="#3-vmstat命令各项含义" class="headerlink" title="3. vmstat命令各项含义"></a>3. <strong>vmstat</strong>命令各项含义</h2><pre><code class="lang-bash">➜  jr vmstat procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st 0  0      0 3088016 136492 976224    0    0   109    41   53   89  0  1 99  0  0</code></pre><ul><li>r即running，表示正在跑的任务数</li><li>b即blocked，表示被阻塞的任务数</li><li>si表示有多少数据从交换分区读入内存</li><li>so表示有多少数据从内存写入交换分区</li><li>bi表示有多少数据从磁盘读入内存</li><li>bo表示有多少数据从内存写入磁盘</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统中和Linux强相关的部分，被放到这一篇来讲。
    
    </summary>
    
    
      <category term="Linux" scheme="jiangren.work/categories/Linux/"/>
    
    
      <category term="Linux" scheme="jiangren.work/tags/Linux/"/>
    
      <category term="面试经验" scheme="jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络面试题目汇总</title>
    <link href="jiangren.work/2020/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    <id>jiangren.work/2020/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</id>
    <published>2020-02-16T05:55:18.000Z</published>
    <updated>2020-03-26T15:28:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络相关的所以题目汇总，应该是网上最全的汇总了。<a id="more"></a></p><h1 id="1-网络结构"><a href="#1-网络结构" class="headerlink" title="1. 网络结构"></a>1. 网络结构</h1><h2 id="1-1-计算机网络有哪些结构？"><a href="#1-1-计算机网络有哪些结构？" class="headerlink" title="1.1 计算机网络有哪些结构？"></a>1.1 计算机网络有哪些结构？</h2><p>计算机网络一共有3种模型。</p><ol><li>OSI七层结构</li><li>TCP/IP结构</li><li>五层协议结构</li></ol><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216134035.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>OSI是Open Systems Interconnect，也就是开放的互联系统，将复杂的互联网系统划分为不同块，方便处理。实际应用中，并没有采用这个理论模型，而是使用TCP/IP协议的四层模型。而5层模型是一个理论上的网络通信模型，方便教学的时候理解，实际上并不存在。</p><h2 id="1-2-计算机网络中各层分别有什么作用？"><a href="#1-2-计算机网络中各层分别有什么作用？" class="headerlink" title="1.2 计算机网络中各层分别有什么作用？"></a>1.2 计算机网络中各层分别有什么作用？</h2><p><strong>（1）应用层</strong></p><p>应用层的任务是通过<strong>应用进程间的交互</strong>来完成特定网络应用，常见的协议有<strong>域名系统DNS</strong>，万维网应用的<strong>HTTP协议</strong>，支持<strong>电子邮件的SMTP协议</strong>。把应用层交互的数据单元称为<strong>报文</strong>。</p><p><strong>（2）运输层</strong></p><p>为两台主机进程之间的通信提供<strong>通用的数据传输服务。</strong>主要包含两种协议：</p><ul><li><p><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）。提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</p></li><li><p><strong>用户数据报协议 UDP</strong>（User Datagram Protocol）。提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</p></li></ul><p><strong>（3）网络层</strong></p><p>使用IP协议。网络层有两个任务：</p><ul><li>把运输层产生的报文段或用户数据报<strong>封装成分组和包进行传送</strong>。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。注意：不要把运输层的用户数据报UDP和网络层的IP数据报弄混。</li><li>选择合适的路由，找到目的主机</li></ul><p><strong>（4）数据链路层</strong></p><p>两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装程帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p><strong>（5）物理层</strong></p><p>物理层的任务就是<strong>透明地传输比特流</strong>，换句话说实际电路传送后比特流没有发生变化。</p><h1 id="2-TCP-IP协议"><a href="#2-TCP-IP协议" class="headerlink" title="2. TCP/IP协议"></a>2. TCP/IP协议</h1><h2 id="2-1-描述一下TCP-IP协议的结构"><a href="#2-1-描述一下TCP-IP协议的结构" class="headerlink" title="2.1 描述一下TCP/IP协议的结构"></a>2.1 描述一下TCP/IP协议的结构</h2><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216134831.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="2-3-TCP和UDP的区别？"><a href="#2-3-TCP和UDP的区别？" class="headerlink" title="2.3 TCP和UDP的区别？"></a>2.3 TCP和UDP的区别？</h2><p>简单来说：</p><ul><li>TCP：面向连接，面向字节流，可靠，传输慢，<strong>有流量控制阻塞控制</strong>。</li><li>UDP：广播形式不需要连接，面向报文，不可靠，传输快，无流量控制阻塞控制。</li></ul><p>解释一下报文和字节流的区别：</p><ul><li>字节流：<strong>发送次数和接收次数可以不相同</strong>，比如向水池倒了20盆水，可以开水龙头一次性全放出。</li><li>报文：<strong>发送次数和接收次数必须相同</strong>。</li></ul><p>两者的应用场景：</p><ul><li>TCP：邮件，远程登录，文件传输等对准确性要求较高的地方</li><li>UDP：及时通信，比如QQ，网络电话等。</li></ul><h2 id="2-4-三次握手和四次挥手"><a href="#2-4-三次握手和四次挥手" class="headerlink" title="2.4 三次握手和四次挥手"></a>2.4 三次握手和四次挥手</h2><p><a href="https://jiangren.work/2019/08/01/Socket网络编程原理/">https://jiangren.work/2019/08/01/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86/</a></p><h2 id="2-5-TCP协议如何保证可靠行"><a href="#2-5-TCP协议如何保证可靠行" class="headerlink" title="2.5 TCP协议如何保证可靠行"></a>2.5 TCP协议如何保证可靠行</h2><p><strong>（1）</strong>采用三次握手四次挥手保证建立的<strong>传输信道是可靠的</strong>。</p><p><strong>（2）</strong>采用了<strong>ARQ自动重传请求</strong>协议<strong>数据传输的可靠性</strong>。</p><p><strong>（3）</strong>采用<strong>滑动窗口</strong>协议进行流量控制</p><p><strong>（4）</strong>使用<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>和<strong>快恢复</strong>来进行<strong>拥塞控制</strong></p><h2 id="2-6-TCP协议如何进行流量控制？"><a href="#2-6-TCP协议如何进行流量控制？" class="headerlink" title="2.6 TCP协议如何进行流量控制？"></a>2.6 TCP协议如何进行流量控制？</h2><p><strong>控制流量的前提当然需要保证正确率，因此首先要引入ARQ协议。</strong></p><p>无差错时，A向B发送<strong>分组</strong>M1，B收到M1后向A回复，A收到回复后，发送下一个M2…..</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214122158.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>如果出现差错，B没有收到信息，自然不会回复，A等待超时后，自动重传一个信息M，这就是所谓的ARQ。</p><p><strong>停止等待ARQ协议信道利用率太低</strong>，所以需要使用<strong>连续ARQ协议</strong>来进行改善。这个协议会连续发送一组数据包，然后再等待这些数据包的ACK。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214123227.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>连续ARQ协议通常是结合滑动窗口协议来使用的，发送方需要维持一个发送窗口，如下图所示：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214123327.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认，这样就提高了信道利用率。发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p><p>接收方一般都是采用累积确认的方式。收到几个分组后，对按序到达的最后一个分组发送确认。</p><p>下载时我们的速度一般都是由慢变快，原因就是拥塞控制。</p><h2 id="2-7-TCP协议如何进行拥塞控制？"><a href="#2-7-TCP协议如何进行拥塞控制？" class="headerlink" title="2.7 TCP协议如何进行拥塞控制？"></a>2.7 TCP协议如何进行拥塞控制？</h2><p>网络拥塞是指在<strong>分组交换网络中传送分组的数目太多</strong>时，由于存储转发节点的资源有限而造成网络传输性能下降的情况。</p><p>常见的拥塞控制有：</p><ul><li>慢开始</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ul><p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。当cwnd<ssthresh时，使用慢开始算法。当cwnd>ssthresh时，改用拥塞避免算法。</p><p><strong>慢开始：</strong>不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。</p><p><strong>拥塞避免：</strong>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。</p><p><strong>快重传：</strong>我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在<strong>收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。</strong>快重传规定：发送方只要<strong>一连收到三个</strong>重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214125708.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p><strong>快恢复：</strong>主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞），但<strong>接下来并不执行慢开始算法</strong>，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214130136.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h1 id="3-DNS协议和ARP协议"><a href="#3-DNS协议和ARP协议" class="headerlink" title="3. DNS协议和ARP协议"></a>3. DNS协议和ARP协议</h1><p>为什么这两个要放在一起说呢？因为这两个协议都是用于地址间的转化，都是起到了翻译官的职责。</p><h2 id="3-1-DNS解析过程是什么？"><a href="#3-1-DNS解析过程是什么？" class="headerlink" title="3.1 DNS解析过程是什么？"></a>3.1 DNS解析过程是什么？</h2><p>DNS (Domain Name System) 是 <strong>域名系统</strong> 的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于 TCP/IP 网络，它从事将主机名或域名转换为实际 IP 地址的工作，类似于<strong>翻译官</strong>。</p><p>DNS查询时优先考虑<strong>本地的Host文件</strong>和<strong>本地的DNS解析器</strong>是否保留有缓存映射，如果没有就<strong>向上一级请求</strong>。依次按照<strong>DNS根服务器，DNS顶层服务器，DNS管理方服务器</strong>的顺序请求。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200120162326.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>所谓<strong>递归查询就是变更查询者，迭代查询则没有变更</strong>：这个例子中查询者由客户端变为了本地DNS服务器，所以是递归查询。</p><h2 id="3-1-什么是MAC地址？"><a href="#3-1-什么是MAC地址？" class="headerlink" title="3.1 什么是MAC地址？"></a>3.1 什么是MAC地址？</h2><p>MAC地址是数据链路层和物理层使用的地址是<strong>硬件地址</strong>，IP地址网络层和以上各层使用的地址，是一种<strong>逻辑地址</strong>。在发送数据时，数据从高层到低层，然后才到通信链路上传输。使用IP地址的IP数据报一旦交给了数据链路层，就被封装成了MAC帧。<strong>MAC帧在传送时使用的源地址和目的地址都是硬件地址。</strong></p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216103838.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="3-2-ARP协议工作机制是什么？"><a href="#3-2-ARP协议工作机制是什么？" class="headerlink" title="3.2 ARP协议工作机制是什么？"></a>3.2 ARP协议工作机制是什么？</h2><p><strong>ARP（Address Resolution Protocol）即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址</strong>。</p><p>在每台安装有TCP/IP协议的电脑或路由器里都有一个ARP缓存表，表里的IP地址与MAC地址是一对应的，如下表所示。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216104026.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>解析MAC地址时，主机A首先在其ARP高速缓存中查找有无主机B的IP地址。</p><p>如果没有就就向<strong>本地网段发起一个ARP请求的广播包</strong>，查询此目的主机对应的MAC地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果相同，该主机首先<strong>将发送端的MAC地址和IP地址添加到自己的ARP列表中</strong>，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，<strong>告诉对方自己是它需要查找的MAC地址</strong>。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216104350.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>收到后<strong>在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射</strong>。并且采用LRU机制，及时淘汰。</p><h1 id="4-HTTP协议"><a href="#4-HTTP协议" class="headerlink" title="4. HTTP协议"></a>4. HTTP协议</h1><h2 id="4-1-HTTP常见的状态码有哪些？"><a href="#4-1-HTTP常见的状态码有哪些？" class="headerlink" title="4.1 HTTP常见的状态码有哪些？"></a>4.1 HTTP常见的状态码有哪些？</h2><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214133230.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="4-2-HTTP协议和其他协议之间的关系是什么？"><a href="#4-2-HTTP协议和其他协议之间的关系是什么？" class="headerlink" title="4.2 HTTP协议和其他协议之间的关系是什么？"></a>4.2 HTTP协议和其他协议之间的关系是什么？</h2><p>HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。<strong>如果TCP是高速路，HTTP就是卡车</strong>。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们能方便地使用TCP/IP协议。</p><h2 id="4-3-解释一下HTTP长连接和短连接"><a href="#4-3-解释一下HTTP长连接和短连接" class="headerlink" title="4.3 解释一下HTTP长连接和短连接"></a>4.3 解释一下HTTP长连接和短连接</h2><p>短连接：客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</p><p>长连接：客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。有一个保持时间。</p><h2 id="4-4-HTTP和HTTPS的区别"><a href="#4-4-HTTP和HTTPS的区别" class="headerlink" title="4.4 HTTP和HTTPS的区别"></a>4.4 HTTP和HTTPS的区别</h2><p>HTTP：运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份</p><p>HTTPS：Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP</p><h2 id="4-5-GET和POST的区别"><a href="#4-5-GET和POST的区别" class="headerlink" title="4.5 GET和POST的区别"></a>4.5 GET和POST的区别</h2><ol><li>GET用于从服务器获取资源，POST用于更新服务器的资源</li><li>GET不会改变服务器的资源，而POST会</li><li>GET请求的数据会附在URL之后，比如<code>http:localhost:8080/id=101?</code>，而POST的数据则是放在请求体中。因此，GET不安全，GET的长度受限制。</li></ol><h2 id="4-6-Cookie和Session的区别"><a href="#4-6-Cookie和Session的区别" class="headerlink" title="4.6 Cookie和Session的区别"></a>4.6 Cookie和Session的区别</h2><p>Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，<strong>cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</strong></p><p>Cookie实际上是<strong>一小段文本信息</strong>。客户端请求服务器，如果服务器需要记录该用户状态，就向客户端浏览器颁发一个Cookie。<strong>客户端浏览器会把Cookie保存起来</strong>。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。</p><p>Session的区别在于，<strong>会话状态完全保存在服务器</strong>。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session就按照sessionid把这个session检索出来使用。服务器Session常常依赖于Cookie机制检索ID，但Cookie被禁用时也有其他方法比如URL重写机制。</p><h2 id="4-7-HTTP请求报文和响应报文的格式"><a href="#4-7-HTTP请求报文和响应报文的格式" class="headerlink" title="4.7 HTTP请求报文和响应报文的格式"></a>4.7 HTTP请求报文和响应报文的格式</h2><p>请求报文格式：</p><ol><li>请求行（请求方法+URI协议+版本）</li><li>请求头部</li><li>空行</li><li>请求主体</li></ol><pre><code class="lang-http">GET/sample.jspHTTP/1.1 请求行Accept:image/gif.image/jpeg, 请求头部Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)Accept-Encoding:gzip,deflateusername=jinqiao&amp;password=1234 请求主体</code></pre><p>响应报文：</p><ol><li>状态行（版本+状态码+原因短语）</li><li>响应首部</li><li>空行</li><li>响应主体</li></ol><pre><code class="lang-http">HTTP/1.1 200 OKServer:Apache Tomcat/5.0.12Date:Mon,6Oct2003 13:23:42 GMTContent-Length:112&lt;html&gt;    &lt;head&gt;        &lt;title&gt;HTTP响应示例&lt;title&gt;    &lt;/head&gt;    &lt;body&gt;        Hello HTTP!    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="4-8-HTTP1-1和2-0"><a href="#4-8-HTTP1-1和2-0" class="headerlink" title="4.8 HTTP1.1和2.0"></a>4.8 HTTP1.1和2.0</h2><p>1.1新功能</p><ul><li>支持长链接</li><li>通过虚拟站点技术能够使不同域名配置在同一个IP地址的服务器上</li></ul><p>2.0新功能</p><ul><li>可以使用同一个连接并行发送多个请求和相应，可以<strong>承接双向数据流</strong></li><li>允许设定数据流中不同资源的<strong>优先级</strong>，明确资源处理的先后顺序</li><li>打破了请求-响应的束缚，除了最初的请求响应外，服务器还能向客户端<strong>推送额外的资源</strong>（客户端没有明确要求的情况下）</li></ul><h1 id="5-IP地址"><a href="#5-IP地址" class="headerlink" title="5. IP地址"></a>5. IP地址</h1><h2 id="5-1-IP地址的格式是什么？"><a href="#5-1-IP地址的格式是什么？" class="headerlink" title="5.1 IP地址的格式是什么？"></a>5.1 IP地址的格式是什么？</h2><p>什么是IP地址？IP协议提供的一种统一的地址格式，<strong>它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</strong></p><p>IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。</p><p>每个IP地址包括两个标识码（ID）</p><ul><li>网络ID</li><li>主机ID。</li></ul><p>同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。3字节的网络地址 + 1字节主机地址的意思就是：前三段号码为网络号码，剩下的一段号码为本地计算机的号码。</p><ul><li><strong>A类地址</strong>：1字节的网络地址 + 3字节主机地址，网络地址的最高位必须是0。A类IP地址的地址范围1.0.0.0到127.255.255.255，IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为<code>256^3-2</code></li><li><strong>B类地址</strong>：2字节的网络地址 + 2字节主机地址，网络地址的最高位必须是10。B类IP地址地址范围128.0.0.0-191.255.255.255B类IP地址的子网掩码为255.255.0.0，每个网络支持的最大主机数为<code>256^2-2</code>。注：1000 0000=128</li><li><strong>C类地址</strong>：3字节的网络地址 + 1字节主机地址，网络地址的最高位必须是110。C类IP地址范围192.0.0.0-223.255.255.255每个网络支持的最大主机数为<code>256-2</code>。<strong>适用于小规模局域网络</strong>。</li><li><strong>D类地址</strong>：多播地址，用于1对多通信，最高位必须是1110。范围从224.0.0.0到239.255.255.255。</li><li><strong>E类地址</strong>:为保留地址，最高位必须是“1111”</li></ul><h2 id="5-2-单播广播多播的区别是什么？"><a href="#5-2-单播广播多播的区别是什么？" class="headerlink" title="5.2 单播广播多播的区别是什么？"></a>5.2 单播广播多播的区别是什么？</h2><p><strong>单播：主机间一对一通信</strong>。优点：个性化服务，及时响应；缺点：流量压力大。</p><p><strong>广播：主机间一对所有通信</strong>。优点：布局简单，维护方便，流量负载低。缺点：缺乏个性化服务，无法在Internet宽带上传播。</p><p><strong>多播（组播）：主机间一对一组通信</strong>。优点：兼具流量负载和个性化的优点，允许在Internet宽带上传播。缺点：与单播协议相比没有纠错机制。</p><h2 id="5-3-如何划分子网？"><a href="#5-3-如何划分子网？" class="headerlink" title="5.3 如何划分子网？"></a>5.3 如何划分子网？</h2><p>划分子网的方法是从主机号借用若干个位作为子网号，而主机号也就相应减少了若干个位。于是两级IP地址在本单位内部就变为三级IP地址：网络号、子网号和主机号。</p><p>区分子网号和主机号的办法是：通过<strong>子网掩码</strong>将<strong>网络号和子网号全设为1</strong>的IP地址为子网掩码。</p><p>假设公司有4个部门，A部门有10台主机，B部门有15台主机，C部门有30台主机，D部门有20台主机。分配了一个总的网段为：192.168.2.0/24。请问该如何划分子网？</p><p><strong>网段前面的数字是我们的网络地址，后面的24表示用24位来表示网络位，用32-24=8位来表示主机位</strong>。主机数目不多，可以小型组网，因此采用C类地址(最大254个主机)，默认掩码为225.255.255.0。</p><p>首先假设借用主机位2位来划分4个子网，则子网掩码组合为：</p><pre><code>11111111.11111111.11111111.0000000011111111.11111111.11111111.0100000011111111.11111111.11111111.1000000011111111.11111111.11111111.11000000</code></pre><p>然而全为0和全为1的地址不能用，所以我们需要借用主机位3位，划分<code>8-2=6</code>个子网：</p><pre><code>11111111.11111111.11111111.0010000011111111.11111111.11111111.0100000011111111.11111111.11111111.0110000011111111.11111111.11111111.1000000011111111.11111111.11111111.1010000011111111.11111111.11111111.11000000</code></pre><p>验证一下：最后提供的主机位数是<code>2^5=32</code>，也就是说每个子网最大的主机数是32，符合题目要求。所以子网划分如下：</p><pre><code>（1）255.255.255.32:    192.168.2.33~ 192.168.2.62（2）255.255.255.64:   192.168.2.65~ 192.168.2.94（3）255.255.255.96:   192.168.2.97~ 192.168.2.126 （4）255.255.255.128:  192.168.2.129~ 192.168.2.158（5）255.255.255.160:  192.168.2.161~ 192.168.2.190 （6）255.255.255.192:  192.168.2.193~ 192.168.2.222</code></pre><p>子网掩码是：</p><pre><code>11111111.11111111.11111111.11100000255.255.255.224</code></pre><h1 id="6-网络安全"><a href="#6-网络安全" class="headerlink" title="6. 网络安全"></a>6. 网络安全</h1><h2 id="6-1-什么是DDos攻击？"><a href="#6-1-什么是DDos攻击？" class="headerlink" title="6.1 什么是DDos攻击？"></a>6.1 什么是DDos攻击？</h2><p>DDos全称Distributed Denial of Service，分布式拒绝服务攻击。最基本的DOS攻击过程如下：</p><ol><li>客户端向服务端发送请求链接数据包</li><li>服务端向客户端发送确认数据包</li><li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认</li></ol><p>DDoS则是采用分布式的方法，通过在网络上占领多台“肉鸡”，用多台计算机发起攻击。</p><p>DOS攻击现在基本没啥作用了，因为服务器的性能都很好，而且是多台服务器共同作用，1V1的模式黑客无法占上风。对于DDOS攻击，预防方法有：</p><ul><li><strong>减少SYN timeout时间。</strong>在握手的第三步，服务器会等待30秒-120秒的时间，减少这个等待时间就能释放更多的资源。</li><li><strong>限制同时打开的SYN半连接数目。</strong></li></ul><h2 id="6-2-什么是XSS攻击？"><a href="#6-2-什么是XSS攻击？" class="headerlink" title="6.2 什么是XSS攻击？"></a>6.2 什么是XSS攻击？</h2><p>XSS也称 cross-site scripting，<strong>跨站脚本</strong>。这种攻击是<strong>由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的</strong>。比如一个存在XSS漏洞的论坛，用户发帖时就可以引入<strong>带有＜script＞标签的代码</strong>，导致恶意代码的执行。</p><p>预防措施有：</p><ul><li>前端：过滤</li><li>后端：转义，比如go自带的处理器就具有转义功能。</li></ul><h2 id="6-3-什么是注入SQL攻击？"><a href="#6-3-什么是注入SQL攻击？" class="headerlink" title="6.3 什么是注入SQL攻击？"></a>6.3 什么是注入SQL攻击？</h2><p>XSS是将脚本代码注入，而SQL注入攻击顾名思义就是注入SQL语句。</p><p>比如代码：</p><pre><code class="lang-go">username:=r.Form.Get(&quot;username&quot;)password:=r.Form.Get(&quot;password&quot;)sql:=&quot;SELECT * FROM user WHERE username=&#39;&quot;+username+&quot;&#39; AND password=&#39;&quot;+password+&quot;&#39;&quot;</code></pre><p>当用户输入<code>myuser&#39; or &#39;foo&#39; = &#39;foo&#39; --</code>，那么SQL就变成了：</p><pre><code class="lang-go">SELECT * FROM user WHERE username=&#39;myuser&#39; or &#39;foo&#39;==&#39;foo&#39; --&#39;&#39; AND password=&#39;xxx&#39;</code></pre><p>在SQL里面<code>--</code>是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。</p><p>预防方法：</p><ul><li>限制数据库权限，给用户提供仅仅能够满足其工作的最低权限。</li><li>对进入数据库的特殊字符（’”\尖括号&amp;*;等）转义处理。</li><li>提供参数化查询接口，不要直接使用原生SQL</li></ul><h1 id="7-综合问题"><a href="#7-综合问题" class="headerlink" title="7. 综合问题"></a>7. 综合问题</h1><h2 id="7-1-浏览器中输入URL地址到显示主页的过程是什么？"><a href="#7-1-浏览器中输入URL地址到显示主页的过程是什么？" class="headerlink" title="7.1 浏览器中输入URL地址到显示主页的过程是什么？"></a>7.1 浏览器中输入URL地址到显示主页的过程是什么？</h2><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214133606.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="7-2-ping命令的具体过程是什么？"><a href="#7-2-ping命令的具体过程是什么？" class="headerlink" title="7.2 ping命令的具体过程是什么？"></a>7.2 ping命令的具体过程是什么？</h2><p>假设现在有ABCD四台主机，一台路由，子网掩码为255.255.255.0，默认路由为192.168.0.1</p><p>在主机 A 上运行<code>Ping 192.168.0.5</code>后,</p><ol><li>Ping命令会构建一个<strong>ICMP协议</strong>的数据包，交到网络层的IP协议中。IP层协议将目的地址和源地址打包后，形成IP数据包</li><li>获取192.168.0.5的MAC地址</li><li>交到数据链路层，添加一些控制信息，构建数据帧</li><li>交到物理层，通过以太网访问</li></ol><p>主机B收到后，</p><ol><li>检查目的地址，不相符就丢弃</li><li>将IP数据包提取后送入网络层的IP层协议，IP层检查后将有用的信息提取后送入ICMP协议</li><li>ICMP协议马上构建一个ICMP应答包以之前的相同方式发送给主机</li></ol><p>根据条件：<strong>是否在同一网段内</strong>，流程可能有所不同，区别在于MAC的获取方式，具体参见ARP协议。</p><h2 id="7-3-负载均衡算法有哪些？"><a href="#7-3-负载均衡算法有哪些？" class="headerlink" title="7.3 负载均衡算法有哪些？"></a>7.3 负载均衡算法有哪些？</h2><p>多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。</p><ul><li>轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势</li><li>随机法：随机获取一台，和轮询类似</li><li>哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie</li><li>加权轮询：根据服务器性能不同加权</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机网络相关的所以题目汇总，应该是网上最全的汇总了。
    
    </summary>
    
    
      <category term="计算机网络" scheme="jiangren.work/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="面试经验" scheme="jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统面试题目汇总</title>
    <link href="jiangren.work/2020/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    <id>jiangren.work/2020/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</id>
    <published>2020-02-16T05:55:18.000Z</published>
    <updated>2020-02-27T19:54:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章包含了操作系统和计算机组成相关的知识信息，Linux部分被专门分出去了。<a id="more"></a></p><h1 id="1-总体概念"><a href="#1-总体概念" class="headerlink" title="1. 总体概念"></a>1. 总体概念</h1><h2 id="1-1-操作系统的特性是什么？"><a href="#1-1-操作系统的特性是什么？" class="headerlink" title="1.1 操作系统的特性是什么？"></a>1.1 操作系统的特性是什么？</h2><p>四个特性：并发、共享、虚拟、异步。</p><ul><li>同一段时间内(时间片轮转算法)多个程序执行。</li><li>系统中的资源可以被内存中多个并发执行的进线程共同使用。</li><li>虚拟：通过时分复用以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个。</li><li>异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进。（同步就是实时处理，比如打电话，异步就是分时处理，比如发短信）</li></ul><h2 id="1-2-操作系统的主要功能有哪些？"><a href="#1-2-操作系统的主要功能有哪些？" class="headerlink" title="1.2 操作系统的主要功能有哪些？"></a>1.2 操作系统的主要功能有哪些？</h2><p>操作系统的本质是<strong>对资源的管理</strong>。包括了：</p><ul><li><strong>处理器管理</strong>：以进程为单位分配资源</li><li><strong>存储器管理</strong>：也叫内存管理</li><li><strong>设备管理</strong>：完成所有的IO请求</li><li><strong>文件管理</strong>：包括磁盘存储空间管理，文件读写管理等等</li></ul><h2 id="1-3-什么是用户态与核心态？"><a href="#1-3-什么是用户态与核心态？" class="headerlink" title="1.3 什么是用户态与核心态？"></a>1.3 什么是用户态与核心态？</h2><p>从整体上讲，操作系统一般可分为<strong>内核（kernel）</strong>和<strong>外壳（shell）</strong>两大部分。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200218111032.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>当程序运行在3级特权级上时，就可以称之为运行在<strong>用户态</strong>。反之则是<strong>内核态</strong>。0级特权直接控制硬件，12级特权是系统程序，包括驱动等等，3级特权是用户程序。</p><p>用户态切换到内核态有三种情况：</p><ul><li>系统调用：用户态进程主动要求切换到内核态的一种方式。</li><li>异常：当前运行进程切换到处理此异常的内核相关程序中</li><li>外围设备中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。</li></ul><h1 id="2-线程与进程"><a href="#2-线程与进程" class="headerlink" title="2. 线程与进程"></a>2. 线程与进程</h1><h2 id="2-1-线程进程协程的区别"><a href="#2-1-线程进程协程的区别" class="headerlink" title="2.1 线程进程协程的区别"></a>2.1 线程进程协程的区别</h2><p>对于操作系统来说，<strong>一个任务就是一个进程(Process)</strong>，比如使用word。而一个进程可能不只干一件事（比如word既要打字又要检查拼写），这种<strong>进程内的多个子任务就是线程</strong>（Thread）。</p><p>具体来说：</p><ul><li>进程是操作系统分配资源的单位，而<strong>线程是进程的一个实体</strong>，是CPU调度和分派的基本单位。</li><li>线程没有独立的内存单元，不能够独立执行，必须依存在应用程序中。</li></ul><p><strong>引入线程的好处：</strong>线程快！创建、终止、切换都很快！</p><p><strong>总结：</strong></p><ol><li>一个程序至少有一个进程,一个进程至少有一个线程。</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存</li><li>虽然线程拥有单独的程序运行入口，出口，但不能独立执行。</li></ol><p>协程与线程的区别：协程不再被内核调度，<strong>而是交给了程序自己</strong>，因此golang中专门引入了GMP模式，设立了专门的逻辑处理器。</p><h2 id="2-2-进程有哪些状态，转换条件是什么？"><a href="#2-2-进程有哪些状态，转换条件是什么？" class="headerlink" title="2.2 进程有哪些状态，转换条件是什么？"></a>2.2 进程有哪些状态，转换条件是什么？</h2><p><strong>就绪状态</strong>：进程获得了除CPU之外的一切所需资源</p><p><strong>运行状态</strong>：一个CPU的一个核只能有一个进程处于运行状态。</p><p><strong>阻塞状态</strong>，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200218102010.png"  style="zoom:55%;display: block; margin: 0px auto; vertical-align: middle;"></p><p><strong>注意区别就绪状态和等待状态：</strong>就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件</p><h2 id="2-3-进程间通信"><a href="#2-3-进程间通信" class="headerlink" title="2.3 进程间通信"></a>2.3 进程间通信</h2><p>也就是所谓的IPC(Interprocess communication)问题，主要是指<strong>进程间交换数据的方式</strong>。</p><p>进程是相互独立的，并不需要条件变量、互斥锁这些机制，要锁也是文件锁这种大锁。而线程需要互斥锁的原因是：<strong>线程之间的资源室共享的，需要程序员来完成变量级别的同步。</strong></p><p>进程间通信分为<strong>低级通信</strong>和<strong>高级通信</strong>。</p><ul><li>低级通信：信号量</li><li>高级通信：<ul><li>管道</li><li>消息队列</li><li>共享内存</li></ul></li></ul><p><strong>信号量</strong>是一个计数器，防止多个进程将资源拿光，防止某进程正在访问共享资源时，其他进程也访问该资源。</p><p><strong>管道</strong>是指用于<strong>连接一个读进程和一个写进程的一个共享文件</strong>，又名pipe文件，以<strong>字符流形式</strong>将数据写入文件。管道分为<strong>无名管道</strong>和<strong>有名管道</strong>：</p><ul><li>无名管道是半双工的通信方式，数据只能单向流动，只能在父子进程中流通；</li><li>有名管道也是半双工，但是它允许无亲缘关系进程间通信。</li></ul><p><strong>消息队列</strong>指的是<strong>进程间的数据交换是以格式化的消息(Message)为单位的</strong>，再由消息组成的链表，形成队列。</p><p><strong>共享内存</strong>指在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。</p><h2 id="2-4-进程间同步"><a href="#2-4-进程间同步" class="headerlink" title="2.4 进程间同步"></a>2.4 进程间同步</h2><p>多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。进程同步的任务就是对<strong>多个相关进程在执行顺序上进行协调</strong>。</p><p>同步手段有：</p><ul><li>临界区</li><li>互斥量</li><li>信号量</li><li>事件： 通过通知操作的方式来保持线程的同步</li></ul><p>其中：互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多。</p><h2 id="2-5-线程间同步"><a href="#2-5-线程间同步" class="headerlink" title="2.5 线程间同步"></a>2.5 线程间同步</h2><p>由于线程间的资源可以共享，同步的方式就会更加细致：</p><ul><li><strong>互斥量</strong></li><li><strong>信号量</strong>，只能用于一个资源的互斥访问，不能实现多个资源的多线程互斥问题</li><li><strong>读写锁</strong>，可以被多个读者拥有，但是只能被一个写者拥有的锁</li><li><strong>条件变量</strong>，线程 A 等待某个条件并挂起，直到线程 B 设置了这个条件，并通知条件变量，然后线程 A 被唤醒</li><li><strong>原子操作</strong></li><li><strong>通道</strong></li></ul><h2 id="2-6-什么是临界区，如何解决冲突？"><a href="#2-6-什么是临界区，如何解决冲突？" class="headerlink" title="2.6 什么是临界区，如何解决冲突？"></a>2.6 什么是临界区，如何解决冲突？</h2><p>每个进程中访问临界资源的那段程序称为临界区，<strong>一次仅允许一个进程使用的资源称为临界资源。</strong></p><p>解决冲突的办法：</p><ul><li>如果有若干进程要求进入空闲的临界区，<strong>一次仅允许一个进程进入</strong>，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；</li><li>进入临界区的进程要在<strong>有限时间内退出</strong>。</li><li>如果进程不能进入自己的临界区，则应<strong>让出CPU</strong>，避免进程出现“忙等”现象。</li></ul><h2 id="2-7-线程的分类"><a href="#2-7-线程的分类" class="headerlink" title="2.7 线程的分类"></a>2.7 线程的分类</h2><p><strong>内核级线程</strong>：这类线程依赖于内核，又称为内核支持的线程或轻量级进程。无论是在用户程序中的线程还是系统进程中的线程，它们的创建、撤销和切换都由内核实现。比如英特尔i5-8250U是4核8线程，这里的线程就是内核级线程</p><p><strong>用户级线程</strong>：它仅存在于用户级中，这种线程是<strong>不依赖于操作系统核心</strong>的。应用进程利用<strong>线程库来完成其创建和管理</strong>，速度比较快，<strong>操作系统内核无法感知用户级线程的存在</strong>。</p><h2 id="2-8-线程池"><a href="#2-8-线程池" class="headerlink" title="2.8 线程池"></a>2.8 线程池</h2><p>线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，<strong>处理完之后线程并不会被销毁，而是等待下一个任务</strong>。由于创建和销毁线程都是消耗系统资源的，所以池化技术能提升性能。</p><p>go实现线程池如下。创建两个通道，通道queue中传入任务函数，通道result传入结果：</p><ul><li>创建结构</li><li>初始化</li><li>开门接客</li><li>关门送客</li><li>辅助函数:添加任务、回调</li></ul><pre><code class="lang-go">type pool struct{    Queue chan func() error    Number int //协程数    Total int //任务数    result chan error    finishCallback func()}func (p *pool) Init(number, total int){    p.Queue=make(chan func() error,total)    p.Number=number    p.Total=total    p.result=make(chan error,total)}// 开门接客func (p *pool) Start(){    // 开启Number个goroutine    for i:=0;i&lt;p.Number;i++{        go func(){            for {                task, ok := &lt;-p.Queue                if !ok { //所有任务已经完成，跳出循环                    break                }                err:=task() //执行任务，每个协程阻塞在此                p.result&lt;-err             }        }()    }    // 获得每个work的执行结果    for i:=0;i&lt;p.Total;i++{        res:=&lt;-p.result //阻塞形式        if res!=nil{            fmt.Println(res)        }    }    // main传入回调函数才可以执行    if p.finishCallback!=nil{        p.finishCallback()    }}// 关门送客func (p *pool) Stop() {       close(p.Queue)    close(p.result)}//添加任务func (p *pool)addTask(task func() error){    p.Queue&lt;-task}//设置结束回调func (p *pool) setFinishCallback(callback func()){    p.finishCallback=callback</code></pre><p>使用过程：</p><pre><code class="lang-go">ool := new(GoroutinePool)pool.Init(3, 10) //开启3个协程处理10个任务for i:=0;i&lt;10;i++{    pool.addTask(func() error{        //从taskName中获取任务要求        return doTask(taskName[i])    })}isFinish:=falsepool.setFinishCallback(func(){    func(isFinish *bool){        *isFinish=true    }(&amp;isFinish)})pool.Start()for{    if isFinished{        break    }    time.Sleep(time.Millisecond*100)}pool.Stop()fmt.Println(&quot;Finished!&quot;)</code></pre><h1 id="3-内存"><a href="#3-内存" class="headerlink" title="3. 内存"></a>3. 内存</h1><h2 id="3-1-逻辑地址、线性地址和物理地址的区别？"><a href="#3-1-逻辑地址、线性地址和物理地址的区别？" class="headerlink" title="3.1 逻辑地址、线性地址和物理地址的区别？"></a>3.1 逻辑地址、线性地址和物理地址的区别？</h2><p><strong>逻辑地址（Logic Address）</strong>是指<strong>由程序产生的与段相关的偏移地址部分</strong>，因此一个逻辑地址<strong>由段标识符和段内偏移量</strong>组成，有时也称<strong>虚拟地址</strong>。比如，在C程序中，<strong>可以使用&amp;操作读取指针变量本身的值，实际上这个值就是逻辑地址</strong>。逻辑地址和绝对的物理地址不相干。</p><p><strong>线性地址（Linear Address）</strong>是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或说是段中的偏移地址，<strong>加上相应段的基地址就生成了一个线性地址。</strong></p><p><strong>物理地址（Physical Address）</strong>是CPU外部地址总线上的地址，也是地址变换的最终地址。</p><h2 id="3-2-寻址方式有哪些？"><a href="#3-2-寻址方式有哪些？" class="headerlink" title="3.2 寻址方式有哪些？"></a>3.2 寻址方式有哪些？</h2><p>寻址寻的都是物理地址。分三组：立即寻址+寄存器寻址；直接间接寻址；相对寻址+2个基变址寻址。</p><ul><li><p><strong>立即寻址</strong>：操作数在指令中给出，作为指令的一部分。</p><pre><code class="lang-assembly">MOV AL,5</code></pre></li><li><p><strong>寄存器寻址</strong>：操作数在CPU内部的寄存器中，指令指定寄存器。<strong>不需要访问存储器</strong>，所以速度快。</p><pre><code class="lang-assembly">MOV AX,BX</code></pre></li><li><p><strong>直接寻址</strong>：<strong>操作数在寄存器中</strong>，指令直接包含有操作数的有效地址。</p><pre><code class="lang-assembly">MOV AX,[8054]</code></pre></li><li><p><strong>间接寻址</strong>：存储操作数的寄存器的地址另一个在寄存器中</p><pre><code class="lang-assembly">MOV AX,[SI]</code></pre></li><li><p><strong>相对寻址</strong>：操作数在存储器中，形式为<strong>基地址+偏移地址</strong>。假设数据段DS地址为5000，DI为3678，最终地址为5000+3678+1223。</p><pre><code class="lang-assembly">MOV AX,[DI+1223H]</code></pre></li><li><p><strong>基变址绝对寻址</strong>：操作数在寄存器中，形式为<strong>基地址寄存器+变址寄存器</strong>。BX基地址+DI变址得到操作数存放的地址。</p><pre><code class="lang-assembly">MOV AX,[BX][DI]</code></pre></li><li><p><strong>基变址相对寻址</strong>：操作数在存储器中，形式为：<strong>基地址寄存器+变址寄存器+偏移地址</strong></p><pre><code class="lang-assembly">MOV AX,[BX+DI-2]</code></pre></li></ul><h2 id="3-3-什么是虚拟内存？"><a href="#3-3-什么是虚拟内存？" class="headerlink" title="3.3 什么是虚拟内存？"></a>3.3 什么是虚拟内存？</h2><p>多任务会带来进程对内存的操作冲突，需要虚拟内存来解决。假设现在有一块物理内存，<strong>操作系统让两个进程共用这一块内存</strong>，彼此并不打扰。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200217135006.png"  style="zoom:55%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="3-4-什么是交换空间？"><a href="#3-4-什么是交换空间？" class="headerlink" title="3.4 什么是交换空间？"></a>3.4 什么是交换空间？</h2><p>操作系统把物理内存(physical RAM)分成一块一块的小内存，每一块内存被称为<strong>页(page)</strong>。当内存资源不足时，<strong>Linux把某些页的内容转移至硬盘上的一块空间上，以释放内存空间</strong>。硬盘上的那块空间叫做<strong>交换空间</strong>(swap space),而这一过程被称为交换(swapping)。<strong>物理内存和交换空间的总容量就是虚拟内存的可用容量。</strong></p><p>用途：</p><ul><li>物理内存不足时一些不常用的页可以被交换出去，腾给系统。</li><li>程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。</li></ul><h2 id="3-5-什么是分页？"><a href="#3-5-什么是分页？" class="headerlink" title="3.5 什么是分页？"></a>3.5 什么是分页？</h2><p>把内存空间划分为<strong>大小相等且固定的块</strong>，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。</strong></p><p>访问分页系统中内存数据需要<strong>两次的内存访问</strong> (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200218105728.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="3-6-什么是分段？"><a href="#3-6-什么是分段？" class="headerlink" title="3.6 什么是分段？"></a>3.6 什么是分段？</h2><p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</strong></p><p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200218110201.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="3-7-分页分段的区别是什么？"><a href="#3-7-分页分段的区别是什么？" class="headerlink" title="3.7 分页分段的区别是什么？"></a>3.7 分页分段的区别是什么？</h2><ul><li>属性：页是信息的物理单位，对用户不可见，段是逻辑单位，用户可见。</li><li>大小：分页固定，分段不固定</li><li>决定权：分页在于系统，分段在于用户</li><li>目的：分页有利于资源的利用，分段方便用户管理内存</li></ul><h2 id="3-8-有哪些页面置换算法？"><a href="#3-8-有哪些页面置换算法？" class="headerlink" title="3.8 有哪些页面置换算法？"></a>3.8 有哪些页面置换算法？</h2><p><strong>缺页中断</strong>：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p><p>有时候操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p><ul><li>先进先出FIFO：总是选择在主存中停留时间最长（即最老）的一页置换</li><li>LRU：选择在最近一段时间里<strong>最久没有使用</strong>过的页面予以置换</li><li>LFU(least frequent)：统计页的使用频率，选择在<strong>最近时期使用最少的页面</strong>作为淘汰页</li></ul><h1 id="4-系统中断"><a href="#4-系统中断" class="headerlink" title="4. 系统中断"></a>4. 系统中断</h1><h2 id="4-1-中断的处理过程"><a href="#4-1-中断的处理过程" class="headerlink" title="4.1 中断的处理过程"></a>4.1 中断的处理过程</h2><ol><li>保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈</li><li>开中断：以便执行中断时能响应较高级别的中断请求。</li><li>中断处理</li><li>关中断：保证恢复现场时不被新中断打扰</li><li>恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态。</li></ol><h2 id="4-2-中断和轮询有什么区别？"><a href="#4-2-中断和轮询有什么区别？" class="headerlink" title="4.2 中断和轮询有什么区别？"></a>4.2 中断和轮询有什么区别？</h2><p>轮询：CPU对<strong>特定设备</strong>轮流询问。中断：通过<strong>特定事件</strong>提醒CPU。</p><p>轮询：效率低等待时间长，CPU利用率不高。中断：容易遗漏问题，CPU利用率不高。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章包含了操作系统和计算机组成相关的知识信息，Linux部分被专门分出去了。
    
    </summary>
    
    
      <category term="Linux" scheme="jiangren.work/categories/Linux/"/>
    
    
      <category term="Linux" scheme="jiangren.work/tags/Linux/"/>
    
      <category term="面试经验" scheme="jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>go设计模式</title>
    <link href="jiangren.work/2020/02/14/go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>jiangren.work/2020/02/14/go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-14T02:09:34.000Z</published>
    <updated>2020-02-18T14:42:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍编程的各种设计模式，用go语言实现。<a id="more"></a></p><h1 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h1><p>单例模式的定义是：保证一个类<strong>仅有一个实例</strong>，并<strong>提供一个访问它的全局访问点</strong>。简单的说就是希望我们的系统中该类仅仅存在1个或0个该类的实例。</p><h2 id="1-1-非并发情况"><a href="#1-1-非并发情况" class="headerlink" title="1.1 非并发情况"></a>1.1 非并发情况</h2><p>提供了一个<code>GetInstance</code>函数去获取它的实例，根据是否为空来判断究竟应该创建新的还是沿用旧的。用系统时间作为鉴别依据。编写时主要考虑：</p><ol><li>实例具有全局性</li><li>创建前先判断</li></ol><pre><code class="lang-go">type manager struct {    t time.Time}func (p manager) manage(){    s:=fmt.Sprintf(&quot;time=%s, managing...&quot;,p.t)    fmt.Println(s)}var m *managerfunc GetInstance() *manager{    if m==nil{        m=new(manager)        m.t=time.Now()    }    return m}func main(){    a:=GetInstance()    a.manage()    b:=GetInstance()    b.manage()//二者输出相同时间，证明单例成功}</code></pre><h2 id="1-2-线程安全"><a href="#1-2-线程安全" class="headerlink" title="1.2 线程安全"></a>1.2 线程安全</h2><p>老问题：<code>if m==nil</code>语句到<code>m=new(manager)</code>之间并不安全，可能创建多次。</p><p><strong>方法一</strong>，可以用锁锁一下：</p><pre><code class="lang-go">var m *managervar mutex sync.Mutex //注意要import syncfunc GetInstance() *manager{    mutex.Lock()    defer mutex.Unlock()    if m==nil{        m=new(manager)        m.t=time.Now()    }    return m}</code></pre><p><strong>方法二</strong>，提高效率可以采用双重锁机制，前者每次都会锁，双重锁机制下只有部分情况才会锁。但双重锁有个问题：new是先创建指针然后分配内存，如果在这中间被if抢先了就会造成误操作，多生成一个manager</p><pre><code class="lang-go">var m *Managervar lock *sync.Mutex = &amp;sync.Mutex {}func GetInstance() *Manager {    if m == nil {        lock.Lock()        defer lock.Unlock()        if m == nil {            m = new(manager)        }    }    return m}</code></pre><p><strong>方法三</strong>，<code>sync.Once</code>，它有一个Do方法，在它中的函数go会只保证仅仅调用一次。跟C++的<code>`std::call_once</code>函数是一个意思。</p><pre><code class="lang-go">var m *managervar once sync.Oncefunc GetInstance() *manager{   lambda:=func(){      m=new(manager)   }   once.Do(lambda)   return m}</code></pre><h1 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h1><h2 id="2-1-简单工厂模式"><a href="#2-1-简单工厂模式" class="headerlink" title="2.1 简单工厂模式"></a>2.1 简单工厂模式</h2><p>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p><p>下面看个例子：</p><div class="table-container"><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Phone</td><td style="text-align:center">接口，只有一个方法来获取电池容量</td></tr><tr><td style="text-align:center">type Huawei struct</td><td style="text-align:center">华为手机构造体</td></tr><tr><td style="text-align:center">type Xiaomi struct</td><td style="text-align:center">小米手机构造体</td></tr><tr><td style="text-align:center">func (p* Huawei) get Battery</td><td style="text-align:center">华为手机的GetBattery实现</td></tr><tr><td style="text-align:center">func (p* Xiaomi) get Battery</td><td style="text-align:center">小米手机的GetBattery实现</td></tr><tr><td style="text-align:center">type PhoneFactory struct</td><td style="text-align:center">手机工厂的构造体</td></tr><tr><td style="text-align:center">func (factory PhoneFactory) CreatePhone(brand string) Phone</td><td style="text-align:center">手机工厂的CreatePhone实现</td></tr></tbody></table></div><p>注意GetBattery函数不是必须的，这里只是方便演示。要注意工厂生产函数的返回类型，<strong>phone的接口类型</strong>。</p><pre><code class="lang-go">//phone作为接口，统一方法type Phone interface{    getBattery()}//华为type Huawei struct{}func (p* Huawei) getBattery(){    fmt.Println(&quot;[Huawei battery]:4500mAn&quot;)}//小米type Xiaomi struct{}func (p* Xiaomi) getBattery(){    fmt.Println(&quot;[Xiaomi battery]:4400mAn&quot;)}//工厂生产type PhoneFactory struct {}func (p* PhoneFactory) Creat(brand string) Phone{    switch brand {    case &quot;Huawei&quot;:        return new(Huawei)    case &quot;Xiaomi&quot;:        return new(Xiaomi)    default:        return nil    }}func main(){    var phone Phone    factory:=new(PhoneFactory)    phone=factory.Creat(&quot;Huawei&quot;)    phone.getBattery()    phone=factory.Creat(&quot;Xiaomi&quot;)    phone.getBattery()}</code></pre><h2 id="2-2-工厂方法模式"><a href="#2-2-工厂方法模式" class="headerlink" title="2.2 工厂方法模式"></a>2.2 工厂方法模式</h2><ul><li>简单工厂需要:<ol><li>工厂结构体</li><li>产品接口</li><li>产品结构体</li></ol></li></ul><p>假设餐馆生产面条和米饭，如果只有一个餐馆则简单工厂模式即可解决，但如果有开了分店，<strong>有多个工厂</strong>，就需要工厂方法模式了。</p><ul><li>工厂方法需要:<ol><li>工厂接口</li><li>工厂结构体</li><li>产品接口</li><li>产品结构体</li></ol></li></ul><pre><code class="lang-go">//Step1. 添加接口//工厂接口type FactoryInterface interface {    Generate(s string) ProductInterface //继承自产品接口}// 产品接口type ProductInterface interface {    create()}//Step2. 创建产品结构体及方法type RiceShopA struct {}type NoodleShopA struct {}type RiceShopB struct {}type NoodleShopB struct {}func (p* RiceShopA) create() {    fmt.Println(&quot;A店米饭&quot;)}func (p* NoodleShopA) create() {    fmt.Println(&quot;A店面条&quot;)}func (p* RiceShopB) create() {    fmt.Println(&quot;B店米饭&quot;)}func (p* NoodleShopB) create() {    fmt.Println(&quot;B店面条&quot;)}//Step3. 创建工厂及方法type shopA struct{}type shopB struct{}func (p* shopA) Generate(s string)ProductInterface{    switch s{    case &quot;rice&quot;:        return new(RiceShopA)    case &quot;noodle&quot;:        return new(NoodleShopA)    default:        return nil    }}func (p* shopB) Generate(s string)ProductInterface{    switch s{    case &quot;rice&quot;:        return new(RiceShopB)    case &quot;noodle&quot;:        return new(NoodleShopB)    default:        return nil    }}func main(){    newshopA:=new(shopA)    a:=newshopA.Generate(&quot;rice&quot;)    a.create()    newshopB:=new(shopB)    b:=newshopB.Generate(&quot;noodle&quot;)    b.create()}</code></pre><h2 id="2-3-抽象工厂模式"><a href="#2-3-抽象工厂模式" class="headerlink" title="2.3 抽象工厂模式"></a>2.3 抽象工厂模式</h2><p>与工厂方法模式的区别在于：工厂方法模式是<strong>一个工厂接口创建了一个方法，一个方法对应了两个工厂结构体</strong>，而抽象工厂模式是<strong>一个工厂接口创建了两个方法生产</strong>。</p><p>假设有广东包子铺和祁山包子铺两家，都生产猪肉和三鲜包子：</p><pre><code class="lang-go">type FactoryInterface interface {       CreatePigMeatBuns() ProductInterface // 创建猪肉馅产品       Create3SBuns() ProductInterface      // 创建三鲜馅产品}type ProductInterface interface {    Intro()}</code></pre><p>然后实现4种产品：</p><pre><code class="lang-go">type GDPigMeatBuns struct {}func (p GDPigMeatBuns) Intro() {    fmt.Println(&quot;广东猪肉馅包子&quot;)}// TODO ... 其他产品实现方法没区别</code></pre><p>之后实现工厂：</p><pre><code class="lang-go">// 齐市包子铺 type QSFactory struct {}func (qs QSFactory) CreatePigMeatBuns() ProductInterface {    return QSPigMeatBuns{}}func (qs QSFactory) Create3SBuns() ProductInterface {    return QS3SBuns{}}// 广东包子铺type GDFactory struct {}func (gd GDFactory) CreatePigMeatBuns() ProductInterface {    return GDPigMeatBuns{}}func (gd GDFactory) Create3SBuns() ProductInterface {    return GD3SBuns{}}</code></pre><p>最后实际生产：</p><pre><code class="lang-go">var f FactoryInterface  // 特意以这种方式声明，更好的体会抽象工厂模式的好处f = new(QSFactory)  b := f.CreatePigMeatBuns()  b.Intro()</code></pre><p><strong>优点</strong>: 抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是<strong>可以在类的内部对产品族进行约束</strong>。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。</p><p><strong>缺点</strong>: <strong>产品族的扩展将是一件十分费力的事情</strong>，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的</p><h1 id="3-策略模式"><a href="#3-策略模式" class="headerlink" title="3. 策略模式"></a>3. 策略模式</h1><p>体现的原则是<strong>对扩展开放，对修改关闭(开闭原则)</strong> ，如果我们要增加一些规则，完全不用修改主业务流程，只需要增加几个策略即可。</p><p>假设创建加减乘除方法：</p><pre><code class="lang-go">//策略接口type Strategier interface {    Compute(num1, num2 int) int}//策略之一：除法type division struct{}func (p* division) Compute(num1,num2 int) int{    if num2 == 0 {        panic(&quot;num2 must not be 0!&quot;)    }    return num1 / num2}func NewStrategy(t string)(res Strategier){    switch t {    case &quot;d&quot;:        res=new(division)    default:        res=nil    }    return}func main(){    Strategy:=NewStrategy(&quot;d&quot;)    val:=Strategy.Compute(20,10)    fmt.Println(val)}</code></pre><h1 id="4-观察者模式"><a href="#4-观察者模式" class="headerlink" title="4. 观察者模式"></a>4. 观察者模式</h1><p>多个对象同时观察一个对象，当这个被观察的对象发生变化的时候，这些对象都会得到通知，可以做一些操作。</p><p>核心要点：</p><ol><li>观察者需要接收观察变化的函数</li><li>被观察者要能创建观察者</li><li>被观察者要能通知观察者</li></ol><pre><code class="lang-go">//创建观察者type IObserver interface{    Notify()}//创建被观察者type IObject interface{    AddObserver(observers Observer)    NotifyObservers()}type Observer struct{}func (p* Observer) Notify(){    fmt.Println(&quot;已触发观察者&quot;)}type Obeject struct{    Observers []IObserver}func (p* Obeject) AddObserver(observer []IObserver){    p.Observers=append(p.Observers, observer...)}func (p* Obeject) NotifyObserver(){    for k:=range p.Observers{        p.Observers[k].Notify()    }}func main(){    // 创建被观察者    s := new(Obeject)    // 创建观察者    o := make([]IObserver,0)    o=append(o, new(Observer))    o=append(o, new(Observer))    // 为主题添加观察者    s.AddObserver(o)    s.NotifyObserver()}</code></pre><h1 id="5-代理模式"><a href="#5-代理模式" class="headerlink" title="5. 代理模式"></a>5. 代理模式</h1><p>举两个生活化的例子：</p><ol><li>火车票的代理售票点。代售点就是代理，它拥有被代理对象的部分功能 — 售票功能</li><li>明星的经纪人，经纪人就是代理，负责为明星处理一些事务。</li></ol><pre><code class="lang-go">type seller interface{    sell(consumer string)}type Station struct{ //真正的销售者    stock int //存货}func (p* Station)sell(consumer string){    if p.stock&gt;0{        p.stock--        fmt.Printf(&quot;火车站，客户：%s买了一张票,剩余：%d \n&quot;, consumer,p.stock)    }else{        fmt.Println(&quot;已售空&quot;)    }}type Xiecheng struct{ //携程代理    station *Station //持有一个火车站}func (p* Xiecheng)sell(consumer string){    if p.station.stock&gt;0{        p.station.stock--        fmt.Printf(&quot;携程网，客户：%s买了一张票,剩余：%d \n&quot;, consumer,p.station.stock)    }else{        fmt.Println(&quot;已售空&quot;)    }}func main(){    sta:=Station{3}    proxy:=new(Xiecheng)    proxy.station=&amp;sta    proxy.sell(&quot;Bob&quot;)    sta.sell(&quot;Lily&quot;)}</code></pre><h1 id="6-生产者消费者模式"><a href="#6-生产者消费者模式" class="headerlink" title="6. 生产者消费者模式"></a>6. 生产者消费者模式</h1><h2 id="6-1-无缓冲"><a href="#6-1-无缓冲" class="headerlink" title="6.1 无缓冲"></a>6.1 无缓冲</h2><p>**</p><pre><code class="lang-go">var wg sync.WaitGroupfunc producer(ch chan&lt;-int){    defer wg.Done()    for i:=0;i&lt;3;i++{        ch&lt;-i        fmt.Println(&quot;send:&quot;,i)    }}func consumer(ch &lt;-chan int){    defer wg.Done()    for i:=0;i&lt;3;i++{        v:=&lt;-ch        fmt.Println(&quot;received:&quot;,v)    }}func main(){    wg.Add(2)    ch:=make(chan int)    go producer(ch)    go consumer(ch)    wg.Wait()}</code></pre><p>因为channel没有缓冲区，所以当<strong>生产者给channel赋值后会进入阻塞状态</strong>。消费者取出一次数据后由于没有数据可读，也会进入阻塞。输出如下：</p><pre><code>send: 0received: 0send: 1received: 1send: 2received: 2</code></pre><p>如果没有按这个顺序输出，是print输出缓冲区的问题，加个50ms延时即可。</p><h2 id="6-2-有缓冲"><a href="#6-2-有缓冲" class="headerlink" title="6.2 有缓冲"></a>6.2 有缓冲</h2><p>只需要在ch创建时改为</p><pre><code class="lang-go">ch := make(chan int, 10)</code></pre><p>输出：</p><pre><code>send: 0send: 1send: 2received: 0received: 1received: 2</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍编程的各种设计模式，用go语言实现。
    
    </summary>
    
    
      <category term="go" scheme="jiangren.work/categories/go/"/>
    
    
      <category term="go" scheme="jiangren.work/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Beego框架学习5-独立模块</title>
    <link href="jiangren.work/2020/02/03/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A05-%E7%8B%AC%E7%AB%8B%E6%A8%A1%E5%9D%97/"/>
    <id>jiangren.work/2020/02/03/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A05-%E7%8B%AC%E7%AB%8B%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-03T07:32:45.000Z</published>
    <updated>2020-02-04T09:54:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Beego的结构模块。<a id="more"></a></p><h1 id="1-Session"><a href="#1-Session" class="headerlink" title="1. Session"></a>1. Session</h1><h2 id="1-1-什么是session"><a href="#1-1-什么是session" class="headerlink" title="1.1 什么是session"></a>1.1 什么是session</h2><p>Session的英文意思是会议，在Beego里面用于<strong>会话控制</strong>。Session对象存储特定用户会话所需的属性及配置信息。这样，<strong>当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失</strong>，而是在整个用户会话中一直存在下去。</p><p>通常session实现机制都是<strong>在客户端放一个session ID (cookie)，然后服务端存储一份session数据与之对应。</strong>服务端存储Session的位置可以自由决定，一般有：</p><ul><li>内存</li><li>cookie</li><li>文件</li><li>mysql</li><li>redis</li></ul><h2 id="1-2-session的基本配置"><a href="#1-2-session的基本配置" class="headerlink" title="1.2 session的基本配置"></a>1.2 session的基本配置</h2><p>beego默认不会开启session，所以要先打开，这一步一定要做。</p><pre><code class="lang-go">sessionon = true</code></pre><p>然后设置session id的名字，这个通常都是保存在客户端cookie里面。</p><pre><code class="lang-go">sessionname = &quot;beegosessionID&quot;</code></pre><p>此外我们还可以设置session的过期时间和session id(一般保存在cookie中)的过期时间（默认都是3600秒）</p><pre><code class="lang-go">sessiongcmaxlifetime = 3600SessionCookieLifeTime = 3600</code></pre><h2 id="1-3-session的例子"><a href="#1-3-session的例子" class="headerlink" title="1.3 session的例子"></a>1.3 session的例子</h2><p>我们一个简单的控制器函数：</p><pre><code class="lang-go">func (this *MainController) Get() {    // 读取session数据    v := this.GetSession(&quot;count&quot;)    if v == nil {        // 写入session数据        this.SetSession(&quot;count&quot;, int(1))        this.Data[&quot;num&quot;] = 0    } else {        // 写入session数据        this.SetSession(&quot;count&quot;, v.(int)+1)        this.Data[&quot;num&quot;] = v.(int)    }    this.TplName = &quot;index.html&quot;}</code></pre><p>其中<code>.(int)</code>是<strong>只有对接口对象才能执行类型动态转换</strong>，在模板中写：</p><pre><code class="lang-html">&lt;body&gt;&lt;h1&gt;访问次数:&lt;/h1&gt;&lt;p&gt; {{ if .num}}    已经访问了：{{.num}} 次！{{else}}    还没有访问！{{end}}&lt;/p&gt;&lt;/body&gt;</code></pre><p>只要我们访问<code>localhost:8080/register</code>，就会统计次数，每次刷新都会增加次数。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200203160353.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>除此之外，session还有很多其他读写函数：</p><ul><li>·<code>SetSession(name string, value interface{})</code> - 设置session值</li><li><code>GetSession(name string) interface{}</code> - 读取session值</li><li><code>DelSession(name string)</code> - 删除指定session值</li><li><code>SessionRegenerateID()</code> - 生成新的session id</li><li><code>DestroySession()</code> - 销毁session</li></ul><h2 id="1-4-配置session的存储引擎"><a href="#1-4-配置session的存储引擎" class="headerlink" title="1.4 配置session的存储引擎"></a>1.4 配置session的存储引擎</h2><p>前面提到的session引擎，默认是内存，这一节介绍其他的存储方法。</p><p><strong>（1）文件存储</strong></p><pre><code class="lang-go"># 设置session保存到文件中sessionprovider = &quot;file&quot;# session数据保存目录sessionproviderconfig = &quot;./data/session&quot;</code></pre><p><strong>（2）mysql存储</strong></p><p>首先还是要mysql驱动，</p><pre><code>go get github.com/astaxie/beego/session/redis</code></pre><p>然后在main.go入口导入redis驱动：</p><pre><code class="lang-go">import _ &quot;github.com/astaxie/beego/session/redis&quot;</code></pre><p>然后</p><pre><code class="lang-go"># 设置session存储引擎sessionprovider = &quot;mysql&quot;# mysql存储引擎配置sessionproviderconfig = &quot;root:123456@tcp(localhost:3306)/tizi365?charset=utf8&quot;</code></pre><p>mysql配置格式是：<strong>username</strong>:password@<strong>protocol</strong>(<strong>address</strong>)/<strong>dbname</strong>?<strong>param</strong>=<strong>value</strong>。</p><p><strong>（3）redis存储</strong></p><p>将session数据保存到redis中，需要先安装redis驱动，然后在main.go文件中导入redis驱动。</p><p>配置:</p><pre><code># 设置session存储引擎sessionprovider = &quot;redis&quot;# redis存储引擎配置# redis配置格式: redis地址,redis连接池最大连接数,redis密码# redis连接池和redis密码配置，没有保持为空，例子:127.0.0.1:6379sessionproviderconfig = &quot;127.0.0.1:6379,1000,123456&quot;</code></pre><p>安装redis驱动:</p><pre><code>go get github.com/astaxie/beego/session/redis</code></pre><p>在main.go入口文件，导入redis驱动</p><pre><code>import _ &quot;github.com/astaxie/beego/session/redis&quot;</code></pre><h1 id="2-日志"><a href="#2-日志" class="headerlink" title="2. 日志"></a>2. 日志</h1><p>前导工作：</p><pre><code>go get github.com/astaxie/beego/logs //安装import ( //导入    &quot;github.com/astaxie/beego/logs&quot;)</code></pre><p>然后需要设置日志级别：</p><pre><code class="lang-go">// debug级别logs.SetLevel(logs.LevelDebug)</code></pre><p>下面是常用的日志级别： 由高到底，高于当前日志级别的日志不展示。</p><ul><li>LevelDebug - 对应数字 7</li><li>LevelInfo - 对应数字 6</li><li>LevelWarn - 对应数字 4</li><li>LevelError - 对应数字 3</li></ul><p>然后是日志输出到文件的配置：</p><pre><code class="lang-go">logs.SetLogger(&quot;file&quot;, `{&quot;filename&quot;:&quot;app.log&quot;, &quot;level&quot;:6}`)</code></pre><p>第二个参数是一个map，可以选用的配置有：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">filename</td><td style="text-align:left">日志文件名</td></tr><tr><td style="text-align:left">maxlines</td><td style="text-align:left">每个文件保存的最大行数，默认值 1000000</td></tr><tr><td style="text-align:left">maxsize</td><td style="text-align:left">每个文件保存的最大尺寸，默认值是 1 &lt;&lt; 28, //256 MB</td></tr><tr><td style="text-align:left">daily</td><td style="text-align:left">是否按照每天 logrotate，默认是 true</td></tr><tr><td style="text-align:left">maxdays</td><td style="text-align:left">文件最多保存多少天，默认保存 7 天</td></tr><tr><td style="text-align:left">rotate</td><td style="text-align:left">是否开启 logrotate，默认是 true</td></tr><tr><td style="text-align:left">level</td><td style="text-align:left">日志保存的时候的级别，默认是 Trace 级别</td></tr><tr><td style="text-align:left">perm</td><td style="text-align:left">日志文件权限</td></tr></tbody></table></div><p>最后是调用不同的日志级别在文件中打印日志：</p><pre><code class="lang-go">logs.Debug(&quot;这是一条debug日志, 后面是参数 &quot;, 2019,2018)logs.Info(&quot;携带参数1: %s, 参数2: %d&quot;, &quot;tizi365&quot;, 2019)logs.Warn(&quot;可以直接打印map类型数据 &quot;, map[string]int{&quot;key&quot;: 2019})logs.Error(&quot;参数1&quot;, &quot;参数2&quot;, &quot;后面可以加入任意参数&quot;)</code></pre><p>输出日志：</p><pre><code class="lang-go">2019/06/30 18:38:23.075 [D] [main.go:29] tizi365 这是一条debug日志, 后面是参数  2019 20182019/06/30 18:38:23.149 [I] [main.go:29] tizi365 携带参数1: tizi365, 参数2: 20192019/06/30 18:38:23.149 [W] [main.go:29] tizi365 可以直接打印map类型数据  map[key:2019]2019/06/30 18:38:23.149 [E] [main.go:29] tizi365 参数1 参数2 后面可以加入任意参数</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Beego的结构模块。
    
    </summary>
    
    
      <category term="go" scheme="jiangren.work/categories/go/"/>
    
    
      <category term="计算机网络" scheme="jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="go" scheme="jiangren.work/tags/go/"/>
    
      <category term="Beego" scheme="jiangren.work/tags/Beego/"/>
    
  </entry>
  
  <entry>
    <title>Beego框架学习4-Viewer</title>
    <link href="jiangren.work/2020/02/03/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A04-Viewer/"/>
    <id>jiangren.work/2020/02/03/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A04-Viewer/</id>
    <published>2020-02-03T05:52:26.000Z</published>
    <updated>2020-02-04T10:41:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍MVC之视图viewer。<a id="more"></a></p><h1 id="1-简单的模板应用"><a href="#1-简单的模板应用" class="headerlink" title="1. 简单的模板应用"></a>1. 简单的模板应用</h1><p>beego 的视图(view)模板引擎是基于Go原生的模板库（html/template）进行开发的。</p><p>用户通过在 Controller 的对应方法中设置相应的模板名称，beego <strong>会自动的在 viewpath 目录下查询该文件并渲染</strong>，例如下面的设置，beego 会在 <code>view/admin</code> 下面找 <code>add.tpl</code> 文件进行渲染：</p><pre><code class="lang-go">func (this *RegController) Get(){    this.TplName = &quot;admin/add.tpl&quot;}</code></pre><p>下面举个例子：</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;用户个人信息:&lt;/h1&gt;        &lt;p&gt;            {{ if .user}}            用户名: {{.user.Username}} &lt;br/&gt;            注册时间: {{.user.InitTime}}            {{else}}            用户不存在!            {{end}}        &lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>在控制器中写：</p><pre><code class="lang-go">type User struct {    Id int    Username string    InitTime time.Time}func (this *RegController) Get(){    user:=&amp;User{1,&quot;ming&quot;,time.Now()}    this.Data[&quot;user&quot;]=user    this.TplName=&quot;index.html&quot;}</code></pre><p>网页输出如下：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200203143835.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p><strong>模板的参数依靠<code>Data</code>这个map传递</strong>，如果我们改为<code>this.Data[&quot;users&quot;]</code>那么就将输出：不存在。</p><h1 id="2-模板函数"><a href="#2-模板函数" class="headerlink" title="2. 模板函数"></a>2. 模板函数</h1><p>户还可以自定义模板函数：</p><pre><code class="lang-go">func newfunc(in string)(out string){    out=in+&quot;- 我是新函数&quot;    return}beego.AddFuncMap(&quot;newFunction&quot;,newfunc)</code></pre><p>然后将模板改为：</p><pre><code class="lang-html">{{.title | newFunction}}</code></pre><h1 id="3-静态资源处理"><a href="#3-静态资源处理" class="headerlink" title="3. 静态资源处理"></a>3. 静态资源处理</h1><p>除了html模板之外，往往还存在js/css/jpg之类的静态资源文件，beego默认静态资源都是保存在static目录，访问静态资源的url是 <code>http://域名/static/资源路径名</code>。</p><p>比如如果我们在<code>/static/img</code>下面放了一张<code>cat.jpg</code>，那么我们访问<code>localhost:8080/static/img/cat.jpg</code>就能出现这张图片。</p><p>然而URL这样会变得很冗长，也不清晰。我们我们需要通过<code>beego.SetStaticPath</code>函数设置静态资源路由和目录。</p><pre><code class="lang-go">// 例: /images/user/1.jpg 实际访问的是 static/images/user/1.jpg beego.SetStaticPath(&quot;/images&quot;,&quot;static/images&quot;)// 通过 /css/资源路径  可以访问static/css目录的内容beego.SetStaticPath(&quot;/css&quot;,&quot;static/css&quot;)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍MVC之视图viewer。
    
    </summary>
    
    
      <category term="go" scheme="jiangren.work/categories/go/"/>
    
    
      <category term="计算机网络" scheme="jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="go" scheme="jiangren.work/tags/go/"/>
    
      <category term="Beego" scheme="jiangren.work/tags/Beego/"/>
    
  </entry>
  
  <entry>
    <title>Beego框架学习3-Controller</title>
    <link href="jiangren.work/2020/02/01/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A03-Controller/"/>
    <id>jiangren.work/2020/02/01/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A03-Controller/</id>
    <published>2020-02-01T03:06:03.000Z</published>
    <updated>2020-02-03T13:46:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章介绍Beego的控制器。<a id="more"></a></p><h1 id="1-参数配置"><a href="#1-参数配置" class="headerlink" title="1. 参数配置"></a>1. 参数配置</h1><h2 id="1-1-修改默认配置"><a href="#1-1-修改默认配置" class="headerlink" title="1.1 修改默认配置"></a>1.1 修改默认配置</h2><p>beego默认会解析当前应用下的conf/app.conf文件，通过这个文件你可以初始化很多 beego 的默认参数：</p><pre><code class="lang-go">appname = firstProjecthttpport = 8080runmode = dev</code></pre><p>也可以在配置文件中配置应用需要用的一些配置信息，例如下面所示的数据库信息：</p><pre><code class="lang-go">mysqlUser = &quot;test&quot;mysqlPass = &quot;asdfg12345&quot;mysqlIp =&quot;cdb-axt937vt.gz.tencentcdb.com&quot;mysqlPort=&quot;10059&quot;mysqlDbname = &quot;test&quot;</code></pre><p>可以通过如下的方式获取设置的配置信息:</p><pre><code class="lang-go">m:=beego.AppConfig.String(&quot;mysqlUser&quot;)n:=beego.AppConfig.String(&quot;mysqlPass&quot;)</code></pre><h2 id="1-2-不同级别的配置"><a href="#1-2-不同级别的配置" class="headerlink" title="1.2 不同级别的配置"></a>1.2 不同级别的配置</h2><p>根据不同的运行环境，产品的配置可能不同。</p><p>可以有不同的 Runmode 的配置，默认优先读取 runmode 下的配置信息，例如下面的配置文件，我们可以把配置分成三份，比如dev，prod，test：</p><pre><code class="lang-go">appname = beegoDemorunmode = dev   [dev]httpport = 9527[test]httpport = 5566[prod] httpport = 8082</code></pre><p>读取不同模式下配置参数的方法是“<strong>模式::配置参数名</strong>”，比如：</p><pre><code class="lang-go">beego.AppConfig.String(&quot;dev::mysqluser&quot;)</code></pre><h1 id="2-路由控制"><a href="#2-路由控制" class="headerlink" title="2. 路由控制"></a>2. 路由控制</h1><p>路由指的就是<strong>一个url请求由谁来处理</strong>，我们知道Go的执行过程如下：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200201114228.png"/></p><p>在Beego中默认路由的执行路径是：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200201114740.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>在<code>routers</code>包中，我们看到：</p><pre><code class="lang-go">package routersimport (    &quot;beegoDemo/controllers&quot;    &quot;github.com/astaxie/beego&quot;)func init() {    beego.Router(&quot;/&quot;, &amp;controllers.MainController{})}</code></pre><p>路由初始化中，我们<strong>通过路由注册函数 <code>beego.Router</code>, 注册了一个<code>MainController{}</code>控制器</strong>。第一个参数是 URL (用户请求的地址)，这里我们注册的是 <code>/</code>，也就是我们访问的不带任何参数的 URL。</p><p>在beego设计中，url请求可以由控制器的函数来处理，也可以由一个单独的函数来处理，因此路由设置由两部分组成：<strong>url路由</strong> 和 <strong>处理函数</strong>。beego提供两种设置处理函数的方式:</p><ul><li><strong>直接绑定一个函数</strong></li><li><strong>绑定一个控制器对象</strong> （RESTful方式）</li></ul><h2 id="2-1-处理函数方式"><a href="#2-1-处理函数方式" class="headerlink" title="2.1 处理函数方式"></a>2.1 处理函数方式</h2><h3 id="2-1-1-直接绑定函数"><a href="#2-1-1-直接绑定函数" class="headerlink" title="2.1.1 直接绑定函数"></a>2.1.1 直接绑定函数</h3><p>这种方式直接将一个url路由和一个函数绑定起来。可以用闭包来表示路由，所以可以在<code>router</code>里面直接写：</p><pre><code class="lang-go">beego.Get(&quot;/hel&quot;,func(ctx *context.Context){    ctx.Output.Body([]byte(&quot;hello world&quot;))})</code></pre><p>这个函数借用了Beego提供的Get接口，但<strong>利用闭包重写了方法</strong>，输出<code>hello world</code>。</p><p>此外还有基本的POST路由：</p><pre><code class="lang-go">beego.Post(&quot;/alice&quot;,func(ctx *context.Context){     ctx.Output.Body([]byte(&quot;bob&quot;))})</code></pre><p>所有的支持的基础函数如下所示：</p><ul><li>beego.Get(router, beego.FilterFunc)</li><li>beego.Post(router, beego.FilterFunc)</li><li>beego.Put(router, beego.FilterFunc)</li><li>beego.Head(router, beego.FilterFunc)</li><li>beego.Options(router, beego.FilterFunc)</li><li>beego.Delete(router, beego.FilterFunc)</li><li>beego.Any(router, beego.FilterFunc)</li></ul><h3 id="2-1-2-RESTful路由"><a href="#2-1-2-RESTful路由" class="headerlink" title="2.1.2 RESTful路由"></a>2.1.2 RESTful路由</h3><p>在beego项目中，<strong>RESTful路由方式就是将url路由跟一个控制器对象绑定</strong>，然后Get请求由控制的Get函数处理，Post请求由Post函数处理，以此类推。</p><pre><code class="lang-go">// url: / 的所有http请求方法都由MainController控制器的对应函数处理beego.Router(&quot;/&quot;, &amp;controllers.MainController{})// url: /user 的所有http请求方法都由UserController控制器的对应函数处理beego.Router(&quot;/user&quot;, &amp;controllers.UserController{})</code></pre><p>接下来看一个例子：</p><p><strong>（1）在controller中写：</strong></p><pre><code class="lang-go">package controllersimport (    &quot;github.com/astaxie/beego&quot;)type HelloController struct {    beego.Controller }func (hello *HelloController) Get() {    hello.Ctx.WriteString(&quot;hello go&quot;)}</code></pre><p>这一步中我们声明了一个控制器 <code>HelloController</code>，内嵌了一个<code>beego.Controller</code>，类似于<strong>继承</strong>的效果。然后为控制器安排了一个方法<code>Get()</code>，输出<code>hello go</code>。</p><p><strong>（2）在routers的初始化函数中写：</strong></p><pre><code class="lang-go">beego.Router(&quot;/hello&quot;, &amp;controllers.HelloController{})</code></pre><p><code>/hello</code>是URL的一部分，可以通过<code>localhost:8080/hello</code>访问。</p><h2 id="2-3-路由方式"><a href="#2-3-路由方式" class="headerlink" title="2.3 路由方式"></a>2.3 路由方式</h2><p>这一部分主要介绍url路由的规则，<strong>以下内容都适用于上面介绍的所有路由设置函数。</strong></p><p><strong>（1）固定路由</strong></p><p>最常见的方式，固定路由指的是url规则是固定的一个url。</p><pre><code class="lang-go">beego.Router(&quot;/user&quot;, &amp;controllers.UserController{})beego.Router(&quot;/shop/order&quot;, &amp;controllers.OrderController{})beego.Router(&quot;/shop/comment&quot;, &amp;controllers.CommentController{})</code></pre><p><strong>（2）正则路由</strong></p><p>由正则表达式形成的路由，先看一个例子：</p><p>首先在controller中定义一个控制器：</p><pre><code class="lang-go">type RegExpController struct {    beego.Controller}func (this *RegExpController) Get() {    this.Ctx.WriteString(fmt.Sprintf(&quot;&lt;p&gt;In RegExp Mode&lt;/p&gt;&quot;))    id := this.Ctx.Input.Param(&quot;:id&quot;)    this.Ctx.WriteString(fmt.Sprintf(&quot;id is %s.&lt;br /&gt;&quot;, id))}</code></pre><p>然后在router注册这个控制器，参数可以由<code>:id</code>传递：</p><pre><code class="lang-go">// 正则路由从path中提取参数beego.Router(&quot;/RegExp1/?:id&quot;, &amp;controllers.RegExpController{})// 正则表达式匹配数字，+表示匹配1次或多次beego.Router(&quot;/RegExp2/?:id([0-9]+)&quot;, &amp;controllers.RegExpController{})//匹配下划线和字符beego.Router(&quot;/RegExp3/?:id([\\w]+)&quot;, &amp;controllers.RegExpController{})// http://127.0.0.1:8081/RegExp4/abc123de  (id=123)beego.Router(&quot;/RegExp4/abc:id([0-9]+)de&quot;, &amp;controllers.RegExpController{})</code></pre><p>键入不同的URL，会出现不同的结果：</p><pre><code>键入：localhost:8080/RegExp1/12a显示：In RegExp Modeid is 12a.键入：localhost:8080/RegExp2/12a显示：404键入：localhost:8080/RegExp2/13显示：In RegExp Modeid is 13</code></pre><p><strong>（3）自动路由</strong></p><p>自动路由指的是通过反射获取到控制器的名字和控制器实现的所有函数名字，自动生成url路由。</p><p>假设我们编写了一个<code>UserController</code>控制器，为控制器添加了Login和Logout方法，<strong>正常来说，需要在router里面调用<code>beego.Router</code>两次，分别注册，这样非常麻烦</strong>。</p><p>如果采用自动路由：</p><pre><code class="lang-go">beego.AutoRouter(&amp;controllers.UserController{})</code></pre><p>url自动路由例子:</p><pre><code class="lang-go">/user/login   调用 UserController 中的 Login 方法/user/logout  调用 UserController 中的 Logout 方法</code></pre><h1 id="3-获取请求参数"><a href="#3-获取请求参数" class="headerlink" title="3. 获取请求参数"></a>3. 获取请求参数</h1><p>我们经常需要获取用户传递的数据，包括 Get、POST 等方式的请求，beego里面会自动解析这些数据。</p><h2 id="3-1-默认获取参数的方式"><a href="#3-1-默认获取参数的方式" class="headerlink" title="3.1 默认获取参数的方式"></a>3.1 默认获取参数的方式</h2><p><code>beego.Controller</code>基础控制器为我们提供了<strong>GetXXX</strong>序列获取参数的函数, XXX指的就是返回不同的数据类型。</p><pre><code class="lang-go">type HelloController struct {    beego.Controller }func (this *HelloController) Get(){    id,_:=this.GetInt(&quot;id&quot;)    username:=this.GetString(&quot;username&quot;,&quot;none&quot;)    this.Ctx.WriteString(strconv.Itoa(id))    this.Ctx.WriteString(&quot;   &quot;)    this.Ctx.WriteString(username)}</code></pre><p>URL输入<code>localhost:8080/hello?id=1&amp;username=clearlove</code>。不仅能在网页上看到输出，还能通过控制台看到：</p><pre><code class="lang-go">2020/02/03 12:03:17.185 [D] [server.go:2802]  |  ::1| 200 | 0s|   match| GET  /hello   r:/hello</code></pre><h2 id="3-2-绑定struct方式"><a href="#3-2-绑定struct方式" class="headerlink" title="3.2 绑定struct方式"></a>3.2 绑定struct方式</h2><p>除了上面一个一个的获取请求参数，针对POST请求的表单数据，beego支持<strong>直接将表单数据绑定到一个struct变量。</strong></p><p>上一节的Demo采用的是URL传入参数，这次采用Post表单的形式传入。首先在<code>viewer</code>文件夹下生成一个HTML文件<code>register.html</code>：</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/register&quot; method=&quot;post&quot;&gt;    &lt;table&gt;        &lt;tbody&gt;        &lt;tr&gt;            &lt;td&gt;用户名&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name =&quot;Name&quot; value=&quot;&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;密码&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;password&quot; name =&quot;Pwd&quot; value=&quot;&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;                &lt;input type=&quot;submit&quot; value=&quot;确认&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;/tbody&gt;    &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;</code></pre><p>然后在控制器中写：</p><pre><code class="lang-go">type Users struct {    Name string    Pwd  string}func (this *RegController) Get(){    this.TplName=&quot;register.html&quot;}func (this *RegController) Post(){    user:=Users{}    err := this.ParseForm(&amp;user)    if err!=nil{        fmt.Println(&quot;err:&quot;,err)    }else{        this.Ctx.WriteString(&quot;我是结构体\n&quot;)        this.Ctx.WriteString(&quot;Name=&quot;+user.Name+&quot;\nPwd=&quot;+user.Pwd)    }}</code></pre><p>这段代码的思路是：首先用户访问<code>localhost:8080/register</code>时，Begoo读取<code>register.html</code>资源。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200203130723.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>当用户输入账号密码，点击确认时，触发<code>Post</code>。控制器接收请求，解析到结构体中，然后显示出来。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200203130855.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><hr><p>如同Beego框架学习2中提到的，我们还可以使用标签来控制解析：</p><p>比如给属性设置别名：</p><pre><code class="lang-go">PlayerName string `form:&quot;Name&quot;`</code></pre><p>结果还是没变，因为我们写的就是如此，</p><pre><code class="lang-go">this.Ctx.WriteString(&quot;Name=&quot;+user.PlayerName+...)</code></pre><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200203131217.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>同时我们也可以设置不想解析的内容，比如验证码。</p><pre><code class="lang-go">type Users struct {    Name string     Pwd  string        VerCode string  `form:&quot;-&quot;`  //忽略验证码}</code></pre><h2 id="3-3-处理Json请求"><a href="#3-3-处理Json请求" class="headerlink" title="3.3 处理Json请求"></a>3.3 处理Json请求</h2><p>有时候会将json请求参数保存在http请求的body里面，所以我们需要解析body的内容。</p><p><strong>处理json参数的步骤</strong>：</p><ol><li>在app.conf配置文件中，添加CopyRequestBody=true</li><li>通过this.Ctx.Input.RequestBody获取请求body的内容</li><li>通过json.Unmarshal反序列化json字符串，将json参数绑定到struct变量。</li></ol><pre><code class="lang-go">// 如果json字段跟struct字段名不一样，可以通过json标签设置json字段名type UserForm struct {    // 忽略掉Id字段    Id    int         `json:&quot;-&quot;`    // json字段名为username    Name  string      `json:&quot;username&quot;`    Phone string      }</code></pre><p>控制器代码:</p><pre><code class="lang-go">func (this *UserController) Post() {    // 定义保存json数据的struct对象    u := UserForm{}    // 获取body内容    body := this.Ctx.Input.RequestBody    // 反序列json数据，结果保存至u    if err := json.Unmarshal(body, &amp;u); err == nil {        // 解析参数失败    }}</code></pre><h1 id="4-响应请求"><a href="#4-响应请求" class="headerlink" title="4. 响应请求"></a>4. 响应请求</h1><p>第三章主要描述了如何解析用户的请求，而这一章则是如何返回处理过的请求给用户。</p><h2 id="4-1-返回json数据"><a href="#4-1-返回json数据" class="headerlink" title="4.1 返回json数据"></a>4.1 返回json数据</h2><pre><code class="lang-go">// 如果struct字段名跟json字段名不一样，可以使用json标签,指定json字段名type User struct {    // - 表示忽略id字段    Id       int    `json:&quot;-&quot;`    Username string `json:&quot;name&quot;`    Phone    string}func (this *UserController) Get() {    // 定义需要返回给客户端的数据    user := User{1, &quot;tizi365&quot;, &quot;13089818901&quot;}    // 将需要返回的数据赋值给json字段    this.Data[&quot;json&quot;] = &amp;user    // 将this.Data[&quot;json&quot;]的数据，序列化成json字符串，然后返回给客户端    this.ServeJSON()}</code></pre><h2 id="4-2-返回XML数据"><a href="#4-2-返回XML数据" class="headerlink" title="4.2 返回XML数据"></a>4.2 返回XML数据</h2><pre><code class="lang-go">// 如果struct字段名跟xml字段名不一样，可以使用xml标签,指定xml字段名type User struct {    // - 表示忽略id字段    Id       int    `xml:&quot;-&quot;`    Username string `xml:&quot;name&quot;`    Phone    string}func (this *UserController) Get() {    // 定义需要返回给客户端的数据    user := User{1, &quot;tizi365&quot;, &quot;13089818901&quot;}    // 将需要返回的数据赋值给xml字段    this.Data[&quot;xml&quot;] = &amp;user    // 将this.Data[&quot;xml&quot;]的数据，序列化成xml字符串，然后返回给客户端    this.ServeXML()}</code></pre><h2 id="4-3-返回网页"><a href="#4-3-返回网页" class="headerlink" title="4.3 返回网页"></a>4.3 返回网页</h2><pre><code class="lang-go">func (c *MainController) Get() {    // 设置模板参数    c.Data[&quot;Website&quot;] = &quot;123.com&quot;    c.Data[&quot;Email&quot;] = &quot;asd@demo.com&quot;    // 需要渲染的模板， beego会渲染这个模板，然后返回结果    c.TplName = &quot;index.tpl&quot;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章介绍Beego的控制器。
    
    </summary>
    
    
      <category term="go" scheme="jiangren.work/categories/go/"/>
    
    
      <category term="计算机网络" scheme="jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="go" scheme="jiangren.work/tags/go/"/>
    
      <category term="Beego" scheme="jiangren.work/tags/Beego/"/>
    
  </entry>
  
  <entry>
    <title>Beego框架学习2-Model</title>
    <link href="jiangren.work/2020/01/31/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A02-Model/"/>
    <id>jiangren.work/2020/01/31/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A02-Model/</id>
    <published>2020-01-31T05:05:35.000Z</published>
    <updated>2020-02-04T09:20:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Beego中的model。<a id="more"></a></p><h1 id="1-Model介绍"><a href="#1-Model介绍" class="headerlink" title="1. Model介绍"></a>1. Model介绍</h1><p>beego ORM 是一个强大的 Go 语言 ORM 框架，orm模块主要是处理MVC中的M（models）</p><blockquote><p>对象-关系映射（Object-Relational Mapping，简称ORM）。当我们实现一个应用程序时（不使用O/R Mapping），我们可能会写特别多数据访问层的代码，从数据库保存、删除、读取对象信息，而这些代码都是重复的。而使用ORM则会大大减少重复性代码。</p></blockquote><p>ORM的特性：</p><ul><li><strong>支持范围广</strong>：支持 Go 的所有类型存储</li><li><strong>上手容易</strong>：采用简单的 CRUD 风格，允许直接使用 SQL 查询／映射</li><li><strong>兼容性好</strong>：跨数据库兼容查询</li><li>自动 Join 关联表</li></ul><h1 id="2-基本应用"><a href="#2-基本应用" class="headerlink" title="2. 基本应用"></a>2. 基本应用</h1><h2 id="2-1-数据库设置"><a href="#2-1-数据库设置" class="headerlink" title="2.1 数据库设置"></a>2.1 数据库设置</h2><p>首先需要安装orm模块和mysql驱动：</p><pre><code>// 安装beego orm包go get github.com/astaxie/beego/orm// 安装mysql驱动go get github.com/go-sql-driver/mysql</code></pre><p>同时，也需要导入包：</p><pre><code class="lang-go">import (    // 导入orm包    &quot;github.com/astaxie/beego/orm&quot;    // 导入mysql驱动    _ &quot;github.com/go-sql-driver/mysql&quot;)</code></pre><p>接下来是配置连接信息，配置过程和GoWeb实战1方法相似：</p><pre><code class="lang-go">const(    userName = &quot;test&quot;    password = &quot;asdfg12345&quot;    ip =&quot;cdb-axt937vt.gz.tencentcdb.com&quot;    port=&quot;10059&quot;    dbName = &quot;test&quot;)func init(){    connectInfo:=[]string{userName,&quot;:&quot;,password,&quot;@tcp(&quot;,ip,&quot;:&quot;,port,&quot;)/&quot;, dbName, &quot;?charset=utf8&amp;parseTime=true&amp;loc=Local&quot;}    path:=strings.Join(connectInfo,&quot;&quot;)    orm.RegisterDataBase(&quot;default&quot;,&quot;mysql&quot;,path)    // 打开调试模式，开发的时候方便查看orm生成什么样子的sql语句    orm.Debug=true}</code></pre><hr><p>数据库注册函数的原型如下：</p><pre><code class="lang-go">func RegisterDataBase(aliasName, driverName, dataSource string, params ...int) error</code></pre><div class="table-container"><table><thead><tr><th style="text-align:left">参数名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:left">aliasName</td><td style="text-align:center">数据库的别名，用来在 ORM 中切换数据库使用</td></tr><tr><td style="text-align:left">driverName</td><td style="text-align:center">驱动名字</td></tr><tr><td style="text-align:left">dataSource</td><td style="text-align:center">数据库连接字符串</td></tr><tr><td style="text-align:left">params</td><td style="text-align:center">附加参数</td></tr></tbody></table></div><p>常用的附加参数有：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数名</th><th style="text-align:left">默认值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">charset</td><td style="text-align:left">none</td><td style="text-align:left">设置字符集，相当于 SET NAMES <value> 语句</td></tr><tr><td style="text-align:left">loc</td><td style="text-align:left">UTC</td><td style="text-align:left">设置时区，可以设置为Local，表示根据本地时区走</td></tr><tr><td style="text-align:left">parseTime</td><td style="text-align:left">false</td><td style="text-align:left">是否需要将 mysql的 DATE 和 DATETIME 类型值转换成GO的time.Time类型。</td></tr><tr><td style="text-align:left">readTimeout</td><td style="text-align:left">0</td><td style="text-align:left">I/O 读超时时间, sql查询超时时间. 单位 (“ms”, “s”, “m”, “h”), 例子: “30s”, “0.5m” or “1m30s”.</td></tr><tr><td style="text-align:left">timeout</td><td style="text-align:left">0</td><td style="text-align:left">连接超时时间，单位(“ms”, “s”, “m”, “h”), 例子: “30s”, “0.5m” or “1m30s”.</td></tr></tbody></table></div><h2 id="2-2-准备工作"><a href="#2-2-准备工作" class="headerlink" title="2.2 准备工作"></a>2.2 准备工作</h2><p>首先我们创建一个表，用于测试：</p><pre><code class="lang-sql">CREATE TABLE `online_orders` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增ID&#39;,  `shop_id` int(10) unsigned NOT NULL COMMENT &#39;店铺id&#39;,  `customer_id` int(10) unsigned NOT NULL COMMENT &#39;用户id&#39;,  `nickname` varchar(20) DEFAULT NULL COMMENT &#39;用户昵称&#39;,  `address` varchar(200) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户地址&#39;,  `init_time` datetime NOT NULL COMMENT &#39;创建订单的时间&#39;,   PRIMARY KEY (`id`)  ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><p>id为无符号整形，长度最长为10，不允许空<code>NOT NULL</code>，自增。<code>varchar</code>是可变字符串类型。<code>datetime</code>类型用于存储时间，存储方式是：</p><pre><code>YYYY-MM-DD HH:MM:SS</code></pre><p>建完后可以看到：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200131135944.png"/></p><hr><p>接下来需要构建结构体承载数据：</p><pre><code class="lang-go">type Order struct{    Id int    ShopId int    UserId int `orm:&quot;colunm(customer_id)&quot;`    Nickname string    Address string    InitTime time.Time}</code></pre><p>ORM中结构体和表明的转化规则是驼峰转蛇形，除了开头以外，遇到大写需要<code>_</code>代替：</p><pre><code>AuthUser -&gt; auth_userAuth_User -&gt; auth__userDB_AuthUser -&gt; d_b__auth_user</code></pre><p>所以，<code>ShopId</code>对应的是<code>shop_id</code>，又因为<code>UserId</code>在表中对应的是<code>customer_id</code>，不匹配，所以需要通过orm标签指定表字段名。</p><p>然后我们再为结构体添加一个函数，指定Order结构体默认绑定的表名：</p><pre><code class="lang-go">func (o *Order) TableName() string {    return &quot;orders&quot;}</code></pre><p>最后在main函数中，注册模型</p><pre><code class="lang-go">orm.RegisterModel(new(Order))</code></pre><hr><p>除了前面提到的用column设置名字外，还有其他有用的参数设置：</p><ul><li>忽略字段<code>-</code></li><li>设置自增键<code>auto</code></li><li>设置为主键<code>pk</code></li><li>在数据库默认非空下，允许为空<code>null</code></li></ul><p>比如：</p><pre><code class="lang-go">type User struct {...    AnyField string `orm:&quot;-&quot;`...}</code></pre><h2 id="2-3-CRUD操作"><a href="#2-3-CRUD操作" class="headerlink" title="2.3 CRUD操作"></a>2.3 CRUD操作</h2><p><strong>（1）插入数据</strong></p><p><strong>单条插入：</strong></p><pre><code class="lang-go">orm.RegisterModel(new(Order))o := orm.NewOrm()order:=Order{    ShopId:1,    UserId:1002,    Nickname:&quot;BOB&quot;,    Address: &quot;北京东路&quot;,    InitTime:time.Now(),}id,err:=o.Insert(&amp;order)if err != nil {    fmt.Println(&quot;插入失败,err:&quot;,err)} else {    // 插入成功会返回插入数据自增字段，生成的id    fmt.Println(&quot;新插入数据的id为:&quot;, id)}</code></pre><p><strong>批量插入：</strong></p><pre><code class="lang-go">o := orm.NewOrm()orders := []Order{    {ShopId:1, UserId:1001, Nickname:&quot;大锤1&quot;, Address:&quot;深圳南山区&quot;, InitTime: time.Now()},    {ShopId:1, UserId:1002, Nickname:&quot;大锤2&quot;, Address:&quot;深圳南山区&quot;, InitTime: time.Now()},    {ShopId:1, UserId:1003, Nickname:&quot;大锤3&quot;, Address:&quot;深圳南山区&quot;, InitTime: time.Now()},}// 调用InsertMulti函数批量插入， 第一个参数指的是要插入多少数据nums, err := o.InsertMulti(3, orders)</code></pre><p><strong>（2）更新数据</strong></p><p><strong>更新所有字段：</strong></p><pre><code class="lang-go">orm.RegisterModel(new(Order))o:=orm.NewOrm()order:=Order{}order.Id=1order.Nickname=&quot;希特&quot;order.Address=&quot;四川资阳&quot;order.InitTime=time.Now()num,err:=o.Update(&amp;order)//shop_id和custom_id将会变为0if err != nil {    fmt.Println(&quot;更新失败,err:&quot;,err)} else {    fmt.Println(&quot;更新数据影响的行数:&quot;, num)}</code></pre><p><strong>更新指定字段：</strong></p><pre><code class="lang-go">num, err := o.Update(&amp;order, &quot;Nickname&quot;, &quot;Address&quot;)</code></pre><p><strong>（3）查询数据</strong></p><pre><code class="lang-go">orm.RegisterModel(new(Order))o:=orm.NewOrm()order:=Order{}// 先对主键id赋值, 查询数据的条件就是where id=2order.Id=1err:=o.Read(&amp;order)if err == orm.ErrNoRows {    fmt.Println(&quot;查询不到&quot;)} else if err == orm.ErrMissPK {    fmt.Println(&quot;找不到主键&quot;)} else {    fmt.Println(order.Id, order.Nickname)}</code></pre><p><strong>（4）删除数据</strong></p><pre><code class="lang-go">orm.RegisterModel(new(Order))o := orm.NewOrm()order := Order{}// 先对主键id赋值, 删除数据的条件就是where id=2order.Id = 1if num, err := o.Delete(&amp;order); err != nil {    fmt.Println(&quot;删除失败&quot;)} else {    fmt.Println(&quot;删除数据影响的行数:&quot;, num)}</code></pre><h1 id="3-高级查询"><a href="#3-高级查询" class="headerlink" title="3. 高级查询"></a>3. 高级查询</h1><p>首先重新定义一个用户表</p><pre><code class="lang-sql">CREATE TABLE `users` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增ID&#39;,  `username` varchar(30) NOT NULL COMMENT &#39;账号&#39;,  `password` varchar(100) NOT NULL COMMENT &#39;密码&#39;,  `city` varchar(50) DEFAULT NULL COMMENT &#39;城市&#39;,  `init_time` datetime NOT NULL COMMENT &#39;创建的时间&#39;,    PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><p>然后再定义结构体：</p><pre><code class="lang-go">type User struct{    Id int    Username string    Password string    City string    InitTime time.Time}func (o *User) TableName() string{    return &quot;users&quot;}</code></pre><h2 id="3-1-过滤查询"><a href="#3-1-过滤查询" class="headerlink" title="3.1 过滤查询"></a>3.1 过滤查询</h2><p>过滤查询主要用的是<code>QuerySeter</code>，下面是一个简单的条件查询，查询来自武汉的且生成时间晚于2020年的用户：</p><pre><code class="lang-go">qs:=o.QueryTable(&quot;users&quot;)var users []Usernum,err:=qs.Filter(&quot;city&quot;,&quot;WUHAN&quot;).Filter((&quot;init_time__gt&quot;, &quot;2020-01-01 22:00:00&quot;).All(&amp;users,&quot;id&quot;,&quot;username&quot;)if err!=nil{    panic(err)}fmt.Println(&quot;结果行数:&quot;, num)</code></pre><p>可以看到Filter能连携使用，还能处理大于小于等条件。使用等于条件时：</p><pre><code class="lang-go">qs.Filter(&quot;id&quot;, 1) // 相当于条件 id = 1</code></pre><p>使用不等条件时，用<strong>双下划线</strong> __ 作为分隔符，尾部连接操作符：</p><pre><code class="lang-go">qs.Filter(&quot;id__gt&quot;, 1) // 相当于条件 id &gt; 1qs.Filter(&quot;id__gte&quot;, 1) // 相当于条件 id &gt;= 1qs.Filter(&quot;id__lt&quot;, 1) // 相当于条件 id &lt; 1qs.Filter(&quot;id__lte&quot;, 1) // 相当于条件 id &lt;= 1qs.Filter(&quot;id__in&quot;, 1,2,3,4,5) // 相当于In语句 id in (1,2,3,4,5)</code></pre><p>此外还有其他操作符：</p><ul><li><strong>exact / iexact</strong> 等于，i表示大小写不敏感</li><li><strong>contains / icontains</strong> 包含，i表示大小写不敏感</li><li><strong>gt / gte</strong> 大于 / 大于等于</li><li><strong>lt / lte</strong> 小于 / 小于等于</li><li><strong>startswith / istartswith</strong> 以…起始</li><li><strong>endswith / iendswith</strong> 以…结束</li><li><strong>in</strong> 在其中</li><li><strong>isnull</strong> </li></ul><p>比如：</p><pre><code class="lang-go">qs.Filter(&quot;Username__icontains&quot;, &quot;大锤&quot;) // 相当于条件 name LIKE &#39;%大锤%&#39;qs.Filter(&quot;profile__age__in&quot;, ids)// WHERE profile.age IN (17, 18, 19, 20)</code></pre><h2 id="3-2-复杂查询"><a href="#3-2-复杂查询" class="headerlink" title="3.2 复杂查询"></a>3.2 复杂查询</h2><p>有的时候我们需要将条件组合起来查询，上面的例子多个Filter函数调用只能生成and连接的查询条件。beego orm为我们提供了Condition对象，用于生成查询条件。</p><pre><code class="lang-go">//  创建一个Condition对象cond := orm.NewCondition()// 组织查询条件, 并返回一个新的Condition对象cond1 := cond.And(&quot;Id__gt&quot;, 100).Or(&quot;City&quot;,&quot;shenzhen&quot;)// 相当于条件 id &gt; 100 or city = &#39;shenzhen&#39;var users []Userqs.SetCond(cond1). // 设置查询条件  Limit(10). // 限制返回数据函数  All(&amp;users) // 查询多行数据</code></pre><p>此外还可以连协Count，Group等功能：</p><pre><code class="lang-go">num, _ := o.QueryTable(&quot;users&quot;).Filter(&quot;Id__gt&quot;, 1).Filter(&quot;Id__lt&quot;, 100).Count()num, err := qs.Filter(&quot;Id__gt&quot;, 1).        Filter(&quot;Id__lt&quot;, 100).        GroupBy(&quot;City&quot;).   // 根据city字段分组        OrderBy(&quot;-InitTime&quot;).   // order by字段名前面的减号 - , 代表倒序。        Limit(10). // 限制返回行数        All(&amp;users)</code></pre><h1 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h1><pre><code class="lang-go">// 创建orm对象o := orm.NewOrm()//  开始事务o.Begin()// 开始执行各种sql语句，更新数据库，这里可以使用beego orm支持任何一种方式操作数据库// 例如,更新订单状态_, err1 := o.QueryTable(&quot;orders&quot;).Filter(&quot;Id&quot;, 1001).Update(orm.Params{    &quot;Status&quot;: &quot;SUCCESS&quot;,})// 给用户加积分_, err2 := o.Raw(&quot;update users set points = points + ? where username=?&quot;, &quot;tizi365&quot;, 100).Exec()// 检测事务执行状态if err1 != nil || err2 != nil {    // 如果执行失败，回滚事务    o.Rollback()} else {    // 任务执行成功，提交事务    o.Commit()}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Beego中的model。
    
    </summary>
    
    
      <category term="go" scheme="jiangren.work/categories/go/"/>
    
    
      <category term="计算机网络" scheme="jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="go" scheme="jiangren.work/tags/go/"/>
    
      <category term="Beego" scheme="jiangren.work/tags/Beego/"/>
    
  </entry>
  
  <entry>
    <title>Beego框架学习1-Beego介绍</title>
    <link href="jiangren.work/2020/01/31/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01-Beego%E4%BB%8B%E7%BB%8D/"/>
    <id>jiangren.work/2020/01/31/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01-Beego%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-01-31T04:35:58.000Z</published>
    <updated>2020-02-03T13:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Beego的基本信息。<a id="more"></a></p><h1 id="1-什么是Beego"><a href="#1-什么是Beego" class="headerlink" title="1. 什么是Beego"></a>1. 什么是Beego</h1><h2 id="1-1-Beego的特点"><a href="#1-1-Beego的特点" class="headerlink" title="1.1 Beego的特点"></a>1.1 Beego的特点</h2><p>beego是一个快速开发Go应用的HTTP框架，他可以用来快速开发API、Web及后端服务等各种应用。他的优势在于：</p><ul><li><strong>简单化</strong>：遵从REST设计理念，<strong>通过标准的几个动作来操纵资源</strong>。此外还可以用bee工具辅助，提高开发效率。</li><li><strong>智能化</strong>：beego框架封装了路由模块，支持智能路由，智能监控，并可以监控内存消耗，CPU使用以及goroutine的运行状况，方便开发者对线上应用进行监控分析。</li><li><strong>模块化</strong>：beego根据功能对代码进行解耦封装，形成了Session，Cache，Log，配置解析，性能监控，上下文操作，ORM等独立的模块，方便开发者进行使用。</li><li><strong>高性能</strong>：采用Go原生的http请求，goroutine的并发效率应付大流量的Web应用和API应用。</li></ul><h2 id="1-2-Beego的架构"><a href="#1-2-Beego的架构" class="headerlink" title="1.2 Beego的架构"></a>1.2 Beego的架构</h2><p>Beego由八个独立模块构建，是一个高度解耦的应用，用户可以不使用beego的http逻辑使用里面的任意模块。</p><blockquote><p>解耦，就是将程序积木化，各个积木块都是独立的，只要他们之间的接口（形状）匹配，就可以灵活地组合在一起。</p><p>一个软件系统由多个模块组成，在划分模块时，要把功能关系紧密的放到一个模块中(高内聚)，功能关系远的放到其它模块中。模块之间的联系越少越好，接口越简单越好。</p></blockquote><p>具体框架设计如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://static.bookstack.cn/projects/beego/1501415f03289cea.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这些模块的组成运行逻辑如下：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200131125059.png"/></p><h2 id="1-3-Beego项目结构"><a href="#1-3-Beego项目结构" class="headerlink" title="1.3 Beego项目结构"></a>1.3 Beego项目结构</h2><p>一般的 beego 项目的目录如下所示，这是一个典型的MVC架构。</p><pre><code>├── conf│   └── app.conf├── controllers│   ├── admin│   └── default.go├── main.go├── models│   └── models.go├── static│   ├── css│   ├── ico│   ├── img│   └── js└── views    ├── admin    └── index.tpl</code></pre><blockquote><p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写。</p><ul><li>Model（模型）表示应用程序核心</li><li>View（视图）显示数据（数据库记录）</li><li>Controller（控制器）处理输入（写入数据库记录</li></ul><p>这种设计方法将业务逻辑、数据、界面显示分离的方法组织代码。</p></blockquote><h1 id="2-Beego的安装与运行"><a href="#2-Beego的安装与运行" class="headerlink" title="2. Beego的安装与运行"></a>2. Beego的安装与运行</h1><p>beego 的安装是典型的 Go 安装包的形式：</p><pre><code>go get github.com/astaxie/beego</code></pre><p>如果需要升级则是：</p><pre><code>go get -u github.com/astaxie/beego</code></pre><p>此外，为了快速开发，还需要安装bee工具：</p><pre><code>go get github.com/beego/bee</code></pre><p>以上内容安装好后，我们可在<code>GOPATH/src/github.com</code>中找到源码，以及在<code>GOPATH/bin</code>中找到<code>bee.exe</code>。此外还需要将<code>GOPATH/bin</code>添加到环境变量中。</p><p>如果输入<code>bee version</code>能够出现标志，即说明配置成功。</p><pre><code>______| ___ \| |_/ /  ___   ___| ___ \ / _ \ / _ \| |_/ /|  __/|  __/\____/  \___| \___| v1.10.0</code></pre><hr><p>之后在控制台输入<code>bee new projectname</code>即可创建一个新的项目。运行后，在<code>localhost:8080</code>中可以看到如下标志，即说明项目成功运行。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200131130340.png"/></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍Beego的基本信息。
    
    </summary>
    
    
      <category term="go" scheme="jiangren.work/categories/go/"/>
    
    
      <category term="计算机网络" scheme="jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="go" scheme="jiangren.work/tags/go/"/>
    
      <category term="Beego" scheme="jiangren.work/tags/Beego/"/>
    
  </entry>
  
  <entry>
    <title>GoWeb编程8-测试</title>
    <link href="jiangren.work/2020/01/28/GoWeb%E7%BC%96%E7%A8%8B8-%E6%B5%8B%E8%AF%95/"/>
    <id>jiangren.work/2020/01/28/GoWeb%E7%BC%96%E7%A8%8B8-%E6%B5%8B%E8%AF%95/</id>
    <published>2020-01-28T06:32:31.000Z</published>
    <updated>2020-01-30T12:21:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节介绍如何使用go自带的测试包testing以及第三方测试包对程序进行测试。<a id="more"></a></p><h1 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1. 单元测试"></a>1. 单元测试</h1><h2 id="1-1-基本的测试方法"><a href="#1-1-基本的测试方法" class="headerlink" title="1.1 基本的测试方法"></a>1.1 基本的测试方法</h2><p>单元测试（unit test），就是一种为验证单元的正确性而设置的自动化测试，一个单元就是程序中的一个模块化部分。一般来说，<strong>一个单元通常会与程序中的一个函数或者一个方法相对应</strong>。</p><p>在Go中，以<code>_test.go</code>作为后缀的文件会被当做测试文件，比如<code>main_test.go</code>会被视为<code>main.go</code>的测试文件。</p><p>下面看一个例子，假设我们在<code>main</code>包内，编写了一个JSON解码器函数<code>decode</code>：</p><pre><code class="lang-go">type Post struct{    Id int `json:&quot;id&quot;`    Content string `json:&quot;content&quot;`}func decode(filename string)(post Post,err error){    jsonFile,err := os.Open(filename)    if err!=nil{        fmt.Println(&quot;Error opening JSON file:&quot;, err)        return    }    defer jsonFile.Close()    decoder:=json.NewDecoder(jsonFile)    err = decoder.Decode(&amp;post)    if err != nil {        fmt.Println(&quot;Error decoding JSON:&quot;, err)        return    }    return}</code></pre><p>那么，我们接下来需要创建<code>main_test.go</code>，然后编写：</p><pre><code class="lang-go">func TestDecode(t *testing.T){    post,err := decode(&quot;post.json&quot;)    if err != nil {        t.Error(err)    }    if post.Id != 1 {        t.Error(&quot;Wrong id, was expecting 1 but got&quot;, post.Id)    }}</code></pre><p>测试文件与被测试的源码文件位于同一个包内，它唯一导入并使用的包为<code>testing</code>包。函数<code>TestDecode</code>是一个测试用例，它代表的是对<code>decode</code>函数的单元测试。</p><p><code>testing.T</code>结构拥有几个非常有用的函数：</p><ul><li>Log——将给定的文本记录到错误日志里面，与fmt.Println类似；</li><li>Logf——根据给定的格式，将给定的文本记录到错误日志里面，与fmt.Printf类似；</li><li>Fail——将测试函数标记为“已失败”，但允许测试函数继续执行；</li><li>FailNow——将测试函数标记为“已失败”并停止执行测试函数。</li></ul><p>运行测试用例的方法是，在控制台输入：</p><pre><code>go test</code></pre><p>然后就能看到：</p><pre><code>D:\Go_Practice&gt;go testPASSok      _/D_/Go_Practice        4.478s</code></pre><h2 id="1-2-跳过部分测试"><a href="#1-2-跳过部分测试" class="headerlink" title="1.2 跳过部分测试"></a>1.2 跳过部分测试</h2><p>有些API暂时没有实现，或者某些功能现在不用测试，因此我们需要跳过。跳过的办法是调用<code>skip</code>：</p><pre><code class="lang-go">func TestLongRunningTest(t *testing.T) {      if testing.Short() {            t.Skip(&quot;Skipping long-running test in short mode&quot;)      }      time.Sleep(10 * time.Second)}</code></pre><p>如果我们使用：</p><pre><code>go test -short</code></pre><p>就能跳过被<code>short</code>引导的部分。</p><hr><p>下面是测试部分：</p><p>当我们输入<code>go test</code>时，延时函数被执行：</p><pre><code>PASSok      _/D_/Go_Practice        11.737s</code></pre><p>给定<code>short</code>标志后：</p><pre><code>PASSok      _/D_/Go_Practice        1.756s</code></pre><h2 id="1-3-并行测试"><a href="#1-3-并行测试" class="headerlink" title="1.3 并行测试"></a>1.3 并行测试</h2><p>只要单元测试可以独立地进行，用户就可以通过并行地运行测试用例来提升测试的速度。</p><p>在<code>main_test.go</code>文件所在的目录中创建一个名为<code>parallel_test.go</code>的文件，并在文件中键入代码：</p><pre><code class="lang-go">func TestParallel_1(t *testing.T){    t.Parallel()    time.Sleep(1*time.Second)}func TestParallel_2(t *testing.T){    t.Parallel()    time.Sleep(2*time.Second)}</code></pre><p>这个程序利用<code>time.Sleep</code>函数，以2个测试用例分别模拟了2个需要耗时1s、2s的任务。只要在终端中执行以下命令，Go就会以并行的方式运行测试：</p><pre><code class="lang-go">go test –v –short –parallel 2</code></pre><h2 id="1-4-性能测试"><a href="#1-4-性能测试" class="headerlink" title="1.4 性能测试"></a>1.4 性能测试</h2><p>性能测试也叫基准测试（benchmarking），和之前的功能测试不同，这种测试的目的是检验程序的性能。</p><p>基准测试用例也需要放置到以<code>_test.go</code>为后缀的文件中，并且每个基准测试函数都需要符合以下格式：</p><pre><code class="lang-go">func BenchmarkXxx(*testing.B) { ... }</code></pre><p>比如我们自建一个<code>bench_test.go</code>，然后输入：</p><pre><code class="lang-go">func BenchmarkDecode(b *testing.B){    for i:=0;i&lt;b.N;i++{        decode(&quot;post.json&quot;)    }}</code></pre><p>测试程序要做的就是将被测试的代码执行b.N次，以便准确地检测出代码的响应时间，<strong>其中b.N的值将根据被执行的代码而改变。</strong></p><p>为了运行基准测试用例，用户需要在执行<code>go test</code>命令时使用基准测试标志<code>-bench</code></p><pre><code>go test -v -short –bench .</code></pre><p>点号表示运行目录下的所有基准测试文件，测试结果如下：</p><pre><code>=== RUN   TestDecode--- PASS: TestDecode (0.00s)=== RUN   TestLongRunningTest--- SKIP: TestLongRunningTest (0.00s)    main_test.go:20: Skipping long-running test in short mode=== RUN   TestParallel_1=== PAUSE TestParallel_1=== RUN   TestParallel_2=== PAUSE TestParallel_2=== CONT  TestParallel_1=== CONT  TestParallel_2--- PASS: TestParallel_1 (1.00s)--- PASS: TestParallel_2 (2.00s)goos: windowsgoarch: amd64BenchmarkDecode-8          31851             40615 ns/opPASSok      _/D_/Go_Practice        5.401s</code></pre><p>结果中的31851为测试时b.N的实际值，也就是函数被循环执行的次数。在这个例子中，迭代进行了31851次，并且每次耗费了40615ns，即0.040615ms。</p><p>在进行基准测试时，<strong>测试用例的迭代次数是由Go自行决定的，测试程序将进行足够多次的迭代，直到获得一个准确的测量值为止。</strong></p><p>上面的命令既运行了基准测试，也运行了功能测试。如果需要，用户也可以通过运行标志<code>-run</code>来忽略功能测试。</p><pre><code>go test -run x -bench .</code></pre><h1 id="2-HTTP测试"><a href="#2-HTTP测试" class="headerlink" title="2. HTTP测试"></a>2. HTTP测试</h1><p>前面介绍的是如何测试Go的普通程序，这一篇介绍如何进行Web方面的测试。</p><p>对Go Web应用的单元测试可以通过<code>testing/httptest</code>包来完成。这个包提供了模拟一个Web服务器所需的设施，用户可以利用<code>net/http</code>包中的客户端函数向这个服务器发送HTTP请求，然后获取模拟服务器返回的HTTP响应。</p><pre><code class="lang-go">func TestHandleGet( t *testing.T){    mux:=http.NewServeMux()    mux.HandleFunc(&quot;/order&quot;,handleRequest)    writer:=httptest.NewRecorder()    request,_:=http.NewRequest(&quot;GET&quot;,&quot;order/20005&quot;,nil)    mux.ServeHTTP(writer,request)    if writer.Code != 200 {// 对记录器记载的响应结果进行检查        t.Errorf(&quot;Response code is %v&quot;, writer.Code)    }    var order Orders    json.Unmarshal(writer.Body.Bytes(),&amp;order)    if order.Order_num!=20005{        t.Error(&quot;Cannot retrieve JSON post&quot;)    }}</code></pre><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200130121954.png"  style="zoom:99%;display: block; margin: 0px auto; vertical-align: middle;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节介绍如何使用go自带的测试包testing以及第三方测试包对程序进行测试。
    
    </summary>
    
    
      <category term="go" scheme="jiangren.work/categories/go/"/>
    
    
      <category term="计算机网络" scheme="jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="go" scheme="jiangren.work/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>GoWeb编程6-搭建Web服务</title>
    <link href="jiangren.work/2020/01/26/GoWeb%E7%BC%96%E7%A8%8B6-%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1/"/>
    <id>jiangren.work/2020/01/26/GoWeb%E7%BC%96%E7%A8%8B6-%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-01-26T04:41:21.000Z</published>
    <updated>2020-01-27T13:54:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面提到了Web应用和Web服务的区别，Web服务就是一个向其他软件程序提供服务的程序。本章将扩展这一定义，并展示如何使用Go语言来编写或使用Web服务。<a id="more"></a></p><h1 id="1-基于REST的Web服务"><a href="#1-基于REST的Web服务" class="headerlink" title="1. 基于REST的Web服务"></a>1. 基于REST的Web服务</h1><p>REST（Representational State Transfer，具象状态传输）是一种设计理念，用于设计那些<strong>通过标准的几个动作来操纵资源</strong>，并以此来进行相互交流的程序。</p><p>在OOP面向对象编程中，人们通过创建称为对象（object）的模型来表示事物，然后定义称为方法（method）的函数并将它们附着到模型之上。REST是以上思想的进化版，但它并不是把函数暴露（expose）为可调用的服务，而是以<strong>资源（resource）的名义把模型暴露出来，并允许人们通过少数几个称为动词的动作来操纵这些资源。</strong></p><p>在使用HTTP协议实现REST服务时，URL将用于表示资源，而HTTP方法则会用作操纵资源的动词：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200126125713.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h1 id="2-XML"><a href="#2-XML" class="headerlink" title="2. XML"></a>2. XML</h1><p>下面介绍go语言是如何实现REST服务的。</p><h2 id="2-1-分析XML"><a href="#2-1-分析XML" class="headerlink" title="2.1 分析XML"></a>2.1 分析XML</h2><p>XML可以以结构化的形式表示数据，跟HTML一样，都是一种流行的<strong>标记语言</strong>。</p><p>在Go语言里面，用户首<strong>先需要将XML的分析结果存储到一些结构里面，然后通过访问这些结构来获取XML记录的数据</strong>。</p><ol><li>创建一些用于存储XML数据的结构；</li><li>使用<code>xml.Unmarshal</code>将XML数据解封（unmarshal）到结构里面</li></ol><p>下面举个例子：</p><p>首先创建一个XML文件</p><pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;post id=&quot;1&quot;&gt;    &lt;content&gt;Hello World!&lt;/content&gt;    &lt;author id=&quot;2&quot;&gt;Sau Sheong&lt;/author&gt;&lt;/post&gt;</code></pre><p>在这个XML文件中，包含了一个post结构，由<code>id</code>决定，成员包括了纯粹文本的<code>content</code>和以结构形式出现的<code>author</code>，而<code>author</code>由<code>id</code>决定。</p><pre><code>--- post    --- id    --- content    --- author        --- id        --- author</code></pre><p>由此我们在程序中定义结构，用于表示数据：</p><pre><code class="lang-go">type Post struct{    XMLname xml.Name `xml:&quot;post&quot;`    Id      string   `xml:&quot;id,attr&quot;`    Content string   `xml:&quot;content&quot;`    Author  Author   `xml:&quot;author&quot;`    Xml     string   `xml:&quot;,innerxml&quot;`}type Author struct {    Id   string `xml:&quot;id,attr&quot;`    Name string `xml:&quot;,chardata&quot;`}</code></pre><p><code>Post</code>结构中每个字段的定义后面都带有一段使用反引号（`）包围的信息，这些信息被称为<strong>结构标签</strong>。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200126131208.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p><strong>出于创建映射的需要，xml包要求被映射的结构以及结构包含的所有字段都必须是公开的，也就是，它们的名字必须以大写的英文字母开头。</strong>以上面展示的代码为例，结构的名字必须为Post而不能是post，至于字段的名字则必须为Content而不能是content。</p><p>XML使用的详细规则如下：</p><ol><li>通过创建一个名字为<code>XMLName</code>、类型为<code>xml.Name</code>的字段，可以将XML元素的名字存储在这个字段里面（在一般情况下，结构的名字就是元素的名字）。</li><li>有模式标志<ol><li>通过创建一个与XML元素属性同名的字段，并使用<code>&#39;xml:&quot;&lt;name&gt;,attr&quot;&#39;</code>作为该字段的结构标签，<strong>可以将元素的<code>&lt;name&gt;</code>属性的值存储到这个字段里面。</strong></li><li>通过创建一个与XML元素标签同名的字段，并使用<code>&#39;xml:&quot;,chardata&quot;</code>‘作为该字段的结构标签，<strong>可以将XML元素的字符数据存储到这个字段里面。</strong></li><li>通过定义一个任意名字的字段，并使用<code>&#39;xml:&quot;,innerxml&quot;</code>‘作为该字段的结构标签，可以<strong>将XML元素中的原始XML存储到这个字段里面。</strong></li></ol></li><li>没有模式标志的结构字段将与同名的<code>XML</code>元素匹配。</li><li>使用<code>&#39;xml:&quot;a&gt;b&gt;c</code>“‘这样的结构标签可以在不指定树状结构的情况下直接获取指定的XML元素，其中a和b为中间元素，而c则是想要获取的节点元素。</li></ol><p>我们按照规则，对结构逐一分析：</p><p>根据规则1：分析程序将XML文件中的元素名字<code>post</code>存储到了<code>Post</code>结构体的<code>XMLName</code>字段里面。</p><p>根据规则2a：分析程序通过结构标签<code>xml:&quot;id,attr</code>“将XML文件中的<code>id</code>属性的值存储到了<code>Post</code>结构的<code>Id</code>字段里面。</p><p>根据规则3：分析程序通过结构标签<code>&#39;xml:&quot;content&quot;&#39;</code>将<code>content</code>子元素包含的字符数据存储到了<code>Post</code>结构的<code>Content</code>字段里面。</p><p>根据规则2c：分析程序定义了一个Xml字段，并使用<code>&#39;xml:&quot;,in-nerxml&quot;&#39;</code>作为该字段的结构标签，以此来获得被<code>post</code>元素包含的原始XML：</p><pre><code class="lang-xml">&lt;content&gt;Hello World!&lt;/content&gt;&lt;author id=&quot;2&quot;&gt;Sau Sheong&lt;/author&gt;</code></pre><p>根据规则3，子元素<code>author</code>拥有<code>id</code>属性，并且包含字符数据<code>SauSheong</code>，为了正确地构建映射，分析程序专门定义了<code>Author</code>结构：</p><pre><code class="lang-go">type Author struct {      Id    string `xml:&quot;id,attr&quot;`      Name  string `xml:&quot;,chardata&quot;`}</code></pre><p>运行后输出：</p><pre><code>{{ post} 1 Hello World! {2 Sau Sheong}     &lt;content&gt;Hello World!&lt;/content&gt;    &lt;author id=&quot;2&quot;&gt;Sau Sheong&lt;/author&gt;}</code></pre><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200126133757.png"  style="zoom:85%;display: block; margin: 0px auto; vertical-align: middle;"></p><hr><p>下面展示规则4的使用：</p><pre><code class="lang-xml">&lt; ?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt; post id=&quot;1&quot;&gt;      &lt; content&gt;Hello World!&lt; /content&gt;      &lt; author id=&quot;2&quot;&gt;Sau Sheong&lt; /author&gt;    &lt;!-- 新添加的代码部分 start--&gt;      &lt; comments&gt;            &lt; comment id=&quot;1&quot;&gt;                  &lt; content&gt;Have a great day!&lt; /content&gt;                  &lt; author id=&quot;3&quot;&gt;Adam&lt; /author&gt;        &lt; /comment&gt;            &lt; comment id=&quot;2&quot;&gt;                  &lt; content&gt;How are you today?&lt; /content&gt;                  &lt; author id=&quot;4&quot;&gt;Betty&lt; /author&gt;            &lt; /comment&gt;      &lt; /comments&gt;    &lt;!-- 新添加的代码部分 end--&gt;  &lt; /post&gt;</code></pre><p>新添加代码定义了一个名为<code>comments</code>的XML子元素，并且这个元素本身也包含多个<code>comment</code>子元素。正常来说分析程序需要获取帖子的评论列表，<strong>但为此专门创建一个<code>Comments</code>结构可能会显得有些小题大做了</strong>。为了简化实现代码，分析程序将根据规则56对<code>comments</code>这个XML子元素<strong>进行跳跃式访问。</strong></p><p>首先修改Post结构：</p><pre><code class="lang-go">type Post struct {      XMLName  xml.Name  `xml:&quot;post&quot;`      Id       string    `xml:&quot;id,attr&quot;`      Content  string    `xml:&quot;content&quot;`      Author   Author    `xml:&quot;author&quot;`      Xml      string    `xml:&quot;,innerxml&quot;`      Comments []Comment `xml:&quot;comments&gt;comment&quot;`}</code></pre><p>通过结构标签<code>&#39;xml:&quot;comments&gt;comment&quot;&#39;</code>将这个字段映射至名为<code>comment</code>的XML子元素。根据规则5，<strong>这一结构标签将允许分析程序跳过XML中的<code>comments</code>元素，直接访问<code>comment</code>子元素。</strong></p><p><code>Comment</code>结构和<code>Post</code>结构非常相似，它的具体定义如下：</p><pre><code class="lang-go">type Comment struct {      Id      string `xml:&quot;id,attr&quot;`      Content string `xml:&quot;content&quot;`      Author  Author `xml:&quot;author&quot;`}</code></pre><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200126135459.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><hr><p>这种做法虽然能够很好地处理体积较小的XML文件，但是却无<strong>法高效地处理以流（stream）方式传输的XML文件以及体积较大的XML文件。</strong>为了解决这个问题，我们需要<strong>使用<code>Decoder</code>结构来代替<code>Unmarshal</code>函数，通过手动解码XML元素的方式来解封XML数据</strong>，这个过程如图所示。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200126135634.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>示例如下：</p><pre><code class="lang-go">func main() {      xmlFile, err := os.Open(&quot;post.xml&quot;)      if err != nil {          fmt.Println(&quot;Error opening XML file:&quot;, err)          return      }      defer xmlFile.Close()  decoder := xml.NewDecoder(xmlFile)//①根据给定的XML数据生成相应的解码器  for {//②每迭代一次解码器中的所有XML数据    t, err := decoder.Token()//③每进行一次迭代，就从解码器里面获取一个token    if err == io.EOF {              break          }          if err != nil {              fmt.Println(&quot;Error decoding XML into tokens:&quot;, err)              return          }            switch se := t.(type) {//④检查token的类型      case xml.StartElement:                if se.Name.Local == &quot;comment&quot; {                    var comment Comment                    decoder.DecodeElement(&amp;comment, &amp;se)//⑤将XML数据解码至结构                }          }      }  }</code></pre><p>虽然这段代码只演示了如何解码<code>comment</code>元素，但这种解码方式同样可以应用于XML文件中的其他元素。这个新的分析程序会通过<code>Decoder</code>结构，一个元素接一个元素地对XML进行解码，而不是像之前那样，使用<code>Unmarshal</code>函数一次将整个XML解封为字符串。</p><h2 id="2-2-创建XML"><a href="#2-2-创建XML" class="headerlink" title="2.2 创建XML"></a>2.2 创建XML</h2><p>go中将结构封装为XML用到了函数<code>marshal</code>。</p><p>装程序首先需要创建表示帖子的<code>post</code>结构，并向结构里面填充数据，然后只要调用<code>Marshal</code>函数，就可以根据<code>Post</code>结构创建相应的XML了</p><pre><code class="lang-go">func main() {      post := Post{          Id:      &quot;1&quot;,            Content: &quot; Hello World!&quot;,//①创建结构并向里面填充数据        Author: Author{            Id:   &quot;2&quot;,                  Name: &quot;Sau Sheong&quot;,         },    }    output, err := xml.Marshal(&amp;post)     _ = ioutil.WriteFile(&quot;post.xml&quot;, output, 0644)  }</code></pre><p>这样输出的XML是没有换行的，格式不太好，可以使用<code>MarshalIndent</code>函数。</p><pre><code class="lang-go">output, err := xml.MarshalIndent(&amp;post, &quot;&quot;, &quot;\t&quot;)</code></pre><p><code>MarshalIndent</code>函数还接受两个额外的参数，这两个参数分别用于指定添加到每个输出行前面的前缀以及缩进，其中缩进的数量会随着元素的嵌套层次增加而增加。</p><p>但是这段输出还没有添加XML声明，我们需要手动添加：</p><pre><code class="lang-go">err = ioutil.WriteFile(&quot;post.xml&quot;, []byte(xml.Header + string(output)), 0644)</code></pre><hr><p>同理，也可以手动使用<code>Encoder</code>编码：</p><pre><code class="lang-go">encoder := xml.NewEncoder(xmlFile)// 根据给定的XML文件，创建出相应的编码器encoder.Indent(&quot;&quot;, &quot;\t&quot;)  err = encoder.Encode(&amp;post)// 把结构编码至文件</code></pre><h1 id="3-JSON"><a href="#3-JSON" class="headerlink" title="3. JSON"></a>3. JSON</h1><h2 id="3-1-分析JSON"><a href="#3-1-分析JSON" class="headerlink" title="3.1 分析JSON"></a>3.1 分析JSON</h2><p><strong>JSON（JavaScript Object Notation）是衍生自JavaScript语言的一种轻量级的文本数据格式，这种格式的主要设计理念是既能够轻易地被人类读懂，又能够简单地被机器读取。</strong></p><p>JSON分析的过程和XML非常相似：</p><ol><li>创建一些用于包含JSON数据的结构；</li><li>通过<code>json.Unmarshal</code>函数，把JSON数据解封到结构里面。</li></ol><p>跟映射XML相比，把结构映射至JSON要简单得多，后者只有一条通用的规则：对于名字为<code>&lt;name&gt;</code>的JSON键，用户只需要在结构里创建一个任意名字的字段，并将该字段的结构标签设置为<code>&#39;json:&quot;&lt;name&gt;&quot;&#39;</code>，就可以把JSON键<code>&lt;name&gt;</code>的值存储到这个字段里面。</p><p>JSON文件：</p><pre><code class="lang-json">{        &quot;id&quot; : 1,        &quot;content&quot; : &quot;Hello World!&quot;,        &quot;author&quot; : {              &quot;id&quot; : 2,              &quot;name&quot; : &quot;Sau Sheong&quot;        },        &quot;comments&quot; : [              {                    &quot;id&quot; : 3,                    &quot;content&quot; : &quot;Have a great day!&quot;,                    &quot;author&quot; : &quot;Adam&quot;              },              {                    &quot;id&quot; : 4,                    &quot;content&quot; : &quot;How are you today?&quot;,                    &quot;author&quot; : &quot;Betty&quot;              }        ]  }</code></pre><p>go的json分析程序：</p><pre><code class="lang-go">type Post struct {      Id       int       `json:&quot;id&quot;`// 定义一些结构，用于表示数据    Content  string    `json:&quot;content&quot;`      Author   Author    `json:&quot;author&quot;`      Comments []Comment `json:&quot;comments&quot;`}type Author struct {      Id   int    `json:&quot;id&quot;`      Name string `json:&quot;name&quot;`}type Comment struct {      Id      int    `json:&quot;id&quot;`      Content string `json:&quot;content&quot;`      Author  string `json:&quot;author&quot;`}func main() {      jsonFile, err := os.Open(&quot;post.json&quot;)      defer jsonFile.Close()      jsonData, err := ioutil.ReadAll(jsonFile)      var post Post      json.Unmarshal(jsonData, &amp;post)//将JSON数据解封至结构    fmt.Println(post)}</code></pre><p>为了将JSON键<code>id</code>的值映射到<code>Post</code>结构的<code>Id</code>字段，程序将该字段的结构标签设置成了<code>&#39;json:&quot;id&quot;&#39;</code>，这种设置基本上就是将结构映射至JSON数据所需完成的全部工作。</p><hr><p>当然也可以用<code>Decoder</code>手动地将JSON数据解码到结构里面。</p><pre><code class="lang-go">jsonFile, err := os.Open(&quot;post.json&quot;)defer jsonFile.Close()decoder := json.NewDecoder(jsonFile)//根据给定的JSON文件，创建出相应的解码器for {//遍历JSON文件，直到遇见EOF为止     var post Post      err := decoder.Decode(&amp;post)//将JSON数据解码至结构      if err == io.EOF {        break      }      fmt.Println(post)}</code></pre><h2 id="3-2-创建JSON"><a href="#3-2-创建JSON" class="headerlink" title="3.2 创建JSON"></a>3.2 创建JSON</h2><p>创建过程和XML类似，首先创建结构，然后调用函数将其封装为JSON数据。</p><pre><code class="lang-go">type Post struct {//创建结构并向里面填充数据        Id       int       `json:&quot;id&quot;`        Content  string    `json:&quot;content&quot;`        Author   Author    `json:&quot;author&quot;`        Comments []Comment `json:&quot;comments&quot;`  }  type Author struct {        Id   int    `json:&quot;id&quot;`        Name string `json:&quot;name&quot;`  }  type Comment struct {        Id      int    `json:&quot;id&quot;`        Content string `json:&quot;content&quot;`        Author  string `json:&quot;author&quot;`  }func main() {        post := Post{              Id:      1,              Content: &quot;Hello World!&quot;,              Author: Author{                    Id:   2,                    Name: &quot;Sau Sheong&quot;,            },            Comments: []Comment{                  Comment{                        Id:      3,                    Content: &quot;Have a great day!&quot;,                        Author:  &quot;Adam&quot;,                  },                  Comment{                        Id:      4,                        Content: &quot;How are you today?&quot;,                        Author:  &quot;Betty&quot;,                  },            },     }      output, err := json.MarshalIndent(&amp;post, &quot;&quot;, &quot;\t\t&quot;)//把结构封装为由字节切片组成的JSON数据     err = ioutil.WriteFile(&quot;post.json&quot;, output, 0644)  }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面提到了Web应用和Web服务的区别，Web服务就是一个向其他软件程序提供服务的程序。本章将扩展这一定义，并展示如何使用Go语言来编写或使用Web服务。
    
    </summary>
    
    
      <category term="go" scheme="jiangren.work/categories/go/"/>
    
    
      <category term="计算机网络" scheme="jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="go" scheme="jiangren.work/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>GoWeb编程5-存储数据</title>
    <link href="jiangren.work/2020/01/25/GoWeb%E7%BC%96%E7%A8%8B5-%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE/"/>
    <id>jiangren.work/2020/01/25/GoWeb%E7%BC%96%E7%A8%8B5-%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE/</id>
    <published>2020-01-25T07:41:29.000Z</published>
    <updated>2020-01-26T12:40:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章介绍go中对数据如何进行持久化，说明如何才能将数据存储到内存、文件、关系数据库以及<code>NoSQL</code>数据库中。<a id="more"></a></p><p>Web应用通常会采取以下手段存储数据：</p><ul><li>在程序运行时，将数据存储到内存里面；</li><li>将数据存储到文件系统的文件里面；</li><li>通过服务器程序前端，将数据存储到数据库里面。</li></ul><h1 id="1-文件存储"><a href="#1-文件存储" class="headerlink" title="1. 文件存储"></a>1. 文件存储</h1><p>内存存储无法做到持久化，Go持久化有两种：<strong>CSV和gob包</strong>。</p><h2 id="1-1-CSV文件"><a href="#1-1-CSV文件" class="headerlink" title="1.1 CSV文件"></a>1.1 CSV文件</h2><p>CSV，即comma separated value，<strong>逗号分隔值文本格式</strong>。</p><p>当你需要用户提供大量数据，但是却因为某些原因而无法让用户把数据填入你提供的表单时，CSV格式就可以派上用场了：你只需要让用户<strong>使用电子表格程序（spreadsheet）输入所有数据，然后将这些数据导出为CSV文件，并将其上传到你的Web应用中</strong>，这样就可以在获得CSV文件之后，根据自己的需要对数据进行解码。同样地，你的Web应用也可以将用户的数据打包成CSV文件，然后通过向用户发送CSV文件来为他们提供数据。</p><p>对Go语言来说，CSV文件可以通过<code>encoding/csv</code>包进行操作。</p><p>下面展示如何写入CSV文件：</p><ol><li>创建一个名为<code>post.csv</code>的文件</li><li>创建一个post切片，作为数据源</li><li>使用<code>NewWriter</code>函数创建一个新的写入器<code>writer</code>，并把文件用作参数，将其传递给写入器</li><li>利用写入器迭代地写入数据</li><li>FLUSH刷新缓冲区</li></ol><pre><code class="lang-go">type post struct{    Id int    Content string    Author string}func main(){    csvFile,err:=os.Create(&quot;post.csv&quot;)    if err!=nil{        panic(err)    }    defer csvFile.Close()    allposts:=[]post{        post{Id:1,Content:&quot;hello&quot;,Author:&quot;Bob&quot;},        post{Id:2,Content:&quot;world&quot;,Author:&quot;Tom&quot;},    }    writer:=csv.NewWriter(csvFile)    for _,post:=range allposts{        line := []string{strconv.Itoa(post.Id),post.Content,post.Author}        err := writer.Write(line)        if err!=nil{            panic(err)        }    }    writer.Flush()}</code></pre><p>下面展示如何读取CSV文件：</p><pre><code class="lang-go">func main(){    file,err:=os.Open(&quot;post.csv&quot;)    if err != nil{        panic(err)    }    defer file.Close()    reader:=csv.NewReader(file)    reader.FieldsPerRecord = -1    record ,err :=reader.ReadAll()    if err != nil{        panic(err)    }    var posts []post    for _, item:= range record{        id, _ := strconv.ParseInt(item[0], 0, 0)        post := post{Id: int(id), Content: item[1], Author: item[2]}        posts = append(posts,post)    }    fmt.Println(posts[0].Id)    fmt.Println(posts[0].Content)    fmt.Println(posts[0].Author)}</code></pre><h2 id="1-2-gob包"><a href="#1-2-gob包" class="headerlink" title="1.2 gob包"></a>1.2 gob包</h2><p><code>encoding/gob</code>包用于管理由<code>gob</code>组成的流（stream），这是一种<strong>在编码器（encoder）和解码器（decoder）之间进行交换的二进制数据</strong>，这种数据原本是为序列化以及数据传输而设计的，但它也可以用于对数据进行持久化。</p><pre><code class="lang-go">func store(data interface{}, filename string) {//  ①        buffer := new(bytes.Buffer)        encoder := gob.NewEncoder(buffer)        err := encoder.Encode(data)        if err != nil {                panic(err)        }        err = ioutil.WriteFile(filename, buffer.Bytes(), 0600)        if err != nil {                panic(err)        }}</code></pre><p>存储函数的第一个参数是空接口，而第二个参数则是被存储的二进制文件的名字。<strong>空接口参数能够接受任意类型的数据作为值。</strong></p><ol><li><code>store</code>函数会创建一个<code>bytes.Buffer</code>结构，这是是一个<strong>拥有<code>Read</code>方法和<code>Write</code>方法的可变长度（variable sized）字节缓冲区</strong>，既是<strong>读入器也是写入器</strong></li><li>把缓冲区传递给<code>NewEncoder</code>函数，以此来创建出一个<code>gob</code>编码器。接着将数据编码到缓冲区里面。</li><li>将缓冲区中已编码的数据写入文件。</li></ol><p>load方法正好相反：</p><pre><code class="lang-go">func load(data interface{}, filename string) {// ②        raw, err := ioutil.ReadFile(filename)        if err != nil {                panic(err)        }        buffer := bytes.NewBuffer(raw)        dec := gob.NewDecoder(buffer)        err = dec.Decode(data)        if err != nil {                panic(err)        }}</code></pre><ol><li>从文件里面读取出未经处理的原始数据</li><li>根据这些原始数据创建一个缓冲区，并藉此为原始数据提供相应的<code>Read</code>方法和<code>Write</code>方法</li><li>调用<code>NewDecoder</code>函数，为缓冲区创建相应的解码器</li><li>使用解码器去解码从文件中读取的原始数据，并最终得到之前写入的真正的数据。</li></ol><h1 id="2-Go与SQL"><a href="#2-Go与SQL" class="headerlink" title="2. Go与SQL"></a>2. Go与SQL</h1><p>以postgres数据库为例，讲解如何利用go对数据库操作。</p><h2 id="2-1-连接数据库"><a href="#2-1-连接数据库" class="headerlink" title="2.1 连接数据库"></a>2.1 连接数据库</h2><p>首先需要创建数据库句柄，程序首先使用<code>Db</code>变量定义了一个指向<code>sql.DB</code>结构的指针，然后使用<code>init()</code>函数来初始化这个变量（Go语言的每个包都会自动调用定义在包内的<code>init()</code>函数）。</p><pre><code class="lang-go">func init() {        var err error        Db, err = sql.Open(&quot;postgres&quot;, &quot;user=gwp dbname=gwp password=gwp sslmode=disable&quot;)     if err != nil {                panic(err)        }}</code></pre><p><code>sql.DB</code>结构是一个数据库句柄（handle），它代表的是一个包含了零个或任意多个数据库连接的连接池（pool），这个连接池由sql包管理。程序可以通过调用<code>Open</code>函数，<strong>并将相应的数据库驱动名字（driver name）以及数据源名字（data source name）传递给该函数来建立与数据库的连接。</strong></p><p><code>Open</code>函数在执行时并不会真正地与数据库进行连接，真正作用是设置好连接数据库所需的各个结构，并以惰性的方式，等到真正需要时才建立相应的数据库连接。</p><hr><p>我们采用第三方程序注册数据库：</p><pre><code class="lang-go">import (        &quot;fmt&quot;        &quot;database/sql&quot;        _ &quot;github.com/lib/pq&quot;)</code></pre><p><code>github.com/lib/pq</code>包就是程序导入的<code>Postgres</code>驱动，在导入这个包之后，包内定义的<code>init</code>函数就会被调用，并对其自身进行注册。因为<strong>Go语言没有提供任何官方数据库驱动，所以Go语言的所有数据库驱动都是第三方函数库，并且这些库必须遵守<code>sql.driver</code>包中定义的接口。</strong></p><h2 id="2-2-创建数据"><a href="#2-2-创建数据" class="headerlink" title="2.2 创建数据"></a>2.2 创建数据</h2><p>代码如下：</p><pre><code class="lang-go">func (post *Post) Create() (err error) {        statement := &quot;insert into posts (content, author) values ($1, $2) returning id &quot;        stmt, err := db.Prepare(statement)        if err != nil {                  return        }        defer stmt.Close()        err = stmt.QueryRow(post.Content, post.Author).Scan(&amp;post.Id)        if err != nil {                  return        }        return}</code></pre><p><code>func</code>和<code>Create</code>之间的括号表明了<code>Create</code>函数是<code>Post</code>结构的一个方法。</p><p><strong>（1）定义一条SQL预处理语句</strong></p><p>一条预处理语句（prepared statement）就是一个<code>SQL</code>语句模板，这种语句通常<strong>用于重复执行</strong>指定的<code>SQL</code>语句，<strong>用户在执行预处理语句时需要为语句中的参数提供实际值</strong>。</p><p>在创建数据库记录的时候，<code>Create</code>函数就会使用实际值去替换以下语句中的<code>$1</code>和<code>$2</code>。</p><p>创建完后，利用<code>sql.DB</code>结构的<code>Prepare</code>方法记性转化，创建一个指向<code>sql.Stmt</code>接口的引用。</p><pre><code class="lang-go">stmt, err := db.Prepare(statement)</code></pre><p>（<strong>2）执行预处理语句</strong></p><p>调用预处理语句的<code>QueryRow</code>方法，并把来自接收者的数据传递给该方法，以此来执行预处理语句：</p><pre><code class="lang-go">err = stmt.QueryRow(post.Content, post.Author).Scan(&amp;post.Id)</code></pre><p>scan的目的是让数据库的Id和post原有的id同步。Scan可以把数据库取出的字段值赋值给指定的数据结构。它的参数是一个空接口的切片，这就意味着可以传入任何值。<strong>通常把需要赋值的目标变量的指针当成参数传入，它能将数据库取出的值赋值到指针值对象上</strong>。</p><h2 id="2-3-查询数据"><a href="#2-3-查询数据" class="headerlink" title="2.3 查询数据"></a>2.3 查询数据</h2><p>代码如下：</p><pre><code class="lang-go">func GetPost(id int) (post Post, err error) {        post = Post{}        err = Db.QueryRow(&quot;select id, content, author from posts where id = $1&quot;, id)        .Scan(&amp;post.Id, &amp;post.Content, &amp;post.Author)    return}</code></pre><p>假设我们不需要重复使用查询语句，所以就不必邀使用stmt结构。程序通过串联<code>QueryRow</code>方法和<code>Scan</code>方法，<strong>将执行查询所得的数据复制到空的<code>Post</code>结构里面</strong>。</p><p>调用方法如下：</p><pre><code class="lang-go">readPost, _ := GetPost(1)</code></pre><hr><p>也可以一次性获取多个数据</p><pre><code class="lang-go">func Posts(limit int) (posts []Post, err error) {        rows, err := Db.Query(&quot;select id, content, author from posts limit $1&quot;, limit)        if err != nil {                return        }        for rows.Next() {                post := Post{}                err = rows.Scan(&amp;post.Id, &amp;post.Content, &amp;post.Author)                if err != nil {                        return                }                posts = append(posts, post)        }        rows.Close()        return}</code></pre><p>来执行查询，这个方法会返回一个<code>Rows</code>接口。<code>Rows</code>接口是一个迭代器，程序可以通过重复调用它的<code>Next</code>方法来对其进行迭代并获得相应的<code>sql.Row</code>；当所有行都被迭代完毕时，<code>Next</code>方法将返回<code>io.EOF</code>作为结果。</p><h2 id="2-3-更新数据"><a href="#2-3-更新数据" class="headerlink" title="2.3 更新数据"></a>2.3 更新数据</h2><p>代码如下：</p><pre><code class="lang-go">func (post *Post) Update() (err error) {        _, err = Db.Exec(&quot;update posts set content = $2, author = $3 where id = $1&quot;,            post.Id, post.Content, post.Author)        return}</code></pre><p>直接调用<code>sql.DB</code>结构的<code>Exec</code>方法，原因主要是不需要对对接收者进行任何更新，<strong>所以不需要使用SCAN扫描方法</strong>，才会选择使用速度更快的<code>Exec</code>方法来执行查询。</p><p><code>Exec</code>方法会返回一个<code>sql.Result</code>和一个可能出现的错误，其中<code>sql.Result</code>记录的是受查询影响的行的数量以及可能会出现的最后插入<code>id</code>。因为更新操作对<code>sql.Result</code>记录的这两项信息都不感兴趣，所以程序会通过将<code>sql.Result</code>赋值给下划线<code>_</code>来忽略它。</p><p>调用如下：</p><pre><code class="lang-go">readPost.Content = &quot;Bonjour Monde!&quot;readPost.Author = &quot;Pierre&quot;readPost.Update()</code></pre><h2 id="2-4-删除数据"><a href="#2-4-删除数据" class="headerlink" title="2.4 删除数据"></a>2.4 删除数据</h2><p>代码如下：</p><pre><code class="lang-go">func (post *Post) Delete() (err error) {        _, err = Db.Exec(&quot;delete from posts where id = $1&quot;, post.Id)        return}</code></pre><h1 id="3-数据库关系"><a href="#3-数据库关系" class="headerlink" title="3. 数据库关系"></a>3. 数据库关系</h1><p>关系型数据库很重要的一个特征是：它可以在表与表之间建立关系，从而使不同的数据能够以一种一致且易于理解的方式互相进行关联。</p><p>按照如下的思路创建数据库表，就可以达到联结的效果：</p><pre><code class="lang-sql">create table posts (      id     serial primary key,      content text,      author  varchar(255));create table comments (      id     serial primary key,      content text,      author  varchar(255),      post_id integer references posts(id));</code></pre><p><code>comments</code>表的大部分列都跟<code>posts</code>表一样，主要区别在于<code>comments</code>表多了一个额外的<code>post_id</code>列：这个<code>post_id</code>会作为外键（foreign key），对<code>posts</code>表的主键<code>id</code>进行引用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章介绍go中对数据如何进行持久化，说明如何才能将数据存储到内存、文件、关系数据库以及&lt;code&gt;NoSQL&lt;/code&gt;数据库中。
    
    </summary>
    
    
      <category term="go" scheme="jiangren.work/categories/go/"/>
    
    
      <category term="计算机网络" scheme="jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="go" scheme="jiangren.work/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>GoWeb编程4-内容展示</title>
    <link href="jiangren.work/2020/01/25/GoWeb%E7%BC%96%E7%A8%8B4-%E5%86%85%E5%AE%B9%E5%B1%95%E7%A4%BA/"/>
    <id>jiangren.work/2020/01/25/GoWeb%E7%BC%96%E7%A8%8B4-%E5%86%85%E5%AE%B9%E5%B1%95%E7%A4%BA/</id>
    <published>2020-01-25T04:17:03.000Z</published>
    <updated>2020-01-27T13:42:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Web页面的展示依靠的是模板技术，<strong>Web模板就是一些预先设计好的 HTML 页面</strong>，模板引擎会通过重复地使用这些页面来创建一个或多个 HTML 页面。<a id="more"></a></p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200125122355.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h1 id="1-Go的模板引擎"><a href="#1-Go的模板引擎" class="headerlink" title="1. Go的模板引擎"></a>1. Go的模板引擎</h1><p>Go 语言的模板引擎也是介于<strong>无逻辑模板引擎</strong>和<strong>嵌入逻辑模板引擎</strong>之间的一种模板引擎。</p><p>Go 的模板都是文本文档（其中 Web 应用的模板通常都是 HTML ），它们<strong>都嵌入了一些称为动作（ action ）的指令</strong>。 从模板引擎的角度来说，<strong>模板就是嵌入了动作的文本，而模板引擎则通过分析并执行这些文本来生成出另外一些文本</strong>。 </p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200125123816.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="1-1-模板的使用过程"><a href="#1-1-模板的使用过程" class="headerlink" title="1.1 模板的使用过程"></a>1.1 模板的使用过程</h2><p>模板中的动作默认使用两个大括号包围。下面就是一个简单的模板：</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html&gt;      &lt;head&gt;            &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;            &lt;title&gt;Go Web Programming&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;            {{ . }}      &lt;/body&gt;&lt;/html&gt;</code></pre><p>代码的模板来源于一个名为 tmpl.html 的模板文件。<strong>用户可以拥有任意多个模板文件， 并且这些模板文件可以使用任意后缀名，但它们的类型必须是可读的文本格式。</strong> 因为 上面这段模板的输出将是一个HTML文件，所以我们使用了.html作为模板文件的后缀名。 </p><pre><code class="lang-go">func process(w http.ResponseWriter, r *http.Request){    t,_:=template.ParseFiles(&quot;tmpl.html&quot;)    t.Execute(w,&quot;hello world&quot;)}func main(){    server:=http.Server{        Addr: &quot;127.0.0.1:8080&quot;,    }    http.HandleFunc(&quot;/process&quot;,process)    server.ListenAndServe()}</code></pre><p>上面的代码展示了使用模板的两个关键步骤：</p><ul><li>调用模板引擎分析模板</li><li>将数据填入模板引擎，充实动作</li></ul><p><code>ResponseWriter</code> 和数据会一起被传入 <code>Execute</code> 方法中，这样一来，模板引擎在生成 HTML 之后就可以把该HTML文件传给 <code>ResponseWriter</code>了。</p><h2 id="1-2-对模板进行语法分析"><a href="#1-2-对模板进行语法分析" class="headerlink" title="1.2 对模板进行语法分析"></a>1.2 对模板进行语法分析</h2><p>当用户调用 ParseFiles 函数的时候， Go会创建一个新的模板，并将用户给定的模板文件的名字用作这个新模板的名字：</p><pre><code class="lang-go">t,_ :=template.ParseFiles(&quot;tmpl.html&quot;)//等价于t := template.New(&quot;tmpl.html&quot;)t,_ := t.ParseFiles(&quot;tmpl.html&quot;)</code></pre><p><code>ParseFiles</code>函数<strong>可以接受任意数量的文件作为参数</strong>，会将他们合并视为一个<strong>模板集合</strong>。</p><p>我们也可以使用<code>ParseGlob</code>进行全局模板分析，读取所有html文件。</p><pre><code class="lang-go">t,_ := template.ParseGlob(&quot;*.html&quot;)</code></pre><h2 id="1-3-执行模板"><a href="#1-3-执行模板" class="headerlink" title="1.3 执行模板"></a>1.3 执行模板</h2><p>但如果模板不止一个，那么当对模板集合调用 Execute 方法的时候， <strong>Execute方法只会执行模板集合中的第一个模板。</strong> </p><pre><code class="lang-go">t, _ := template.ParseFiles(&quot;t1.html&quot;,&quot;t2.html&quot;)t.Execute(w,&quot;Hello!&quot;)</code></pre><p>如果想执行另一个，就需要使用函数<code>ExecuteTemplate</code>：</p><pre><code class="lang-go">t.ExecuteTemplate(w, &quot;t2.html&quot;,&quot;Hello&quot;)</code></pre><h1 id="2-动作"><a href="#2-动作" class="headerlink" title="2. 动作"></a>2. 动作</h1><h2 id="2-1-条件动作"><a href="#2-1-条件动作" class="headerlink" title="2.1 条件动作"></a>2.1 条件动作</h2><p>条件动作会根据参数的值来决定对多条语句中的哪一条语句进行求值。最简单的条件动作的格式如下：</p><pre><code>{{ if arg }}  some content{{ end }}</code></pre><p>这个动作的另一种格式如下：</p><pre><code>{{ if arg }}some content{{ else }}other content{{ end }}</code></pre><p>下面的Demo中，我们会在服务器上面创建一个处理器，这个处理器会随机0-10之间的整数，然后通过判断这个随机整数是否大于5。</p><pre><code class="lang-go">func process(w http.ResponseWriter, r *http.Request) {        t, _ := template.ParseFiles(&quot;tmpl.html&quot;)        rand.Seed(time.Now().Unix())        t.Execute(w, rand.Intn(10) &gt; 5)}</code></pre><p>将模板文件的body改为：</p><pre><code class="lang-html">&lt;body&gt;        {{ if . }}          Number is greater than 5!        {{ else }}          Number is 5 or less!       {{ end }}  &lt;/body&gt;</code></pre><h2 id="2-2-迭代动作"><a href="#2-2-迭代动作" class="headerlink" title="2.2 迭代动作"></a>2.2 迭代动作</h2><p>迭代动作可以对数组、切片、映射或者通道进行迭代，而在迭代循环的内部，<strong>点<code>.</code>则会被设置为当前被迭代的元素</strong>，就像这样：</p><pre><code>{{ range array }}    Dot is set to the element {{ . }}{{ end }}</code></pre><p>下面是一个使用了迭代动作的例子：</p><pre><code class="lang-html">&lt;body&gt;    &lt;ul&gt;        {{ range . }}        &lt;li&gt;{{ . }}&lt;/li&gt;        {{ end}}    &lt;/ul&gt;&lt;/body&gt;</code></pre><p>下面是模板处理器：</p><pre><code class="lang-go">func process(w http.ResponseWriter, r *http.Request) {        t, _ := template.ParseFiles(&quot;tmpl.html&quot;)        daysOfWeek := []string{&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;}        t.Execute(w, daysOfWeek)}</code></pre><p>在网页中，会以无序列表的形式展示周一到周日：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200125132442.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><hr><p>下面展示了一个具有备选结果的迭代动作：</p><pre><code class="lang-html">&lt;body&gt;        &lt;ul&gt;            {{ range . }}              &lt;li&gt;{{ . }}&lt;/li&gt;          {{ else }}              &lt;li&gt; Nothing to show &lt;/li&gt;            {{ end}}        &lt;/ul&gt;  &lt;/body&gt;</code></pre><h2 id="2-3-设置动作"><a href="#2-3-设置动作" class="headerlink" title="2.3 设置动作"></a>2.3 设置动作</h2><p>设置动作允许用户在指定的范围之内为点<code>.</code>设置值。比如，在以下代码中：</p><pre><code>{{ with arg }}    Dot is set to arg{{ end }}</code></pre><p>介于<code>with arg</code>和<code>end</code>之间的点将被设置为参数<code>arg</code>的值，比如：</p><pre><code class="lang-html">&lt;body&gt;        &lt;div&gt;The dot is {{ . }}&lt;/div&gt;    &lt;div&gt;            {{ with "world"}}              Now the dot is set to {{ . }}            {{ end }}        &lt;/div&gt;        &lt;div&gt;The dot is {{ . }} again&lt;/div&gt;  &lt;/body&gt;</code></pre><p>传入的还是hello，但是经过设置动作后，点的内容被替换为world。</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200125133434.png"  style="zoom:88%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="2-4-包含动作"><a href="#2-4-包含动作" class="headerlink" title="2.4 包含动作"></a>2.4 包含动作</h2><p>包含动作（include action）允许用<strong>户在一个模板里面包含另一个模板，从而构建出嵌套的模板</strong>。包含动作的格式为<code>template &quot;name&quot;</code>，其中<code>name</code>参数为被包含模板的名字。</p><pre><code class="lang-html">&lt;body&gt;        &lt;div&gt; This is t1.html before&lt;/div&gt;        &lt;div&gt;This is the value of the dot in t1.html - [{{ . }}]&lt;/div&gt;        &lt;hr/&gt;        {{ template "t2.html" }}        &lt;hr/&gt;        &lt;div&gt; This is t1.html after&lt;/div&gt;&lt;/body&gt;</code></pre><pre><code class="lang-html">&lt;div style=&quot;background-color: yellow;&quot;&gt;      This is t2.html&lt;br/&gt;      This is the value of the dot in t2.html - [{{ . }}]&lt;/div&gt;</code></pre><p>下面展示了处理器：</p><pre><code class="lang-go">func process(w http.ResponseWriter, r *http.Request) {        t, _ := template.ParseFiles(&quot;t1.html&quot;, &quot;t2.html&quot;)        t.Execute(w, &quot;Hello World!&quot;)}</code></pre><p>结果如下：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200125134406.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h1 id="3-函数、变量与管道"><a href="#3-函数、变量与管道" class="headerlink" title="3. 函数、变量与管道"></a>3. 函数、变量与管道</h1><h2 id="3-1-变量与管道"><a href="#3-1-变量与管道" class="headerlink" title="3.1 变量与管道"></a>3.1 变量与管道</h2><p>用户还可以在动作中设置变量。变量以美元符号<code>$</code>开头，就像这样：</p><pre><code class="lang-html">$variable := value</code></pre><p>利用变量，我们可以实现迭代动作的一个变种：</p><pre><code class="lang-html">{{ range $key, $value := . }}      The key is {{ $key }} and the value is {{ $value }}{{ end }}</code></pre><hr><p>模板中的管道（pipeline）是多个有序地串联起来的参数、函数和方法，它的工作方式和语法跟Unix的管道也非常相似：</p><pre><code class="lang-html">{{ p1 | p2 | p3 }}</code></pre><p>管道允许用户将一个参数的输出传递给下一个参数，而各个参数之间则使用<code>|</code>分隔。</p><pre><code class="lang-html">&lt;body&gt;        {{ 12.3456 | printf "%.2f" }}  &lt;/body&gt;</code></pre><p>上面的代码就是一个利用管道原理格式化的例子。</p><h2 id="3-2-函数"><a href="#3-2-函数" class="headerlink" title="3.2 函数"></a>3.2 函数</h2><p>Go函数也可以用作模板的参数：Go模板引擎内置了一些非常基础的函数。需要注意的是，Go的模板引擎函数都是受限制的：<strong>尽管这些函数可以接受任意多个参数作为输入，但它们只能返回一个值，或者返回一个值和一个错误。</strong></p><p>为了创建一个自定义模板函数，用户需要：</p><ol><li>创建一个名为<code>FuncMap</code>的映射，并将映射的键设置为函数的名字，而映射的值则设置为实际定义的函数；</li><li>将<code>FuncMap</code>与模板进行绑定。</li></ol><p>举个例子：在编写Web应用的时候，用户常常需要将时间对象或者日期对象转换为ISO8601格式的时间字符串或者日期字符串，又或者将ISO8601格式的字符串转换为相应的对象。</p><pre><code class="lang-go">func formatDate(t time.Time) string {        layout := &quot;2006-01-02&quot;        return t.Format(layout)}func process(w http.ResponseWriter, r *http.Request) {        funcMap := template.FuncMap { &quot;fdate&quot;: formatDate }        t := template.New(&quot;tmpl.html&quot;).Funcs(funcMap)        t, _ = t.ParseFiles(&quot;tmpl.html&quot;)        t.Execute(w, time.Now())}</code></pre><ol><li>首先定义了一个名为<code>formatDate</code>的函数，它接受一个<code>Time</code>结构作为输入，然后以<code>年-月-日</code>的形式返回一个ISO8601格式的字符串。</li><li>在之后的处理器中，程序将名字<code>fdate</code>映射至<code>formatDate</code>函数。</li><li>序使用<code>template.New</code>函数创建了一个名为<code>tmpl.html</code>的模板。以程序直接以串联的方式调用模板的<code>Funcs</code>方法。</li></ol><p>在html文件中，通过管道使用自定义函数：</p><pre><code class="lang-html">&lt;body&gt;        &lt;div&gt;The date/time is {{ . | fdate }}&lt;/div&gt; &lt;/body&gt;</code></pre><h1 id="4-上下文感知"><a href="#4-上下文感知" class="headerlink" title="4. 上下文感知"></a>4. 上下文感知</h1><h2 id="4-1-什么是上下文感知"><a href="#4-1-什么是上下文感知" class="headerlink" title="4.1 什么是上下文感知"></a>4.1 什么是上下文感知</h2><p>所谓上下文感知就是<strong>对被显示的内容实施正确的转义</strong>：如果模板显示的是HTML格式的内容，那么模板将对其实施HTML转义；如果模板显示的是JavaScript格式的内容，那么模板将对其实施JavaScript转义；诸如此类。除此之外，Go模板引擎还可以识别出内容中的URL或者CSS样式。</p><p>比如：</p><pre><code class="lang-go">t, _ := template.ParseFiles(&quot;tmpl.html&quot;)    content := `I asked: &lt;i&gt;&quot;What&#39;s up?&quot;&lt;/i&gt;`t.Execute(w, content)</code></pre><p>上下文感知模板：</p><pre><code class="lang-html"> &lt;body&gt;         &lt;div&gt;{{ . }}&lt;/div&gt;         &lt;div&gt;&lt;a href=&quot;/{{ . }}&quot;&gt;Path&lt;/a&gt;&lt;/div&gt;         &lt;div&gt;&lt;a href=&quot;/?q={{ . }}&quot;&gt;Query&lt;/a&gt;&lt;/div&gt;      &lt;div&gt;&lt;a onclick=&quot;f(&#39;{{ . }}&#39;)&quot;&gt;Onclick&lt;/a&gt;&lt;/div&gt;   &lt;/body&gt;</code></pre><p>根据动作所在位置，输出结果将变为：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200125145406.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="4-2-防御XSS攻击"><a href="#4-2-防御XSS攻击" class="headerlink" title="4.2 防御XSS攻击"></a>4.2 防御XSS攻击</h2><p>XXS也称 cross-site scripting，<strong>跨站脚本</strong>。这种攻击是<strong>由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的</strong>。 </p><p>举个例子，如果有一个存在持久性 xss 漏洞的论坛，它允许用户在论坛上面发布帖子或者回复，并且其他用户也可以阅读这些帖子以及回复，那么攻击者就可能会在他发布的内容中<strong>引入带有＜script＞标签的代码</strong>。 因为论坛即使在内容带有＜script＞标签的情况下，仍然会原原本本地向用户显示这些内容，所以用户将在毫不知情的情况下，使用自己的权限去执行攻击者发布的恶意代码。 <strong>预防这一攻击的常见方法就是在显示或者存储用户传入的数据之前，对数据进行转义。</strong></p><p>假设我们想要通过一个HTML表单发送数据：</p><pre><code class="lang-html">&lt;html&gt;      &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;        &lt;title&gt;Go Web Programming&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;            &lt;form action=&quot;/process&quot; method=&quot;post&quot;&gt;                  Comment: &lt;input name=&quot;comment&quot; type=&quot;text&quot;&gt;            &lt;hr/&gt;                 &lt;button id=&quot;submit&quot;&gt;Submit&lt;/button&gt;         &lt;/form&gt;      &lt;/body&gt;&lt;/html&gt;</code></pre><p>为了防止XSS攻击，我们使用如下模板：</p><pre><code class="lang-html">&lt;html&gt;      &lt;head&gt;            &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;            &lt;title&gt;Go Web Programming&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;            &lt;div&gt;{{ . }}&lt;/div&gt;      &lt;/body&gt;&lt;/html&gt;</code></pre><p>然后将模板和表单都绑定到处理器：</p><pre><code class="lang-go">http.HandleFunc(&quot;/process&quot;, process)    http.HandleFunc(&quot;/form&quot;, form)</code></pre><p>当我们访问form时，将以下内容输入到表单的文本框里面，然后按下<code>Submit</code>按钮：</p><pre><code>&lt;script&gt;alert(&#39;Pwnd!&#39;);&lt;/script&gt;</code></pre><p>由于go的模板引擎的防护，将漏洞成功转义：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200125150655.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="4-3-不转义"><a href="#4-3-不转义" class="headerlink" title="4.3 不转义"></a>4.3 不转义</h2><p>如果真的想要允许用户输入HTML代码或者JavaScript代码，并在显示内容时执行这些代码，可以使用Go提供的“不转义HTML”机制：只要把不想被转义的内容传给<code>template.HTML</code>函数，模板引擎就不会对其进行转义。 </p><pre><code class="lang-go">func process(w http.ResponseWriter, r *http.Request) {        t, _ := template.ParseFiles(&quot;tmpl.html&quot;)        t.Execute(w, template.HTML(r.FormValue(&quot;comment&quot;)))}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web页面的展示依靠的是模板技术，&lt;strong&gt;Web模板就是一些预先设计好的 HTML 页面&lt;/strong&gt;，模板引擎会通过重复地使用这些页面来创建一个或多个 HTML 页面。
    
    </summary>
    
    
      <category term="go" scheme="jiangren.work/categories/go/"/>
    
    
      <category term="计算机网络" scheme="jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="go" scheme="jiangren.work/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>GoWeb编程3-处理Web请求</title>
    <link href="jiangren.work/2020/01/23/GoWeb%E7%BC%96%E7%A8%8B3-%E5%A4%84%E7%90%86Web%E8%AF%B7%E6%B1%82/"/>
    <id>jiangren.work/2020/01/23/GoWeb%E7%BC%96%E7%A8%8B3-%E5%A4%84%E7%90%86Web%E8%AF%B7%E6%B1%82/</id>
    <published>2020-01-23T06:09:59.000Z</published>
    <updated>2020-01-25T12:19:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节讨论如何利用go处理客户端发来的请求。<a id="more"></a>Request结构体作为客户端请求的载体，其中HTML作为Request请求的主体，而传入服务器后需要利用相关的响应方法对请求进行相应。Cookie是辅助响应的手段，用于保存状态。</p><p>学习的是如何使用 Go 提供的工具来处理请求，以及如何把响应回传给客户端。<!--more--></p><h1 id="1-请求方法"><a href="#1-请求方法" class="headerlink" title="1. 请求方法"></a>1. 请求方法</h1><h2 id="1-1-Request结构"><a href="#1-1-Request结构" class="headerlink" title="1.1 Request结构"></a>1.1 Request结构</h2><p>Request 结构表示一<strong>个由客户端发送的 HTTP 请求报文</strong>，包括：</p><ul><li>URL字段</li><li>Header字段</li><li>Body字段</li><li>Form，PostForm字段和MultipartForm字段</li></ul><p>虽然 HTTP 请求报文是由一系列文本行组成的，但 Request 结构<strong>并不是完全按照报文逐字逐句定义的</strong>。 实际情况是，这个结构只包含了报文在经过语法分析之后，其中较为重要的信息。</p><h2 id="1-2-请求URL"><a href="#1-2-请求URL" class="headerlink" title="1.2 请求URL"></a>1.2 请求URL</h2><p>Request结构体中包含的URL字段指向了一个<code>url.URL</code>结构体：</p><pre><code class="lang-go">type URL struct {    Scheme   string    Opaque   string    // 编码后的不透明数据    User     *Userinfo // 用户名和密码信息    Host     string    // host或host:port    ath     string    RawQuery string // 编码后的查询字符串，没有&#39;?&#39;     Fragment string // 引用的片段（文档位置），没有&#39;#&#39;}</code></pre><p>URL的一般格式是：</p><pre><code class="lang-go">scheme:// [user info@] host/path [?query] [#fragment]</code></pre><p>而scheme之后不带斜线的URL会被解释为：</p><pre><code class="lang-go">scheme:opaque[?query] [#fragment ]</code></pre><p>当我们输入<code>http://www.example.com/post?id=123&amp;thread_id=456</code>这个<code>id=123&amp;thread_id=456</code>就是查询字段<code>RawQuery</code></p><h2 id="1-3-请求头部"><a href="#1-3-请求头部" class="headerlink" title="1.3 请求头部"></a>1.3 请求头部</h2><p>请求和响应的首部都使用 Header 类型描述，这种类型<strong>使用一个映射来表示 HTTP 首部中的多个键值对</strong>。 Header 类型拥有 4 种基本方法，这些方法可以根据给定的键执行<strong>添加、 删除、获取和设置值</strong>等操作。 </p><p>下面展示了读取头部的方法：</p><pre><code class="lang-go">func headers(w http.ResponseWriter, r *http.Request){    h := r.Header    fmt.Fprintln(w,h)}func main(){    server:=http.Server{        Addr: &quot;127.0.0.1:8080&quot;,    }    http.HandleFunc(&quot;/headers&quot;,headers)    server.ListenAndServe()}</code></pre><p>在浏览器会输出：</p><pre><code>map[Accept:[text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9] Accept-Encoding:[gzip, deflate, br] Accept-Language:[zh,en-US;q=0.9,en;q=0.8,zh-CN;q=0.7] Connection:[keep-alive] Cookie:[_ga=GA1.1.1969723589.1578322265; _xsrf=2|86b77755|fdefd0fe22a4955aac4be46f30abdbfe|1578603653; ...省略] Sec-Fetch-Mode:[navigate] Sec-Fetch-Site:[none] Sec-Fetch-User:[?1] Upgrade-Insecure-Requests:[1] User-Agent:[Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36]]</code></pre><p>通过这些，我们能知道头部的所有信息，当然我们也能返回特定的信息：</p><pre><code class="lang-go">h:=r.Header[&quot;Accept-Encoding&quot;]</code></pre><h2 id="1-4-请求主体"><a href="#1-4-请求主体" class="headerlink" title="1.4 请求主体"></a>1.4 请求主体</h2><p>请求和响应的主体都由 <code>Request</code> 结构的 <code>Body</code> 字段表示，这个字段是一个 <code>io.Read</code> <code>Closer</code> 接口，该接口既包含了：</p><ul><li>Reader接口：接口拥有 Read 方法，这个方法<strong>接受一个字节切片为输入</strong>，并在执行之后返回被读取内容的字节数以及一个可选的错误作为结果； </li><li>Closer接口：这个方法不接受任何参数，但会在出错时返回一个错误。 </li></ul><p>下面是一个demo：</p><pre><code class="lang-go">func body(w http.ResponseWriter, r *http.Request){    len := r.ContentLength    body :=make([]byte,len)    r.Body.Read(body)    fmt.Fprintln(w,string(body))}func main(){    server:=http.Server{        Addr: &quot;127.0.0.1:8080&quot;,    }    http.HandleFunc(&quot;/body&quot;,body)    server.ListenAndServe()}</code></pre><p>由于<strong>GET请求并不包含BODY</strong>，所以我们访问时，控制台没有任何输出。所以如果我们想要测试这个服务器，就需要通<strong>过HTML表单发送 POST 请求</strong>。这里我们不用表单，用cURL命令来测试：</p><pre><code>curl -id &quot;first_name=11&amp;last_name=22&quot; 127.0.0.1:8080/body</code></pre><p>在控制台可以看到：</p><pre><code>HTTP/1.1 200 OKDate: Thu, 23 Jan 2020 14:53:52 GMTContent-Length: 27Content-Type: text/plain; charset=utf-8first_name=11&amp;last_name=22</code></pre><h1 id="2-HTML表单"><a href="#2-HTML表单" class="headerlink" title="2. HTML表单"></a>2. HTML表单</h1><h2 id="2-1-什么是表单"><a href="#2-1-什么是表单" class="headerlink" title="2.1 什么是表单"></a>2.1 什么是表单</h2><p>POST 请求都是通过HTML表单发送的，这些表单看上去通常会是下面这个样子：</p><pre><code class="lang-html">&lt;form action=”/process ” method=”post”&gt; &lt;input type=”text” name=”first name” /&gt; &lt;input type=”text” name=”last name&quot;/&gt; &lt;input type=”submit”/&gt; &lt;/form&gt;</code></pre><p><strong>&lt;form＞标签可以包围文本行、文本框、单选按钮、复选框以及文件上传等多种HTML表单元素</strong>， 而用户则可以把想要传递给服务器的数据输入到这些元素里面。当用户按下发送按钮、又或者通过某种方式触发了表单的发送操作之后，用户在表单中输入的数据就会被发送至服务器。 </p><p>表单的编码属性由enctype属性的值设置，有两种：</p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li></ul><p>第一种，浏览器将把 HTML 表单中的数据编码为一个<strong>连续的“长查询字符串”</strong>（ long query string ）：在这个字符串中，<strong>不同的键值对将使用＆符号分隔，而键值对中的键和值则使用等号＝分隔</strong>。 </p><pre><code>first_name=sau%20sheong&amp;last_name=chang</code></pre><p>第二种，表单中的数据将被转<strong>换成一条 MIME 报文 (Multipurpose Internet Mail Extensions)</strong>：表单中的<strong>每个键值对都构成了这条报文的一部分，并且每个键值对都带有它们各自的内容类型以及内容配置</strong>（ disposition ） 。 </p><pre><code>------WebKitFormBoundaryMPNjKpe09cLiocMw Content-Disposition : f orm-data ; name=”first name&quot; sau sheong ------WebKitFormBoundaryMPNjKpe09cLiocMw Content- Disposition: form-data; name=”l ast name” chang ------WebKitFormBoundaryMPNjKpe09cLiocMw--</code></pre><hr><p>除了post外也可以通过get发送表单</p><pre><code class="lang-html">&lt;form action=”/process ” method=”get&quot;&gt;    ...&lt;/form&gt;</code></pre><h2 id="2-2-Form字段"><a href="#2-2-Form字段" class="headerlink" title="2.2 Form字段"></a>2.2 Form字段</h2><p>为了提取表单的键值对数据，我们需要对表单进行处理，<code>net/http</code>库提供了许多函数能够满足需求。通过调用 <code>Request</code> 结构提供的方法，用户<strong>可以将 URL、Body数据提取到该结构的 <code>Form</code>, <code>PostForm</code> 和 <code>MultipartForm</code> 等字段当中。</strong> </p><p>过程如下：</p><ol><li>调用 <code>ParseForm</code> 方法或者 <code>ParseMultipartForm</code> 方法，对请求进行语法分析。 </li><li>根据步骤 l 调用的方法，访问相应的 Form 字段、 PostForm 字段或 MultipartForm 字段。</li></ol><p>举个例子：</p><pre><code class="lang-go">func process(w http.ResponseWriter, r *http.Request){    r.ParseForm()    fmt.Fprintln(w,r.Form)    fmt.Println(&quot;收到了&quot;)}func main(){    server:=http.Server{        Addr: &quot;127.0.0.1:8080&quot;,    }    http.HandleFunc(&quot;/process&quot;,process)    server.ListenAndServe()}</code></pre><p>然后我们创建一个html文件，包含了：</p><pre><code class="lang-html">&lt;html&gt;  &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;    &lt;title&gt;Go Web Programming&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;form action=&quot;http://localhost:8080/process?hello=world&amp;thread=123&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;      &lt;input type=&quot;text&quot; name=&quot;hello&quot; value=&quot;sau sheong&quot;/&gt;      &lt;input type=&quot;text&quot; name=&quot;post&quot; value=&quot;456&quot;/&gt;      &lt;input type=&quot;file&quot; name=&quot;uploaded&quot;&gt;      &lt;input type=&quot;submit&quot;&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>用浏览器打开这个html文件，点击提交，可以在浏览器看到：</p><pre><code>map[hello:[world] thread:[123]]</code></pre><p>在控制台可以看到“收到了”的消息提醒。</p><h2 id="2-3-PostForm字段"><a href="#2-3-PostForm字段" class="headerlink" title="2.3 PostForm字段"></a>2.3 PostForm字段</h2><p>当我们写入<code>r.Form[&quot;post&quot;]</code>时返回一个切片<code>456</code>，但是当我们输入<code>r.Form[&quot;hello&quot;]</code>时却返回了<code>world</code>而不是<code>sau sheong</code>。这是因为<code>hello</code><strong>同时出现在表单和 URL 两个地方的键</strong>。</p><pre><code>&lt;input type=&quot;text&quot; name=&quot;hello&quot; value=&quot;sau sheong&quot;/&gt;action=&quot;http://localhost:8080/process?hello=world&amp;thread=123&quot;</code></pre><p>面对这种情况，我们需要改为<code>r.PostForm</code>语句。</p><h2 id="2-4-MultipartForm字段"><a href="#2-4-MultipartForm字段" class="headerlink" title="2.4 MultipartForm字段"></a>2.4 MultipartForm字段</h2><p>前面的字段针对<code>application/x-www-form-urlencoded</code>类型，而对于另一种<code>multipart/form-data</code>类型，需要使用<code>MultipartForm</code>字段。</p><pre><code class="lang-go">r.ParseMultipartForm(1024) fmt.Fprintln (w,r.MultipartForm)</code></pre><p>的第一行代码说明了我们想要从 <code>multipart</code> 编码的表单里面取出多少字节的数据，而第二行语句则会打印请求的 <code>MultipartForm</code> 字段。</p><hr><p>MultipartForm字段<strong>只包含表单键值对，不包含URL键值对</strong>。</p><p>它也不是一个单映射，而是两个映射的组合：<strong>第一个键为字符串，值为字符串组成的切片，第二个映射为空，用来记录用户上传的文件。</strong></p><p>此外还有<code>FormValue</code>和<code>PostFormValue</code>，他们只会从Form结构中取出给定键的第一个值：</p><pre><code class="lang-go">fmt.Fprintln(w, r.ForrnValue (&quot;hello&quot; ))</code></pre><p>上面的代码将输出<code>sau sheong</code>。</p><hr><p>对比：</p><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200124095905.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><h2 id="2-5-文件"><a href="#2-5-文件" class="headerlink" title="2.5 文件"></a>2.5 文件</h2><p><code>multipart/form-data</code>编码，通常用于实现文件上传功能，这种功能需要用到 file 类型的 input 标签:</p><pre><code class="lang-html">&lt;html&gt;  &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;    &lt;title&gt;Go Web Programming&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;form action=&quot;http://localhost:8080/process?hello=world&amp;thread=123&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;      &lt;input type=&quot;text&quot; name=&quot;hello&quot; value=&quot;sau sheong&quot;/&gt;      &lt;input type=&quot;text&quot; name=&quot;post&quot; value=&quot;456&quot;/&gt;      &lt;input type=&quot;file&quot; name=&quot;uploaded&quot;&gt;      &lt;input type=&quot;submit&quot;&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>为了能够接收表单上传的文件，处理器函数也需要做相应的修改：</p><pre><code class="lang-go">func process(w http.ResponseWriter, r *http.Request){    r.ParseMultipartForm(1024)    fileHeader:= r.MultipartForm.File[&quot;uploaded&quot;][0]    file,err := fileHeader.Open()    if err == nil {        data, err:=ioutil.ReadAll(file)        if err == nil{            fmt.Fprintln(w,string(data))        }    }}</code></pre><p>文件处理步骤可以总结为：</p><ol><li>执行<code>ParseMultipartForm</code>方法解析字段；</li><li>从<code>MultipartForm</code>字段的File字段中提取出文件头<code>FileHeader</code>；</li><li>通过open打开这个文件；</li><li>用<code>ioutil</code>函数将文件内容读取到一个字节数组中。</li></ol><h1 id="3-响应方法"><a href="#3-响应方法" class="headerlink" title="3. 响应方法"></a>3. 响应方法</h1><p>响应时需要用到<code>ResponseWriter</code>接口，处理器可以通过这个接口创建HTTP响应。</p><p>我们知道<code>ServeHTTP</code>接收<code>ResponseWriter</code>接口和一个指向<code>Request</code>结构的指针作为参数。之所以要用指针传递而不是值传递，是<strong>为了探测对<code>Request</code>结构的修改情况</strong>。而<code>ResponseWriter</code>看起来像传值，但实际上它<strong>是response这个非导出结构的接口，也是传引用</strong>。</p><p>ResponseWriter 接口拥有以下 3 个方法：</p><ul><li>Write</li><li>WriteHeader</li><li>Header</li></ul><h2 id="3-1-Write"><a href="#3-1-Write" class="headerlink" title="3.1 Write"></a>3.1 Write</h2><p>Write方法<strong>接受一个字节数组</strong>作为参数，并将数组中的字节写入HTTP响应的主体中。</p><pre><code class="lang-go">func writeExample(w http.ResponseWriter, r *http.Request){    str:=`&lt;html&gt;&lt;head&gt;&lt;title&gt;Go Web&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello world&lt;/h1&gt;&lt;body&gt;&lt;/html&gt;`    w.Write([]byte(str))}func main(){    server:=http.Server{        Addr: &quot;127.0.0.1:8080&quot;,    }    http.HandleFunc(&quot;/write&quot;,writeExample)    server.ListenAndServe()}</code></pre><p>注意这段Demo使用 ` 符号，用于多行字符串。我们用命令行输入:</p><pre><code class="lang-go">curl -i localhost:8080/write</code></pre><p>可以得到响应：</p><pre><code class="lang-http">HTTP/1.1 200 OKDate: Fri, 24 Jan 2020 10:35:59 GMTContent-Length: 82Content-Type: text/html; charset=utf-8&lt;html&gt;&lt;head&gt;&lt;title&gt;Go Web&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello world&lt;/h1&gt;&lt;body&gt;&lt;/html&gt;</code></pre><h2 id="3-2-WriteHeader"><a href="#3-2-WriteHeader" class="headerlink" title="3.2 WriteHeader"></a>3.2 WriteHeader</h2><p>注意：WriteHeader并不能用于设置响应的头部(Header)。WriteHeader 方法<strong>接受一个代表 HTTP 响应状态码的整数作为参数， 并将这个整数用作 HTTP 响应的返回状态码</strong>；在调用这个方法之后，用户可以继续对 ResponseWriter 进行写人，但是不能对响应的首部做任何写入操作。 <strong>如果用户在调用 Write 方法之前没有执行过 WriteHeader 方法，那么程序默认会使用 200 OK作为响应的状态码。</strong> </p><p>注意别忘了使用 HandleFune 方法将新处理器绑定到 DefaultServeMux多路复用器里面！</p><p>比如，你编写了一个API，但尚未完全实现，所以希望返回一个 501 Not Implemented 状态码：</p><pre><code class="lang-go">func writeExample(w http.ResponseWriter, r *http.Request){    str:=`&lt;html&gt;&lt;head&gt;&lt;title&gt;Go Web&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello world&lt;/h1&gt;&lt;body&gt;&lt;/html&gt;`    w.Write([]byte(str))}func writeHeaderExample(w http.ResponseWriter, r *http.Request){    w.WriteHeader(501)    fmt.Fprintln(w, &quot;TO DO&quot;)}func main(){    server:=http.Server{        Addr: &quot;127.0.0.1:8080&quot;,    }    http.HandleFunc(&quot;/write&quot;,writeExample)    http.HandleFunc(&quot;/writeheader&quot;,writeHeaderExample)    server.ListenAndServe()}</code></pre><p><strong>通过 cURL 访问刚刚添加的新处理器：</strong></p><pre><code class="lang-go">curl -i localhost:8080/writeheader</code></pre><p>我们将得到以下响应：</p><pre><code class="lang-http">HTTP/1.1 501 Not ImplementedDate: Fri, 24 Jan 2020 10:57:32 GMTContent-Length: 6Content-Type: text/plain; charset=utf-8TO DO</code></pre><h2 id="3-3-Header"><a href="#3-3-Header" class="headerlink" title="3.3 Header"></a>3.3 Header</h2><p>过调用 Header 方法可以<strong>取得一个由首部组成的映射</strong>，修改这个映射就可以修改首部，修改后的首部将被包含在 HTTP 响应里面， 并随着响应一向发送至客户端。</p><pre><code class="lang-go">func headerExample(w http.ResponseWriter, r *http.Request){    w.Header().Set(&quot;Location&quot;,&quot;http://google.com&quot;)    w.WriteHeader(302)}func main(){    ...     http.HandleFunc(&quot;/redirect&quot;,headerExample)    server.ListenAndServe()}</code></pre><p>那么cURL响应将得到以下结果：</p><pre><code class="lang-http">HTTP/1.1 302 FoundLocation: http://google.comDate: Fri, 24 Jan 2020 11:04:47 GMTContent-Length: 0</code></pre><p>除了将状态码设置成了 302 之外， 它还给响应添加了一个名为 Location 的首部，并<strong>将这个首部的值设置成了重定向的目的地</strong>。 需要注意的是，因为 WriteHeader 方法在执行完毕之后就不允许再对首部进行写入了，所以<strong>用户必须先写入 Location 首部，然后再写入状态码。</strong> 现在，如果我们在浏览器里面访问这个处 理器， 那么浏览器将被重定向到 Google。 </p><h1 id="4-Cookie"><a href="#4-Cookie" class="headerlink" title="4. Cookie"></a>4. Cookie</h1><p>cookie 是一种存储在客户端的、体积较小的信息，这些信息最初都是由服务器通过 HTTP 响应报文发送的。 <strong>每当客户端向服务器发送一个 HTTP 请求时， cookie 都会随着请求被一同发送至服务器</strong>。 cookie 的设计本意是要<strong>克服 HTTP 的无状态性</strong>，虽然 cookie 并不是完成这一目的的唯一方法，但它却是最常用也最流行的方法之一：整个计算机行业的收入都建立在 cookie机制之上，对互联网广告领域来说，更是如此<strong>:)</strong>。 </p><h2 id="4-1-Go中的Cookie"><a href="#4-1-Go中的Cookie" class="headerlink" title="4.1 Go中的Cookie"></a>4.1 Go中的Cookie</h2><p>cookie 在 Go 语言里面用 Cookie 结构表示：</p><pre><code class="lang-go">type Cookie struct {    Name  string    Value string    Path       string    // optional    Domain     string    // optional    Expires    time.Time // optional    RawExpires string    // for reading cookies only    MaxAge   int    Secure   bool    HttpOnly bool    Raw      string    Unparsed []string // Raw text of unparsed attribute-value pairs}</code></pre><p>cookie根据是否含有Expires信息分为两种：</p><ul><li><strong>会话cookie</strong>，或者叫临时cookie。<strong>在浏览器关闭的时候就会自动被移除。</strong></li><li><strong>持久cookie</strong>，存在直到<strong>指定的过期时间来临</strong>或者<strong>被手动删除为止</strong>。 </li></ul><p>Expires 宇段和 MaxAge 字段都可以用于设置 cookie 的过期时间：</p><ul><li>Expires，什么时候到期</li><li>MaxAge，能活多少秒</li></ul><h2 id="4-2-将cookie发送至浏览器"><a href="#4-2-将cookie发送至浏览器" class="headerlink" title="4.2 将cookie发送至浏览器"></a>4.2 将cookie发送至浏览器</h2><p>完整的步骤是：</p><ol><li>创建一个cookie结构体</li><li>用Cookie 结构的 String 方法将结构体序列化</li><li>使用set设置cookie</li></ol><pre><code class="lang-go">func setCookie(w http.ResponseWriter, r *http.Request){    c1:= http.Cookie{        Name:       &quot;first_cookie&quot;,        Value:      &quot;Go web&quot;,        Path:       &quot;&quot;,        Domain:     &quot;&quot;,        Expires:    time.Time{},        RawExpires: &quot;&quot;,        MaxAge:     0,        Secure:     false,        HttpOnly:   true,        SameSite:   0,        Raw:        &quot;&quot;,        Unparsed:   nil,    }    w.Header().Set(&quot;Set-Cookie&quot;,c1.String())    //w. Header() . Add (&quot;Set-Cookie”, c1. String ()) 也可以}func main(){    server:=http.Server{        Addr: &quot;127.0.0.1:8080&quot;,    }    http.HandleFunc(&quot;/set_cookie&quot;,setCookie)    server.ListenAndServe()}</code></pre><p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200124113822.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;"></p><p>除了 Set 方法和 Add 方法之外 ，Go语言还提供了一种更为快捷方便的 cookie 设置方法:</p><pre><code class="lang-go">http.SetCookie(w, &amp;c1)</code></pre><h2 id="4-3-从浏览器获取cookie"><a href="#4-3-从浏览器获取cookie" class="headerlink" title="4.3 从浏览器获取cookie"></a>4.3 从浏览器获取cookie</h2><p>添加：</p><pre><code class="lang-go">func getCookie(w http.ResponseWriter, r *http.Request){    h:=r.Header[&quot;Cookie&quot;]    fmt.Fprintln(w,h)}http.HandleFunc(&quot;/get_cookie&quot;,getCookie)</code></pre><p>当我们进入这个网页时，会显示一大堆cookie信息。如果用户想要取得单独的键值对格式的 cookie，就需要进行分析，go提供了一些分析方法：</p><pre><code class="lang-go">func getCookie(w http.ResponseWriter, r *http.Request){    c1,err:=r.Cookie(&quot;first_cookie&quot;)    if err!=nil{        fmt.Fprintln(w,&quot;Can not find the cookie&quot;)    }    cs := r.Cookies()    fmt.Fprintln(w,c1)    fmt.Fprintln(w,cs)}func main(){    server:=http.Server{        Addr: &quot;127.0.0.1:8080&quot;,    }    http.HandleFunc(&quot;/set_cookie&quot;,setCookie)    http.HandleFunc(&quot;/get_cookie&quot;,getCookie)    server.ListenAndServe()}</code></pre><p>先进入网页<code>/set_cookie</code>，然后进入<code>/get_cookie</code>。第一行显示我们设置的cookie，后面的为所有cookie。</p><pre><code>first_cookie=&quot;Go web&quot;[_ga=GA1.1.193589.15722265 _xsrf=2|86b77755|fdefd0aac4be46f30abdbfe|1578603653 username-localhost-...8889|44:OTJhZmZiMjM5OTJiNGY2Y4MTAxNDdkM2UxM2U=|f8d50574e991203f0303f948b092ad1786a2f79c5ecbee1db10cf4c first_cookie=&quot;Go web&quot;]</code></pre><h2 id="4-4-利用cookie实现闪现消息"><a href="#4-4-利用cookie实现闪现消息" class="headerlink" title="4.4 利用cookie实现闪现消息"></a>4.4 利用cookie实现闪现消息</h2><p>当某个条件被满足时，在页面上显示一条临时出现的消息，然而当用户在刷新页面之后就不会再看见相同的消息了一一我们把这种<strong>临时出现的消息称为问现消息（ flash message ）。</strong>比如论坛发帖时，因为某种原因失败了，需要弹出失败消息。</p><pre><code class="lang-go">func setMessage(w http.ResponseWriter,r *http.Request){    msg:=[]byte(&quot;hello world!&quot;)    c :=http.Cookie{        Name:       &quot;flash&quot;,        Value:      base64.URLEncoding.EncodeToString(msg),    }    http.SetCookie(w,&amp;c)}func showMessage(w http.ResponseWriter,r *http.Request){    c,err:=r.Cookie(&quot;flash&quot;)    if err!=nil{        if err==http.ErrNoCookie{            fmt.Fprintln(w,&quot;No message&quot;)        }    }else{        rc:=http.Cookie{            Name:       &quot;flash&quot;,            Expires:    time.Unix(1,0),            MaxAge:     -1,        }        http.SetCookie(w,&amp;rc)        val,_:=base64.URLEncoding.DecodeString(c.Value)        fmt.Fprintln(w,string((val)))    }}func main(){    server:=http.Server{        Addr: &quot;127.0.0.1:8080&quot;,    }    http.HandleFunc(&quot;/set_message&quot;,setMessage)    http.HandleFunc(&quot;/show_message&quot;,showMessage)    server.ListenAndServe()}</code></pre><p>首先set_message这一段，其实跟之前的set_cookie比较类似，主要区别在于编码：<strong>对消息使用了 Base64URL 编码，以此来满足响应首部对 cookie 值的 URL 编码要求。</strong></p><p>再来看show_message这一段，思路是：</p><ol><li>尝试获取指定的 cookie ， 如果没找到就返回错误</li><li>找到后，创建一个同名cookie，将 MaxAge 值设置为负数，并且将 Expires 值也设置成 一个已经过去的时间； </li><li>使用 SetCookie 方法将刚刚创建的同名 cookie 发送至客户端。</li><li>对原来的cookie解码，显示消息。</li></ol><p>由于新的消息同名，所以会顶替掉原来的cookie，又因为时间是过期时间，会将这个cookie清除，以此来达到闪现的目的。当我们刷新页面时，<code>hello world</code>消失。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节讨论如何利用go处理客户端发来的请求。
    
    </summary>
    
    
      <category term="go" scheme="jiangren.work/categories/go/"/>
    
    
      <category term="计算机网络" scheme="jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="go" scheme="jiangren.work/tags/go/"/>
    
  </entry>
  
</feed>
