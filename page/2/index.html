<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-EffectiveModernCPP笔记6-右值引用与移动语义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B06-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" class="article-date">
  <time datetime="2019-12-26T12:43:58.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B06-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/">EffectiveModernCPP笔记6-右值引用与移动语义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本章围绕<code>move</code>和<code>forward</code>这两个函数展开，详细介绍了右值引用，普适引用，移动语义，完美转发等概念。</p>
<h1 id="Item-23-Understand-std-move-and-std-forward"><a href="#Item-23-Understand-std-move-and-std-forward" class="headerlink" title="Item 23:Understand std::move and std::forward."></a>Item 23:Understand std::move and std::forward.</h1><p><code>std::move</code>和<code>std::forward</code>仅仅是进行转换的函数。<code>std::move</code><strong>无条件</strong>地将它的参数转换为右值，而<code>std::forward</code>只在<strong>某些条件满足时</strong>进行这种转换。</p>
<p><strong>（1）move的特性</strong></p>
<p>下面一个接近标准库实现的<code>std::move</code>实现的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// version C++11</span></span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmeplate &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// version C++14</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) move(T&amp;&amp; param) &#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>remove_reference_t</code>用于移除类型的引用，返回原始类型。比如<code>std::remove_reference::type</code>就等同于<code>int</code>。在上面的代码中，<strong>我们先移除了对象的引用，然后加上&amp;&amp;，转化为右值</strong>。</p>
<p>所以我们看到，<code>std::move</code><strong>只做了转换，并没有进行实际的移动</strong>，在一个对象上应用<code>std::move</code>就告知了编译器这个对象可以被移动，这就是它叫这个名字的原因：<strong>易于标记出可能被移动的对象</strong>。</p>
<p>因此，这就出现了一个问题：我们<strong>只转化了引用，对const并没有进行任何操作</strong>。下面看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> text)</span></span></span><br><span class="line">        : value(std::move(text))</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>会收到IDE送来的警告，告诉我们最好<strong>不要对const类型进行移动构造</strong>。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191226124946.png" style="zoom:67%;" />

<p>我们来看看<code>std::string</code>的复制构造函数和移动构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">string</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; rhs);</span><br><span class="line">    <span class="built_in">string</span>(<span class="built_in">string</span>&amp;&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设输入<code>const string&amp;&amp;</code>，显然没办法传给<code>string(string&amp;&amp; rhs)</code>，但能传给<code>string(const string&amp; rhs)</code>。因此<code>value</code>的构造使用了复制构造函数，即使它的参数是右值引用。</p>
<p>因此，我们可以总结：</p>
<ul>
<li><strong>不要把希望移动的变量声明为<code>const</code>。</strong></li>
<li><strong><code>std::move</code>不意味着移动任何东西，甚至不保证它转换的对象可移动。它只保证它的转换结果一定是右值。</strong></li>
</ul>
<p><strong>（2）forward的特性</strong></p>
<p><code>std::forward</code>与<code>std::move</code>很类似，只是<code>std::move</code>是无条件的转换，而<strong><code>std::forward</code>是有条件的转换</strong>。下面举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">const</span> Widget&amp; lval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(Widget&amp;&amp; rval)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndProcess</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    makeLogEntry(<span class="string">"Calling 'process'"</span>, now);</span><br><span class="line">    process(<span class="built_in">std</span>::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望在<code>param</code>类型为左值引用时调用<code>process(const Widget&amp; lval)</code>，在<code>param</code>为右值引用时调用<code>process(Widget&amp;&amp; rval)</code>。<strong>但<code>param</code>是函数参数，它本身永远是左值</strong>。因此我们需要一种方法在条件满足时将其转换为右值——<code>logAndProcess</code>的实参为右值。这就是<code>std::forward</code>要做的，有条件的转换，即<strong>当且仅当它的参数是通过右值初始化时进行转换</strong>。</p>
<p>两者最大的区别是<code>std::move</code>是无条件的转换，而<code>std::forward</code>只在参数为右值引用时将其转换为右值。</p>
<h1 id="Item-24-Distinguish-universal-references-from-rvalue-references"><a href="#Item-24-Distinguish-universal-references-from-rvalue-references" class="headerlink" title="Item 24:Distinguish universal references from rvalue references."></a>Item 24:Distinguish universal references from rvalue references.</h1><p>在Item1中我们就介绍了普适引用(universal reference)这个东西，那时候我们基本上把它和右值引用是画等号，在这一节中，我们对他们两进行详细的区别。</p>
<p><code>T&amp;&amp;</code>有两个含义，第一个就是右值引用，它的主要作用是<strong>标记一个可以移动的对象</strong>；第二个含义则既可能是右值引用也可能是左值引用，我们可以将其<strong>绑定在任何对象上</strong>，称其为“普适引用”。</p>
<p>普适引用有两个场景：</p>
<p><strong>函数模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>auto声明</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;</span><br></pre></td></tr></table></figure>

<p>它们的共同点就是<strong>需要类型推断</strong>。如果不需要类型推断，例如<code>Widget&amp;&amp; var1 = Widget();</code>，这<strong>就不是普适引用，就只是一个右值引用。</strong></p>
<p>普适引用的<strong>初始化式决定了它是右值引用还是左值引用</strong>：如果初始化式是右值，普适引用就是右值引用；如果初始化式是左值，普适引用就是左值引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;    <span class="comment">// universal reference</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line">f(w);                 <span class="comment">// lvalue passed to f: Widget&amp;</span></span><br><span class="line">f(<span class="built_in">std</span>::move(w));      <span class="comment">// rvalue passed to f: Widget&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p>光有类型推断还不足够，普适引用要求引用的声明格式<strong>必须是<code>T&amp;&amp;</code></strong>，而不是<code>std::vector&amp;&amp;</code>或<code>const T&amp;&amp;</code>这样的声明。</p>
<p>当然你在模板中看到了一个函数参数为<code>T&amp;&amp;</code>，也不代表它是普适引用，因为这里可能根本不需要类型推断。下面这个例子中，<code>push_back</code>的参数<code>x</code>不是普适引用，因为编译器会先实例化<code>vector</code>，之后你就发现<code>push_back</code>根本<strong>没有涉及到类型推断</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; x)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与之相反，<code>emplace_back</code>应用了类型推断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">emplace_back</span>(<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Item-25-Use-std-move-on-rvalue-references-std-forward-on-universal-references"><a href="#Item-25-Use-std-move-on-rvalue-references-std-forward-on-universal-references" class="headerlink" title="Item 25:Use std::move on rvalue references, std::forward on universal references."></a>Item 25:Use std::move on rvalue references, std::forward on universal references.</h1><p>前面我们已经讨论过，右值引用总是可以无条件转换为右值因此用<code>std::move</code>，但普适引用不一定是右值，因此要用<code>std::forward</code>做<strong>有条件</strong>的右值转换。</p>
<p>由于<code>move</code>没有办法应对<code>const</code>，所以有的人会说，我们重载两个函数来灵活应对，当传入<code>const</code>时，我们使用复制，否则就使用移动构造。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; newName)</span> </span>&#123;</span><br><span class="line">        name = <span class="built_in">std</span>::move(newName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>想得很美好，代码也能运行，但实际情况是如果我有$n$个参数，则需要重载$2^n$个版本。</p>
<p>所以我们可以用<code>std::forward</code>（对于普适引用）去移动它们。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSignText</span><span class="params">(T&amp;&amp; text)</span> </span>&#123;</span><br><span class="line">    sign.setText(text); <span class="comment">// use text, but don't modify it</span></span><br><span class="line">    <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now(); </span><br><span class="line">    signHistory.add(now, <span class="built_in">std</span>::forward&lt;T&gt;(text)); </span><br><span class="line">    <span class="comment">// conditionally cast text to rvalue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有一个<strong>按值返回的函数</strong>，其返回的对象是右值引用或普适引用，那么也可以用<code>std::move</code>或<code>std::forward</code>来获得更好的性能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="keyword">const</span> Matrix&amp; rhs) &#123;</span><br><span class="line">    lhs += rhs;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(lhs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者是</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Fraction <span class="title">reduceAndCopy</span><span class="params">(T&amp;&amp; frac)</span> </span>&#123;</span><br><span class="line">    frac.reduce();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;T&gt;(frac);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>Matrix</code>和<code>frac</code>不支持移动，用<code>std::move</code>和<code>std::forward</code>也不会有副作用。等到他们支持移动了，上面的代码马上就能享受到性能的提升。</p>
<p>如果返回的对象是个<strong>local对象</strong>，有些人可能会想到用<code>std::move</code>来避免复制（注意和上面返回的区别）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样并不对，有个概念叫<strong>RVO</strong>，即“<strong>返回值优化</strong>”，即编译器会在返回一个local对象时，如果函数的返回类型就是值类型，那么编译器可以直接将这个local对象构造在接收函数返回值的对象上，省掉中间的复制过程。换句话说，在RVO的帮助下，直接返回这个local对象要比返回它的右值还要节省。</p>
<h1 id="Item-26-Avoid-overloading-on-universal-references"><a href="#Item-26-Avoid-overloading-on-universal-references" class="headerlink" title="Item 26:Avoid overloading on universal references."></a>Item 26:Avoid overloading on universal references.</h1><p>注意：<strong>根据C++的重载决议规则，普适引用版本总会被优先匹配。</strong></p>
<p>假设我对普适引用进行重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; names;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*part1*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">    names.emplace(<span class="built_in">std</span>::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*part2*/</span></span><br><span class="line"><span class="comment">//获取ID后，利用函数nameFromIdx得到string再构造</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">nameFromIdx</span><span class="params">(<span class="keyword">int</span> idx)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> to_string(idx) + <span class="string">"_myname"</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    names.emplace(nameFromIdx(idx));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">short nameId=<span class="number">10086</span>;</span><br><span class="line">logAndAdd(nameId); <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>对上面的代码我们可以分为以下几种情况：</p>
<ol>
<li>part1和part2存在，输入int。换完美运行重载函数，</li>
<li>part1和part2存在。输入short，优先运行普适引用版本，报错。</li>
<li>part1删除，保留part2，输入short。编译器隐式转换，扩大范围，转换为int，完美运行。</li>
</ol>
<p>因此，我们知道<strong>普适引用版本在重载决议中的顺序都非常靠前</strong>，它们几乎能完美匹配所有类型，重载版本很可能无法顺利工作（除非类型完全匹配，不包含任何隐式转换）</p>
<p><strong>在类的构造函数这里，情况变得更糟了：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    explicit Person(T&amp;&amp; n) : name(std::forward&lt;T&gt;(n)) &#123;&#125;</span><br><span class="line">    explicit Person(int idx) : name(nameFromIdx(idx)) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据item17，某个类有模板构造函数不会阻止编译器为它生成复制和移动构造函数，因此<code>Person</code>中的构造函数实际上有4个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(T&amp;&amp; n)</span></span></span><br><span class="line">: name(std::forward&lt;T&gt;(n)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> idx)</span></span></span><br><span class="line">    : name(nameFromIdx(idx)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person(<span class="keyword">const</span> Person&amp; rhs);</span><br><span class="line">Person(Person&amp;&amp; rhs);</span><br></pre></td></tr></table></figure>

<p>当我们调用如下代码时，我们以为调用了复制构造函数，实际上却是匹配到了普适引用的版本，这相当违反直觉！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Baolan"</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;<span class="comment">//error</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Person <span class="title">p3</span><span class="params">(<span class="string">"Clearlove"</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(p3)</span></span>;<span class="comment">//work</span></span><br></pre></td></tr></table></figure>

<p>因为生成的默认拷贝构造函数需要<code>const</code>，此时编译器判断输入的Baolan<strong>不是完美匹配</strong>，所以他选择了普适引用的版本，除非我们像Clearlove那样构造<code>cosnt Person</code>这样才能顺利通过编译。</p>
<h1 id="Item-27-Familiarize-yourself-with-alternatives-to-overloading-on-universal-references"><a href="#Item-27-Familiarize-yourself-with-alternatives-to-overloading-on-universal-references" class="headerlink" title="Item 27:Familiarize yourself with alternatives to overloading on universal references."></a>Item 27:Familiarize yourself with alternatives to overloading on universal references.</h1><p>如何解决上一章的问题呢？一种思路是放弃重载普适引用，原书中介绍了三种方式：完全放弃重载构建两个不同名函数，通过值传递，通过C98的老办法const T&amp;构造。这里先不做介绍，接下来介绍两种能够重载普适引用的办法，这两种办法非常trick，运用了很多现代CPP编程的特性，非常值得学习。</p>
<p><strong>（1）使用标签分发(Tag dispatch)</strong></p>
<p>重载决议是在所有参数上发生的，那么如果我们人为的增加一个Tag参数，用Tag参数来匹配，就能避免普适引用带来的问题。</p>
<p>首先是原始版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; names;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">"logAndAdd"</span>);</span><br><span class="line">    names.emplace(<span class="built_in">std</span>::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">    logAndAddImpl(<span class="built_in">std</span>::forward&lt;T&gt;(name), <span class="built_in">std</span>::is_integral&lt;T&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的问题在于，当实参是左值时，<code>T</code>会被推导为左值引用，即如果实参类型是<code>int</code>，那么<code>T</code>就是<code>int&amp;</code>，<code>std::is_integral()</code>就会返回false。这里我们需要把<code>T</code>可能的引用性去掉：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">    logAndAddImpl(</span><br><span class="line">        <span class="built_in">std</span>::forward&lt;T&gt;(name),</span><br><span class="line">        <span class="built_in">std</span>::is_integral&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&gt;()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>logAndAddImpl</code>提供两个特化版本。为什么用<code>std::true_type</code>/<code>std::false_type</code>而不用<code>true/false</code>？<strong>前者是编译期值，后者是运行时值。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAddImpl</span><span class="params">(T&amp;&amp; name, <span class="built_in">std</span>::false_type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">log</span>(now, <span class="string">"logAndAdd"</span>);</span><br><span class="line">    names.emplace(<span class="built_in">std</span>::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">nameFromIdx</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAddImpl</span><span class="params">(T&amp;&amp; name, <span class="built_in">std</span>::true_type)</span> </span>&#123;</span><br><span class="line">    logAndAdd(nameFromIdx(idx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们并没有给<code>logAndAddImpl</code>的第二个参数起名字，说明它就是一个Tag。这种方法常用于模板元编程。</p>
<p><strong>（2）限制模板使用普适引用</strong></p>
<p>Tag dispatch的思路是利用一个不重载的函数作为入口，他会安排一个tag参数，再分发给重载函数。但这种办法并不能解决类的构造函数问题，编译器依然会自己生成复制和移动构造函数。</p>
<p>我们可以利用C++的SFINAE特性(Substitution Failure Is Not An Error)，使用<code>std::enable_if</code>，只有里面的条件为真是，这个参数才有效，否则我们就忽略它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line">              <span class="keyword">typename</span> = <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;condition&gt;::type&gt;</span><br><span class="line">    <span class="keyword">explicit</span> Person(T&amp;&amp; n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们引入了一个强大的工具，现在需要考虑怎么运用它。我们之前的问题是：我重载了普适引用，但<strong>由于<code>const</code>，引用符等问题导致我的重载函数和传入的参数不能完美匹配，从而让编译器选择了普适引用，</strong>现在我想让编译器明白：有没有CV符号不重要，只要长得差不多，你就赶紧给我调用重载版本！！！</p>
<p>因此，我们可以把condition设为：忽略CV符号和引用，<code>T</code>和<code>person</code>是不是同一种类型。标准库中对应的工具是<code>std::decay</code>，它会<strong>把对象身上的引用和cv特性都去掉</strong>。它在处理数组和函数类型时会把它们转为指针类型。</p>
<p><strong>引用和cv特性都去掉</strong>。它在处理数组和函数类型时会把它们转为指针类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;</span><br><span class="line">            !<span class="built_in">std</span>::is_same&lt; Person,</span><br><span class="line">                <span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;T&gt;::type</span><br><span class="line">            &gt;::value&gt;</span><br><span class="line">        &gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> Person(T&amp;&amp; n);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于<code>Person</code>的构造函数，上面的版本已经能解决了：在传入的参数类型为<code>Person</code>时调用我们希望的复制和移动构造函数，而在其它时候调用完美转发函数。</p>
<p>最后一个问题是派生类，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialPerson</span>:</span> <span class="keyword">public</span> Persion &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SpecialPerson(<span class="keyword">const</span> SpecialPerson&amp; rhs)  <span class="comment">// copy ctor: calls Person forwarding ctor!</span></span><br><span class="line">    : Person(rhs)</span><br><span class="line">    &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    SpecialPerson(SpecialPerson&amp;&amp; rhs)       <span class="comment">// move ctor: calls Person forwarding ctor!</span></span><br><span class="line">    : Person(<span class="built_in">std</span>::move(rhs))</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看起来这并没有解决， 因为<code>std::is_same::value</code>是<code>false</code>，我们需要的是<code>std::is_base_of</code>，其作用是判断是否为基类，我们就可以改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;</span><br><span class="line">            !<span class="built_in">std</span>::is_base_of&lt;</span><br><span class="line">                Person,</span><br><span class="line">                <span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;T&gt;::type</span><br><span class="line">            &gt;::value&gt;</span><br><span class="line">        &gt;::type</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> Person(T&amp;&amp; n);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++14中代码可以省一点：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;</span><br><span class="line">            !<span class="built_in">std</span>::is_base_of&lt;Person, <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;T&gt;&gt;::value&gt;</span><br><span class="line">        &gt;</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> Person(T&amp;&amp; n);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还没有结束，最后一个问题：如何区分整数类型和非整数类型。直接看最终版本，这个版本就代表了：如果参数T不是派生出来的也不是整数，那么就采用普适引用版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;</span><br><span class="line">        <span class="keyword">typename</span> T,</span><br><span class="line">        <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;</span><br><span class="line">            !<span class="built_in">std</span>::is_base_of&lt;Person, <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;T&gt;&gt;::value&gt; &amp;&amp;</span><br><span class="line">            !<span class="built_in">std</span>::is_integral&lt;<span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class="line">        &gt;</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="keyword">explicit</span> Person(T&amp;&amp; n)</span><br><span class="line">    : name(<span class="built_in">std</span>::forward&lt;T&gt;(n))</span><br><span class="line">    &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">explicit</span> Person(<span class="keyword">int</span> idx)</span><br><span class="line">    : name(nameFromIdx(idx))</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Item-28-Understand-reference-collapsing"><a href="#Item-28-Understand-reference-collapsing" class="headerlink" title="Item 28:Understand reference collapsing."></a>Item 28:Understand reference collapsing.</h1><p>一般来说，引用的引用在C++中是非法的，你不能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; &amp;m;</span><br></pre></td></tr></table></figure>

<p>但在类型推断中，有一套单独的规则：<strong>引用折叠</strong>。可以看出这套规则中只要不是4个&amp;，统统折叠为左值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T&amp; &amp;   =&gt; T&amp;</span><br><span class="line">T&amp; &amp;&amp;  =&gt; T&amp;</span><br><span class="line">T&amp;&amp; &amp;  =&gt; T&amp;</span><br><span class="line">T&amp;&amp; &amp;&amp; =&gt; T&amp;&amp;</span><br></pre></td></tr></table></figure>

<p>引用折叠就是<code>std::forward</code>依赖的关键特性。一个简化的<code>std::forward</code>实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我传入了一个<code>widget&amp;</code>，则</p>
<ol>
<li><p><code>remove_reference::type</code>去除引用，将T变为<code>widget&amp;</code>，此时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Widget&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用引用折叠<code>widget&amp; &amp;&amp; = widget&amp;</code>，返回。</p>
</li>
</ol>
<p>若传入的是右值，则在折叠阶段，返回<code>widget&amp;&amp;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget&amp;&amp; <span class="title">forward</span><span class="params">(Widget&amp; param)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Widget&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Item-30-Familiarize-yourself-with-perfect-forwarding-failure-cases"><a href="#Item-30-Familiarize-yourself-with-perfect-forwarding-failure-cases" class="headerlink" title="Item 30:Familiarize yourself with perfect forwarding failure cases."></a>Item 30:Familiarize yourself with perfect forwarding failure cases.</h1><p>假设有一个非完美转发的函数<code>f</code>，和它对应的完美转发版本<code>fwd</code>，我们会遇到几个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwd</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    f(<span class="built_in">std</span>::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们希望以下两个函数有相同行为</span></span><br><span class="line">f(expression);</span><br><span class="line">fwd(expression);</span><br></pre></td></tr></table></figure>

<p><strong>（1）花括号初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span>;</span><br><span class="line">f(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);   <span class="comment">// fine, "&#123;1, 2, 3&#125;" implicitly converted to std::vector&lt;int&gt;</span></span><br><span class="line">fwd(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// error! doesn't compile</span></span><br></pre></td></tr></table></figure>

<p>原因在于，编译器知道<code>f</code>的形参类型，所以它知道可以把实参类型隐式转换为形参类型。但编译器不知道<code>fwd</code>的形参类型，因此需要通过实参进行类型推断。这里完美转发会在发生以下情况时失败：</p>
<ul>
<li>无法推断出<code>fwd</code>的某个参数类型。</li>
<li>推断出错误类型。这里的“错误”可以是推断出的类型无法实例化<code>fwd</code>，也可以是<code>fwd</code>的行为与<code>f</code>不同。后者的一个可能原因是<code>f</code>是重载函数的名字，推断的类型不对会导致调用错误的重载版本。</li>
</ul>
<p>在<code>fwd({1, 2, 3})</code>这个例子中，问题在于它是一个“未推断上下文”，标准规定禁止推断作为函数参数的花括号初始化式，除非形参类型是<code>std::initializer_list</code>。</p>
<p>解决方案很简单，这里我们应用了Item2中提到的一个<code>auto</code>特性：会优先推断接收的表达式为<code>std::initializer_list</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> il = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">fwd(il);</span><br></pre></td></tr></table></figure>

<p><strong>（2）使用0或NULL</strong></p>
<p>例子见Item8，结论就是不要用<code>0</code>或<code>NULL</code>作为空指针，用<code>nullptr</code>。</p>
<p><strong>（3）只有声明的<code>static const</code>或<code>constexpr</code>的整数成员</strong></p>
<p>通常来说我们不需要给类的声明为<code>static const</code>或<code>constexpr</code>的整数成员一个定义，因为编译器会把这些成员直接替换为对应的整数值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> MinVals = <span class="number">28</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;; <span class="comment">// no def for MinVals</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; widgetData;</span><br><span class="line">widgetData.reserve(Widget::MinVals);</span><br></pre></td></tr></table></figure>

<p>如果没有任何地方取<code>MinVals</code>的地址，编译器就没有必要给它安排一块内存，可以直接替换为整数字面值。否则我们就要给<code>MinVals</code>一个定义，不然程序会在链接阶段出错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> val)</span></span>;</span><br><span class="line"></span><br><span class="line">f(Widget::MinVals);   <span class="comment">// fine, treated as 28</span></span><br><span class="line">fwd(Widget::MinVals); <span class="comment">// error! shouldn't link</span></span><br></pre></td></tr></table></figure>

<p>问题在于<code>fwd</code>的参数类型是非const引用，这相当于取了<code>MinVals</code>的地址，因此我们需要给它一个定义，注意这里就不用给初始值了，否则编译器会报错的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> Widget::MinVals;  <span class="comment">// in Widget's .cpp file</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）重载的函数名字和模板名字</strong></p>
<p>假设<code>f</code>的参数是一个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> (*pf)(<span class="keyword">int</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> pf(<span class="keyword">int</span>))</span></span>; <span class="comment">//这样也可以</span></span><br></pre></td></tr></table></figure>

<p>以及我们有两个重载函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processVal</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processVal</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当我们把<code>processVal</code>传入时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(processVal); <span class="comment">// fine</span></span><br><span class="line">fwd(processVal); <span class="comment">// error! which processVal?</span></span><br></pre></td></tr></table></figure>

<p>因为<code>fwd</code>的参数没有类型，<code>processVal</code>这个名字本身也没能给出一个确定的类型。</p>
<p>模板函数也有这样的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">workOnVal</span><span class="params">(T param)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">fwd(workOnVal); <span class="comment">// error! which workOnVal instantiation?</span></span><br></pre></td></tr></table></figure>

<p>解决方案就是确定下来重载函数名字或模板函数名字对应的函数类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ProcessFuncType = <span class="keyword">int</span> (*)(<span class="keyword">int</span>);</span><br><span class="line">ProcessFuncType processValPtr = processVal;</span><br><span class="line">fwd(processValPtr);</span><br><span class="line">fwd(<span class="keyword">static_cast</span>&lt;ProcessFuncType&gt;(workOnVal));</span><br></pre></td></tr></table></figure>

<p><strong>（5）位域</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IPv4Header</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">uint32_t</span> version:<span class="number">4</span>,</span><br><span class="line">                  IHL:<span class="number">4</span>,</span><br><span class="line">                  DSCP:<span class="number">6</span>,</span><br><span class="line">                  ECN:<span class="number">2</span>,</span><br><span class="line">                  totalLength:<span class="number">16</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> sz)</span></span>;</span><br><span class="line"></span><br><span class="line">IPv4Header h;</span><br><span class="line">...</span><br><span class="line">f(h.totalLength);   <span class="comment">// fine</span></span><br><span class="line">fwd(h.totalLength); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<p>问题在于<code>fwd</code>的参数是非const引用，而C++标准禁止创建位域的非const引用。实际上，位域的const引用就是引用一个临时的复制整数。解决方案很简单：把位域的值复制出来，再传入<code>fwd</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> length = <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">uint16_t</span>&gt;(h.totalLength);</span><br><span class="line">fwd(length);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B06-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" data-id="ck4o2tur9000du4vy9rtvffmo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-EffectiveModernCPP笔记5-智能指针" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B05-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="article-date">
  <time datetime="2019-12-26T11:34:53.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B05-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">EffectiveModernCPP笔记5-智能指针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="EffectiveModernCPP笔记5-智能指针"><a href="#EffectiveModernCPP笔记5-智能指针" class="headerlink" title="EffectiveModernCPP笔记5-智能指针"></a>EffectiveModernCPP笔记5-智能指针</h1><p>描述了三大智能指针：unique_ptr, shared_ptr, weak_ptr，介绍了为什么更倾向于用make构造而不是new，如何构建Pimpl来减轻编译负担</p>
<h1 id="Item-18-Use-unique-ptr-for-exclusive-ownership-resource-management"><a href="#Item-18-Use-unique-ptr-for-exclusive-ownership-resource-management" class="headerlink" title="Item 18:Use unique_ptr for exclusive-ownership resource management."></a>Item 18:Use unique_ptr for exclusive-ownership resource management.</h1><p>先解释一下，exclusive ownership是独占所有权的意思，顾名思义这一章的主要目的是介绍如何利用<code>unique_ptr</code>管理独占所有权的资源。</p>
<p><code>std::unique_ptr</code>体现了显式所有权的语义：非空的<code>std::unique_ptr</code>总是拥有它指向的对象，换句话说我们只能<strong>通过移动转移所有权，而不允许复制</strong>。</p>
<p>它的主要应用是在<strong>工厂模式</strong>。假设有一个基类和三个派生类，通过一个工厂函数来返回某个派生类的<code>std::unique_ptr</code>，这样调用方就不需要费心什么时候销毁返回的对象了：<code>std::unique_ptr</code>会负责这件事。</p>
<blockquote>
<p>工厂函数使用了C++<strong>多态</strong>的特性，将存在<strong>继承</strong>关系的类，通过一个<strong>工厂类创建</strong>对应的子类（派生类）对象。比如父类是Shoes，子类有Nike，LiNing，Adidas，假设有一个工厂函数，把生产鞋子的需求输入其中，他就能调用shoes父类下面的子类进行构造。</p>
</blockquote>
<p>我们做一个完整的例子，投资类下面有三个子类：股票、债券、期货，再带一个工厂函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Investment() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"investment destoryed\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeLogEntry</span><span class="params">(Investment* pInv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deleting investment on "</span> &lt;&lt; pInv &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> :</span> <span class="keyword">public</span> Investment &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stock() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"make an invesetment on stock\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Stock() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a stock investment destoryed,"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bond</span> :</span> <span class="keyword">public</span> Investment &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bond() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"make an investmentt on bond\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Bond() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a bond investment destroyed,"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealEstate</span> :</span> <span class="keyword">public</span> Investment &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RealEstate() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"make an investmentt on RealEstate\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~RealEstate() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a RealEstatend investment destroyed,"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteAndLog</span><span class="params">(Investment* pInv)</span> </span>&#123;</span><br><span class="line">    makeLogEntry(pInv);</span><br><span class="line">    <span class="keyword">delete</span> pInv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">auto</span> <span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> delInvmt = [](Investment* pInv)</span><br><span class="line">    &#123;</span><br><span class="line">        makeLogEntry(pInv);</span><br><span class="line">        <span class="keyword">delete</span> pInv;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Investment, <span class="keyword">decltype</span>(delInvmt)&gt; InvestmentPtr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(InvestmentPtr) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">InvestmentPtr <span class="title">pInv</span><span class="params">(<span class="literal">nullptr</span>, delInvmt)</span></span>;</span><br><span class="line">    pInv.reset(<span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;Ts&gt;(params)...));<span class="comment">//不能直接将裸指针赋值给一个unique_ptr，要使用reset</span></span><br><span class="line">    <span class="keyword">return</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unique_ptr</code>默认的销毁方式是通过对<code>unique_ptr</code>中的裸指针进行<code>delete</code>操作，但是也可以在声明的时候指定销毁函数，在上面的代码中，通过<code>lambda</code>表达式置顶了一个打印日志函数，要在销毁指针的时候会打印日志。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> delLog = [](<span class="keyword">int</span>* pInv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"See you !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pInv;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>, <span class="keyword">decltype</span>(delLog)&gt; pInt(<span class="literal">nullptr</span>, delLog);</span><br><span class="line">pInt.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *pInt &lt;&lt; <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure>

<p>客户端的调用方法如下，这样会产生一个<code>unique_ptr</code>指针指向stock，只要这个程序不结束，那么他就不会调用销毁函数，反之当程序终止时调用函数销毁对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pInvestment = makeInvestment&lt;Stock&gt;();</span><br></pre></td></tr></table></figure>

<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191108103101.png" alt="img" style="zoom:67%;" />

<p>我们还可以通过<code>move</code>的方式转移所有权，但不能调用拷贝构造，参见delete那一章。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pInvestment = makeInvestment&lt;Bond&gt;();</span><br><span class="line"><span class="keyword">auto</span> pInvestment2 = <span class="built_in">std</span>::move(pInvestment);</span><br></pre></td></tr></table></figure>

<p>总结一下：</p>
<ul>
<li><code>delInvmt</code>是自定义的销毁器，在<code>std::unique_ptr</code>析构时，自定义的销毁器会来完成释放资源必需的操作。这里用lambda表达式来实现<code>delInvmt</code>，不仅更方便，性能还更好。</li>
<li>自定义的销毁器的类型必须与<code>std::unique_ptr</code>的第二个模板参数相同，因此我们要用<code>decltype(delInvmt)</code>来声明<code>std::unique_ptr</code>。</li>
<li><code>makeInvestment</code>的基本策略是创建一个空的<code>std::unique_ptr</code>，再令它指向合适的类型，再返回。其中我们把<code>delInvmt</code>作为第二个构造参数传给<code>std::unique_ptr</code>，从而将销毁器与<code>pInv</code>关联起来。</li>
<li>无法将裸指针隐式转换为<code>std::unique_ptr</code>，需要用<code>reset</code>来修改<code>std::unique_ptr</code>持有的裸指针。</li>
<li>我们在创建具体的对象时，使用了<code>std::forward</code>将<code>makeInvestment</code>的所有参数完美转发给对应的构造函数。</li>
<li>注意<code>delInvmt</code>的参数是<code>Investment*</code>，而它的实际类型可能是派生类，因此需要基类<code>Investment</code>有一个虚的析构函数。</li>
</ul>
<h1 id="Item-19-Use-shared-ptr-for-shared-ownership-resource-management"><a href="#Item-19-Use-shared-ptr-for-shared-ownership-resource-management" class="headerlink" title="Item 19:Use shared_ptr for shared-ownership resource management."></a>Item 19:Use shared_ptr for shared-ownership resource management.</h1><p>很多语言都有GC(garbage collection)机制，但这种机制带来的是资源释放的不确定性，而原始的C语言有两种内存：<strong>栈上的内存</strong>（函数的局部变量等等，由操作系统释放），<strong>动态内存</strong>（依靠new，malloc等方式用户自己分配的内存，需要手动释放）。如果我们在程序中忘了释放这些动态内存，而程序又是会持续运行的服务进程，会导致内存占用越来越高，轻者致残影响系统性能，重者致命导致进程崩溃。下面举个例子：</p>
<p>下面这一段程序按照规范合理释放内存，他的内存使用情况如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *p = i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191108110927.png" alt="img" style="zoom:67%;" />

<p>然而如果我去掉了<code>free(p)</code>这一句，就会导致如下的情况，问题一目了然！有可能你的程序从70MB跑了一年跑到200MB了。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191108111028.png" alt="img" style="zoom:67%;" />

<p>以上介绍了<strong>不及时释放内存导致泄露</strong>的结果，下面就正式介绍C++是如何<strong>在保证手工管理内存的确定性和自动GC机制的便利性</strong>中做平衡的。现代CPP给出的方案是<code>shared_ptr</code>！</p>
<p>从c++11开始引入的<code>shared_ptr</code>，用来表示指针对指向对象的“<strong>共享所有权</strong>”；一个对象可以被多个<code>shared_ptr</code>指向和访问，这些<code>shared_ptr</code>类型的指针共同享有该对象的所有权，<strong>当最后一个指向该对象的<code>shared_ptr</code>生命周期结束的时候，对象被销毁</strong>。</p>
<p>下面介绍他的机制和特点：</p>
<p><strong>（1）基于引用计数实现</strong></p>
<p>他的机制和JVM的机制一样，基于引用计数实现，<code>shared_ptr</code>的构造将引用计数加1，销毁的时候引用计数减1，而赋值则将源指针引用计数加1，目标指针引用计数减1，例如<code>P1=P2</code>，<code>P1</code>指向对象的引用计数减1，<code>P2</code>指向对象的引用计数加1。当引用计数减1之后为0的时候，<code>shared_ptr</code>将会销毁指向的对象。<code>shared_ptr</code>的<strong>构造函数函数会增加引用计数</strong>，但是移动构造除外，因为<strong>移动构造并没有增加指向对象的引用计数，所以不需要改变引用计数</strong>；需要注意：</p>
<ul>
<li><code>std::shared_ptr</code>占用的内存空间是原生指针的两倍</li>
<li>被指向对象的内存空间必须是<strong>动态分配</strong>的</li>
<li>增加或者减少指针引用对象的操作必须是原子操作类型的，多线程操作时要谨慎使用<code>std::shared_ptr</code></li>
</ul>
<p><strong>（2）销毁器不是指针类型的一部分</strong></p>
<p>与<code>unique_ptr</code>类似，<code>shared_ptr</code>同样也支持自定义销毁方法（默认是直接调用<code>delete</code>），<strong>与<code>unique_ptr</code>不同的是，销毁方式是<code>unique_ptr</code>类型的一部分，而<code>shared_ptr</code>的销毁方式却不是。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> loggingDel = [](Widget *pw)</span><br><span class="line">                  &#123;</span><br><span class="line">                      makeLogEntry(pw);</span><br><span class="line">                      <span class="keyword">delete</span> pw;</span><br><span class="line">                  &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget, <span class="keyword">decltype</span>(loggingDel)&gt; upw(<span class="keyword">new</span> Widget, loggingDel);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw(<span class="keyword">new</span> Widget, loggingDel);</span><br></pre></td></tr></table></figure>

<p>不把销毁方式作为<code>shared_ptr</code>类型的一部分可以带来更大的灵活性，因为这里不同的<code>shared_ptr</code>指针对象可能需要不同的销毁方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> customDeleter1 = [](Widget *pw) &#123; … &#125;; <span class="comment">// custom deleters,</span></span><br><span class="line"><span class="keyword">auto</span> customDeleter2 = [](Widget *pw) &#123; … &#125;; <span class="comment">// each with adifferent type</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw1(<span class="keyword">new</span> Widget, customDeleter1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw2(<span class="keyword">new</span> Widget, customDeleter2);</span><br><span class="line"><span class="comment">//由于有相同的结构，所以可以写成</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;&gt;vpw&#123;pw1, pw2&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（3）包含一个控制块</strong></p>
<p>与unique_ptr不同的是<strong>，自定义销毁方式并不会改变shared_ptr的size，shared_ptr的size始终是两倍的裸指针size，</strong>其内存布局是如下图所示：</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191108113130.png" alt="img" style="zoom: 67%;" />

<ul>
<li>使用<code>std::make_shared</code>的时候<strong>总是</strong>分配控制块</li>
<li><code>shared_ptr</code>由<code>unique_ptr</code>或裸指针构建时分配控制块</li>
<li><code>shared_ptr</code>由其他<code>shared_ptr</code>或<code>weak_ptr</code>构建时不分配新的控制块，而是沿用既有智能指针的控制块</li>
</ul>
<p>这就会带来一个问题，当我们用一个裸指针构建多个shared_ptr时，会<strong>分配多个控制块</strong>，同一个对象确有多个引用计数（控制块），这就很容易<strong>导致一个对象被销毁多次</strong>，下面的代码描述了这种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pw = <span class="keyword">new</span> Widget; <span class="comment">// pw 是原生指针</span></span><br><span class="line"><span class="comment">//…</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw1(pw, loggingDel); <span class="comment">// create control block for *pw</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw2(pw, loggingDel); <span class="comment">// create 2nd control block</span></span><br></pre></td></tr></table></figure>

<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191108113840.png" alt="img" style="zoom:67%;" />

<p>如何避免这个问题呢？尽可能<strong>避免使用裸指针来构建<code>shared_ptr</code>，使用<code>make_shared</code></strong>。</p>
<p><strong>关于shared_ptr性能的讨论</strong></p>
<p><code>shared_ptr</code>的控制块是动态生成的，尽管占用的空间并不大，但是控制块的实际实现比想象的要复杂，实现控制块<strong>使用到了继承和虚函数，同时引用计数的增减是原子操作</strong>也增加了性能上的代价，这些都导致了<code>shared_ptr</code>并不是管理所有动态资源的最好方案，使用<code>shared_ptr</code>解引用获取对象时会比直接使用裸指针的代价更高；</p>
<p>然而，尽管<code>shared_ptr</code>有在性能上付出了一定的代价，其带来的收益是非常显著的，<code>shared_ptr</code>解决了动态分配资源的生命周期自动管理，大多数时候，在“共享所有权”的语义下，使用<code>shared_ptr</code>管理动态资源都是值得推荐的；而没有“共享所有权”语义的其他情况下，例如“独占所有权”，则可以使用<code>unique_ptr</code>来代替；</p>
<p>另一个<code>shared_ptr</code>不能做的事情是管理数组，不能使用<code>std::shared_ptr</code>这样的类型，然而，c++ 11之后标准库已经引入了<code>std::array</code>，<code>shared_ptr</code>管理一个<code>std::array</code>类型的对象是可行的。</p>
<h1 id="Item-20-Use-weak-ptr-for-shared-ptr-like-pointers-that-can-dangle"><a href="#Item-20-Use-weak-ptr-for-shared-ptr-like-pointers-that-can-dangle" class="headerlink" title="Item 20:Use weak_ptr for shared_ptr-like pointers that can dangle."></a>Item 20:Use weak_ptr for shared_ptr-like pointers that can dangle.</h1><p>虽然有了<code>std::shared_ptr</code>，但我们却并不知道指向的资源到底有没有被销毁，我们希望有一种智能指针能够追踪他什么时候空悬(dangle，即对象不存在)，解决方案就是采用<code>std::weak_ptr</code>。</p>
<p>先，这个指针并不是单独存在的，他需要搭配<code>shared_ptr</code>一起使用。<code>std::weak_ptr</code>通常是由<code>std::shared_ptr</code>中创建而来。它们指向的地方与初始化它们的<code>std::shared_ptr</code>指向的地方相同，但它们<strong>不会影响指向对象的引用计数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = <span class="built_in">std</span>::make_shared&lt;Widget&gt;();  <span class="comment">// spw是std::shared_ptr&lt;Widget&gt;</span></span><br><span class="line">                                        <span class="comment">// 引用计数为1</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Widget&gt; wpw(spw); <span class="comment">// wpw指向spw指向的Widget，引用计数仍然为1</span></span><br><span class="line">...</span><br><span class="line">spw = <span class="literal">nullptr</span>;    <span class="comment">// 引用计数变成0，Widget被销毁，wpw现在变成空悬指针</span></span><br></pre></td></tr></table></figure>

<p>如上所示，当<code>weak_ptr</code>变为空悬指针时，我们可以去检查它<code>if (wpw.expired())</code></p>
<p>不过一般状况是：当你去检查<code>std::weak_ptr</code>是否过期，如果没有过期（即不是空悬），就要取得它指向的对象。</p>
<p>因为<code>std::weak_ptr</code>没有解引用操作，所以没有办法写出解引用的代码。就算有这个操作，<strong>单独的检查操作和解引用操作会引出一个竞争条件</strong>：在调用检查操作和解引用操作之间，另一个线程重赋值或销毁最后一个指向对象的<code>std::shared_ptr</code>，因此导致对象被销毁，这样解引用就产生了未定义行为。</p>
<p>因此需要原子操作来检查<code>shared_ptr</code>是否过期，通常情况我们使用<code>std::weak_ptr::lock</code>，如果<strong>不为空则返回对应的<code>shared_ptr</code>否则返回<code>nullptr</code></strong></p>
<p><strong>（1）应用一：cache缓存</strong></p>
<p>下面是一个使用<code>weak_ptr</code>和哈希表容器构建缓存的示例，由于<code>loadWidget</code>的操作可能是大开销函数，所以我们最好设计一个缓存，保存我们加载过的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> Widget&gt; fastLoadWidget(WidgetID id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;WidgetID, <span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">const</span> Widget&gt;&gt; cache; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> objPtr = cache[id].lock(); <span class="comment">// objPtr是指向缓存对象的shared_ptr(否则为空)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!objPtr) &#123;                    <span class="comment">// 如果不在缓存中</span></span><br><span class="line">        objPtr = loadWidget(id);      <span class="comment">// 大开销函数加载它</span></span><br><span class="line">        cache[id] = objPtr;           <span class="comment">// 缓存它</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。</p>
<ul>
<li>该变量在全局数据区分配内存；</li>
<li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li>
<li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li>
<li>其作用域为局部作用域</li>
</ul>
</blockquote>
<p><strong>（2）应用二：观察者模式</strong></p>
<p>这个设计模式的主要组成是subject（主题，即状态可能改变的对象）和observer（观察者，即出现状态改变时被通知的对象）。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191108132318.png" alt="img"></p>
<p>B是主题，AC为观察者，AC对B有共同使用权，他们都有指向B的<code>shared_ptr</code>用于接收B的改变。现在的问题是如果B要及时知道A是否被销毁，问号处应该使用什么指针？有三种选择：</p>
<ul>
<li>原生指针。若A被销毁，则B指向A的指针会空悬，B没有能力发现，B去解指针的引用时会发生未定义行为！</li>
<li><code>shared_ptr</code>。A指向B且B指向A，形成循环。他们两抱团取暖，互相引用计数，形成闭环，即使其他数据不再指向AB，他们依然不会被销毁。从另一个角度来说，AB已经泄露：程序不能使用它们，资源无法回收。</li>
<li><code>weak_ptr</code>。很好的解决了问题！尽管A和B在互指，B的指针也不会影响A对象的引用计数。如果A被销毁了，B的指针能知道它已经过期了。</li>
</ul>
<h1 id="Item-21-Prefer-std-make-unique-and-std-make-shared-to-direct-use-of-new"><a href="#Item-21-Prefer-std-make-unique-and-std-make-shared-to-direct-use-of-new" class="headerlink" title="Item 21:Prefer std::make_unique and std::make_shared to direct use of new"></a>Item 21:Prefer std::make_unique and std::make_shared to direct use of new</h1><p>为什么用make比用new好？直接上结论：</p>
<p><strong>（1）不用重复类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">upw1</span><span class="params">(<span class="built_in">std</span>::make_unique&lt;Widget&gt;())</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; upw2(<span class="keyword">new</span> Widget);</span><br></pre></td></tr></table></figure>

<p>上述代码通过make，我们只用写一遍<code>widget</code>，如果连续重复类型，有可能会导致dump</p>
<p><strong>（2）异常安全</strong></p>
<p>假设我们有这样的两个函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw, <span class="keyword">int</span> priority)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">computePriority</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">processWidget(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), computePriority()); <span class="comment">// potential resource leak!</span></span><br></pre></td></tr></table></figure>

<p>在<code>processWidget</code>的参数求值过程中，我们只能确定下面几点：</p>
<ul>
<li><code>new Widget</code>一定会执行，即一定会有一个<code>Widget</code>对象在堆上被创建。</li>
<li><code>std::shared_ptr</code>的构造函数一定会执行。</li>
<li><code>computePriority</code>一定会执行。</li>
</ul>
<p><code>new Widget</code>的结果是<code>std::shared_ptr</code>构造函数的参数，因此前者一定早于后者执行。除此之外，编译器不保证其它操作的顺序，即有可能执行顺序为：</p>
<ol>
<li><code>new Widget</code></li>
<li>执行<code>computePriority</code></li>
<li>构造<code>std::shared_ptr</code></li>
</ol>
<p><strong>如果第2步抛异常，第1步创建的对象还没有被<code>std::shared_ptr</code>管理，就会发生内存泄漏。</strong>如果这里我们用<code>std::make_shared</code>，就能<strong>保证<code>new Widget</code>和<code>std::shared_ptr</code>是一起完成</strong>的，中间不会有其它操作插进来，即不会有不受智能指针保护的裸指针出现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::make_shared&lt;Widget&gt;(), computePriority()); <span class="comment">// no potential resource leak</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）更高效</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>:<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw(<span class="keyword">new</span> Widget);</span><br></pre></td></tr></table></figure>

<p>这行代码中，我们以为只有一次内存分配，实际发生了两次，第二次是在分配<code>std::shared_ptr</code>控制块。如果用<code>std::make_shared</code>，它会把<code>Widget</code>对象和控制块合并为一次内存分配。</p>
<hr>
<p>但他也存在一些问题：</p>
<ul>
<li>无法传入自定义的销毁器。</li>
<li>make函数初始化时使用了括号初始化，而不是花括号初始化，比如<code>std::make_unique&gt;(10, 20)</code>创建了一个有着20个值为10的元素的<code>vector</code>，而不是创建了<code>{10, 20}</code>这么两个元素的<code>vector</code></li>
<li>对象和控制块分配在一块内存上，减少了内存分配的次数，但也导致对象和控制块占用的内存也要一次回收掉。即，如果还有<code>std::weak_ptr</code>存在，控制块就要在，对象占用的内存也没办法回收。如果对象比较大，且<code>std::weak_ptr</code>在对象析构后还可能长期存在，那么这种开销是不可忽视的。</li>
</ul>
<p>如果我们因为前面这三个缺点而不能使用<code>std::make_shared</code>，那么我们要保证<strong>，智能指针的构造一定要单独一个语句</strong>。回到之前<code>processWidget</code>的例子中，假设我们有个自定义的销毁器<code>void cusDel(Widget* ptr);</code>，因此不能使用<code>std::make_shared</code>，那么我们要这么写来保证异常安全性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw(<span class="keyword">new</span> Widget, cusDel);</span><br><span class="line">processWidget(spw, computePriority());</span><br></pre></td></tr></table></figure>

<p>当然我们还可以加上移动语义，让它更高效：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw(<span class="keyword">new</span> Widget, cusDel);</span><br><span class="line">processWidget(<span class="built_in">std</span>::move(spw), computePriority());</span><br></pre></td></tr></table></figure>

<h1 id="Item-22-When-using-the-Pimpl-Idiom-define-special-member-functions-in-the-implementation-file"><a href="#Item-22-When-using-the-Pimpl-Idiom-define-special-member-functions-in-the-implementation-file" class="headerlink" title="Item 22:When using the Pimpl Idiom, define special member functions in the implementation file."></a>Item 22:When using the Pimpl Idiom, define special member functions in the implementation file.</h1><p><strong>什么是Pimpl？</strong></p>
<p><code>Pimpl</code>(Pointer to implementation)特别用于减轻编译负担，这是一个C++编程的小技巧，通过它你能<strong>将一个类的数据成员打包放进一个具体的实现类或者结构体中，这些数据成员的访问能将通过指针间接访问</strong>。举个例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">Widget</span><span class="params">()</span>      <span class="comment">//定义在头文件`widget.h`</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; data;</span><br><span class="line">    Gadget g1, g2, g3;  <span class="comment">//Gadget是用户自定义的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们改变<code>Gadget</code>类的时候，整个程序都需要重新编译，所以我们希望改变这种现状。现在我们使用智能指针实现一个Pimpl来解决这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>       //在"<span class="title">Widget</span>.<span class="title">h</span>"中</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Impl</span>;</span>    <span class="comment">//声明一个 实现结构体</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Impl&gt; pImpl;   <span class="comment">//使用智能指针而不是原始指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现文件写为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span>     <span class="comment">//以下代码均在实现文件 widget.cpp里</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gadget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span>:</span>:Impl     <span class="comment">//跟之前一样</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; data;</span><br><span class="line">    Gadget g1,g2,g3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::Widget(): pImpl(<span class="built_in">std</span>::make_unique&lt;Imple&gt;())&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码不会编译通过，因为我们<strong>没有给<code>Widget</code>实现自定义的析构函数</strong>，因此编译器为<code>Widget</code>准备了一个。这个析构函数会被放到<code>Widget</code>的定义体内，默认是内联的，因此会有一份实现在用户文件中。<code>~Widget</code>中只做一件事：析构<code>pImpl</code>，即析构一个<code>std::unique_ptr</code>。注意，<strong>我们隐藏了<code>Impl</code>的实现，在析构<code>std::unique_ptr</code>时编译器发现<code>Impl</code>还是个不完整类型</strong>，此时对它调用<code>delete</code>是危险的，因此编译器用<code>static_cast</code>禁止了这种行为。</p>
<p>解决方案就是我们自己实现一个析构函数，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// widget.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    ~Widget();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Impl</span></span></span><br><span class="line"><span class="class">    <span class="title">std</span>:</span>:<span class="built_in">unique_ptr</span>&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// widget.cpp</span></span><br><span class="line">...</span><br><span class="line">Widget::Widget(): pImpl(<span class="built_in">std</span>::make_unique&lt;Impl&gt;())&#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()&#123;&#125; = <span class="keyword">default</span>; <span class="comment">//参见item17</span></span><br></pre></td></tr></table></figure>

<p>根据Item17，自定义的析构函数会阻止编译器生成移动构造函数和移动赋值函数，因此如果你想要<code>Widget</code>有移动的能力，就要自己实现（注意<strong>不要在这些特殊成员函数的声明后面加<code>= default</code></strong>，这样会重复上面析构函数的问题：会被内联，因此在用户代码中有一份实现，遇到不完整类型）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    ~Widget();</span><br><span class="line">    <span class="comment">//Widget(Widget&amp;&amp; rhs) = default; // right idea, wrong code!</span></span><br><span class="line">    <span class="comment">//Widget&amp; operator=(Widget&amp;&amp; rhs) = default;</span></span><br><span class="line">    Widget(Widget&amp;&amp; rhs) ; </span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs) ;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来就是复制构造函数和复制赋值函数了。我们用<code>std::unique_ptr</code>是为了更好的实现Pimpl方法，这也导致了<code>Widget</code>无法自动生成复制函数（<code>std::unique_ptr</code>不支持），但这并不意味着<code>Widget</code>就不能支持复制了，我们还可以自己定义两个复制函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// widget.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// widget.cpp</span></span><br><span class="line">Widget::Widget(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">    : pImpl(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rhs.pImpl) &#123;</span><br><span class="line">        pImpl = <span class="built_in">std</span>::make_unique&lt;Impl&gt;(*rhs.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!rhs.pImpl) &#123;</span><br><span class="line">        pImpl.reset();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pImpl) &#123;</span><br><span class="line">        pImpl = <span class="built_in">std</span>::make_unique&lt;Impl&gt;(*rhs.pImpl);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *pImpl = *rhs.pImpl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你把<code>pImpl</code>的类型改为<code>std::shared_ptr</code>，你会发现上面所有这些注意事项，都不见了。你不需要手动实现析构函数、移动函数、构造函数，程序编译仍然是好的。所以这么多东西仅仅针对<code>unique_ptr</code>。<strong>这种差异来自于<code>std::unique_ptr</code>和<code>std::shared_ptr</code>对自定义销毁器的支持方式不同</strong>。</p>
<p>对<code>std::unique_ptr</code>而言，<strong>销毁器的类型是<code>unique_ptr</code>的一部分</strong>，这让编译器有可能生成<strong>更小的运行时数据结构和更快的运行代码</strong>。 这种更高效率的后果之一就是<code>unique_ptr</code>指向的类型，在编译器的生成<strong>特殊成员函数被调用时(如析构函数，移动操作)时，必须已经是一个完成类型</strong>。 而对<code>std::shared_ptr</code>而言，销毁器的类型不是该智能指针的一部分，这让它会生成更大的运行时数据结构和稍微慢点的代码，但是当编译器生成的特殊成员函数被使用的时候，指向的对象不必是一个完成类型。</p>
<p>对于<code>pImpl</code>惯用法而言，在<code>std::unique_ptr</code>和<code>std::shared_ptr</code>的特性之间，没有一个比较好的折中。 因为<strong>对于类<code>Widget</code>以及<code>Widget::Impl</code>而言，他们是独享占有权关系</strong>，这让<code>std::unique_ptr</code>使用起来很合适。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B05-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" data-id="ck4o2tur5000bu4vyctx1cl1t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-EffectiveModernCPP笔记3-现代CPP特性下" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8B/" class="article-date">
  <time datetime="2019-12-26T09:51:27.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8B/">EffectiveModernCPP笔记3-现代CPP特性下</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>介绍六个特性：overriding，const_iterator，noexcept，constexpr，const线程安全，类的特殊成员函数</p>
<h1 id="Item-12-Declare-overriding-functions-override"><a href="#Item-12-Declare-overriding-functions-override" class="headerlink" title="Item 12:Declare overriding functions override."></a>Item 12:Declare overriding functions override.</h1><p>在派生和继承中，常常涉及虚函数的使用。</p>
<blockquote>
<p>C++多态(polymorphism)是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。</p>
</blockquote>
<p>然而虚函数能够重写的条件很苛刻，他需要满足很多条件，我们编程时很容易搞错。他需要满足以下要求：</p>
<ul>
<li>基类函数必须是<code>virtual</code></li>
<li>基类和派生类函数名必须完全一样</li>
<li>基类和派生类函数参数必须完全一样</li>
<li>基类和派生类函数常量性(constness)必须完全一样</li>
<li>基类和派生类函数的返回值和异常说明(exception specifications)必须兼容</li>
<li>基类和派生类函数的引用限定符（reference qualifiers）必须完全一样。</li>
</ul>
<p>下面的代码展示了这些错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最可气的是，编译器根本不会报错，最多只是给个warning，但编译时根本不会重写，所以我们需要将它<strong>显式声明</strong>为<code>override</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span> &amp; <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>; <span class="comment">// 可以添加virtual，但不是必要</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比起让编译器通过warnings告诉你重写实际不会重写，不如给你的派生类成员函数全都加上<code>override</code>。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191106111508.png" alt="img" style="zoom:80%;" />

<h1 id="Item-13-Prefer-const-iterators-to-iterators"><a href="#Item-13-Prefer-const-iterators-to-iterators" class="headerlink" title="Item 13:Prefer const_iterators to iterators."></a>Item 13:Prefer const_iterators to iterators.</h1><p>在STL中<code>const_iterator</code>等价于常量指针，他们<strong>指向不能被修改的值</strong>。C98中支持得不是很好，而在11中：<code>const_iterator</code>即容易获取又容易使用。容器的成员函数<code>cbegin</code>和<code>cend</code>产出<code>const_iterator</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> ci = <span class="built_in">std</span>::find(values.cbegin(), values.cend(), <span class="number">3</span>);</span><br><span class="line">*ci = <span class="number">10</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>这其中，<code>ci</code>就直接被划定为<code>const_iterator</code>，所以就不能做修改</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191106114436.png" alt="img"></p>
<h1 id="Item-14-Declare-functions-noexcept-if-they-won’t-emit-exceptions"><a href="#Item-14-Declare-functions-noexcept-if-they-won’t-emit-exceptions" class="headerlink" title="Item 14:Declare functions noexcept if they won’t emit exceptions."></a>Item 14:Declare functions noexcept if they won’t emit exceptions.</h1><p>在C++中人们认为异常信息最有用的在于：<strong>一个函数是否会抛出异常</strong>，这是一个二元性判断，即会和不会。就其本身而言，函数是否为<strong>noexcept</strong>和成员函数是否<strong>const</strong>一样重要。这个可以影响到调用代码的异常安全性和效率。原因如下：</p>
<p><strong>1）避免运行时栈展开</strong></p>
<p>C++98和11有不同的不抛出异常声明方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// C++98风格</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// C++11风格</span></span><br></pre></td></tr></table></figure>

<p>他们最大的不同在于：在C++98的异常说明中，调用栈<strong>会展开</strong>至<code>f</code>的调用者，一些不合适的动作比如程序终止也会发生。C++11异常说明的运行时行为明显不同：调用栈<strong>只是可能</strong>在程序终止前展开。一个必然一个可能，这两者会对代码生成产生巨大的影响。<strong>在一个<code>noexcept</code>函数中，当异常传播到函数外，优化器不需要保证运行时栈的可展开状态，也不需要保证<code>noexcept</code>函数中的对象按照构造的反序析构。</strong>而<code>throw()</code>标注的异常声明缺少这样的优化灵活性，它和没加一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="keyword">noexcept</span></span>;   <span class="comment">// 极尽所能优化</span></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span> <span class="title">throw</span><span class="params">()</span></span>;    <span class="comment">// 较少优化</span></span><br><span class="line"><span class="function">RetType <span class="title">function</span><span class="params">(params)</span></span>;            <span class="comment">// 较少优化</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）保证移动语义能充分发挥作用</strong></p>
<p>当新元素添加到<code>std::vector</code>，<code>std::vector</code>可能没地方放它，这时候，<code>std::vector</code>会分配一片的新的大块内存用于存放，然后将元素从已经存在的内存移动到新内存。在C++98中，移动是<strong>通过复制</strong>老内存区的每一个元素到新内存区完成的，然后<strong>老内存区的每个元素发生析构</strong>。<br>这种方法使得<code>push_back</code>可以提供很强的异常安全保证：<strong>如果在复制元素期间抛出异常，<code>std::vector</code>状态保持不变，因为老内存元素析构必须建立在它们已经成功复制到新内存的前提下。</strong></p>
<p>在C++11中，一个很自然的优化就是将上述复制操作<strong>替换为移动操作</strong>。但是很不幸，破坏了<code>push_back</code>的异常安全。如果异常在移动中抛出，那么<code>push_back</code>操作就不能完成。但是原始的<code>std::vector</code>已经被修改。</p>
<p>因此容器们演化出了一种策略：<strong>如果可以就移动，如果必要则复制</strong>，比如说<code>std::vector::push_back</code>，<code>std::vector::reverse</code>，<code>std:;deque::insert</code>等等。而判断可不可以移动的关键就在于，<strong>移动中是否可能产生异常</strong>！如何判断？<strong>检查是否声明noexcept</strong></p>
<p><strong>那么哪些函数可以写为noexcept呢？</strong></p>
<p>具体来说，<strong>移动操作和swap</strong>可以写为不抛出异常，有助于程序优化。宽泛点来说，我们需要讨论<strong>宽泛契约(wild contracts)和严格契约(narrow contracts)函数</strong></p>
<blockquote>
<p>有宽泛契约的函数没有前置条件。这种函数<strong>不管程序状态如何都能调用</strong>，<strong>它对调用者传来的实参不设约束</strong>。反之，没有宽泛契约的函数就有严格契约。对于这些函数，如果违反<strong>前置条件</strong>，结果将会是未定义的。</p>
</blockquote>
<p>假如现在有一个函数，我想在里面加一个前置条件冲突检查<code>s.size()&lt;32</code>，那么我就不能声明为<code>noexcept</code>，我需要在里面写一个异常抛出函数，抛出<code>&quot;precondition was violated&quot;</code>异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="Item-15-Use-constexpr-whenever-possible"><a href="#Item-15-Use-constexpr-whenever-possible" class="headerlink" title="Item 15:Use constexpr whenever possible."></a>Item 15:Use constexpr whenever possible.</h1><p><code>const</code>是一个古老的关键词，他从C++诞生之日就存在，在漫长的岁月中它承担了很多很多功能，在11中，人们觉得<code>const</code>干太多活，让它太难顶了，于是搞了一个<code>constexpr</code>来帮他分担一些工作，并且使得一些功能更加明确。</p>
<p>总的来说<code>constexpr</code>就是指<strong>编译期可知</strong>，潜台词是：告诉编译器我可以是编译期间可知的，尽情的优化我吧。而<code>const</code><strong>专门用来声明不变量</strong>，潜台词是：告诉程序员没人动得了我，放心的把我传出去；或者放心的把变量交给我，我啥也不动就瞅瞅。</p>
<p><strong>（1）关于常量</strong></p>
<p>这一部分比较简单，往往用于C++要求出现整数常量表达式（ <strong>integral constant expression</strong> ）的上下文。这类上下文包括<strong>数组大小，整数模板参数（包括<code>std::array</code>对象的长度），枚举量，对齐修饰符</strong>（<a href="https://en.cppreference.com/w/cpp/language/alignas" target="_blank" rel="noopener"><code>alignas(val)</code></a>），等等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sz;                             <span class="comment">// 非constexpr变量</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize1 = sz;     <span class="comment">// 错误! sz的值在编译期不可知</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, sz&gt; data1;          <span class="comment">// 错误!一样的问题</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> arraySize2 = <span class="number">10</span>;     <span class="comment">// 没问题，10是编译期可知常量</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, arraySize2&gt; data2;  <span class="comment">// 没问题, arraySize2是constexpr</span></span><br></pre></td></tr></table></figure>

<p>注意const不提供constexpr所能保证之事，因为const对象不需要在编译期初始化它的值。简而言之，<strong>所有constexpr对象都是const，但不是所有const对象都是constexpr。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sz;                            <span class="comment">// 和之前一样</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> arraySize = sz;         <span class="comment">// 没问题，arraySize是sz的常量复制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, arraySize&gt; data;   <span class="comment">// 错误，arraySize值在编译期不可知</span></span><br></pre></td></tr></table></figure>

<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191106135004.png" alt="img" style="zoom:67%;" />

<p><strong>（2）关于函数</strong></p>
<p><strong>如果实参是编译期常量，它们将产出编译期值；如果是运行时值，它们就将产出运行时值</strong>。</p>
<p>如果传给constexpr函数的实参是在编译期可知的，结果就将在编译期计算完成。如果不可知，函数就不理你。</p>
<p>换句话说，当一个constexpr函数被一个或者多个编译期不可知值调用时，它就像普通函数一样，运行时计算它的结果。<strong>这意味着你不需要两个函数</strong>，一个用于编译期计算，一个用于运行时计算。</p>
<p><strong>例子1：</strong>假如我来测量电位，把他们的结果评估为高、中、低三种情况，现在我测量了n组样本，那么得到的组合就是<code>3^n</code>。我们需要一个方法在编译期计算<code>3^n</code>。C++标准库提供了<code>std::pow</code>，这里还有两个问题。</p>
<ul>
<li>第一，<code>std::pow</code>是为浮点类型设计的 我们需要整型结果。</li>
<li>第二，<code>std::pow</code>不是constexpr。因此我们需要自己来写：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> <span class="keyword">noexcept</span> <span class="comment">// C++11</span></span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="params">(<span class="built_in">exp</span> == <span class="number">0</span> ? <span class="number">1</span> : base * <span class="built_in">pow</span>(base, <span class="built_in">exp</span> - <span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> <span class="keyword">noexcept</span>  <span class="comment">// C++14</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">exp</span>; ++i) result *= base;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为11的要求是<strong>constexpr函数的代码不超过一行语句</strong>，所以需要采用三目运算符加递归的方式，非常麻烦，所幸14中得到了解决。</p>
<p><strong>例子2：</strong>构建一个点类</p>
<p>在C++11中，除了void外的所有内置类型可以是<strong>constexpr</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    constexpr Point(double xVal = 0, double yVal = 0) noexcept : x(xVal), y(yVal)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">xValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> x; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">yValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Point的构造函数被声明为constexpr，因为如果传入的参数在编译期可知，Point的数据成员也能在编译器可知。因此Point就能被初始化为constexpr：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>; <span class="comment">// 没问题，构造函数会在编译期“运行”</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>; <span class="comment">// 也没问题</span></span><br></pre></td></tr></table></figure>

<p>类似的，<code>xValue</code>和<code>yValu</code>的<code>getter</code>函数也能是<code>constexpr</code>，这使得我们可以写一个constexpr函数里面调用Point的getter并初始化constexpr的对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">midpoint</span><span class="params">(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; (p1.xValue() + p2.xValue()) / <span class="number">2</span>, </span><br><span class="line">             (p1.yValue() + p2.yValue()) / <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = midpoint(p1, p2);</span><br></pre></td></tr></table></figure>

<p>这就很给力了，因为：</p>
<ul>
<li>mid对象通过调用构造函数，getter和成员函数就能在只读内存中创建！</li>
<li>你可以在模板或者需要枚举量的表达式里面使用像<code>mid.xValue()*10</code>的表达式！</li>
<li>以前相对严格的某一行代码只能用于编译期，某一行代码只能用于运行时的界限变得模糊，一些运行时的普通计算能并入编译时。越多这样的代码并入，你的程序就越快。（当然，编译会花费更长时间）</li>
</ul>
<p>在14中，放开了对void的限制，现在你可以：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也能写这样的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">reflection</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point result; </span><br><span class="line">    result.setX(-p.xValue());</span><br><span class="line">    result.setY(-p.yValue()); </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在客户端就能写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = midpoint(p1, p2);</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> reflectedMid =  reflection(mid);</span><br></pre></td></tr></table></figure>

<h1 id="Item-16-Make-const-member-functions-thread-safe"><a href="#Item-16-Make-const-member-functions-thread-safe" class="headerlink" title="Item 16:Make const member functions thread safe"></a>Item 16:Make const member functions thread safe</h1><p>本文解决以下问题：</p>
<ul>
<li>是什么导致const成员函数变成了非线程安全</li>
<li>如何避免非线程安全问题</li>
</ul>
<p><strong>什么导致const成员函数变成了非线程安全</strong>？</p>
<p>首先<strong><code>const</code>的成员函数的线程是绝对安全的</strong>，因为它不允许对类的成员变量进行修改操作，只能读取。<strong>让它变得不安全的是<code>mutable</code>关键词</strong></p>
<blockquote>
<p><code>mutable</code> 只能用来修饰类的数据成员；而被 <code>mutable</code> 修饰的数据成员，可以在 <code>const</code> 成员函数中修改。</p>
</blockquote>
<p>下面这段代码展示了<code>mutable</code>的作用和为什么线程不安全。<code>roots</code>本身是一个<code>const</code>成员函数，每次返回<code>rootVals</code>，而这个值只有在第一次的时候才需要计算，此后只需要直接返回即可，所以这就<strong>有了一个<code>rootsAreValid</code>来表明这个值是否是已经计算</strong>。</p>
<p>此时如果有两个线程同时执行<code>roots</code>，第一个线程发现<code>rootsAreValid</code>是<code>false</code>，开始计算<code>rootVals</code>，在计算的过程中，第二个线程开始执行，发现<code>rootsAreValid</code>也是<code>false</code>，也开始计算<code>rootvals</code>，这就会出错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polynomial</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!rootsAreValid) &#123;</span><br><span class="line">        ....</span><br><span class="line">        rootsAreValid = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> rootVals;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> rootsAreValid &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootVals&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>如何避免这个问题？</strong></p>
<p><strong>（1）使用互斥锁</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polynomial</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> RootsType = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function">RootsType <span class="title">roots</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; g(m);        <span class="comment">// lock mutex</span></span><br><span class="line">        <span class="keyword">if</span> (!rootsAreVaild) &#123;                    <span class="comment">// 如果缓存无效</span></span><br><span class="line">            rootsAreVaild = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootsVals;</span><br><span class="line">    &#125;                                            <span class="comment">// unlock mutex</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> rootsAreVaild &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> RootsType rootsVals &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码中引入了一个<code>mutable</code>的<code>mutex</code>，因为加锁和解锁本身是会对mutex本身有改动，所以是<code>mutable</code>，但这就带来两个问题：</p>
<ul>
<li>开销变大了，后面<strong>每次都要</strong>加锁获取<code>rootVals</code>，但是其实<strong>只有第一次是可读可写的，非线程安全的，后面就变成只读的了是线程安全的</strong></li>
<li><code>mutex</code>本身其实是一个<strong>只具备移动语义的类</strong>，这导致<code>Polynomial</code>类相应也变成了只具备移动语义的类了，限制了<code>Polynomial</code>类的使用范围。</li>
</ul>
<p><strong>（2）使用原子变量</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span>                                    <span class="comment">// 2D point</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ++callCount;                            <span class="comment">// 原子的递增</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>((x * x) + (y * y));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">unsigned</span>&gt; callCount&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用<code>atomic</code>确保修饰的counter，<strong>保证其他线程视这个操作为不可分割的</strong>。与<code>std::mutex</code>一样，<code>std::atomic</code>是<code>move-only</code>类型，所以在<code>Point</code>中调用<code>Count</code>的意思就是<code>Point</code>也是<code>move-only</code>的。因为<strong>对<code>std::atomic</code>变量的操作通常比互斥量的获取和释放的消耗更小</strong>，所以可能更倾向与依赖<code>std::atomic</code>。但他也有一个很大的问题：</p>
<p>下面的代码的问题是：</p>
<ul>
<li>一个线程调用<code>Widget::magicValue</code>，将<code>cacheValid</code>视为<code>false</code>，执行这两个昂贵的计算，并将它们的和分配给<code>cachedValue</code>。</li>
<li>此时，第二个线程调用<code>Widget::magicValue</code>，也将<code>cacheValid</code>视为<code>false</code>，因此执行刚才完成的第一个线程相同的计算。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">magicValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheVaild) <span class="keyword">return</span> cachedValue;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> val1 = expensiveComputation1();</span><br><span class="line">            <span class="keyword">auto</span> val2 = expensiveComputation2();</span><br><span class="line">            cachedValue = val1 + val2;                <span class="comment">// 第一步</span></span><br><span class="line">            cacheVaild = <span class="literal">true</span>;                        <span class="comment">// 第二步</span></span><br><span class="line">            <span class="keyword">return</span> cachedVaild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; cacheVaild&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; cachedValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以<strong>原子操作只适合于单变量的情况，如果是多变量或多内存位置应使用互斥锁。</strong></p>
<h1 id="Item-17-Understand-special-member-function-generation"><a href="#Item-17-Understand-special-member-function-generation" class="headerlink" title="Item 17:Understand special member function generation"></a>Item 17:Understand special member function generation</h1><p>在C++术语中，特殊成员函数是指C++自己生成的函数。C++98有四个：<strong>默认构造函数函数，析构函数，拷贝构造函数，拷贝赋值运算符</strong>。这些函数仅在需要的时候才生成。</p>
<ul>
<li>class没有任何的<code>constructor</code>，但它内含<code>member object</code>，而后者有默认的构造函数。</li>
<li>class没有任何的<code>constructor</code>，但是它派生自一个带有默认构造函数的基类。</li>
<li>带有虚函数的类</li>
<li>继承自带有虚函数的基类</li>
</ul>
<p>只有在满足上述情况下，编译期才会帮我们生成默认的构造函数，帮我们调用成员变量的构造函数进行初始化，或者是创建虚函数表，调用基类的构造函数，初始化基类等工作。下面的代码就不会产生默认构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">simple</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除此以外，11还产生了两个新的特殊成员函数：<strong>移动构造函数，移动赋值操作符</strong>，其声明方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    .....</span><br><span class="line">    Widget(Widget&amp;&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(widget&amp;&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>移动构造函数的生成规则类似于拷贝构造函数，仅仅当编译器需要的时候才会生成，要求<strong>其每一个非<code>static</code>的成员都具有移动语义</strong>。下面给出一个例子，<strong>Private类型不具有移动语义</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    test() &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    test(<span class="keyword">const</span> test&amp; other) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test t;</span><br><span class="line">    <span class="function">test <span class="title">c</span><span class="params">(<span class="built_in">std</span>::move(t))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>当执行<code>test t</code>时，调用默认构造函数，将<code>p</code>赋值为<code>a</code>。执行<code>test c(std::move(t));</code>时，由于成员不具有移动语义，所以并不能移动构造，只能调用拷贝构造函数，输出<code>&quot;copy construct&quot;</code>，同时<code>p</code>也没有赋值，依然是nullptr。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191107125425.png" alt="img" style="zoom:67%;" />

<p>因此当我们将成员变量改为公有类型，去掉拷贝构造函数，就能使这个类具有移动语义特性时，它就能正确执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  test() &#123;</span><br><span class="line">    str = <span class="string">"test"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  test t;</span><br><span class="line">  <span class="function">test <span class="title">c</span><span class="params">(<span class="built_in">std</span>::move(t))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果给上面的代码加一个拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="keyword">const</span> test&amp; other) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果会调用拷贝构造函数，而不是使用移动构造</strong>。所以我们可以总结得到，造成不能移动构造的<strong>罪魁祸首</strong>是<code>test(const test&amp; other)</code>和<code>char* p = nullptr;</code></p>
<p><strong>那么为什么会这样呢？6个特殊函数的关系如何呢？</strong></p>
<ul>
<li><strong>默认构造函数</strong>，在用户没有声明自定义的构造函数的时候并且编译期需要的时候生成</li>
<li><strong>默认析构函数</strong>，销毁对象时，没有自定义的析构函数就会生成</li>
<li><strong>拷贝构造函数和拷贝赋值操作符</strong>，用户自定义了移动操作会导致不生成默认的拷贝构造函数，其他和上面写的C98的四条原则一样</li>
<li><strong>移动构造函数和移动赋值操作符</strong>，仅仅在没有用户自定义的拷贝操作，移动操作和析构操作的时候才会生成</li>
</ul>
<p>那么如何在自定义能有效使用默认移动构造函数呢？<strong>使用<code>default</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    test() &#123;</span><br><span class="line">        str = <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test(<span class="keyword">const</span> test&amp; other) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test(test&amp;&amp;) = <span class="keyword">default</span>; <span class="comment">//显示的声明默认的移动构造函数</span></span><br><span class="line">    test&amp; <span class="keyword">operator</span>=(test&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8B/" data-id="ck4o2tur8000cu4vyhcn34xv1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-EffectiveModernCPP笔记3-现代CPP特性上" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8A/" class="article-date">
  <time datetime="2019-12-26T09:51:22.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8A/">EffectiveModernCPP笔记3-现代CPP特性上</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>主要介绍C++11/14里面的新东西，分为12两个篇章，这一篇章介绍五个特性：初始化方式，nullptr，别名using，限定域枚举，deleted函数</p>
<h1 id="Item-7-Distinguish-between-and-when-creating-objects"><a href="#Item-7-Distinguish-between-and-when-creating-objects" class="headerlink" title="Item 7:Distinguish between () and {} when creating objects"></a>Item 7:Distinguish between () and {} when creating objects</h1><p>大体上来说，C++的初始化方式分为三种：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> z&#123;<span class="number">0</span>&#125;; <span class="comment">//等价于int c=&#123;0&#125;;</span></span><br></pre></td></tr></table></figure>

<p>对于<code>int</code>这种内置类型来说，他们的区别并没有太大的意义，而对于用户自定义的类型而言，区别赋值运算符和初始化就非常重要了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;              <span class="comment">//调用默认构造函数</span></span><br><span class="line">Widget w2 = w1;         <span class="comment">//不是赋值运算符，调用拷贝构造函数</span></span><br><span class="line">w1 = w2;                <span class="comment">//是一个赋值运算符，调用operator=函数</span></span><br></pre></td></tr></table></figure>

<p>为了整合这些混乱的初始化方式，C++11引入了<strong>统一初始化(uniform initialization)</strong>，实现的办法是使用花括号！具体来说<strong>有四个好处：</strong></p>
<p><strong>（1）类中非静态成员指定默认初始值</strong></p>
<p>括号初始化也能被用于为非静态数据成员指定默认初始值。C++11允许”=”初始化也拥有这种能力：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x&#123;<span class="number">0</span>&#125;;       <span class="comment">//没问题，x初始值为0</span></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;      <span class="comment">//同上</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>;       <span class="comment">//错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）用于不可拷贝对象初始化</strong></p>
<p><code>std::atomic</code>(原子化操作)是不可拷贝对象，所以不能用<code>=</code>初始化！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ai1&#123;<span class="number">0</span>&#125;;    <span class="comment">//没问题，x初始值为0</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ai2(<span class="number">0</span>);    <span class="comment">//没问题</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; ai3 = <span class="number">0</span>;   <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）避免变窄转换(narrowing conversion)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x,y,z; </span><br><span class="line"><span class="keyword">int</span> sum1&#123;x+y+z&#125;;             <span class="comment">//错误</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum2</span><span class="params">(x + y +z)</span></span>;         <span class="comment">//可以（表达式的值被截为int）,损失精度</span></span><br><span class="line"><span class="keyword">int</span> sum3 = x + y + z;       <span class="comment">//同上，损失精度</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）避免语法解析歧义</strong></p>
<p>尝试使用一个没有参数的构造函数构造对象，它就会变成函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">()</span></span>; <span class="comment">//最令人头疼的解析！声明一个函数w2，返回Widget</span></span><br></pre></td></tr></table></figure>

<p>由于函数声明中形参列表不能使用花括号，所以使用花括号初始化就可以消除这种歧义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w3&#123;&#125;;<span class="comment">//调用没有参数的构造函数构造对象</span></span><br></pre></td></tr></table></figure>

<hr>
<p>但是使用花括号统一初始化一个大毛病！<strong><code>std::initializer_list</code>误匹配！</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">int</span> i,<span class="keyword">bool</span> b);</span><br><span class="line">    Widget(<span class="keyword">int</span> i,<span class="keyword">double</span> b);</span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; il);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget(<span class="number">10</span>,<span class="literal">true</span>);    <span class="comment">//调用的是第一个构造函数，</span></span><br><span class="line">Widget&#123;<span class="number">10</span>,<span class="literal">true</span>&#125;;    <span class="comment">//按理应该是调用第一个构造函数，但是现在却调用了带初始化列表的构造函数</span></span><br></pre></td></tr></table></figure>

<p>这是因为<strong>编译器热衷于把花括号初始化与使<code>std::initializer_list</code>构造函数匹配，</strong>热衷程度甚至超过了最佳匹配。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">bool</span> b);</span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">double</span> d);                         </span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">bool</span>&gt; il);                           </span><br><span class="line">  …                                   </span><br><span class="line">&#125;;                                      </span><br><span class="line">Widget w&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;;      <span class="comment">//错误！要求变窄转换</span></span><br></pre></td></tr></table></figure>

<p>当然出现这样的问题主要还是因为<strong>统一初始化是允许宽化转换的</strong>，所以上面的上面<code>10</code>和<code>true</code>都转换成<code>long double</code>了。而上面那个<code>10</code>和<code>5.0</code>转化到<code>bool</code>是<strong>窄式转化</strong>，这是不允许的！</p>
<p>只有当没办法把括号初始化中实参的类型转化为<code>std::initializer_list</code>时，编译器才会回到正常的函数决议流程中。比如下面的<code>string</code>就是如此。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">bool</span> b);              </span><br><span class="line">    Widget(<span class="keyword">int</span> i, <span class="keyword">double</span> d);           </span><br><span class="line">    Widget(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; il); </span><br><span class="line">     …         </span><br><span class="line">&#125;;                                   </span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">(<span class="number">10</span>, <span class="literal">true</span>)</span></span>;<span class="comment">// 使用小括号初始化，调用第一个构造函数</span></span><br><span class="line">Widget w2&#123;<span class="number">10</span>, <span class="literal">true</span>&#125;;<span class="comment">// 使用花括号初始化，调用第一个构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w3</span><span class="params">(<span class="number">10</span>, <span class="number">5.0</span>)</span></span>;<span class="comment">// 使用小括号初始化，调用第二个构造函数</span></span><br><span class="line">Widget w4&#123;<span class="number">10</span>, <span class="number">5.0</span>&#125;;<span class="comment">// 使用花括号初始化，调用第二个构造函数</span></span><br></pre></td></tr></table></figure>

<p>这个毛病会造成某些时候<strong>括号和花括号不同语义</strong>。<code>std::vector</code>有一个非<code>std::initializer_list</code>构造函数允许你去指定容器的初始大小，以及使用一个值填满你的容器。但它也有一个<code>std::initializer_list</code>构造函数允许你使用花括号里面的值初始化容器。令人头疼！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>, <span class="number">20</span>);    <span class="comment">//使用非std::initializer_list</span></span><br><span class="line">                                <span class="comment">//构造函数创建一个包含10个元素</span></span><br><span class="line">                                <span class="comment">//所有的元素的值都是20</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;    <span class="comment">//使用std::initializer_list</span></span><br><span class="line">                                <span class="comment">//构造函数创建包含两个元素的std::vector</span></span><br><span class="line">                                <span class="comment">//元素的值为10和20</span></span><br></pre></td></tr></table></figure>

<p>总的来说，为了避免这些问题，那么作为库的开发者你应该<strong>把你的构造函数设计为不管用户是小括号还是使用花括号进行初始化都不会有什么影响</strong>（避免vector设计的睿智操作）；作为库的使用者必须<strong>认真的在花括号和小括号之间选择一个来创建对象</strong>。大多数开发者都使用其中一种作为默认情况，只有当他们不能使用这种的时候才会考虑另一种。</p>
<h1 id="Item-8-Prefer-nullptr-to-0-and-NULL"><a href="#Item-8-Prefer-nullptr-to-0-and-NULL" class="headerlink" title="Item 8: Prefer nullptr to 0 and NULL."></a>Item 8: Prefer nullptr to 0 and NULL.</h1><p>废话不多说，直接说好处：</p>
<p><strong>（1）使用nullptr*代替0和NULL可以避开那些烦人的函数重载决议</strong></p>
<p><code>NULL</code>最大的问题在于它没有明确的类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;        <span class="comment">//三个f的重载函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line">f(<span class="literal">NULL</span>);            <span class="comment">//可能会不通过，也可能会调用int,但不会调用void*</span></span><br></pre></td></tr></table></figure>

<p><code>f(NULL)</code>的不确定性是由于<code>NULL</code>的实现不同造成的，在我的编译环境下(Visual Studio 2019)，<code>NULL</code>被划定为<code>int</code>型。这样的话，调用就具有<strong>二义性</strong>！</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191104144642.png" alt="img" style="zoom:67%;" />

<p>现在做一个实验：注释掉<code>int</code>的重载类型，发现</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191104144832.png" alt="img" style="zoom: 80%;" />

<p>这是因为缺失了<code>int</code>类型的重载，它会开始转化，而<strong>从<code>int</code>到<code>long, bool, void\*</code>的转换都会被考虑。</strong>同理，<strong>调用<code>f(0)</code>也会出现这样的状况</strong>。</p>
<p><strong>为了避免二义性，准确地定位到<code>void\*</code>，推荐使用<code>nullptr</code></strong>！</p>
<p><code>nullptr</code>的类型是<code>std::nullptr_t</code>，这种类型的特点是可以<strong>转换为指向任何内置类型的指针</strong>，这也是为什么把它叫做<strong>通用类型的指针</strong>。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191104145308.png" alt="img" style="zoom:80%;" />

<p><strong>（2）和auto共用时，让代码更加明确</strong></p>
<p>如果你不知道<code>findRecord</code>返回了什么（或者不能轻易的找出），那么你就不太清楚到底result是一个指针类型还是一个整型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = findRecord( <span class="comment">/* arguments */</span> );</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们最好改为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = findRecord( <span class="comment">/* arguments */</span> );</span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">nullptr</span>) &#123;  </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）模板中有更好兼容性</strong></p>
<p>假如有一些函数只能被合适的已锁互斥量调用。每个函数都有一个不同类型的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">f1</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; spw)</span></span>;  <span class="comment">// 只能被合适的已锁互斥量调用</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; upw)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">bool</span>   <span class="title">f3</span><span class="params">(Widget* pw)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们用模板：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FuncType,<span class="keyword">typename</span> MuxType,<span class="keyword">typename</span> PtrType&gt; </span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) lockAndCall(FuncType func,                 </span><br><span class="line">                MuxType&amp; mutex,                 </span><br><span class="line">                PtrType ptr) &#123; </span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(mutex)</span></span>;  </span><br><span class="line">    <span class="keyword">return</span> func(ptr); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以写这样的代码调用<strong>lockAndCall</strong>模板:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result1 = lockAndCall(f1, f1m, <span class="number">0</span>);          <span class="comment">// 错误！</span></span><br><span class="line"><span class="keyword">auto</span> result2 = lockAndCall(f2, f2m, <span class="literal">NULL</span>);       <span class="comment">// 错误！</span></span><br><span class="line"><span class="keyword">auto</span> result3 = lockAndCall(f3, f3m, <span class="literal">nullptr</span>);    <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>为什么会出现错误呢？还是老毛病：0和NULL都是<code>int</code>型（至少在我的编译环境下是），但我们期待的参数是<code>std::shared_ptr</code>，所以推导的过程中就会发生错误。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191104151009.png" alt="img" style="zoom:80%;" />

<h1 id="Item-9-Prefer-alias-declarations-to-typedefs"><a href="#Item-9-Prefer-alias-declarations-to-typedefs" class="headerlink" title="Item 9:Prefer alias declarations to typedefs"></a>Item 9:Prefer alias declarations to typedefs</h1><p>C++常常为复杂的类型做一个重定义，方式有两种：<code>typedef</code>和<code>using</code>使用别名。前者是98的东西，后者是11提供的新东西。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;  UPtrMapSS; </span><br><span class="line"><span class="keyword">using</span> UPtrMapSS =  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>具体来说使用<code>using</code>别名有这么几个好处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FP是一个指向函数的指针的同义词，它指向的函数带有int和const std::string&amp;形参，不返回任何东西</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FP)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;      <span class="comment">// typedef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="keyword">using</span> FP = <span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);     <span class="comment">// 别名声明</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）方便使用模板</strong></p>
<p><code>typedef</code><strong>没有办法在模板声明的作用域中做类型重定义</strong>，必须放在一个自定义类型作用域内，而using没有这个限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                     </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyAllocList</span> &#123;</span>                    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt; type;  </span><br><span class="line">&#125;;                                      </span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw;</span><br></pre></td></tr></table></figure>

<p>而using没有这个限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> MyAllocList = <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T,MyAlloc&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt; lw;</span><br></pre></td></tr></table></figure>

<p><strong>对于嵌套类型</strong>来说，<code>typedef</code>需要使用<code>typename</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                     </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyAllocList</span> &#123;</span>                    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T, MyAlloc&lt;T&gt;&gt; type;  </span><br><span class="line">&#125;;                                      </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>                     </span><br><span class="line"><span class="keyword">private</span>:                               </span><br><span class="line">    <span class="keyword">typename</span> MyAllocList&lt;T&gt;::type <span class="built_in">list</span>;    </span><br><span class="line">    … </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于<code>MyAllocList::type</code>使用了一个类型，它依赖于模板参数T，因此它是一个依赖类型，<strong>依赖类型就必须在前面加上<code>typename</code></strong>。</p>
<p>相反，使用<code>using</code>就不会有问题。对你来说，<code>MyAllocList</code>（使用了模板别名声明的版本）可能看起来和<code>MyAllocList::type</code>（使用<code>typedef</code>的版本）一样都应该依赖模板参数<code>T</code>，但编译器和你想的不同。</p>
<p>当编译器处理<code>MyAllocList</code>（使用模板别名声明的版本），<strong>它们知道<code>MyAllocList</code>是一个类型名</strong>，它一定是一个类型名。因此<code>MyAllocList</code>就是一个非依赖类型，就不要求必须使用<code>typename</code>。</p>
<h1 id="Item-10-Prefer-scoped-enums-to-unscoped-enums"><a href="#Item-10-Prefer-scoped-enums-to-unscoped-enums" class="headerlink" title="Item 10:Prefer scoped enums to unscoped enums."></a>Item 10:Prefer scoped enums to unscoped enums.</h1><p>首先介绍一下枚举：</p>
<blockquote>
<p>打开一个文件可能有三种状态：input, output和append. 典型做法是，对应定义3个常数，即：<br><code>const int input = 1;</code><br><code>const int output = 2;</code><br><code>const int append = 3;</code><br>然后，调用以下函数：<br><code>bool open_file(string file_name, int open_mode);</code></p>
<p>问题是可能用户手贱输了一个4进去，超出范围，这就很麻烦了，而且纯数字也不好记忆和分辩。通过枚举可以解决这个问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">enum</span> open_modes &#123;input = <span class="number">1</span>, output, append&#125;;</span><br><span class="line">&gt;open_file(<span class="string">"Phenix_and_the_Crane"</span>, append);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>C++的枚举分为两种：<strong>有限定域</strong>的枚举和<strong>无限定域</strong>枚举，前者是11的新特性，后者是98的特性。推荐使用有限定域的枚举，理由如下：</p>
<p><strong>（1）防止污染命名空间</strong></p>
<p>通常来说我们在花括号中定义的名称其作用域就在花括号中，但是<strong>C++98</strong>的枚举类型的声明却不遵从这个规则。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;black,white,red&#125;;</span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;   <span class="comment">//编译出错white已经声明了</span></span><br></pre></td></tr></table></figure>

<p>在11中，我们通过使用<strong>enum class</strong>关键词就可以声明限定域枚举，避免泄露枚举名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span> black, white, red &#125;; <span class="comment">// black, white, red</span></span><br><span class="line">                                          <span class="comment">// 限制在Color域内</span></span><br><span class="line"><span class="keyword">auto</span> white = <span class="literal">false</span>;                     <span class="comment">// 没问题，同样域内没有这个名字</span></span><br><span class="line"></span><br><span class="line">Color c = white;                        <span class="comment">// 错误，这个域中没有white</span></span><br><span class="line"></span><br><span class="line">Color c = Color::white;                 <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">auto</span> c = Color::white;                  <span class="comment">// 也没问题（也符合条款5的建议）</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）避免隐式转化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primeFactors</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> x)</span> </span>&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color &#123; black, white, red &#125;;       <span class="comment">// 未限域枚举</span></span><br><span class="line">Color c = red;</span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">3.5</span>) &#123; <span class="comment">//int和double比较，玩蛇？</span></span><br><span class="line">    primeFactors(c); <span class="comment">// int强转编程size_t，终极玩蛇？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这些操作在玩蛇，但编译器依然将他们通过，这可能会造成不好的结果，所以我们倾向于使用限域枚举，上面的玩蛇操作都不会通过编译！如果真的很想进行转化，<strong>使用强转符号</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(c) &lt; <span class="number">14.5</span>) &#123; <span class="comment">// 奇怪的代码，但是有效</span></span><br><span class="line">    <span class="keyword">auto</span> factors =primeFactors(<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(c)); <span class="comment">// 能通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）支持前项声明</strong></p>
<p>先解释一下前项声明：</p>
<blockquote>
<p><strong>前向声明</strong>（<strong>Forward Declaration</strong>）是指声明标识符(表示编程的实体，如数据类型、变量、函数)时还没有给出完整的定义。下面就是一个函数前向声明的例子。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printThisInteger</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printThisInteger</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用未限定域枚举前向声明会发生错误:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color;         <span class="comment">// 错误！</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span>;</span>   <span class="comment">// 没问题</span></span><br></pre></td></tr></table></figure>

<p>原因是<strong>unscoped</strong>枚举类型的<strong>实际类型并不是<code>enum</code>，它有一个底层存储类型。而这个底层存储类型是编译器在编译的时候决策的，根据你的取值范围来定义你的底层存储类型</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; black, white, red &#125;; <span class="comment">//编译器选择char型，因为只有三个值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Status &#123; good = <span class="number">0</span>, <span class="comment">//编译器选择int或long，因为范围比较大</span></span><br><span class="line">                failed = <span class="number">1</span>,</span><br><span class="line">                incomplete = <span class="number">100</span>,</span><br><span class="line">                corrupt = <span class="number">200</span>,</span><br><span class="line">                indeterminate = <span class="number">0xFFFFFFFF</span></span><br><span class="line">                &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，由于类型未定，所以不能前置声明，这就带来一个问题：<strong>编译依赖过强</strong>！换句话说，整个枚举类作用于整个系统，我<strong>新添加一个成员，就会导致全部重新编译</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>;</span> <span class="comment">// forward declaration</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">continueProcessing</span><span class="params">(Status s)</span></span>; <span class="comment">// use of fwd-declared enum</span></span><br></pre></td></tr></table></figure>

<p>即使<code>Status</code>的定义发生改变，包含这些声明的头文件也不会重新编译，如果它只是添加一个枚举名。<code>continueProcessing</code>也不会受影响，因为他不涉及新添加的枚举。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(Color c)</span></span>;</span><br><span class="line"><span class="comment">//修改成员后，上面的部分都不用管</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> &#123;</span>red,black&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(Color red)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Color r = Color::red;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; foo(r) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，<strong>使用限定域枚举有的时候反而会加大工作量！</strong></p>
<p>比如在社交网站中，假设我们有一个<code>tuple</code>保存了用户的名字，email地址，声望点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UserInfo = <span class="comment">// 类型别名，参见Item 9</span></span><br><span class="line">    <span class="built_in">std</span>::tuple&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="comment">// 名字</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="comment">// email地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; ; <span class="comment">// 声望</span></span><br><span class="line"></span><br><span class="line">UserInfo uInfo; <span class="comment">// tuple对象</span></span><br><span class="line"><span class="keyword">auto</span> val = <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(uInfo); <span class="comment">// 获取第一个字段</span></span><br></pre></td></tr></table></figure>

<p>这里先说明一下tuple：</p>
<blockquote>
<p><code>std::tuple</code>是类似<code>pair</code>的模板。每个<code>pair</code>的成员类型都不相同，但每个<code>pair</code>都恰好有两个成员。不同<code>std::tuple</code>类型的成员类型也不相同，但一个<code>std::tuple</code>可以有任意数量的成员。</p>
<p>要访问一个<code>tuple</code>的成员，就要使用一个名为<code>get</code>的标准库函数模板。<code>get</code>尖括号中的值必须是一个整型常量表达式。与往常一样，我们从0开始计数，意味着<code>get&lt;0&gt;</code>是第一个成员。</p>
</blockquote>
<p>虽然注释说明了tuple各个字段对应的意思，但还是要记住第一个字段代表用户的email地址，这让人很不爽。我们可以使用非限定域枚举将名字和字段编号关联起来解决这个问题。</p>
<p>之所以它能正常工作是因为<code>UserInfoFields</code>中的枚举名隐式转换成<code>std::size_t</code>了,其中<strong><code>std::size_t</code>是<code>std::get</code>模板实参所需的</strong>。</p>
<p>对应的限域枚举版本就很啰嗦了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoFields</span> &#123;</span> uiName, uiEmail, uiReputation &#125;;</span><br><span class="line">UserInfo uInfo; <span class="comment">// as before</span></span><br><span class="line">…</span><br><span class="line"><span class="keyword">auto</span> val =</span><br><span class="line"><span class="built_in">std</span>::get&lt;<span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(UserInfoFields::uiEmail)&gt;</span><br><span class="line">(uInfo);</span><br></pre></td></tr></table></figure>

<h1 id="Item-11-Prefer-deleted-functions-to-private-undefined-ones"><a href="#Item-11-Prefer-deleted-functions-to-private-undefined-ones" class="headerlink" title="Item 11:Prefer deleted functions to private undefined ones."></a>Item 11:Prefer deleted functions to private undefined ones.</h1><p>我们都知道，如果你写的代码不想别人使用，你可以将它声明为private，但在C++11以后，建议使用<code>delete</code>而不是<code>private</code>。<code>delete</code>的用法有三类：</p>
<p><strong>（1）在类中防止某些函数调用</strong></p>
<p>比如说，我们要防止拷贝<code>istream</code>和<code>ostream</code>。因为要进行哪些操作是模棱两可的。比如一个<code>istream</code>对象，代表一个输入值的流，流中有一些已经被读取，有一些可能马上要被读取。解决这个问题最好的方法是不定义这个操作。直接禁止拷贝流。</p>
<p>在98中是这样写的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span> = <span class="title">char_traits</span>&lt;charT&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">basic_ios</span> :</span> <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    basic_ios(<span class="keyword">const</span> basic_ios&amp; ); <span class="comment">// not defined</span></span><br><span class="line">    basic_ios&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> basic_ios&amp;); <span class="comment">// not defined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在11中可以改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="title">class</span> <span class="title">traits</span> = <span class="title">char_traits</span>&lt;charT&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">basic_ios</span> :</span> <span class="keyword">public</span> ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    …</span><br><span class="line">    basic_ios(<span class="keyword">const</span> basic_ios&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">    basic_ios&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>deleted</code>函数不能以任何方式被调用，即使你<strong>在成员函数或者友元函数里面调用<code>deleted</code>函数也不能通过编译</strong>。</p>
<p>需要注意的是：<strong><code>deleted</code>函数被声明为<code>public</code>而不是<code>private</code></strong>。这也是有原因的。当客户端代码试图调用成员函数，C++会在检查<code>deleted</code>状态前检查它的访问性。当客户端代码调用一个私有的<code>deleted</code>函数，一些编译器只会给出该函数是<code>private</code>的错误。</p>
<p><strong>（2）作用于非成员函数禁止调用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br></pre></td></tr></table></figure>

<p>C++有沉重的C包袱，使得含糊的、能被视作数值的任何类型都能隐式转换为<code>int</code>，但是有一些调用可能是没有意义的：</p>
<p>如果我们想幸运数必须是整数，就应该禁止通过这些编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">int</span> number)</span></span>; <span class="comment">// 原始版本</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">char</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 拒绝char</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">bool</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 拒绝bool</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">double</span>)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 拒绝float和double</span></span><br></pre></td></tr></table></figure>

<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191106103715.png" alt="img" style="zoom:80%;" />

<p><strong>（3）禁止一些模板实例化</strong></p>
<p>在指针的世界里有两种特殊情况。一是<code>void*</code>指针，因为没办法对它们进行解引用，或者加加减减等。另一种指针是<code>char*</code>，因为它们通常代表C风格的字符串，而不是正常意义下指向单个字符的指针。这两种情况要特殊处理，在<code>processPointer</code>模板里面，我们假设<strong>正确的函数应该拒绝这些类型</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> processPointer&lt;<span class="keyword">void</span>&gt;(<span class="keyword">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> processPointer&lt;<span class="keyword">char</span>&gt;(<span class="keyword">char</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8A/" data-id="ck4o2tur4000au4vyhzy09b3h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-EffectiveModernCPP笔记2-auto的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B02-auto%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2019-12-26T09:36:38.000Z" itemprop="datePublished">2019-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B02-auto%E7%9A%84%E4%BD%BF%E7%94%A8/">EffectiveModernCPP笔记2-auto的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Item-5-Prefer-auto-to-explicit-type-declarations"><a href="#Item-5-Prefer-auto-to-explicit-type-declarations" class="headerlink" title="Item 5:Prefer auto to explicit type declarations"></a>Item 5:Prefer auto to explicit type declarations</h1><p>这一条条款全篇都在强调：<strong>为什么我们更青睐使用<code>auto</code>而不是显示类型声明</strong>。总得来说，好处有四个：</p>
<p><strong>（1）避免潜在未初始化变量的出现</strong></p>
<p>在C++中有可能因为定义了变量却没有初始化导致错误的结果。而且编译器也不报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x1;                <span class="comment">//不报错，但潜在的未初始化的变量</span></span><br><span class="line"><span class="keyword">auto</span> x2;            <span class="comment">//错误！必须要初始化</span></span><br><span class="line"><span class="keyword">auto</span> x3=<span class="number">0</span>;            <span class="comment">//没问题，x已经定义了</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）省略冗长的声明类型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=mymap.<span class="built_in">begin</span>(); <span class="comment">//复杂</span></span><br><span class="line"><span class="keyword">auto</span> it=mymap.<span class="built_in">begin</span>(); <span class="comment">//简单</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）直接保存闭包</strong></p>
<p>所谓闭包通俗点说就是指lambda表达式、重载运算符、bind表达式。</p>
<p>自从C++11后，我们可以用auto来存储lambda表达式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> derefUPLess = [](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; &amp;p1,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; &amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *p1&lt;*p2;</span><br><span class="line">&#125;;<span class="comment">//专用于Widget类型的比较函数</span></span><br></pre></td></tr></table></figure>

<p>在C++14，lambda表达式也可以使用auto：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> derefUPLess = [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p1,<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *p1&lt;*p2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述例子中，我们<strong>使用auto来保存这个闭包(lambda表达式)</strong>。如果不使用auto就必须使用<code>std::function</code>！</p>
<blockquote>
<p><code>std::function</code>是一个C++11标准模板库中的一个模板，它泛化了函数指针的概念。与函数指针只能指向函数不同，<code>std::function</code>可以<strong>指向任何可调用对象</strong>，也就是那些像函数一样能进行调用的东西。当你声明函数指针时你<strong>必须指定函数类型（即函数签名）</strong>，同样当你创建<code>std::function</code>对象时你也需要提供函数签名</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; &amp;p1,</span><br><span class="line">     <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; &amp;p2);</span><br></pre></td></tr></table></figure>

<p>就需要使用<code>std::function</code>这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; &amp;p1,</span><br><span class="line">                   <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; &amp;p2)&gt; func;</span><br></pre></td></tr></table></figure>

<p>如果不用auto，上面那么大一坨东西十分繁琐！</p>
<p><strong>（4）避免类型不匹配</strong></p>
<p>这里举两个常见的错误，他们都可以被auto很友好的规避。</p>
<p><strong>错误1</strong>：误以为<code>std::vector::size_type</code>就是<code>unsigned</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">unsigned</span> sz = v.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<p>在<strong>Windows 32-bit</strong>上<code>std::vector::size_type</code>和<code>unsigned int</code>都是一样的类型，但是在<strong>Windows 64-bit</strong>上<code>std::vector::size_type</code>是64位，<code>unsigned int</code>是32位。这意味着这段代码在Windows 32-bit上正常工作，但是当把应用程序移植到Windows 64-bit上时就可能会出现一些问题。</p>
<p><strong>错误2：</strong><code>std::unordered_map</code>的key是一个常量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&amp; p : m)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于是常量，所以上面的调用应该改为<code>std::pair</code></p>
<h1 id="Item-6-Use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types"><a href="#Item-6-Use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types" class="headerlink" title="Item 6:Use the explicitly typed initializer idiom when auto deduces undesired types."></a>Item 6:Use the explicitly typed initializer idiom when auto deduces undesired types.</h1><p>auto推断也存在一些问题。</p>
<p>现在有一个函数<code>feature</code>，传入一个<code>vector</code>数组，比较每个元素正负，然后返回<code>vector</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; features(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums)</span><br><span class="line">        res.push_back(x &gt; <span class="number">0</span> ? <span class="literal">true</span>:<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我想返回数组容器的第5个元素的正负情况，我这么来调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> negative4 = features(nums)[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>当把鼠标移到<code>negative4</code>上查看类型时，结果….</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191104124251.png" alt="img"></p>
<p><code>vector</code>的<code>operator[]</code>的返回值<strong>并不是bool类型</strong>却变为了<code>std::vector::reference</code>，这样的话，后面的调用一定会出现奇奇怪怪的问题，这是怎么回事呢？</p>
<ul>
<li>因为<code>bool</code>占用一个字节，标准库为了节省内存，改用bit来表示</li>
<li>因为<code>operator[]</code>需要返回一个内部元素的引用，但是没办法对一个bit进行引用</li>
<li>为了让返回的类型统一，无论是bool类型，还是其它类型</li>
</ul>
<p>此标准库为了实现上述三个目标就封装了一个内部的类型<code>vector::reference</code>，是一个proxy类(代理类)。其实这个问题指针对于<code>bool</code>类型，<strong>如果是实数类型，不会受到任何影响</strong>！</p>
<p>解决的办法是调用<strong>显式类型初始器</strong>！通过强制转化达成目的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> negative4 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(features(nums)[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/26/EffectiveModernCPP%E7%AC%94%E8%AE%B02-auto%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="ck4o2tur10007u4vycj6n8pc8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-EffectiveModernCPP笔记1-类型推断" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/24/EffectiveModernCPP%E7%AC%94%E8%AE%B01-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/" class="article-date">
  <time datetime="2019-12-24T13:06:44.000Z" itemprop="datePublished">2019-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/24/EffectiveModernCPP%E7%AC%94%E8%AE%B01-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/">EffectiveModernCPP笔记1-类型推断</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Item-1-Understand-template-type-deduction"><a href="#Item-1-Understand-template-type-deduction" class="headerlink" title="Item 1:Understand template type deduction"></a>Item 1:Understand template type deduction</h1><p>在模板的使用过程中，我们需要区分两个类型<code>T</code>和<code>Paramtype</code>。<code>T</code>是基本类型，<code>paramtype</code>是包含CV修饰后的结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> expr = <span class="number">0</span>;</span><br><span class="line">f(expr);</span><br></pre></td></tr></table></figure>

<p>解释一下<code>param type</code>是<code>param</code>最后的类型</p>
<p>下面就围绕<code>T</code>, <code>expr</code>, <code>param type</code>展开讨论：</p>
<p><strong>（1）Case 1:ParamType is a Reference or Pointer, but not a Universal Reference</strong></p>
<p>当<code>param type</code>是<strong>引用或者指针</strong>类型时，它的推断遵从<strong>两个原则</strong>：</p>
<ol>
<li>忽略<code>expr</code>中<code>param type</code>包含的部分得到T</li>
<li>将<code>T</code>与<code>param type</code>配对的到<code>param</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;       <span class="comment">// param is a reference</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;             <span class="comment">// x is an int </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;       <span class="comment">// cx is a const int </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;      <span class="comment">// rx is a reference to x as a const int</span></span><br><span class="line"></span><br><span class="line">f(x);     <span class="comment">// T is int, param's type is int&amp;</span></span><br><span class="line">f(cx);    <span class="comment">// T is const int,                     </span></span><br><span class="line">        <span class="comment">// param's type is const int&amp;</span></span><br><span class="line">f(rx);    <span class="comment">// T is const int,                     </span></span><br><span class="line">        <span class="comment">// param's type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;  <span class="comment">// param is now a ref-to-const</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;              <span class="comment">// as before </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;        <span class="comment">// as before </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;       <span class="comment">// as before</span></span><br><span class="line">f(x);     <span class="comment">// T is int, param's type is const int&amp;</span></span><br><span class="line">f(cx);     <span class="comment">// T is int, param's type is const int&amp;</span></span><br><span class="line">f(rx);     <span class="comment">// T is int, param's type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////</span></span><br><span class="line"><span class="comment">//指针也适用这个原则</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;        </span><br><span class="line"><span class="comment">// param is now a pointer</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;                 <span class="comment">// as before </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *px = &amp;x;         <span class="comment">// px is a ptr to x as a const int</span></span><br><span class="line">f(&amp;x);    <span class="comment">// T is int, param's type is int*</span></span><br><span class="line">f(px);  <span class="comment">// T is const int,               </span></span><br><span class="line">        <span class="comment">// param's type is const int*</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）Case 2: ParamType is a Universal Reference</strong></p>
<p>当考虑全局引用(universal reference, <code>T&amp;&amp;</code>)的时候，情况会变得有些不一样。他遵循两个原则：</p>
<ol>
<li>如果expr是左值，T和param都被推为<strong>左值引用</strong>(不管有没有统统加上引用符)</li>
<li>如果是右值，T不变，<code>param</code>加上&amp;&amp;。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;       <span class="comment">// param is now a universal reference</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;              <span class="comment">// as before </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;        <span class="comment">// as before </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;       <span class="comment">// as before</span></span><br><span class="line">f(x);                   <span class="comment">// x is lvalue, so T is int&amp;, </span></span><br><span class="line">                        <span class="comment">// param's type is also int&amp;</span></span><br><span class="line">f(cx);                  <span class="comment">// cx is lvalue, so T is const int&amp;,   </span></span><br><span class="line">                        <span class="comment">// param's type is also const int&amp;</span></span><br><span class="line">f(rx);                  <span class="comment">// rx is lvalue, so T is const int&amp;,   </span></span><br><span class="line">                        <span class="comment">// param's type is also const int&amp;</span></span><br><span class="line">f(<span class="number">27</span>);                  <span class="comment">// 27 is rvalue, so T is int,           </span></span><br><span class="line">                        <span class="comment">// param's type is therefore int&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）case3: ParamType is Neither a Pointer nor a Reference</strong></p>
<p>这就是最基本的值传递。意味着，<code>param</code>复制了一个传入的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> </span><br><span class="line">f(T param);         <span class="comment">// param is now passed by value</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>expr</code>是引用，忽略引用的部分</li>
<li>如果忽略引用后，<code>expr</code>是<code>const</code>类型或<code>volatile</code>类型，忽略。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;          <span class="comment">// as before </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;    <span class="comment">// as before </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;   <span class="comment">// as before</span></span><br><span class="line">f(x);                <span class="comment">// T's and param's types are both int</span></span><br><span class="line">f(cx);               <span class="comment">// T's and param's types are again both int</span></span><br><span class="line">f(rx);               <span class="comment">// T's and param's types are still both int</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>只是忽略引用，指针还是不变</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;         </span><br><span class="line"><span class="comment">// param is still passed by value</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> ptr =<span class="string">"Fun with pointers"</span>;  </span><br><span class="line"><span class="comment">// ptr is const pointer to const object  </span></span><br><span class="line">f(ptr);                  </span><br><span class="line"><span class="comment">// pass arg of type const char * const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> theAnswer = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x = theAnswer;</span><br><span class="line"><span class="keyword">auto</span> y = &amp;theAnswer; <span class="comment">// const int* 取引用相当于转成了指针</span></span><br></pre></td></tr></table></figure>

<hr>
<p>首先要澄清一个误区：<strong>数组类型和指针类型是完全不一样的</strong>(虽然他们在使用时可以混用)。由于C语言老祖宗的继承关系，C++依然保留了这些特性，导致很多人误以为数组和指针参数是一样的。</p>
<p>在传递过程中，<strong>数组会退化为它第一个元素的指针</strong>。注意，这里是<strong>退化</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;      <span class="comment">// template with by-value parameter</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">"J. P. Briggs"</span>;  <span class="comment">// name's type is const char[13]</span></span><br><span class="line"></span><br><span class="line">f(name); <span class="comment">// name is array, but T deduced as const char*</span></span><br></pre></td></tr></table></figure>

<p>这种退化导致有用的信息(数组长度)丢失<strong>。然而声明引用，可以使得模板推断保留成数组的形式</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line">f(name);  <span class="comment">//deduce to const char[13]</span></span><br></pre></td></tr></table></figure>

<p>根据原则：<strong>忽略paramtype包含的部分T，T加上包含的部分得到param。</strong>在这个例子中<code>T</code>被推导为<code>const char[13]</code>，<code>param</code>则被推导为<code>const char(&amp;)[13]</code>。</p>
<p>如果改为<code>T&amp;&amp;</code>，根据原则：<strong>统统推导为左值引用</strong>。则<code>T</code>和<code>param</code>都被推为<code>const char(&amp;)[13]</code></p>
<p>利用这一特性，我们在对模板函数声明为一个指向数组的引用使得我们可以在模板函数中推导出数组的大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> N&gt;                </span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> arraySize(T (&amp;)[N]) <span class="keyword">noexcept</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">return</span> N; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键词<code>constexpr</code>能够让结果在编译时有效，从而实现以下的效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> keyVals[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">35</span> &#125;;      <span class="comment">// keyVals has 7 elements</span></span><br><span class="line"><span class="keyword">int</span> mappedVals[arraySize(keyVals)];</span><br></pre></td></tr></table></figure>

<hr>
<p>讲完数组，再来讲讲函数。在C++中不止是数组会退化为指针，函数类型也会<strong>退化为一个函数指针</strong>，我们对于数组的全部讨论都可以应用到函数来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;  <span class="comment">// someFunc is a function;</span></span><br><span class="line">                             <span class="comment">// type is void(int, double)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;     <span class="comment">// in f1, param passed by value</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;    <span class="comment">// in f2, param passed by ref</span></span><br><span class="line">f1(someFunc);               <span class="comment">// param deduced as ptr-to-func;</span></span><br><span class="line">                            <span class="comment">// type is void (*)(int, double)</span></span><br><span class="line">f2(someFunc);               <span class="comment">// param deduced as ref-to-func;</span></span><br><span class="line">                            <span class="comment">// type is void (&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>

<h1 id="Item-2-Understand-auto-type-deduction"><a href="#Item-2-Understand-auto-type-deduction" class="headerlink" title="Item 2:Understand auto type deduction."></a>Item 2:Understand auto type deduction.</h1><p><code>auto</code>推断和模板推断具有清晰的映射关系，也分为3+1种情况：</p>
<p><strong>（1） 参数类型为指针或引用，但不是universal reference</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">7</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp; rx = x; <span class="comment">//rx is int &amp;</span></span><br><span class="line"><span class="keyword">int</span>&amp; z = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; rx = z; <span class="comment">// rx is const int&amp;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）参数类型为universal reference</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;uref1 = x;  <span class="comment">// uref1的类型为int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;uref2 = cx; <span class="comment">// uref2的类型为const int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;uref3 = <span class="number">27</span>; <span class="comment">// uref3的类型为int &amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）参数类型为pass-by-value</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">7</span>; <span class="comment">// x is int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; y=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> rx = y; <span class="comment">// rx is int</span></span><br></pre></td></tr></table></figure>

<p><strong>Tips:</strong> 我们在使用<code>for-auto</code>语句时，以下两种情况完全不同，一个可以改变原有的值一个不能。原因就是<code>auto&amp;</code>把<code>x</code>推断为 <code>int&amp;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:nums)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x:nums)</span><br></pre></td></tr></table></figure>

<p><strong>（4） 数组和函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = [...]           <span class="comment">// name's type is const char[13]  "R. N. Briggs";</span></span><br><span class="line"><span class="keyword">auto</span> arr1 = name;              <span class="comment">// arr1's type is const char*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; arr2 = name;             <span class="comment">// arr2's type is const char (&amp;)[13]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;       <span class="comment">// someFunc is a function;</span></span><br><span class="line">                                <span class="comment">// type is void(int, double)</span></span><br><span class="line"><span class="keyword">auto</span> func1 = someFunc;            <span class="comment">// func1's type is</span></span><br><span class="line">                                <span class="comment">// void (*)(int, double)</span></span><br><span class="line"><span class="keyword">auto</span>&amp; func2 = someFunc;           <span class="comment">// func2's type is </span></span><br><span class="line">                                <span class="comment">// void (&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>下面来说说<code>auto</code>和模板推断不一样的地方：</strong></p>
<p>在C++中<code>auto</code>初始化有四种方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>; </span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>; </span><br><span class="line"><span class="keyword">auto</span> x3 = &#123; <span class="number">27</span> &#125;; </span><br><span class="line"><span class="keyword">auto</span> x4&#123; <span class="number">27</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>前两个会被推导为<code>int</code>类型，后两个则是<code>std::initial izer_list</code>。这是因为当<code>auto</code>遇到花括号时会做自动转化，因此，以下情况是不允许的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x5 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span> &#125;;   <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<p>与模板推断不同的地方如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;;   <span class="comment">// x's type is std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;     </span><br><span class="line">f(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;);         <span class="comment">// error! can't deduce type for T</span></span><br></pre></td></tr></table></figure>

<p>如果我们改一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; initList)</span></span>;</span><br><span class="line">f(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;);         <span class="comment">// T deduced as int, and initList's type is std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是C++14允许<code>auto</code>用于函数返回值并会被推导（参见Item3），而且C++14的<code>lambda</code>函数也允许在形参中使用<code>auto</code>。在<strong>表面上使用的是auto但是实际上是模板类型推导的那一套规则在工作</strong>，所以说下面这样的代码不会通过编译：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createInitList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;     <span class="comment">//错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Item-3-Understand-Decltype"><a href="#Item-3-Understand-Decltype" class="headerlink" title="Item 3:Understand Decltype."></a>Item 3:Understand Decltype.</h1><p><code>decltype</code>不像是<code>auto</code>和模板推断那样有着很多奇奇怪怪的限制。它，简单直观，是什么类型就一定返回什么类型。举一些例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;           <span class="comment">// decltype(i) is const int</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Widget&amp; w)</span></span>;   <span class="comment">// decltype(w) is const Widget&amp; </span></span><br><span class="line">                            <span class="comment">// decltype(f) is bool(const Widget&amp;)</span></span><br><span class="line">Widget w;                  <span class="comment">// decltype(w) is Widget</span></span><br><span class="line"><span class="keyword">if</span> (f(w)) …                <span class="comment">// decltype(f(w)) is bool</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;             <span class="comment">// decltype(v) is vector&lt;int&gt; </span></span><br><span class="line"><span class="keyword">if</span> (v[<span class="number">0</span>] == <span class="number">0</span>)               <span class="comment">// decltype(v[0]) is int&amp;</span></span><br></pre></td></tr></table></figure>

<p>在C++11中<code>decltype</code>结合<code>auto</code>还可以完成<strong>函数返回值的类型推导</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container,<span class="keyword">typename</span> Index&gt;</span><br><span class="line">auto AccessContainer(Container&amp; c,Index i) -&gt; decltype(c[i]) &#123;</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了C++14的时候就可以省略掉后面的<code>-&gt; decltype(c[i])</code>了，变成下面的样子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container,<span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">AccessContainer</span><span class="params">(Container&amp; c,Index i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更高级的可以改为如下形式。它的作用原理是：<code>auto</code>声明表示“我要进行推断了”，而<code>decltype</code>则表示“<code>auto</code>你听我说，必须按照我<code>decltype</code>的方法推断（原封不动）”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container,<span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) AccessContainer(Container&amp; c,Index i) &#123;</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>decltype</code>保证返回变量的本来类型这一特性，保证不丢失<code>CV</code>限制符，和引用等，因此<strong>在C++14中可以通过<code>decltype</code>和<code>auto</code>来声明变量，保证变量的类型和赋值的类型一模一样</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; cw = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> autoia = cw;             <span class="comment">//推导出的类型是int，引用和CV限制符都会忽略</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) deautoia = cw; <span class="comment">//const int&amp; 保证和cw的类型一模一样</span></span><br></pre></td></tr></table></figure>

<p>上面的方案通过<code>decltype</code>和<code>auto</code>让返回值的类型变的完美，但是如果用户传入一个<code>const</code>的容器，将会导致编译出错。因为<code>AccessContainer</code>的参数类型是非常量引用，为了让他可以接收常量和非常量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container,<span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) AccessContainer(<span class="keyword">const</span> Container&amp; c,Index i) &#123;</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这带来的另外一个问题就是，<code>c[i]</code>，返回的是常量引用，无法修改。好在C++11中引入了右值引用，它可以接收左值，右值还有带<code>const</code>的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container,<span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) AccessContainer(Container&amp;&amp; c,Index i) &#123;</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于传入后，会把<code>c</code>的原本的形式给整没，也就是说：如果用户传入的是一个右值，通过移动语义传递给了<code>AccessContainer</code>的参数<code>c</code>，c变成了一个左值，如果在<code>AccessContainer</code>中需要把<code>c</code>再次传递给其他的函数的话就不能再次利用右值的移动语义了，带来了不必要的拷贝开销。那么就需要用到<strong>完美转发</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container,<span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) AccessContainer(Container&amp;&amp; c,Index i) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Item-4-Know-how-to-view-deduced-types"><a href="#Item-4-Know-how-to-view-deduced-types" class="headerlink" title="Item 4:Know how to view deduced types."></a>Item 4:Know how to view deduced types.</h1><p>这一节主要针对实际问题做讨论，做一下简化，只讨论可能用得到的。</p>
<p>查看类型推导最简单的方法就是在IDE里面，把鼠标移到变量上查看。大部分情况下是很好用的，但不能适用于很复杂的情况。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191103165229.png" alt="img"></p>
<p>如果要在运行时推断，有两种方法：</p>
<p>（1）<code>typeid</code>的应用。简单明了，但忽略了CV限定符和引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; m = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="keyword">decltype</span>(m)).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//输出int</span></span><br></pre></td></tr></table></figure>

<p>（2）boost库函数。能准确提取结果，但需要额外安装boost库。<a href="https://blog.csdn.net/fsac213330/article/details/52748223" target="_blank" rel="noopener">windows安装方法</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"param = "</span></span><br><span class="line">        &lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name()</span><br><span class="line">        &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"param = "</span></span><br><span class="line">        &lt;&lt; type_id_with_cvr&lt;<span class="keyword">decltype</span>(param)&gt;().pretty_name()</span><br><span class="line">        &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; m = <span class="number">10</span>;</span><br><span class="line">f(m);</span><br><span class="line"><span class="comment">//output: </span></span><br><span class="line">param = <span class="keyword">int</span></span><br><span class="line">param = <span class="keyword">int</span> <span class="keyword">const</span> &amp; __ptr64</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/24/EffectiveModernCPP%E7%AC%94%E8%AE%B01-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/" data-id="ck4o2tur00006u4vyae0b9640" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode题目总结11-其他" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/24/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%9311-%E5%85%B6%E4%BB%96/" class="article-date">
  <time datetime="2019-12-24T10:01:31.000Z" itemprop="datePublished">2019-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/24/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%9311-%E5%85%B6%E4%BB%96/">Leetcode题目总结11-其他</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-树的构造和遍历"><a href="#1-树的构造和遍历" class="headerlink" title="1. 树的构造和遍历"></a>1. 树的构造和遍历</h1><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144 二叉树的前序遍历"></a>144 二叉树的前序遍历</h2><p><strong>非递归：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">while</span> (root||!stk.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root)</span><br><span class="line">        &#123;</span><br><span class="line">            data.push_back(root-&gt;val);</span><br><span class="line">            stk.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            <span class="comment">//中序就把push_back写在这里</span></span><br><span class="line">            stk.pop();</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归：</strong></p>
<p>注意递归前要先判断是否存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> data;</span><br><span class="line">    recursive(data,root);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data,TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    data.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left) recursive(data,root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right) recursive(data,root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="094-二叉树的中序遍历"><a href="#094-二叉树的中序遍历" class="headerlink" title="094 二叉树的中序遍历"></a>094 二叉树的中序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> data;</span><br><span class="line">    <span class="keyword">while</span>(root||!stk.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            stk.push(root);</span><br><span class="line">            root=root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            root=stk.top();</span><br><span class="line">            data.push_back(root-&gt;val);</span><br><span class="line">            stk.pop();</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145 二叉树的后序遍历"></a>145 二叉树的后序遍历</h2><p>因为前面两道题前序和中序分别占据了if-else的其中一个，所以后序没得用了。换种思路：前序遍历是：中-左-右，而后序是左-右-中，它是中-右-左的逆过程，所以只需要两个关键技术：在<strong>前序的基础上调换左右位置</strong>，形成中-右-左，<strong>辅助栈引导逆过程</strong>。就可以大功告成！</p>
<p>在前序遍历中我们将<code>data.push_back()</code>塞到了<code>if(root)</code>中，在这里我们只需要将容器栈放到这里即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; result_stk;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; traversal_stk;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> data;</span><br><span class="line">    <span class="keyword">while</span>(root||!traversal_stk.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            result_stk.push(root); <span class="comment">//塞到这里</span></span><br><span class="line">            traversal_stk.push(root);</span><br><span class="line">            root=root-&gt;right; <span class="comment">//和前序不同</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            root= traversal_stk.top();</span><br><span class="line">            traversal_stk.pop();</span><br><span class="line">            root=root-&gt;left; <span class="comment">//和前序不同</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!result_stk.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        data.push_back(result_stk.top()-&gt;val);</span><br><span class="line">        result_stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="105-从前序与中序遍历构造二叉树"><a href="#105-从前序与中序遍历构造二叉树" class="headerlink" title="105 从前序与中序遍历构造二叉树"></a>105 从前序与中序遍历构造二叉树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>前序的第一个一定是root，假设位置为prei，找到其在中序的位置midi。此时中序左边是左子树所有的部分，右边是右子树所有的部分。那么左子节点就是prei+1，右子节点计算方法是：跳过所有左子树，下一个就是右子节点，<code>prei+(midi-inorder_start)+1</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">generate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> inorder_start, <span class="keyword">int</span> inorder_end,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> pre_root_index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder_start == inorder_end)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[pre_root_index]);</span><br><span class="line">    <span class="keyword">if</span> (inorder_start &gt; inorder_end)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> value = preorder[pre_root_index];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; inorder.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == value)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;left = generate(preorder, inorder,</span><br><span class="line">                          inorder_start, i - <span class="number">1</span>,</span><br><span class="line">                          pre_root_index + <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = generate(preorder, inorder,</span><br><span class="line">                           i + <span class="number">1</span>, inorder_end,</span><br><span class="line">                           pre_root_index + <span class="number">1</span> + i - inorder_start);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="106-从中序与后序遍历构造二叉树"><a href="#106-从中序与后序遍历构造二叉树" class="headerlink" title="106 从中序与后序遍历构造二叉树"></a>106 从中序与后序遍历构造二叉树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder &#x3D; [9,15,7,20,3]</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fun(preorder, inorder, <span class="number">0</span>, preorder.size() - <span class="number">1</span>, <span class="number">0</span>, inorder.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">fun</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, </span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> pre_start, <span class="keyword">int</span> pre_end, <span class="keyword">int</span> in_start, <span class="keyword">int</span> in_end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre_start &gt; pre_end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pre_first_result = preorder[pre_start];</span><br><span class="line">    <span class="keyword">int</span> root_position = in_start;</span><br><span class="line">    <span class="keyword">for</span> (; root_position &lt; in_end; root_position++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[root_position] == pre_first_result) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode(pre_first_result);</span><br><span class="line">    <span class="keyword">int</span> left_length = root_position - in_start;</span><br><span class="line">    <span class="keyword">int</span> right_length = in_end - root_position;</span><br><span class="line">    node-&gt;left = fun(preorder, inorder, pre_start + <span class="number">1</span>, pre_start + left_length, in_start, root_position - <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = fun(preorder, inorder, pre_end - right_length + <span class="number">1</span>, pre_end, root_position + <span class="number">1</span>, in_end);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-二维数组"><a href="#2-二维数组" class="headerlink" title="2. 二维数组"></a>2. 二维数组</h1><h2 id="036-有效的数独"><a href="#036-有效的数独" class="headerlink" title="036 有效的数独"></a>036 有效的数独</h2><p>判断一个 9x9 的数独是否有效。只需要<strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ol>
<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; rows(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; cols(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; cell(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> val = board[i][j]-<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!rows[i].count(val)) rows[i].insert(val);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!cols[j].count(val)) cols[j].insert(val);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = cell_index(i,j);</span><br><span class="line">            <span class="keyword">if</span>(!cell[index].count(val)) cell[index].insert(val);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cell_index</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i/<span class="number">3</span>+<span class="number">3</span>*(j/<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="048-旋转图像"><a href="#048-旋转图像" class="headerlink" title="048 旋转图像"></a>048 旋转图像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>先沿副对角线交换，再沿中间水平线交换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//沿副对角线交换</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - <span class="number">1</span> - j][n - <span class="number">1</span> - i];</span><br><span class="line">            matrix[n - <span class="number">1</span> - j][n - <span class="number">1</span> - i]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - <span class="number">1</span> - i][j];</span><br><span class="line">            matrix[n - <span class="number">1</span> - i][j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="054-旋转矩阵"><a href="#054-旋转矩阵" class="headerlink" title="054 旋转矩阵"></a>054 旋转矩阵</h2><p><strong>题目：</strong></p>
<p>给定一个包含 <em>m</em> x <em>n</em> 个元素的矩阵（<em>m</em> 行, <em>n</em> 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">输出: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> len1 = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> len2 = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> right = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> down = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125; ,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;<span class="comment">//列行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 * len2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(matrix[row][col]);</span><br><span class="line">        row += dir[<span class="number">1</span>][k % <span class="number">4</span>];</span><br><span class="line">        col += dir[<span class="number">0</span>][k%<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">switch</span> (k % <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (col &gt; right)</span><br><span class="line">                &#123;</span><br><span class="line">                    col = right;</span><br><span class="line">                    row++;</span><br><span class="line">                    right--;</span><br><span class="line">                    k++;<span class="comment">//转向</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (row &gt; down)</span><br><span class="line">                &#123;</span><br><span class="line">                    row = down;</span><br><span class="line">                    col--;</span><br><span class="line">                    down--;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> (col &lt; left)</span><br><span class="line">                &#123;</span><br><span class="line">                    col = left;</span><br><span class="line">                    row--;</span><br><span class="line">                    left++;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> (row &lt; up)</span><br><span class="line">                &#123;</span><br><span class="line">                    row = up;</span><br><span class="line">                    col++;</span><br><span class="line">                    up++;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="059-旋转矩阵-II"><a href="#059-旋转矩阵-II" class="headerlink" title="059 旋转矩阵 II"></a>059 旋转矩阵 II</h2><p><strong>题目：</strong></p>
<p>给定一个正整数 <em>n</em>，生成一个包含 1 到 <em>n</em>2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (n== <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> len1 = n;</span><br><span class="line">    <span class="keyword">int</span> len2 = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> down = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125; ,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;<span class="comment">//列行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 * len2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res[row][col] = i + <span class="number">1</span>;</span><br><span class="line">        row += dir[<span class="number">1</span>][k % <span class="number">4</span>];</span><br><span class="line">        col += dir[<span class="number">0</span>][k % <span class="number">4</span>];</span><br><span class="line">        <span class="keyword">switch</span> (k % <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (col &gt; right)</span><br><span class="line">                &#123;</span><br><span class="line">                    col = right;</span><br><span class="line">                    row++;</span><br><span class="line">                    right--;</span><br><span class="line">                    k++;<span class="comment">//转向</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (row &gt; down)</span><br><span class="line">                &#123;</span><br><span class="line">                    row = down;</span><br><span class="line">                    col--;</span><br><span class="line">                    down--;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> (col &lt; left)</span><br><span class="line">                &#123;</span><br><span class="line">                    col = left;</span><br><span class="line">                    row--;</span><br><span class="line">                    left++;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> (row &lt; up)</span><br><span class="line">                &#123;</span><br><span class="line">                    row = up;</span><br><span class="line">                    col++;</span><br><span class="line">                    up++;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="073-矩阵置零"><a href="#073-矩阵置零" class="headerlink" title="073 矩阵置零"></a>073 矩阵置零</h2><p><strong>题目：</strong></p>
<p>给定一个 <em>m</em> x <em>n</em> 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用<strong>原地</strong>算法<strong>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>为了能使空间为$O(1)$，我们就不能令设参数来记录哪些行列应该为0，解决办法是用边界来记录。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191224125238.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> row = <span class="literal">false</span>, col = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123; <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) col = <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="number">0</span>) row = <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>, matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>)</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (col)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/24/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%9311-%E5%85%B6%E4%BB%96/" data-id="ck4o2turg000ku4vy5qxx4sfq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode题目总结10-链表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/23/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%9310-%E9%93%BE%E8%A1%A8/" class="article-date">
  <time datetime="2019-12-23T12:57:46.000Z" itemprop="datePublished">2019-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/23/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%9310-%E9%93%BE%E8%A1%A8/">Leetcode题目总结10-链表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-虚拟节点"><a href="#1-虚拟节点" class="headerlink" title="1. 虚拟节点"></a>1. 虚拟节点</h1><p>虚拟节点有两个作用：</p>
<ol>
<li>保护head，便于返回</li>
<li>用于节点交换的引导</li>
</ol>
<h2 id="002-两数相加"><a href="#002-两数相加" class="headerlink" title="002 两数相加"></a>002 两数相加</h2><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>需要运用加法进位的技术，具体参考数学那一篇中讲解。也需要用到虚拟节点的办法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode* pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* p1=l1,*p2=l2,*p3=pre;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1!=<span class="literal">nullptr</span>||p2!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> val1=(p1==<span class="literal">nullptr</span>)?<span class="number">0</span>:p1-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> val2=(p2==<span class="literal">nullptr</span>)?<span class="number">0</span>:p2-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> tmp=val1+val2+carry;</span><br><span class="line">        carry=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;=<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            carry=tmp/<span class="number">10</span>;</span><br><span class="line">            tmp=tmp%<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p3-&gt;next=<span class="keyword">new</span> ListNode(tmp);</span><br><span class="line"></span><br><span class="line">        p3=p3-&gt;next;</span><br><span class="line">        p1=(p1==<span class="literal">nullptr</span>)?<span class="literal">nullptr</span>:p1-&gt;next;</span><br><span class="line">        p2=(p2==<span class="literal">nullptr</span>)?<span class="literal">nullptr</span>:p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry!=<span class="number">0</span>)</span><br><span class="line">        p3-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="021-合并两个有序链表"><a href="#021-合并两个有序链表" class="headerlink" title="021 合并两个有序链表"></a>021 合并两个有序链表</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode* pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* cur=pre;</span><br><span class="line">    <span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next=l1;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next=l2;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span>) cur-&gt;next=l1;</span><br><span class="line">    <span class="keyword">if</span>(l2!=<span class="literal">nullptr</span>) cur-&gt;next=l2;</span><br><span class="line">    <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="024-两两交换链表中的节点"><a href="#024-两两交换链表中的节点" class="headerlink" title="024 两两交换链表中的节点"></a>024 两两交换链表中的节点</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191223131633.png" style="zoom:80%;" />

<p>注意，不能返回head，否则会变为1-4-3，应该先预设一个dummy来准备返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    pre-&gt;next=head;</span><br><span class="line">    ListNode* first = head;</span><br><span class="line">    ListNode* dummy = pre;</span><br><span class="line">    <span class="keyword">while</span>(first&amp;&amp;first-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* last = first-&gt;next;</span><br><span class="line">        first-&gt;next=last-&gt;next;</span><br><span class="line">        last-&gt;next=first;</span><br><span class="line">        pre-&gt;next=last;</span><br><span class="line"></span><br><span class="line">        pre=first;</span><br><span class="line">        first=first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="083-删除排序链表中的重复元素"><a href="#083-删除排序链表中的重复元素" class="headerlink" title="083 删除排序链表中的重复元素"></a>083 删除排序链表中的重复元素</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191223132856.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    pre-&gt;next=head;</span><br><span class="line">    ListNode* cur=head;</span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* last=cur-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(last!=<span class="literal">nullptr</span>&amp;&amp;cur-&gt;val==last-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            last=last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next=last;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="082-删除排序链表中的重复元素-II"><a href="#082-删除排序链表中的重复元素-II" class="headerlink" title="082 删除排序链表中的重复元素 II"></a>082 删除排序链表中的重复元素 II</h2><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现</em> 的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">输出: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191223135629.png" style="zoom:80%;" />

<p><strong>时刻要牢记</strong><code>three&amp;&amp;two-&gt;next-&gt;val==three-&gt;val</code>，用之前要先判断是否为null！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    pre-&gt;next=head;</span><br><span class="line">    ListNode* one=pre;</span><br><span class="line">    <span class="keyword">while</span>(one-&gt;next&amp;&amp;one-&gt;next-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* two = one-&gt;next;</span><br><span class="line">        ListNode* three = one-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(three&amp;&amp;two-&gt;val==three-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            three=three-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(three&amp;&amp;two-&gt;next-&gt;val==three-&gt;val)<span class="comment">//没有重复</span></span><br><span class="line">            one=one-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            one-&gt;next=three;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206 反转链表"></a>206 反转链表</h2><p>反转一个单链表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191223140359.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    pre-&gt;next=head;</span><br><span class="line">    ListNode* cur=head;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* last = cur-&gt;next;</span><br><span class="line">        cur-&gt;next=last-&gt;next;</span><br><span class="line">        last-&gt;next=pre-&gt;next;</span><br><span class="line">        pre-&gt;next=last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="092-反转链表-II"><a href="#092-反转链表-II" class="headerlink" title="092 反转链表 II"></a>092 反转链表 II</h2><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。说明: 1 ≤ m ≤ n ≤ 链表长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class="line">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>pre一定要随动，所以需要一个dummy来返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    pre-&gt;next=head;</span><br><span class="line">    ListNode* dummy=pre;</span><br><span class="line">    ListNode* cur=head;</span><br><span class="line">    <span class="keyword">int</span> flag=n-m;</span><br><span class="line">    <span class="keyword">while</span>(m!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">        pre=pre-&gt;next;</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next&amp;&amp;flag!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* last = cur-&gt;next;</span><br><span class="line">        cur-&gt;next=last-&gt;next;</span><br><span class="line">        last-&gt;next=pre-&gt;next;</span><br><span class="line">        pre-&gt;next=last;</span><br><span class="line">        flag--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143 重排链表"></a>143 重排链表</h2><p>给定一个单链表 <em>L</em>：<em>L</em>0→<em>L</em>1→…→<em>Ln</em>-1→<em>L</em>n ，<br>将其重新排列后变为： <em>L</em>0→<em>Ln<em>→</em>L<em>1→</em>Ln</em>-1→<em>L</em>2→Ln-2→…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>将原来的链表全部塞入双端队列，然后从前后分别放出。</p>
<p>注意：</p>
<ul>
<li>while里面要双重判断</li>
<li>最后要处理一下屁股</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//双端队列</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;ListNode*&gt; de;</span><br><span class="line">    ListNode* pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    pre-&gt;next = head;</span><br><span class="line">    ListNode* dummy = pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dummy-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        de.push_back(dummy-&gt;next);</span><br><span class="line">        dummy = dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (de.empty()) <span class="keyword">break</span>;</span><br><span class="line">        pre-&gt;next = de.front();</span><br><span class="line">        de.pop_front();</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        <span class="comment">//再后，这里判断一下是不是空了</span></span><br><span class="line">        <span class="keyword">if</span> (de.empty()) <span class="keyword">break</span>;</span><br><span class="line">        pre-&gt;next = de.back();</span><br><span class="line">        de.pop_back();</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把屁股处理一下</span></span><br><span class="line">    pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203 移除链表元素"></a>203 移除链表元素</h2><p>除链表中等于给定值 <strong>val</strong> 的所有节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val &#x3D; 6</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode* pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    pre-&gt;next = head;</span><br><span class="line">    ListNode* dummy = pre;</span><br><span class="line">    <span class="keyword">while</span> (pre-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;next-&gt;val == val)</span><br><span class="line">            pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-快慢指针"><a href="#2-快慢指针" class="headerlink" title="2. 快慢指针"></a>2. 快慢指针</h1><h2 id="019-删除链表的倒数第N个节点"><a href="#019-删除链表的倒数第N个节点" class="headerlink" title="019 删除链表的倒数第N个节点"></a>019 删除链表的倒数第N个节点</h2><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191223153629.png" style="zoom:80%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    pre-&gt;next=head;</span><br><span class="line">    ListNode* fast=pre;</span><br><span class="line">    ListNode* slow=pre;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow-&gt;next=slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="061-旋转链表"><a href="#061-旋转链表" class="headerlink" title="061 旋转链表"></a>061 旋转链表</h2><p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</span><br><span class="line">输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    pre-&gt;next = head;</span><br><span class="line">    ListNode* fast = pre;</span><br><span class="line">    ListNode* slow = pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> jump = len - (k % len);</span><br><span class="line">    <span class="keyword">while</span> (jump &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        jump--;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//        输入: pre-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span></span><br><span class="line">    <span class="comment">//                       slow  fast</span></span><br><span class="line">    <span class="comment">//        输出: pre-&gt;4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL*/</span></span><br><span class="line">    fast-&gt;next = pre-&gt;next;</span><br><span class="line">    pre-&gt;next = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141 环形链表"></a>141 环形链表</h2><p>给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" style="zoom:50%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* fast=head;</span><br><span class="line">    ListNode* slow=head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142 环形链表 II"></a>142 环形链表 II</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;ListNode*&gt; s;</span><br><span class="line">    ListNode* index=head;</span><br><span class="line">    <span class="keyword">while</span>(index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.count(index))</span><br><span class="line">        &#123;</span><br><span class="line">            s.insert(index);</span><br><span class="line">            index=index-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148 排序链表"></a>148 排序链表</h2><p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>归并排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[ivan_allen]https://leetcode-cn.com/problems/sort-list/comments/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">1</span>; size &lt; len; size = size &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* cur = dummy-&gt;next;</span><br><span class="line">        ListNode* tail = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = cur;</span><br><span class="line">            <span class="keyword">auto</span> right = cut(left, size);</span><br><span class="line">            cur = cut(right, size);</span><br><span class="line"></span><br><span class="line">            tail-&gt;next = merge(left, right);</span><br><span class="line">            <span class="keyword">while</span> (tail-&gt;next)</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">cut</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* first = head;</span><br><span class="line">    <span class="comment">//--n！！！</span></span><br><span class="line">    <span class="keyword">while</span> (--n &amp;&amp; first)</span><br><span class="line">    &#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!first)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//second为第二链表开头，first为第一</span></span><br><span class="line">    ListNode* second = first-&gt;next;</span><br><span class="line">    first-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode* dummy = pre;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> val1 = l1-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> val2 = l2-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (val1 &gt; val2)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = l2;</span><br><span class="line">            pre = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = l1;</span><br><span class="line">            pre = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1)</span><br><span class="line">        pre-&gt;next = l1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre-&gt;next = l2;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234 回文链表"></a>234 回文链表</h2><p>请判断一个链表是否为回文链表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    pre-&gt;next=head;</span><br><span class="line">    ListNode* fast=pre;</span><br><span class="line">    ListNode* slow=pre;</span><br><span class="line">    <span class="built_in">stack</span>&lt;ListNode*&gt; stk;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        fast=fast-&gt;next-&gt;next;</span><br><span class="line">        stk.push(slow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//bool isEven=false;</span></span><br><span class="line">    <span class="keyword">if</span>(fast==<span class="literal">NULL</span>)</span><br><span class="line">        stk.pop();</span><br><span class="line">    <span class="keyword">while</span>(slow-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* cur=stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val!=slow-&gt;next-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-其他类型"><a href="#3-其他类型" class="headerlink" title="3. 其他类型"></a>3. 其他类型</h1><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160 相交链表"></a>160 相交链表</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img" style="zoom: 50%;" />

<p><strong>题解：</strong></p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191223151415.png" alt=""></p>
<p>一定要保证每个引导指针都能跑到<code>NULL</code>节点，即使两个不相干的链表也能将NULL视为相交节点！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">    ListNode* index1 = headA;</span><br><span class="line">    ListNode* index2 = headB;</span><br><span class="line">    <span class="keyword">if</span> (index1 == <span class="literal">NULL</span> || index2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//如果长度相同没有交点，第一轮后同时为NULL，退出</span></span><br><span class="line">    <span class="comment">//如果长度不同没有交点，第二轮后两者移动相同距离</span></span><br><span class="line">    <span class="comment">//同时为NULL，退出</span></span><br><span class="line">    <span class="keyword">while</span> (index1 != index2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//必须写index1而不是index1-&gt;next，不然没法出NULL</span></span><br><span class="line">        index1 = (index1 == <span class="literal">NULL</span>) ? headB : index1-&gt;next;</span><br><span class="line">        index2 = (index2 == <span class="literal">NULL</span>) ? headA : index2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237 删除链表中的节点"></a>237 删除链表中的节点</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<p><strong>解答：</strong></p>
<p><code>node=node-&gt;next</code>不行，要改为指针传递或引用传递。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">    *node=*node-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/23/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%9310-%E9%93%BE%E8%A1%A8/" data-id="ck4o2ture000iu4vyb57pbfcc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode题目总结9-字符串" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/23/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%939-%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="article-date">
  <time datetime="2019-12-23T09:42:48.000Z" itemprop="datePublished">2019-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/23/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%939-%E5%AD%97%E7%AC%A6%E4%B8%B2/">Leetcode题目总结9-字符串</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-字符串流的运用"><a href="#1-字符串流的运用" class="headerlink" title="1. 字符串流的运用"></a>1. 字符串流的运用</h1><p>字符串流<code>stringstream</code>配合读写符&gt;&gt;可以轻松做到精确分割。分割的办法有两种</p>
<ul>
<li><p>字符数字交替分割，可以分割<code>1.22.3</code>这样的数，但并不实用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">str&gt;&gt;c;str&gt;&gt;num;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一种是以空格为标志的分割，非常好用。我们可以实现将原字符串某些部分转化为空格，以此作为分割的标志。</p>
</li>
</ul>
<h2 id="008-字符串转换整数-atoi"><a href="#008-字符串转换整数-atoi" class="headerlink" title="008 字符串转换整数(atoi)"></a>008 字符串转换整数(atoi)</h2><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br><span class="line"></span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。</span><br><span class="line"></span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br><span class="line"></span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">stringstream</span> <span class="title">s</span><span class="params">(str)</span></span>;</span><br><span class="line">	<span class="keyword">long</span> val=<span class="number">0</span>;</span><br><span class="line">	s &gt;&gt; val;</span><br><span class="line">	<span class="keyword">if</span> (val &gt; INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">	<span class="keyword">if</span> (val &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="058-最后一个单词的长度"><a href="#058-最后一个单词的长度" class="headerlink" title="058 最后一个单词的长度"></a>058 最后一个单词的长度</h2><p>给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串，返回其最后一个单词的长度。如果不存在最后一个单词，请返回 0 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;Hello World&quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>在stringstream中判断是否为空的办法是<code>s.rdbuf()-&gt;in_avail()</code>返回剩余字符串长度，如果为0就是为空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">str</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> word;</span><br><span class="line">    <span class="keyword">while</span> (str.rdbuf()-&gt;in_avail())</span><br><span class="line">    &#123;</span><br><span class="line">        str &gt;&gt; word;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> word.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="071-简化路径"><a href="#071-简化路径" class="headerlink" title="071 简化路径"></a>071 简化路径</h2><p>以 Unix 风格给出一个文件的<strong>绝对路径</strong>，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;&#x2F;home&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。</span><br><span class="line"></span><br><span class="line">输入：&quot;&#x2F;..&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</span><br><span class="line"></span><br><span class="line">输入：&quot;&#x2F;home&#x2F;&#x2F;foo&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;home&#x2F;foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>第一步需要从/中切割出想要的成分。第二部开始分析，由于<code>//</code>也是消灭的对象所以需要考虑<code>part==&quot;&quot;</code>。将/替换为空格，就可以利用流的特性进行分割读取。</p>
<p>注意：</p>
<ul>
<li>在<code>s&gt;&gt;part</code>之前要先把垃圾清空</li>
<li><code>part == &quot;..&quot;</code>的判断一定要分两步走，防止<code>/../</code>这种情况</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line">	<span class="keyword">auto</span> lambda = [](<span class="keyword">auto</span>&amp; element) &#123;</span><br><span class="line">		<span class="keyword">if</span> (element == <span class="string">'/'</span>)</span><br><span class="line">			element = <span class="string">' '</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	for_each(path.begin(), path.end(), lambda);</span><br><span class="line">	<span class="function"><span class="built_in">stringstream</span> <span class="title">s</span><span class="params">(path)</span></span>;</span><br><span class="line">	<span class="built_in">string</span> part;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (s.rdbuf()-&gt;in_avail())</span><br><span class="line">	&#123;</span><br><span class="line">        part = <span class="string">""</span>;</span><br><span class="line">		s &gt;&gt; part;</span><br><span class="line">		<span class="keyword">if</span> (part == <span class="string">"."</span> || part == <span class="string">""</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (part == <span class="string">".."</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!stk.empty()) </span><br><span class="line">                stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">else</span> stk.push(<span class="string">"/"</span> + part);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">while</span> (!stk.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//注意顺序</span></span><br><span class="line">		res = stk.top() + res;</span><br><span class="line">		stk.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (res.size() == <span class="number">0</span>) res = <span class="string">"/"</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125 验证回文串"></a>125 验证回文串</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>思路和上面一样，不过在lambda中需要先转化为小写，因为本题要求不考虑大小写。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> lambda = [](<span class="keyword">auto</span>&amp; element) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">isalnum</span>(element))</span><br><span class="line">			element = <span class="string">' '</span>;</span><br><span class="line">		element = <span class="built_in">tolower</span>(element);</span><br><span class="line">	&#125;;</span><br><span class="line">	for_each(s.begin(), s.end(), lambda);</span><br><span class="line">	<span class="function"><span class="built_in">stringstream</span> <span class="title">str</span><span class="params">(s)</span></span>;</span><br><span class="line">	<span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">while</span> (str.rdbuf()-&gt;in_avail())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">string</span> tmp;</span><br><span class="line">		str &gt;&gt; tmp;</span><br><span class="line">		ans += tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> rev_ans = ans;</span><br><span class="line">	reverse(rev_ans.begin(), rev_ans.end());</span><br><span class="line">	<span class="keyword">return</span> ans == rev_ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165 比较版本号"></a>165 比较版本号</h2><p>比较两个版本号 version1 和 version2。<br>如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：version1 &#x3D; &quot;1.01&quot;, version2 &#x3D; &quot;1.001&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。</span><br><span class="line"></span><br><span class="line">输入: version1 &#x3D; &quot;7.5.2.4&quot;, version2 &#x3D; &quot;7.5.3&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>承接容器必须要int类型，如果用string来接会出现<code>&quot;001&quot;</code>和<code>&quot;1&quot;</code>不相等的情况。最后还要考虑长度问题解决<code>version1 = &quot;7.5.3.4&quot;, version2 = &quot;7.5.3&quot;</code>这一类长度不等的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(<span class="built_in">string</span> version1, <span class="built_in">string</span> version2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lambda=[](<span class="keyword">auto</span>&amp; element)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(element))</span><br><span class="line">            element=<span class="string">' '</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">string</span> str1=version1;</span><br><span class="line">    <span class="built_in">string</span> str2 = version2;</span><br><span class="line">    for_each(str1.begin(),str1.end(),lambda);</span><br><span class="line">    for_each(str2.begin(),str2.end(),lambda);</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">s1</span><span class="params">(str1)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">s2</span><span class="params">(str2)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(s1.rdbuf()-&gt;in_avail()||s2.rdbuf()-&gt;in_avail())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp2=<span class="number">0</span>;</span><br><span class="line">        s1&gt;&gt;tmp1;</span><br><span class="line">        s2&gt;&gt;tmp2;</span><br><span class="line">        <span class="keyword">if</span>(tmp1&gt;tmp2||(tmp2==<span class="number">0</span>&amp;&amp;tmp1!=<span class="number">0</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp1&lt;tmp2||(tmp1==<span class="number">0</span>&amp;&amp;tmp2!=<span class="number">0</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-其他"><a href="#2-其他" class="headerlink" title="2. 其他"></a>2. 其他</h1><h2 id="006-Z字变换"><a href="#006-Z字变换" class="headerlink" title="006 Z字变换"></a>006 Z字变换</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>如果行数为3，就分成3个子串分别收集，依靠step进行指路。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.empty()||numRows==<span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">int</span> step=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> dir=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str(numRows);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        str[dir]+=s[i];</span><br><span class="line">        <span class="keyword">if</span>(dir==numRows<span class="number">-1</span>||dir==<span class="number">0</span>)</span><br><span class="line">            step=-step;</span><br><span class="line">        dir+=step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:str)</span><br><span class="line">        res=res+x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="014-最长公共前缀"><a href="#014-最长公共前缀" class="headerlink" title="014 最长公共前缀"></a>014 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>C++中字符串的大小比较是按照字典序排序的，利用这一性质我们可以找到最大和最小，只需要比较最大最小的前缀即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(strs.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">auto</span> it_max = max_element(strs.begin(),strs.end());</span><br><span class="line">    <span class="keyword">auto</span> it_min = min_element(strs.begin(),strs.end());</span><br><span class="line">    <span class="built_in">string</span> max=*it_max;</span><br><span class="line">    <span class="built_in">string</span> min=*it_min;</span><br><span class="line">    <span class="keyword">auto</span> size = <span class="built_in">std</span>::min(max.size(),min.size());</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(max[i]!=min[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max.substr(<span class="number">0</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/23/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%939-%E5%AD%97%E7%AC%A6%E4%B8%B2/" data-id="ck4o2turm000su4vyf9pia6g3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode题目总结8-数学" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/22/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%938-%E6%95%B0%E5%AD%A6/" class="article-date">
  <time datetime="2019-12-22T14:32:29.000Z" itemprop="datePublished">2019-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/22/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%938-%E6%95%B0%E5%AD%A6/">Leetcode题目总结8-数学</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-数字反转"><a href="#1-数字反转" class="headerlink" title="1. 数字反转"></a>1. 数字反转</h1><h2 id="007-整数反转"><a href="#007-整数反转" class="headerlink" title="007 整数反转"></a>007 整数反转</h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>可以转化为字符串来做，也可以按照数学题中常见的数字分割来做。注意检查溢出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        sum=sum*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">        x=x/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;INT_MAX||sum&lt;INT_MIN)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="009-回文数"><a href="#009-回文数" class="headerlink" title="009 回文数"></a>009 回文数</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> origin=x;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        sum=sum*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">        x=x/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (sum==origin)?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-进位问题"><a href="#2-进位问题" class="headerlink" title="2. 进位问题"></a>2. 进位问题</h1><h2 id="043-字符串相乘"><a href="#043-字符串相乘" class="headerlink" title="043 字符串相乘"></a>043 字符串相乘</h2><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。<strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br><span class="line">输入: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>注意<code>index = num1.size() + num2.size() - 2;</code>因为是数组下标。进位最后不要忘了carry还要加上去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     *       1 2 3</span></span><br><span class="line"><span class="comment">     *     * 3 2 1</span></span><br><span class="line"><span class="comment">     *     ----------</span></span><br><span class="line"><span class="comment">     *       1 2 3</span></span><br><span class="line"><span class="comment">     *     2 4 6</span></span><br><span class="line"><span class="comment">     *   3 6 9</span></span><br><span class="line"><span class="comment">     *   --------------</span></span><br><span class="line"><span class="comment">     *   3 8 14 8 9</span></span><br><span class="line"><span class="comment">     *   乘法的计算是错位相加最后的位数=n+(m-1),原数有3位，乘以一个三位数相当于向左添加了2位</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1 == <span class="string">"0"</span> || num2 == <span class="string">"0"</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">222</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> index = num1.size() + num2.size() - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num1.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = num2.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mul = (num1[i] - <span class="string">'0'</span>) * (num2[j] - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">int</span> t = index - i - j; <span class="comment">//index:0-4</span></span><br><span class="line">            res[t] = res[t] + mul;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理完成3 8 14 8 9</span></span><br><span class="line">    <span class="comment">//反过来装 9 8 14 8 3</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i] += carry;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (res[i] &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            carry = res[i] / <span class="number">10</span>;</span><br><span class="line">            res[i] = res[i] % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str.append(to_string(res[i]));<span class="comment">//数字转string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>) str.append(to_string(carry));</span><br><span class="line">    reverse(str.begin(), str.end());</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="066-加一"><a href="#066-加一" class="headerlink" title="066 加一"></a>066 加一</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>分三种情况讨论即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = digits.size();</span><br><span class="line">    <span class="keyword">int</span> lastdigit = digits[len<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(lastdigit!=<span class="number">9</span>)</span><br><span class="line">    &#123;digits[len<span class="number">-1</span>]+=<span class="number">1</span>; <span class="keyword">return</span> digits;&#125;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:digits)</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">9</span>) flag++;</span><br><span class="line">    <span class="keyword">if</span>(flag==len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(len+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    digits[len<span class="number">-1</span>]+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i]+=carry;</span><br><span class="line">        carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(digits[i]&gt;=<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            carry = digits[i]/<span class="number">10</span>;</span><br><span class="line">            digits[i]=digits[i]%<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="067-二进制求和"><a href="#067-二进制求和" class="headerlink" title="067 二进制求和"></a>067 二进制求和</h2><p>给定两个二进制字符串，返回他们的和（用二进制表示）。输入为<strong>非空</strong>字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>注意判空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!a.empty()||!b.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        sum+=carry;</span><br><span class="line">        carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!a.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=a.back()-<span class="string">'0'</span>;</span><br><span class="line">            a.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!b.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=b.back()-<span class="string">'0'</span>;</span><br><span class="line">            b.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        carry=sum/<span class="number">2</span>;</span><br><span class="line">        res.append(to_string(sum%<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry!=<span class="number">0</span>) res.append(to_string(carry));</span><br><span class="line">    reverse(res.begin(),res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-进制"><a href="#3-进制" class="headerlink" title="3. 进制"></a>3. 进制</h1><h2 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168 Excel表列名称"></a>168 Excel表列名称</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假设26，取余后变为1了，结果不正确</span></span><br><span class="line">        <span class="comment">//不能(n%26)-1+'A'</span></span><br><span class="line">        n--;</span><br><span class="line">        res=<span class="keyword">char</span>((n % <span class="number">26</span>) + <span class="string">'A'</span>)+res;</span><br><span class="line">        n = n / <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171 Excel表列序号"></a>171 Excel表列序号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> val = c-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line">        sum=sum*<span class="number">26</span>+val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h1><h2 id="029-两数相除"><a href="#029-两数相除" class="headerlink" title="029 两数相除"></a>029 两数相除</h2><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。返回被除数 dividend 除以除数 divisor 得到的商。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend &#x3D; 10, divisor &#x3D; 3</span><br><span class="line">输出: 3</span><br><span class="line">输入: dividend &#x3D; 7, divisor &#x3D; -3</span><br><span class="line">输出: -2</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191025145248.png" alt="img" style="zoom: 80%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ans = <span class="number">0</span>, up = <span class="built_in">std</span>::<span class="built_in">fabs</span>(dividend), down = <span class="built_in">std</span>::<span class="built_in">fabs</span>(divisor);</span><br><span class="line">    <span class="keyword">while</span>(up &gt;= down)&#123;</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">1</span>, base = down;</span><br><span class="line">        <span class="keyword">while</span>(up &gt; (base &lt;&lt; <span class="number">1</span>))&#123;</span><br><span class="line">            count &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            base &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += count;</span><br><span class="line">        up -= base;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ((dividend &lt; <span class="number">0</span>)^(divisor &lt; <span class="number">0</span>)) ? -ans : ans;</span><br><span class="line">    <span class="keyword">return</span> (ans &gt; INT_MAX || ans &lt; INT_MIN) ? INT_MAX : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="050-Pow-x-n"><a href="#050-Pow-x-n" class="headerlink" title="050 Pow(x,n)"></a>050 Pow(x,n)</h2><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>如果直接线性循环，太慢通不过。需要用快速幂算法，复杂度O(lgn)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//排除特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//一定要转化为long型，防止表示-n时溢出</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmpn=n;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">        tmpn=-(<span class="keyword">long</span> <span class="keyword">long</span>)n;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mymypow(x, tmpn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mymypow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x; </span><br><span class="line">    <span class="comment">//递归主体</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> res = mymypow(x, tmp);</span><br><span class="line">    <span class="comment">//返回情况</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> res * res;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res * res * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172 阶乘后的零"></a>172 阶乘后的零</h2><p>给定一个整数 <em>n</em>，返回 <em>n</em>! 结果尾数中零的数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 1</span><br><span class="line">解释: 5! &#x3D; 120, 尾数中有 1 个零.</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p> 首先题目的意思是末尾有几个0，</p>
<p>比如$6! = [1* 2* 3* 4* 5* 6]$其中只有2*5末尾才有0，所以就可以抛去其他数据专门看2和5 以及其倍数，毕竟 4 * 25末尾也是0</p>
<p>比如$10!= [2<em>4</em>5<em>6</em>8<em>10]$其中 $4$能拆成$2</em>2$  ,$10$能拆成$2<em>5$ 所以$10！ = [2</em>（2<em>2）</em>5<em>（2</em>3）<em>（2</em>2<em>2）</em>（2*5）]$一个2和一个5配对 就产生一个0 所以10！末尾2个0</p>
<p>转头一想 2肯定比5多 所以只数5的个数就行了</p>
<p>假若N=31 31里能凑10的5为$[5, 2<em>5, 3</em>5, 4<em>5, 25, 6</em>5]$， 其中 25还能拆为 5*2 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n/<span class="number">5</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">        count+=n/<span class="number">5</span>;</span><br><span class="line">        n/=<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204 计数质数"></a>204 计数质数</h2><p>统计所有小于非负整数 <em>n</em> 的质数的数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 4</span><br><span class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>如果x是质数，则nx全部都不是质数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; judge(n, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (judge[i])<span class="comment">//如果是质数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt; n; j = j + i)</span><br><span class="line">            &#123;</span><br><span class="line">                judge[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/22/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%938-%E6%95%B0%E5%AD%A6/" data-id="ck4o2turl000ru4vyczrd2eac" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程4-可变参数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B3-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0/">CPP泛型编程3-非类型的模板参数</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B2-%E7%B1%BB%E6%A8%A1%E6%9D%BF/">CPP泛型编程2-类模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程1-函数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/">CPP多线程总结4-并发数据结构设计实例</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>