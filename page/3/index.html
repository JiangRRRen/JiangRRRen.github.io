<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;3&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Leetcode题目总结7-容器的应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/22/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%937-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/" class="article-date">
  <time datetime="2019-12-22T09:51:59.000Z" itemprop="datePublished">2019-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/22/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%937-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/">Leetcode题目总结7-容器的应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-关联容器"><a href="#1-关联容器" class="headerlink" title="1. 关联容器"></a>1. 关联容器</h1><p>关联容器指set和map，这两种容器都是有序的，依靠内部的红黑树维护。</p>
<h2 id="001-两数之和"><a href="#001-两数之和" class="headerlink" title="001 两数之和"></a>001 两数之和</h2><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>注意：</p>
<ol>
<li>不能排序，因为要返回下标序列，排序会打乱</li>
<li>这里需要用map记录而不是set，因为需要记录下标</li>
</ol>
<p>对比一下167题输入的是有序数组，015三数之和要求返回的是数字组合而不是下标。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> another = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span>(m.find(another)!=m.end())</span><br><span class="line">        &#123;</span><br><span class="line">            res[<span class="number">0</span>]=m[another];</span><br><span class="line">            res[<span class="number">1</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            m[nums[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="012-整数转罗马数字"><a href="#012-整数转罗马数字" class="headerlink" title="012 整数转罗马数字"></a>012 整数转罗马数字</h2><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>遍历从M到I的所有罗马数字，遇到合适的就填进res中，同时num减少。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&gt; vec;</span><br><span class="line">    vec.push_back(make_pair(<span class="number">1000</span>, <span class="string">"M"</span>));</span><br><span class="line">    vec.push_back(make_pair(<span class="number">900</span>, <span class="string">"CM"</span>));</span><br><span class="line">    vec.push_back(make_pair(<span class="number">500</span>, <span class="string">"D"</span>));</span><br><span class="line">    vec.push_back(make_pair(<span class="number">400</span>, <span class="string">"CD"</span>));</span><br><span class="line">    vec.push_back(make_pair(<span class="number">100</span>, <span class="string">"C"</span>));</span><br><span class="line">    vec.push_back(make_pair(<span class="number">90</span>, <span class="string">"XC"</span>));</span><br><span class="line">    vec.push_back(make_pair(<span class="number">50</span>, <span class="string">"L"</span>));</span><br><span class="line">    vec.push_back(make_pair(<span class="number">40</span>, <span class="string">"XL"</span>));</span><br><span class="line">    vec.push_back(make_pair(<span class="number">10</span>, <span class="string">"X"</span>));</span><br><span class="line">    vec.push_back(make_pair(<span class="number">9</span>, <span class="string">"IX"</span>));</span><br><span class="line">    vec.push_back(make_pair(<span class="number">5</span>, <span class="string">"V"</span>));</span><br><span class="line">    vec.push_back(make_pair(<span class="number">4</span>, <span class="string">"IV"</span>));</span><br><span class="line">    vec.push_back(make_pair(<span class="number">1</span>, <span class="string">"I"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;=vec[i].first)</span><br><span class="line">        &#123;</span><br><span class="line">            num-=vec[i].first;</span><br><span class="line">            res+=vec[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="013-罗马数字转整数"><a href="#013-罗马数字转整数" class="headerlink" title="013 罗马数字转整数"></a>013 罗马数字转整数</h2><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>转化规则：前一个数小于后一个数，则前一个数为负记入总数，反之为正记入总数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">    mymap.insert(make_pair(<span class="string">'M'</span>,<span class="number">1000</span>));</span><br><span class="line">    mymap.insert(make_pair(<span class="string">'D'</span>, <span class="number">500</span>));</span><br><span class="line">    mymap.insert(make_pair(<span class="string">'C'</span>, <span class="number">100</span>));</span><br><span class="line">    mymap.insert(make_pair(<span class="string">'L'</span>, <span class="number">50</span>));</span><br><span class="line">    mymap.insert(make_pair(<span class="string">'X'</span>, <span class="number">10</span>));</span><br><span class="line">    mymap.insert(make_pair(<span class="string">'V'</span>, <span class="number">5</span>));</span><br><span class="line">    mymap.insert(make_pair(<span class="string">'I'</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size()<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mymap[s[i]]&lt;mymap[s[i+<span class="number">1</span>]])</span><br><span class="line">            res-=mymap[s[i]];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res+=mymap[s[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    res+=mymap[s.back()];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="017-电话号码的字母组合"><a href="#017-电话号码的字母组合" class="headerlink" title="017 电话号码的字母组合"></a>017 电话号码的字母组合</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>需要关注临时容器，依靠push的作用增添新元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; mp;</span><br><span class="line">    mp[<span class="string">'2'</span>] = &#123; <span class="string">"abc"</span> &#125;;</span><br><span class="line">    mp[<span class="string">'3'</span>] = &#123; <span class="string">"def"</span> &#125;;</span><br><span class="line">    mp[<span class="string">'4'</span>] = &#123; <span class="string">"ghi"</span> &#125;;</span><br><span class="line">    mp[<span class="string">'5'</span>] = &#123; <span class="string">"jkl"</span> &#125;;</span><br><span class="line">    mp[<span class="string">'6'</span>] = &#123; <span class="string">"mno"</span> &#125;;</span><br><span class="line">    mp[<span class="string">'7'</span>] = &#123; <span class="string">"pqrs"</span> &#125;;</span><br><span class="line">    mp[<span class="string">'8'</span>] = &#123; <span class="string">"tuv"</span> &#125;;</span><br><span class="line">    mp[<span class="string">'9'</span>] = &#123; <span class="string">"wxyz"</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (digits.size() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">else</span> res.push_back(<span class="string">""</span>); <span class="comment">//一定要做这一步不然循环都进不去</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> digit:digits)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> letter = mp[digit];</span><br><span class="line">        <span class="comment">//需要做一个临时容器，否则会污染</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> oldstring:res)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> newletter:letter)</span><br><span class="line">                tmp.push_back(oldstring+newletter);</span><br><span class="line">        res=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="049-字母异位词分组"><a href="#049-字母异位词分组" class="headerlink" title="049 字母异位词分组"></a>049 字母异位词分组</h2><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>如何判定是否异位相似：对每个字符串排序，将结果插入map中，最后再取出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(strs.size()==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> str:strs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> tmp = str;</span><br><span class="line">        sort(tmp.begin(),tmp.end());</span><br><span class="line">        m[tmp].push_back(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:m)</span><br><span class="line">        res.push_back(x.second);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138 复制带随机指针的链表"></a>138 复制带随机指针的链表</h2><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191022132738.png" alt="img"></p>
<p><strong>解答：</strong></p>
<p>克隆每个节点需要干三件事：val, next, random，由于random的缘故我们需要一个<code>map&lt;Node*,Node*&gt;</code>来记录原来的节点和克隆节点的对应关系。</p>
<p>注意</p>
<ol>
<li>必须<code>m[NULL]=NULL</code></li>
<li>复制时，必须由<code>origin_index</code>在前开路</li>
<li>添加随机时，两者同行</li>
<li>添加随机时需要重置</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用map记录</span></span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Node* clone = <span class="keyword">new</span> Node(head-&gt;val, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    Node* clonde_index = clone;</span><br><span class="line">    Node* origin_index = head-&gt;next;<span class="comment">////注意！</span></span><br><span class="line">    <span class="comment">//克隆的时候必须一前一后</span></span><br><span class="line">    <span class="built_in">map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">    m[head] = clone;</span><br><span class="line">    m[<span class="literal">NULL</span>] = <span class="literal">NULL</span>; <span class="comment">//!非常重要</span></span><br><span class="line">    <span class="comment">//先不复制随机</span></span><br><span class="line">    <span class="keyword">while</span> (origin_index)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* tmp = <span class="keyword">new</span> Node(origin_index-&gt;val, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        clonde_index-&gt;next = tmp;</span><br><span class="line">        m[origin_index] = tmp;</span><br><span class="line">        clonde_index = clonde_index-&gt;next;</span><br><span class="line">        origin_index = origin_index-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加随机</span></span><br><span class="line">    clonde_index = clone; <span class="comment">//重置</span></span><br><span class="line">    origin_index = head; <span class="comment">//注意！</span></span><br><span class="line">    <span class="keyword">while</span> (clonde_index)</span><br><span class="line">    &#123;</span><br><span class="line">        clonde_index-&gt;random = m[origin_index-&gt;random];</span><br><span class="line">        clonde_index = clonde_index-&gt;next;</span><br><span class="line">        origin_index = origin_index-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146 LRU缓存机制"></a>146 LRU缓存机制</h2><p>设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 <code>get(key)</code> - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191005135726.png" alt="LRU原理" style="zoom:67%;" />

<p><strong>解答：</strong></p>
<p>数据结构的核心：List存数据，map记录某个数据在list中的位置，我们每次get和put都需要维护这两个数据结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//list参数：key，val</span></span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; l;</span><br><span class="line">    <span class="comment">//map参数：key，iterator(这个key在list中的顺序)</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; m;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//it返回的不是顺序，而是map的pair</span></span><br><span class="line">        <span class="comment">//it指向map中发现key的位置(一个pair,包含key和iterator)</span></span><br><span class="line">        <span class="comment">//it-&gt;second指向list的iterator</span></span><br><span class="line">        <span class="comment">//it-&gt;second-&gt;second指向val</span></span><br><span class="line">        <span class="keyword">auto</span> it = m.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it == m.end())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//it的第一个是key，第二个是iterator</span></span><br><span class="line">        <span class="keyword">int</span> val = it-&gt;second-&gt;second;</span><br><span class="line">        <span class="comment">//更新list</span></span><br><span class="line">        l.erase(it-&gt;second);</span><br><span class="line">        l.push_front(make_pair(key, val));</span><br><span class="line">        <span class="comment">//更新map</span></span><br><span class="line">        m[key] = l.begin();</span><br><span class="line">        <span class="comment">//返回val</span></span><br><span class="line">        <span class="keyword">return</span> it-&gt;second-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it != m.end())</span><br><span class="line">            <span class="comment">//l的erase参数是iterator</span></span><br><span class="line">            l.erase(it-&gt;second);</span><br><span class="line"></span><br><span class="line">        l.push_front(make_pair(key, value));</span><br><span class="line">        m[key] = l.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l.size() &gt; cap)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> key = l.back().first;</span><br><span class="line">            <span class="comment">//m的erase参数是key</span></span><br><span class="line">            <span class="comment">//擦去的时候map擦key，list擦iterator</span></span><br><span class="line">            m.erase(key);</span><br><span class="line">            l.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205 同构字符串"></a>205 同构字符串</h2><p>给定两个字符串 s和 t，判断它们是否是同构的。如果s中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;paper&quot;, t &#x3D; &quot;title&quot;</span><br><span class="line">输出: true</span><br><span class="line">输入: s &#x3D; &quot;foo&quot;, t &#x3D; &quot;bar&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>抽象为ABAC类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> abstract(s)==abstract(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">abstract</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="built_in">string</span> tmp=str;</span><br><span class="line">      <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; m;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.size();i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(m.find(str[i])==m.end())</span><br><span class="line">          &#123;</span><br><span class="line">              tmp[i]=<span class="string">'a'</span>+flag;</span><br><span class="line">              m[str[i]]=tmp[i];</span><br><span class="line">              flag++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              tmp[i]=m[str[i]];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="208-实现Trie-前缀树"><a href="#208-实现Trie-前缀树" class="headerlink" title="208 实现Trie(前缀树)"></a>208 实现Trie(前缀树)</h2><p>实现一个 Trie (前缀树)，包含 <code>insert</code>, <code>search</code>, 和 <code>startsWith</code> 这三个操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; 返回 true</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 false</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 true</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191222114549.png" style="zoom:80%;" />

<p>注意打上leaf不表示这一脉真的结束了，而是表示从头到这个节点，在字典里有对应，方便<code>search</code>操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,TrieNode*&gt; child;</span><br><span class="line">        <span class="keyword">bool</span> isLeaf;</span><br><span class="line">        TrieNode():isLeaf(<span class="literal">false</span>)&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    TrieNode* root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root=<span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode* cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it=cur-&gt;child.find(c);</span><br><span class="line">            <span class="keyword">if</span>(it==cur-&gt;child.end())</span><br><span class="line">                cur-&gt;child.insert(make_pair(c,<span class="keyword">new</span> TrieNode()));</span><br><span class="line">            cur=cur-&gt;child[c];</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;isLeaf=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode* cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it=cur-&gt;child.find(c);</span><br><span class="line">            <span class="keyword">if</span>(it==cur-&gt;child.end())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            cur=cur-&gt;child[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;isLeaf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:prefix)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it=cur-&gt;child.find(c);</span><br><span class="line">            <span class="keyword">if</span>(it==cur-&gt;child.end())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            cur=cur-&gt;child[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217 存在重复元素"></a>217 存在重复元素</h2><p>给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>SET去重</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)</span><br><span class="line">        s.insert(num);</span><br><span class="line">    <span class="keyword">return</span> s.size()!=nums.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219 存在重复元素 II"></a>219 存在重复元素 II</h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 <code>nums [i] = nums [j]</code>，并且<code>i</code>和<code>j</code>的差的绝对值最大为<code>k</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1], k &#x3D; 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()==<span class="number">0</span>||k==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.find(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(it==m.end())</span><br><span class="line">            m[nums[i]]=i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i-m[nums[i]]&lt;=k)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                m[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="220-存在重复元素-III"><a href="#220-存在重复元素-III" class="headerlink" title="220 存在重复元素 III"></a>220 存在重复元素 III</h2><p>给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 <code>nums [i]</code>和<code>nums [j]</code>的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 k。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1], k &#x3D; 3, t &#x3D; 0</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>这道题也可以按219的模板来做，但速度就很感人了。可以维护一个窗口，大小不超过k，滑动窗口比较nums的值是否满足要求。采用set来存储窗口的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i - j &gt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            s.erase(nums[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> it = s.lower_bound((<span class="keyword">long</span> <span class="keyword">long</span>)nums[i] - t);<span class="comment">//有可能nums[i] - t是个负数</span></span><br><span class="line">        <span class="keyword">if</span> (it != s.end() &amp;&amp; <span class="built_in">abs</span>(nums[i] - *it) &lt;= t)<span class="comment">//必须要double check</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        s.insert(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-容器适配器"><a href="#3-容器适配器" class="headerlink" title="3. 容器适配器"></a>3. 容器适配器</h1><p>指stack，queue的运用</p>
<h2 id="020-有效的括号"><a href="#020-有效的括号" class="headerlink" title="020 有效的括号"></a>020 有效的括号</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>switch一定要跟break，不然会顺序执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> : <span class="built_in">cout</span> &lt;&lt; <span class="string">'1'</span>; <span class="comment">// 打印 "1",</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> : <span class="built_in">cout</span> &lt;&lt; <span class="string">'2'</span>; <span class="comment">// 然后打印 "2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后要判断栈是否为空，防止输入<code>[</code>，返回true这种情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>: stk.push(<span class="string">'('</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>:stk.push(<span class="string">'['</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#123;'</span>:stk.push(<span class="string">'&#123;'</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span>(stk.empty()||stk.top()!=<span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> stk.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">                <span class="keyword">if</span>(stk.empty()||stk.top()!=<span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> stk.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">                <span class="keyword">if</span>(stk.empty()||stk.top()!=<span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> stk.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150 逆波兰表达式求值"></a>150 逆波兰表达式求值</h2><p>根据<a href="https://baike.baidu.com/item/逆波兰式/128437" target="_blank" rel="noopener">逆波兰表示法</a>，求表达式的值。有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: (4 + (13 &#x2F; 5)) &#x3D; 6</span><br><span class="line"></span><br><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: ((2 + 1) * 3) &#x3D; 9</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>从前往后遍历数组，遇到数字则压入栈中，遇到符号，则把栈顶的两个数字拿出来运算，把结果再压入栈中，直到遍历完整个数组，栈顶数字即为最终答案。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> c = tokens[i];</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">"+"</span> || c == <span class="string">"-"</span> || c == <span class="string">"*"</span> || c == <span class="string">"/"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//栈存取顺序！</span></span><br><span class="line">            <span class="keyword">int</span> val2 = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">int</span> val1 = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">"+"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                val1 += val2;</span><br><span class="line">                s.push(val1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">"-"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                val1 -= val2;</span><br><span class="line">                s.push(val1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">"*"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                val1 *= val2;</span><br><span class="line">                s.push(val1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">"/"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                val1 = val1 / val2;</span><br><span class="line">                s.push(val1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s.push(stoi(tokens[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155 最小栈"></a>155 最小栈</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p><strong>解答：</strong></p>
<p>维护两个栈：一个存最小，一个存数据。注意一定要小于等于，为了pop的一致性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; min;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        data.push(x);</span><br><span class="line">        <span class="keyword">if</span>(min.empty()||x&lt;=getMin())</span><br><span class="line">            min.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.top()==min.top())</span><br><span class="line">            min.pop();</span><br><span class="line">        data.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225 用队列实现栈"></a>225 用队列实现栈</h2><p><strong>解答:</strong></p>
<p>可以用双端队列，但比较慢，而且没什么意思。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jr225_MyStack</span> &#123;</span></span><br><span class="line">    <span class="comment">//双队列交替存储</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q1.empty() &amp;&amp; q2.empty())</span><br><span class="line">            q1.push(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            q2.push(x);</span><br><span class="line">            <span class="keyword">while</span> (!q1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                q2.push(q1.front());</span><br><span class="line">                q1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//q1.empty</span></span><br><span class="line">        &#123;</span><br><span class="line">            q1.push(x);</span><br><span class="line">            <span class="keyword">while</span> (!q2.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                q1.push(q2.front());</span><br><span class="line">                q2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">if</span> (!q1.empty())</span><br><span class="line">        &#123;</span><br><span class="line">             val= q1.front();</span><br><span class="line">            q1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!q2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            val = q2.front();</span><br><span class="line">            q2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q1.empty())</span><br><span class="line">            <span class="keyword">return</span> q1.front();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!q2.empty()) </span><br><span class="line">            <span class="keyword">return</span> q2.front();</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q2.empty() &amp;&amp; q1.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232 用栈实现队列"></a>232 用栈实现队列</h2><p><strong>解答:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!s2.empty()) &#123;</span><br><span class="line">            s1.push(s2.top());</span><br><span class="line">            s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s2.push(x);</span><br><span class="line">        <span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">            s2.push(s1.top());</span><br><span class="line">            s1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = s2.top();</span><br><span class="line">        s2.pop();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/22/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%937-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/" data-id="ck4o2turl000qu4vy2uz91ucl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode题目总结6-BFS和DFS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/21/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%936-BFS%E5%92%8CDFS/" class="article-date">
  <time datetime="2019-12-21T14:03:49.000Z" itemprop="datePublished">2019-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/21/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%936-BFS%E5%92%8CDFS/">Leetcode题目总结6-BFS和DFS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-算法介绍"><a href="#1-算法介绍" class="headerlink" title="1. 算法介绍"></a>1. 算法介绍</h1><p>BFS和DFS是一对孪生兄弟，几乎所有DFS可以完成的地方BFS都可以完成。本章主要以BFS的介绍为主，DFS为辅。</p>
<p>简单的说，BFS是从根节点开始，沿着树（图）的宽度遍历树（图）的节点。如果所有节点均被访问，则算法中止。BFS同样属于盲目搜索。一般用<strong>队列数据结构</strong>来辅助实现BFS算法。</p>
<p>解题步骤一般是：</p>
<ol>
<li>首先将根节点放入队列中。</li>
<li>从队列中取出第一个节点，并检验它是否为目标。如果找到目标，则结束搜寻并回传结果。否则将它所有尚未检验过的直接子节点加入队列中。</li>
<li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</li>
<li>重复步骤2。</li>
</ol>
<p>DFS递归和栈都能用，BFS统统使用队列。</p>
<h1 id="2-树的BFS"><a href="#2-树的BFS" class="headerlink" title="2. 树的BFS"></a>2. 树的BFS</h1><p>树BFS基本就是纯粹的模板，模板有两个while，第一个是大while，第二个是小while。假设如下的二叉树，最开始队列存储root，1</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191221143105.png" style="zoom:50%;" />


<table>
<thead>
<tr>
<th align="center">while次数</th>
<th align="center">队列存储结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">[2,3]</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">[4,5,6,7]</td>
</tr>
</tbody></table>
<p>存储的顺序是正序还是反序，主要根据<code>left</code>和<code>right</code>的先后顺序。模板见102题。</p>
<h2 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102 二叉树的层次遍历"></a>102 二叉树的层次遍历</h2><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br><span class="line"> RES&#x3D;[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>注意要先判断是否为空，剩下的内容基本都是套路模板。注意<code>while(!q.empty())</code>是取非，不要马虎写错了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> size = q.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span>(size--)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            tmp.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103 二叉树的锯齿形层次遍历"></a>103 二叉树的锯齿形层次遍历</h2><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">[[3],[20,9],[15,7]]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>很巧妙的翻转。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">auto</span> size=q.size();</span><br><span class="line">        <span class="keyword">while</span>(size--)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node=q.front();</span><br><span class="line">            tmp.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag%<span class="number">2</span>==<span class="number">1</span>) reverse(tmp.begin(),tmp.end());</span><br><span class="line">        flag++;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107 二叉树的层次遍历 II"></a>107 二叉树的层次遍历 II</h2><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">[[15,7],[9,20],[3]]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">    <span class="comment">//和102一样，最后反转即可</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; myq;</span><br><span class="line">    myq.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!myq.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">auto</span> size = myq.size();</span><br><span class="line">        <span class="keyword">while</span> (size--)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node=myq.front();</span><br><span class="line">            myq.pop();</span><br><span class="line">            tmp.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                myq.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                myq.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116 填充每个节点的下一个右侧节点指针"></a>116 填充每个节点的下一个右侧节点指针</h2><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191021151214.png" alt="img" style="zoom: 50%;" />

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="comment">//每一个while循环都是一层</span></span><br><span class="line">    <span class="comment">//size就是这一层的节点数量</span></span><br><span class="line">    <span class="comment">//i&lt;size-1时，代表要右指</span></span><br><span class="line">    <span class="comment">//每一层干三件事：1.弹出旧的 2.判断右指 3.添加新的</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> size = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node* t = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                t-&gt;next = q.front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199 二叉树的右视图"></a>199 二叉树的右视图</h2><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        res.push_back(q.front()-&gt;val);</span><br><span class="line">        <span class="comment">//BFS新技术size法</span></span><br><span class="line">        <span class="keyword">while</span> (size--)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;right)</span><br><span class="line">                q.push(tmp-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;left)</span><br><span class="line">                q.push(tmp-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226 翻转二叉树"></a>226 翻转二叉树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> size = q.size();</span><br><span class="line">        <span class="keyword">while</span>(size--)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            swap(node-&gt;left,node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-图的BFS"><a href="#2-图的BFS" class="headerlink" title="2. 图的BFS"></a>2. 图的BFS</h1><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191221151952.png" alt="img" style="zoom: 67%;" />

<h2 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133 克隆图"></a>133 克隆图</h2><p>给定无向<a href="https://baike.baidu.com/item/连通图/6460995?fr=aladdin" target="_blank" rel="noopener"><strong>连通</strong></a>图中一个节点的引用，返回该图的<a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank" rel="noopener"><strong>深拷贝</strong></a>（克隆）。图中的每个节点都包含它的值 <code>val</code>（<code>Int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p>
<p><strong>解答：</strong></p>
<p>需要通过map来进行映射，记录是否已经拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">    q.push(node);</span><br><span class="line">    <span class="comment">//注意下vector&lt;Node*&gt;&#123;&#125;写法</span></span><br><span class="line">    Node* clone = <span class="keyword">new</span> Node(node-&gt;val, <span class="built_in">vector</span>&lt;Node*&gt;&#123;&#125;);</span><br><span class="line">    m[node] = clone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node* t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (Node* nei : t-&gt;neighbors)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//nei是原节点，m[nei]是复制节点，凡是</span></span><br><span class="line">            <span class="comment">//m[xx]都是复制节点</span></span><br><span class="line">            <span class="keyword">if</span> (!m.count(nei))</span><br><span class="line">            &#123;</span><br><span class="line">                m[nei] = <span class="keyword">new</span> Node(nei-&gt;val,<span class="built_in">vector</span>&lt;Node*&gt;&#123;&#125;);</span><br><span class="line">                q.push(nei);</span><br><span class="line">            &#125;</span><br><span class="line">            m[t]-&gt;neighbors.push_back(m[nei]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207 课程表"></a>207 课程表</h2><p>现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；</span><br><span class="line">并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>本质就是有向图是否存在环的问题。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191009152556.png" alt="img"  />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有向图的标准设置：map&lt;int, set&lt;int&gt;&gt;存领域，vector&lt;int&gt;存入度</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; adjacent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : prerequisites) <span class="comment">//建图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> from = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> to = edge[<span class="number">1</span>];</span><br><span class="line">        adjacent[from].insert(to);</span><br><span class="line">        indegree[to]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Inq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        <span class="keyword">if</span> (!indegree[i])</span><br><span class="line">            Inq.push(i);</span><br><span class="line">    <span class="keyword">while</span> (!Inq.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> v = Inq.front();</span><br><span class="line">        Inq.pop();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">auto</span> adjs = adjacent[v];</span><br><span class="line">        <span class="comment">//因为把v删了，所以入度也要改变</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; adj : adjs)</span><br><span class="line">        &#123;</span><br><span class="line">            indegree[adj]--;</span><br><span class="line">            <span class="keyword">if</span> (!indegree[adj])</span><br><span class="line">                Inq.push(adj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reverse(indegree.begin(), indegree.end());;</span></span><br><span class="line">    <span class="keyword">return</span> count == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210 课程表 II"></a>210 课程表 II</h2><p>和上面一样，不过要记录下可能的课程顺序（一种即可）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; adjacent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : prerequisites)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> from = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> to = edge[<span class="number">1</span>];</span><br><span class="line">        adjacent[from].insert(to);</span><br><span class="line">        indegree[to]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Inq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        <span class="keyword">if</span> (!indegree[i])</span><br><span class="line">            Inq.push(i);</span><br><span class="line">    <span class="keyword">while</span> (!Inq.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> v = Inq.front();</span><br><span class="line">        Inq.pop();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//添加</span></span><br><span class="line">        res.push_back(v);</span><br><span class="line">        <span class="keyword">auto</span> adjs = adjacent[v];</span><br><span class="line">        <span class="comment">//因为把v删了，所以入度也要改变</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; adj : adjs)</span><br><span class="line">        &#123;</span><br><span class="line">            indegree[adj]--;</span><br><span class="line">            <span class="keyword">if</span> (!indegree[adj])</span><br><span class="line">                Inq.push(adj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    <span class="keyword">if</span> (numCourses != count)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-其他结构的BFS"><a href="#3-其他结构的BFS" class="headerlink" title="3. 其他结构的BFS"></a>3. 其他结构的BFS</h1><h2 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127 单词接龙"></a>127 单词接龙</h2><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<ul>
<li>每次转换只能改变一个字母</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;,</span><br><span class="line">endWord &#x3D; &quot;cog&quot;,</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">     返回它的长度 5。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>实质上就是统计BFS的层数</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191221165752.png" style="zoom: 80%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wordList.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//假如当前为dot，</span></span><br><span class="line">    <span class="comment">//则下一个为log或dog，q就是存log和cog的</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">    <span class="comment">//字典，存单词</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dic;</span><br><span class="line">    <span class="comment">//初始化字典，1表示有这个单词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordList.size(); i++)</span><br><span class="line">        dic[wordList[i]] = <span class="number">1</span>;</span><br><span class="line">    q.push(beginWord);</span><br><span class="line">    <span class="keyword">int</span> layer=<span class="number">1</span>;</span><br><span class="line">    dic.erase(beginWord);</span><br><span class="line">    <span class="keyword">while</span> ((!q.empty()) &amp;&amp; dic.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取一个出来</span></span><br><span class="line">        <span class="keyword">auto</span> size=q.size();</span><br><span class="line">        layer++;</span><br><span class="line">        <span class="keyword">while</span>(size--)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">string</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; now.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = now;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp[i] == c) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> tmp[i] = c;</span><br><span class="line">                <span class="keyword">if</span> (dic.find(tmp) != dic.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tmp == endWord)<span class="keyword">return</span> layer;</span><br><span class="line">                    q.push(tmp);</span><br><span class="line">                    dic.erase(tmp); <span class="comment">//擦掉tmp不是now</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200 岛屿数量"></a>200 岛屿数量</h2><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//总体思路是把某个点1相连通的区域变为0，</span></span><br><span class="line"><span class="comment">//这样有多少个点就有多少个连通</span></span><br><span class="line"><span class="comment">//BFS用队列，DFS使用递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.size() == <span class="number">0</span> || grid[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M = grid.size(), N = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gird[x][y] = 1, delete it and its around.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M = grid.size(), N = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.push(&#123; x, y &#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> head = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">int</span> x = head.first;</span><br><span class="line">        <span class="keyword">int</span> y = head.second;</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y] != <span class="string">'1'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        grid[x][y] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> d : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = x + d.first;</span><br><span class="line">            <span class="keyword">int</span> j = y + d.second;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= M || j &lt; <span class="number">0</span> || j &gt;= N || grid[i][j] != <span class="string">'1'</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.push(&#123; i, j &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/21/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%936-BFS%E5%92%8CDFS/" data-id="ck4o2turj000pu4vyd00vhc21" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode题目总结5-位运算" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/21/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%935-%E4%BD%8D%E8%BF%90%E7%AE%97/" class="article-date">
  <time datetime="2019-12-21T12:17:39.000Z" itemprop="datePublished">2019-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/21/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%935-%E4%BD%8D%E8%BF%90%E7%AE%97/">Leetcode题目总结5-位运算</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-常见的位运算技巧"><a href="#1-常见的位运算技巧" class="headerlink" title="1. 常见的位运算技巧"></a>1. 常见的位运算技巧</h1><p><strong>(1) 判断奇偶</strong></p>
<p>奇数最后一位为1，偶数为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(num&amp;<span class="number">1</span>)&#123;&#125; <span class="comment">//奇数</span></span><br><span class="line"><span class="keyword">else</span> &#123;&#125; <span class="comment">//偶数</span></span><br></pre></td></tr></table></figure>

<p><strong>(2) 交换两数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a!=b) a^=b,b^=a,a^=b;</span><br></pre></td></tr></table></figure>

<p><strong>(3) 变换符号</strong></p>
<p>二进制取反+1就可以将正变负，负变正。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ~a+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>（4）取出某一位的数字</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val=(x &gt;&gt; i) &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="2-移位取值"><a href="#2-移位取值" class="headerlink" title="2. 移位取值"></a>2. 移位取值</h1><p>这一类题目都运用到了前面提到的<strong>取出某一位数字</strong>的技巧，这种方法将位运算转化为类似字符串的操作形式，十分简便。</p>
<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136 只出现一次的数字"></a>136 只出现一次的数字</h2><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>假设数组是001,001,000,000,011，多余的元素是011，最后一位操作加起来取余2，余下了1，所以，多余元素就是1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums)</span><br><span class="line">            <span class="comment">//取出单个比特的数字</span></span><br><span class="line">            sum += (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> residue = sum % <span class="number">2</span>;</span><br><span class="line">        target = target | residue &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137 只出现一次的数字 II"></a>137 只出现一次的数字 II</h2><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,1,0,1,99]</span><br><span class="line">输出: 99</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>方法和上面一样，不过是取余3而已。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:nums)</span><br><span class="line">            sum+=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> residue=sum%<span class="number">3</span>;</span><br><span class="line">        res|=residue&lt;&lt;i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169 多数元素"></a>169 多数元素</h2><p>给定一个大小为 <em>n</em> 的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>和上面两题一脉相承，如果数组有7个元素，而001是众数，则第0位的1的数量一定大于等于4，0的数量小于等于3，所以只需要比较0和1的数量就可以判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> zeros=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ones=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>) ones++;</span><br><span class="line">            <span class="keyword">else</span> zeros++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ones&gt;zeros) res|=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190 颠倒二进制位"></a>190 颠倒二进制位</h2><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 00000010100101000001111010011100</span><br><span class="line">输出: 00111001011110000010100101000000</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>利用栈的特性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> reverseBits(<span class="keyword">uint32_t</span> n) &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">uint32_t</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> val =(n&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        st.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res|=st.top()&lt;&lt;i;</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191 位1的个数"></a>191 位1的个数</h2><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量" target="_blank" rel="noopener">汉明重量</a>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>极其简单，也可以一行解决<code>return bitset&lt;32&gt;(n).count();</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((n&gt;&gt;i)&amp;<span class="number">1</span>)</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/21/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%935-%E4%BD%8D%E8%BF%90%E7%AE%97/" data-id="ck4o2turi000nu4vy6c4948qm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode题目总结4-回溯" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/20/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%934-%E5%9B%9E%E6%BA%AF/" class="article-date">
  <time datetime="2019-12-20T13:44:31.000Z" itemprop="datePublished">2019-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/20/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%934-%E5%9B%9E%E6%BA%AF/">Leetcode题目总结4-回溯</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-算法讲解"><a href="#1-算法讲解" class="headerlink" title="1. 算法讲解"></a>1. 算法讲解</h1><p><strong>回溯法（backtracking）</strong>本质其实是一种在<strong>深度优先搜索（DFS）</strong>的基础上，加入了<strong>剪枝函数（pruning）</strong>，从而使得空间复杂度在一定程度上有所降低。回溯法适合组合数相当大的问题，也就是许多<strong>组合优化的问题</strong>适合用回溯法解决。</p>
<p>常见的地方有两个</p>
<ul>
<li><code>backtrack</code>函数的开头，<strong>剪掉后方便放入收集容器</strong></li>
<li>for循环的开头，<strong>一般是去重</strong></li>
</ul>
<p>回溯函数的一般化<strong>流程</strong>是:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(原数组，结果容器，临时容器，起始位置，....)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(...) <span class="keyword">return</span><span class="comment">//剪枝条件</span></span><br><span class="line">    <span class="keyword">if</span>(...) <span class="comment">//结果容器收集条件</span></span><br><span class="line">    &#123;</span><br><span class="line">       res.push_back(tmp);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里也可能有剪枝条件，比如去除重复元素</span></span><br><span class="line">        tmp.push_back();</span><br><span class="line">        backtrack(位置);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-组合问题"><a href="#2-组合问题" class="headerlink" title="2. 组合问题"></a>2. 组合问题</h1><p>组合是按先后顺序依次进行，区分组合和排列的关键就是看：<strong>前面用过后面还用不用</strong>。</p>
<p>比如，[1,2,3]的全排列，1虽然用过，但依然可能出现在其他位置，再接着用；而[1,2,3,4,5]数组中和为8的数组集合，这里用过1（pass过）就不会再出现了。所以<strong>排列问题需要用<code>flag</code>标记</strong>，组合则不需要。</p>
<h2 id="039-组合总和"><a href="#039-组合总和" class="headerlink" title="039 组合总和"></a>039 组合总和</h2><p>给定一个<strong>无重复元素</strong>的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<strong>candidates 中的数字可以无限制重复被选取。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>注意，要排序！最后调用backtrack进入的是i，不是start！并且不加1（<code>candidates</code> 中的数字可以无限制重复被选取）。注意要<strong>传引用</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    sort(candidates.begin(), candidates.end());</span><br><span class="line">    backtrack(res,tmp,candidates,target,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(target ==<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;candidates.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp.push_back(candidates[i]);</span><br><span class="line">        backtrack(res,tmp,candidates,target-candidates[i],i);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="040-组合总和II"><a href="#040-组合总和II" class="headerlink" title="040 组合总和II"></a>040 组合总和II</h2><p>给定一个数组<strong>有重复元素的数组</strong> <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的<strong>每个数字在每个组合中只能使用一次</strong>。</p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>因为有数组有重复所以要去重，因为只能用一次所以backtrack时需要+1防止自环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    sort(candidates.begin(),candidates.end());</span><br><span class="line">    backtrack(res,tmp,candidates,target,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> target,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;candidates.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;start&amp;&amp;candidates[i]==candidates[i<span class="number">-1</span>]) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        tmp.push_back(candidates[i]);</span><br><span class="line">        backtrack(res,tmp,candidates,target-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="077-组合"><a href="#077-组合" class="headerlink" title="077 组合"></a>077 组合</h2><p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>按照直觉，先构建数组。注意比较的时候<code>tmp.size()==k</code>而不是<code>start==k</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        vec.push_back(i);</span><br><span class="line">    backtrack(res,tmp,vec,<span class="number">0</span>,k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> start,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp.size()==k)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;vec.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp.push_back(vec[i]);</span><br><span class="line">        backtrack(res,tmp,vec,i+<span class="number">1</span>,k);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="216-组合总和III"><a href="#216-组合总和III" class="headerlink" title="216 组合总和III"></a>216 组合总和III</h2><p>找出所有相加之和为 <strong><em>n\</em></strong> 的 <strong>k</strong> 个数的组合<strong>。</strong>组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>这道题和077一样，需要自己创造一个<code>nums</code>容器出来，这样会比较清晰。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">        nums.push_back(i);</span><br><span class="line">    backtrack(k,n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> n,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;k!=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;k==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        backtrack(k<span class="number">-1</span>,n-nums[i],i+<span class="number">1</span>);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="078-子集"><a href="#078-子集" class="headerlink" title="078 子集"></a>078 子集</h2><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    backtrack(res,tmp,nums,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    res.push_back(tmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        backtrack(res,tmp,nums,i+<span class="number">1</span>);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="090-子集II"><a href="#090-子集II" class="headerlink" title="090 子集II"></a>090 子集II</h2><p>给定一个可能包含重复元素的整数数组 <strong><em>nums\</em></strong>，返回该数组所有可能的子集（幂集）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>两个要点：</p>
<ul>
<li>查重，注意<code>i&gt;start</code>不是<code>i&gt;0</code></li>
<li>排序，不排序的话如果出现[4,4,4,1,4]这种，查重查不出来</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    backtrack(res,tmp,nums,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    res.push_back(tmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;start&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        backtrack(res,tmp,nums,i+<span class="number">1</span>);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="093-复原IP地址"><a href="#093-复原IP地址" class="headerlink" title="093 复原IP地址"></a>093 复原IP地址</h2><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;25525511135&quot;</span><br><span class="line">输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>这道题特别复杂，而且也不是传统的回溯套路。这里的<code>for</code>代表第<code>n</code>个字节，有三个剪枝条件，注意第二个的办法非常巧妙。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; restoreIpAddresses(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line">    backtrack(s, res, tmp, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="built_in">string</span> tmp, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.size()&gt;<span class="number">3</span>*(<span class="number">4</span>-n)) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">4</span>&amp;&amp;s.size()==<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        tmp.pop_back(); <span class="comment">//去掉最后的'.'</span></span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;i) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> val=stoi(s.substr(<span class="number">0</span>,i));</span><br><span class="line">        <span class="keyword">if</span>(i!=to_string(val).size()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(val&gt;<span class="number">255</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        tmp+=s.substr(<span class="number">0</span>,i)+<span class="string">'.'</span>;</span><br><span class="line">        backtrack(s.substr(i),res,tmp,n+<span class="number">1</span>);</span><br><span class="line">        tmp=tmp.substr(<span class="number">0</span>,tmp.size()-i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113 路径总和 II"></a>113 路径总和 II</h2><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">          5</span><br><span class="line">         &#x2F; \</span><br><span class="line">        4   8</span><br><span class="line">       &#x2F;   &#x2F; \</span><br><span class="line">      11  13  4</span><br><span class="line">     &#x2F;  \    &#x2F; \</span><br><span class="line">    7    2  5   1</span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>112不需要存值，直接DFS就好，要存值最好用回溯模板。容器收集判断需要放在push后面！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    path(res, root, sum, tmp);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, TreeNode* root,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//相较于112,需要记录</span></span><br><span class="line">    <span class="comment">//采用深度优先的办法</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    tmp.push_back(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == sum)</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    path(res, root-&gt;left, sum - root-&gt;val, tmp);</span><br><span class="line">    path(res, root-&gt;right, sum - root-&gt;val, tmp);</span><br><span class="line">    tmp.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131 分割回文串"></a>131 分割回文串</h2><p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。返回 <em>s</em> 所有可能的分割方案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    backtrack(s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> tmp = s;</span><br><span class="line">    reverse(tmp.begin(),tmp.end());</span><br><span class="line">    <span class="keyword">return</span> s==tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//start是开始计算的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果不满足回文，start不会增长，start&gt;s.size()-1意味着检验完毕</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; s.size() - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//len是分割字符的长度</span></span><br><span class="line">    <span class="comment">//这里必须小于等于，start=0，len=3，有效</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= s.size() - start; len++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//substr:pos+len</span></span><br><span class="line">        <span class="keyword">if</span> (isPalindrome(s.substr(start, len)))</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.push_back(s.substr(start, len));</span><br><span class="line">            backtrack(s, start + len);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-排列问题"><a href="#3-排列问题" class="headerlink" title="3. 排列问题"></a>3. 排列问题</h1><p>前面讲过，组合问题是按先后顺序进行，而排列则不是：前面用过的元素后面依然可能用到。所以<strong>排列问题需要用<code>flag</code>标记</strong>，组合则不需要。</p>
<h2 id="046-全排列"><a href="#046-全排列" class="headerlink" title="046 全排列"></a>046 全排列</h2><p>给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>我们需要用<code>flag</code>来做标记，用了某个元素就打上标记，回溯完以后就撤掉这个标记，重复利用。除了标记还需要注意<code>int i = 0</code>而不是组合问题中<code>int i=start</code>;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; flag(nums.size(),<span class="literal">false</span>);</span><br><span class="line">    backtrack(nums,flag);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp.size()==nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[i]) <span class="keyword">continue</span>;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        flag[i]=<span class="literal">true</span>;</span><br><span class="line">        backtrack(nums,flag);</span><br><span class="line">        flag[i]=<span class="literal">false</span>;</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="047-全排列II"><a href="#047-全排列II" class="headerlink" title="047 全排列II"></a>047 全排列II</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>简单的去重没什么好说的，注意一定要sort排序，避免<code>[4,4,4,1,4]</code>这种情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="comment">//sort(nums.begin(), nums.end());</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; flag(nums.size(), <span class="literal">false</span>);</span><br><span class="line">    backtrack(nums, flag, res, tmp);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; flag, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp.size() == nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !flag[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        flag[i] = <span class="literal">true</span>;</span><br><span class="line">        tmp.push_back(nums[i]);</span><br><span class="line">        backtrack(nums, flag, res,tmp);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">        flag[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/20/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%934-%E5%9B%9E%E6%BA%AF/" data-id="ck4o2turg000lu4vy2pfp6ynn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode题目总结3-动态规划" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/19/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%933-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="article-date">
  <time datetime="2019-12-19T16:20:00.000Z" itemprop="datePublished">2019-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/19/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%933-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">Leetcode题目总结3-动态规划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-算法讲解"><a href="#1-算法讲解" class="headerlink" title="1. 算法讲解"></a>1. 算法讲解</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>动态规划脱胎于暴力解法，<strong>通过优化重叠子问题</strong>形成了DP这种高效的解法。</p>
<p>动态规划过程是：每次决策<strong>依赖于当前状态</strong>，又随即<strong>引起状态的转移</strong>。将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，<strong>前一子问题的解，为后一子问题的求解提供了有用的信息</strong>。分治法也是将问题分为若干个子问题，但<strong>经分解后得到的子问题往往不是互相独立的</strong>。</p>
<p>要解决动态规划(dp)的问题需要考虑四个步骤：</p>
<ol>
<li><strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来</li>
<li><strong>状态转移方程和转移条件</strong>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。</li>
<li><strong>初始状态</strong>的本质是递推，递推就需要明确初始条件。</li>
<li><strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件</li>
</ol>
<p>其实最主要的还是考虑23，<strong>转移方程转移条件和初始状态</strong>！</p>
<p><strong>以爬楼梯为例</strong>，假设每次爬楼梯只能爬1步或2步，求爬到第n阶有多少种办法？</p>
<ul>
<li><p><strong>确定状态和状态变量：</strong>爬到第<code>i</code>层所需要的步数<code>dp</code>。</p>
</li>
<li><p><strong>转移方程：</strong><code>dp[i] = dp[i - 1] + dp[i - 2]</code>。</p>
</li>
<li><p><strong>初始条件</strong>：<code>dp[0] = 1;</code>和<code>dp[1] = 2;</code></p>
</li>
<li><p><strong>边界条件：</strong>第n层结束。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>,dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-解法"><a href="#1-2-解法" class="headerlink" title="1.2 解法"></a>1.2 解法</h2><p>前面说到，动态规划脱胎于暴力解法，需要优化。优化的办法有两种：<strong>带备忘录的递归解法（自顶向下），动态规划解法（自底向上）</strong></p>
<h3 id="带备忘录的递归优化"><a href="#带备忘录的递归优化" class="headerlink" title="带备忘录的递归优化"></a>带备忘录的递归优化</h3><p>一个斐波那契数列的暴力解法如下，画出递归树后发现了大量重复的子问题，因此导致时间复杂度很高（呈指数上升$O(2^n)$）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191014152151.png" alt="img" style="zoom: 50%;" />

<p>因此我们想到利用一个备忘录记载用过的子问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    <span class="comment">// 未被计算过</span></span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于递归的时候，<strong>先从左子树一路向下</strong>，因此通过备忘录就能实现剪枝：</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191014152447.png" alt="img" style="zoom:50%;" />

<p>如上图所示，直接把$2^n$的树形结构，剪成了nn的一维数组结构，大大减小了时间复杂度！</p>
<h3 id="动态规划优化"><a href="#动态规划优化" class="headerlink" title="动态规划优化"></a>动态规划优化</h3><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一个专门的容器，直接在这个容器中完成所有算法，这样时间和备忘录一样，但空间更节省。这就是<strong>自底向上</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-线性一维DP"><a href="#2-线性一维DP" class="headerlink" title="2. 线性一维DP"></a>2. 线性一维DP</h1><h2 id="005-最长回文子串"><a href="#005-最长回文子串" class="headerlink" title="005 最长回文子串"></a>005 最长回文子串</h2><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>这里的一维是指处理对象的维度，dp容器可以是二维的。解答思路很简单，如果<code>abba</code>是回文，则<code>bb</code>肯定是回文。</p>
<p>一定要写<code>l &lt;= length</code>，因为这里的<code>l</code>代表了回文的长度，如果<code>aaaa</code>则<code>l==length</code>。</p>
<p>这道题要维护两个重要变量，回文串起始位置<code>start</code>和长度<code>len</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length = s.size();</span><br><span class="line">    <span class="comment">//最后返回字符串，返回的记录方式是：位置(start)+长度（maxlen）</span></span><br><span class="line">    <span class="keyword">int</span> maxlength = <span class="number">1</span>, start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(length + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(length + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; length - <span class="number">1</span> &amp;&amp; s.at(i) == s.at(i + <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            start = i;</span><br><span class="line">            maxlength = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一定要写等于</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">3</span>; l &lt;= length; l++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= length - l; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s_start = i;</span><br><span class="line">            <span class="keyword">int</span> s_end = i + l - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dp[s_start + <span class="number">1</span>][s_end - <span class="number">1</span>] &amp;&amp; s.at(s_start) == s.at(s_end))</span><br><span class="line">            &#123;</span><br><span class="line">                dp[s_start][s_end] = <span class="literal">true</span>;</span><br><span class="line">                maxlength = l;</span><br><span class="line">                start = s_start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxlength &gt;= <span class="number">2</span>) <span class="keyword">return</span> s.substr(start, maxlength);</span><br><span class="line">    <span class="comment">//maxlength=1时，直接返回第一个字符（要写成串的形式）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s.substr(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="053-最大子序和"><a href="#053-最大子序和" class="headerlink" title="053 最大子序和"></a>053 最大子序和</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>最重要是写出转移方程<code>sum[i]=max(sum[i-1]+a[i],a[i]);</code>只要<code>a[i]</code>不是大，当前组就还有机会靠下一个<code>a[i+1]</code>翻盘。</p>
<p><code>std::max_element()</code>返回的是迭代器位置，所以还需要解引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(nums.size());</span><br><span class="line">    sum[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)</span><br><span class="line">        sum[i]=max(sum[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">    <span class="keyword">return</span> *max_element(sum.begin(), sum.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="091-解码方法"><a href="#091-解码方法" class="headerlink" title="091 解码方法"></a>091 解码方法</h2><p>一条包含字母 <code>A-Z</code> 的消息通过以下方式进行了编码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;226&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6)</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>这道题引入了转移条件：</p>
<ul>
<li>只要前一位不为0，就可以<code>dp[i]+=dp[i-1]</code> </li>
<li>只要前两位组合在[10,26]之间，就可以<code>dp[i]+=dp[i-2]</code></li>
</ul>
<p>要注意<code>dp[m]</code>不是表示s的下标，而是<strong>表示长度，表示第m位</strong>！<code>dp[0]=dp[1]=1</code>，<code>dp[0]</code>表示第0位（这是<strong>虚拟状态</strong>，有利于做题而已），<code>dp[1]</code>表示第1位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.size()+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>]= <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;s.size()+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i<span class="number">-1</span>]!=<span class="string">'0'</span>) dp[i]+=dp[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s.substr(i<span class="number">-2</span>,<span class="number">2</span>)&gt;=<span class="string">"10"</span>&amp;&amp;s.substr(i<span class="number">-2</span>,<span class="number">2</span>)&lt;<span class="string">"27"</span>) </span><br><span class="line">            dp[i]+=dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="096-不同的二叉搜索树"><a href="#096-不同的二叉搜索树" class="headerlink" title="096 不同的二叉搜索树"></a>096 不同的二叉搜索树</h2><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>和上一题一样，这里加一个<strong>虚拟状态</strong>！状态转移方程：<code>dp[i] += dp[left] * dp[right]</code>。<code>dp[num]</code>代表了<code>num</code>个节点能够组成多少个BST。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>]=dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num=<span class="number">2</span>;num&lt;=n;num++)<span class="comment">//有多少个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>;left&lt;num;left++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> right = num-left<span class="number">-1</span>;<span class="comment">//要分配一个为root</span></span><br><span class="line">            dp[num]+=dp[left]*dp[right];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121 买卖股票的最佳时机"></a>121 买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>维护两个变量<code>minPrice[i]</code>和<code>maxProfit[i]</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minprice(prices.size());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxprofit(prices.size());</span><br><span class="line">    <span class="keyword">if</span>(prices.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    minprice[<span class="number">0</span>]=prices[<span class="number">0</span>];</span><br><span class="line">    maxprofit[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        minprice[i]=min(prices[i],minprice[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">int</span> curprofit = prices[i]-minprice[i];</span><br><span class="line">        maxprofit[i]=max(curprofit,maxprofit[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit[prices.size()<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="122-买卖股票的最佳时机II"><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122 买卖股票的最佳时机II"></a>122 买卖股票的最佳时机II</h2><p>比上一道题目加了条件：多次买卖一支股票</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。</span><br><span class="line">    随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span><span class="number">-3</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>因为同一天又能买又能卖，所以转移方程<code>dp[i]=max(dp[i-1]+p[i]-p[i - 1],dp[i-1])</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(prices.size(),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++)</span><br><span class="line">        dp[i]=max(dp[i<span class="number">-1</span>],dp[i<span class="number">-1</span>]+prices[i]-prices[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[prices.size()<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="152-乘积最大子序列"><a href="#152-乘积最大子序列" class="headerlink" title="152 乘积最大子序列"></a>152 乘积最大子序列</h2><p>给定一个整数数组 <code>nums</code> ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>由于乘法的特殊性，两个转移变量，同时需要比较三个变量的最大最小。注意一下<code>maxvec</code>不是递增序列，需要返回一个最大值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxvec(nums.size());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minvec(nums.size());</span><br><span class="line">    maxvec[<span class="number">0</span>]=minvec[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxvec[i]=max3(maxvec[i<span class="number">-1</span>]*nums[i],nums[i],minvec[i<span class="number">-1</span>]*nums[i]);</span><br><span class="line">        minvec[i]=min3(minvec[i<span class="number">-1</span>]*nums[i],nums[i],maxvec[i<span class="number">-1</span>]*nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *max_element(maxvec.begin(),maxvec.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(a,max(b,c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min(a,min(b,c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198 打家劫舍"></a>198 打家劫舍</h2><p><strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>解答：</p>
<p>转移方程很简单<code>dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</code>，需要注意一下初始条件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(len);</span><br><span class="line">    dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>]=max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="213-打家劫舍II"><a href="#213-打家劫舍II" class="headerlink" title="213 打家劫舍II"></a>213 打家劫舍II</h2><p>这个地方所有的房屋都<strong>围成一圈</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>分类讨论，每次讨论时，前3个初始变量都需要考虑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp1(nums.size());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp2(nums.size());</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> *max_element(nums.begin(),nums.end());</span><br><span class="line">    <span class="comment">//偷第一家</span></span><br><span class="line">    dp1[<span class="number">0</span>]=dp1[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    dp1[<span class="number">2</span>]=nums[<span class="number">0</span>]+nums[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        dp1[i]=max(dp1[i<span class="number">-2</span>]+nums[i],dp1[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="comment">//不偷第一家</span></span><br><span class="line">    dp2[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp2[<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line">    dp2[<span class="number">2</span>]=max(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;n;i++)</span><br><span class="line">        dp2[i]=max(dp2[i<span class="number">-2</span>]+nums[i],dp2[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> max(*max_element(dp1.begin(),dp1.end()),</span><br><span class="line">               *max_element(dp2.begin(),dp2.end()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-矩形二维DP"><a href="#3-矩形二维DP" class="headerlink" title="3. 矩形二维DP"></a>3. 矩形二维DP</h1><h2 id="062-不同的路径"><a href="#062-不同的路径" class="headerlink" title="062 不同的路径"></a>062 不同的路径</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191220120733.png" style="zoom: 67%;" />

<p><strong>解答：</strong></p>
<p>转移方程<code>dp[i][j]=dp[i-1][j]+dp[i][j-1]</code>，注意边界的转移条件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>) dp[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="063-不同路径II"><a href="#063-不同路径II" class="headerlink" title="063 不同路径II"></a>063 不同路径II</h2><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><strong>解答：</strong></p>
<p>需要分类讨论。由于加了障碍物所以需要特别考虑边的情况，看看是否有东西堵住。需要注意：<strong>初始化要放到循环里面</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=obstacleGrid.size();</span><br><span class="line">    <span class="keyword">int</span> n=obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)</span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) dp[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j!=<span class="number">0</span>) dp[i][j]=dp[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>) dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="064-最小路径和"><a href="#064-最小路径和" class="headerlink" title="064 最小路径和"></a>064 最小路径和</h2><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>需要分类讨论。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.size();</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, &#123; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>) &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) dp[i][j]=grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j!=<span class="number">0</span>) dp[i][j]=dp[i][j<span class="number">-1</span>]+grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) dp[i][j]=dp[i<span class="number">-1</span>][j]+grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221 最大正方形"></a>221 最大正方形</h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>和前面的路径题非常相似，但需要比较3个中的最小者。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> M = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> N = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(M, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]!=<span class="string">'1'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>) dp[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],</span><br><span class="line">                          min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:dp)</span><br><span class="line">        res=max(res,*max_element(x.begin(),x.end()));</span><br><span class="line">    <span class="keyword">return</span> res*res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-三角形二维DP"><a href="#4-三角形二维DP" class="headerlink" title="4. 三角形二维DP"></a>4. 三角形二维DP</h1><h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118 杨辉三角"></a>118 杨辉三角</h2><p>给定一个非负整数 <em>numRows，*生成杨辉三角的前 *numRows</em> 行。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191220130341.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>两边要特别处理。每次需要resize一下，因为维度都不相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(numRows);</span><br><span class="line">    <span class="keyword">if</span>(numRows==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i].resize(i+<span class="number">1</span>); <span class="comment">//对dp[i]resize而不是dp</span></span><br><span class="line">        dp[i][<span class="number">0</span>]=dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++) <span class="comment">//i=0被直接跳过</span></span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="119-杨辉三角II"><a href="#119-杨辉三角II" class="headerlink" title="119 杨辉三角II"></a>119 杨辉三角II</h2><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>如果按照上一题的思路老实推的话，占用空间较大。这里选择原地修改的办法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(rowIndex +<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rowIndex == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    <span class="comment">//i代表第几行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowIndex; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp.resize(i + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//原地修改</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            dp[j] = dp[j] + dp[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120 三角形最小路径和"></a>120 三角形最小路径和</h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br><span class="line">自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>和前面的三角并没有什么不用，还是要注意两边，另外初始化的resize要特别注意。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rowSize = triangle.size();</span><br><span class="line">	<span class="keyword">if</span> (rowSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> colSize = triangle[<span class="number">0</span>].size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(rowSize);</span><br><span class="line">	dp[<span class="number">0</span>].resize(<span class="number">1</span>);<span class="comment">//没有这一句内存会出错</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rowSize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i].resize(i + <span class="number">1</span>);</span><br><span class="line">		dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];</span><br><span class="line">		dp[i][i] = dp[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">			dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + triangle[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *min_element(dp[rowSize - <span class="number">1</span>].begin(), dp[rowSize - <span class="number">1</span>].end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/19/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%933-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" data-id="ck4o2turh000mu4vycego5skb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode题目总结2-双指针" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/19/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%932-%E5%8F%8C%E6%8C%87%E9%92%88/" class="article-date">
  <time datetime="2019-12-19T13:13:27.000Z" itemprop="datePublished">2019-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/19/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%932-%E5%8F%8C%E6%8C%87%E9%92%88/">Leetcode题目总结2-双指针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-首尾双指针"><a href="#1-首尾双指针" class="headerlink" title="1. 首尾双指针"></a>1. 首尾双指针</h1><p>将两个指针分布在首尾，特别针对<strong>排序数组</strong>。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191013121537.png" alt="img"></p>
<h2 id="167-两数之和II-输入有序数组"><a href="#167-两数之和II-输入有序数组" class="headerlink" title="167 两数之和II-输入有序数组"></a>167 两数之和II-输入有序数组</h2><p>给定一个已按照<strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>这道题在二分法那一篇中已经讲过了，现在我们改为用双指针。注意：使用双指针之前一定<strong>要确保排序</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> l =<span class="number">0</span>,r=numbers.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[l]+numbers[r]==target)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;l+<span class="number">1</span>,r+<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[l]+numbers[r]&lt;target)</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            r--;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="015-三数之和"><a href="#015-三数之和" class="headerlink" title="015 三数之和"></a>015 三数之和</h2><p>给定一个包含 n 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如, 给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>这道题不太一样，它需要收集所有的可能结果，并且要排除重复结果。而且要<strong>注意它本身无序，所以要排序</strong>。</p>
<p>最简单的办法是利用<code>std::set</code>的去重特性来做，不要忘了<code>if(nums[i]+nums[l]+nums[r]==0)</code>也要做<code>l++</code>和<code>r--</code>，否则会死循环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    sort(nums.begin(),nums.end());</span><br><span class="line">    <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l=i+<span class="number">1</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[l]+nums[r]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp=&#123;nums[i],nums[l],nums[r]&#125;;</span><br><span class="line">                s.insert(tmp);</span><br><span class="line">                l++;r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[l]+nums[r]&lt;<span class="number">0</span>) l++;</span><br><span class="line">            <span class="keyword">else</span>  r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:s)</span><br><span class="line">        res.push_back(x);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种办法慢得离谱，酌情使用。常规做法是去重。要注意对i去重是<strong>用过了再去</strong>，因为可能出现<code>[-1,-1,2]</code>这种情况，如果按照<code>if(nums[i] == nums[i + 1]) continue;</code>就会导致结果不全。</p>
<p>对<code>l</code>和<code>r</code>去重时要注意，<code>l++</code>和<code>r--</code><strong>用两次</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对i去重</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = i + <span class="number">1</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span> - nums[i];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] + nums[r] == sum)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[l], nums[r]&#125;);</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) l++;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) r--;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] + nums[r] &lt; sum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) l++;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) r--;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="016-最接近的三数之和"><a href="#016-最接近的三数之和" class="headerlink" title="016 最接近的三数之和"></a>016 最接近的三数之和</h2><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如，给定数组 nums &#x3D; [-1，2，1，-4], 和 target &#x3D; 1.</span><br><span class="line">与 target 最接近的三个数的和为2. (-1 + 2 + 1 &#x3D; 2).</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>相较于上一题，不用去除重复。需要加一个<code>closest</code>，表示最接近的数。每次循环都比较<strong>更新维护</strong>这个数。要注意<code>closet</code>不能设为<code>INT_MAX</code>，后面可能会溢出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sort(nums.begin(),nums.end());</span><br><span class="line">    <span class="keyword">int</span> closet = accumulate(nums.begin(),nums.begin()+<span class="number">3</span>,<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-2</span>;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l=i+<span class="number">1</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum=nums[l]+nums[r]+nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum==target) <span class="keyword">return</span> sum;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(sum-target)&lt;<span class="built_in">abs</span>(closet-target))</span><br><span class="line">                closet=sum;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target) l++;</span><br><span class="line">            <span class="keyword">else</span> r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> closet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="018-四数之和"><a href="#018-四数之和" class="headerlink" title="018 四数之和"></a>018 四数之和</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。</span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>更015一样，多一层即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()&lt;<span class="number">4</span>) <span class="keyword">return</span> res;</span><br><span class="line">    sort(nums.begin(),nums.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.size()<span class="number">-2</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j!=i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> l=j+<span class="number">1</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> sum12=nums[i]+nums[j];</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum34=nums[l]+nums[r];</span><br><span class="line">                <span class="keyword">if</span>(sum12+sum34==target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp&#123;nums[i],nums[j],nums[l],nums[r]&#125;;</span><br><span class="line">                    res.push_back(tmp);</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]==nums[l+<span class="number">1</span>]) l++;</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r]==nums[r<span class="number">-1</span>]) r--;</span><br><span class="line">                    l++;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum12+sum34&lt;target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]==nums[l+<span class="number">1</span>]) l++;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) r--;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="011-乘最多水的容器"><a href="#011-乘最多水的容器" class="headerlink" title="011 乘最多水的容器"></a>011 乘最多水的容器</h2><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20191013201120.png" alt="img" style="zoom:50%;" />

<p><strong>解答：</strong></p>
<p>面积=最短边*距离，要提高面积就有两种办法：增大最短边，保持长距离。让两边较小者往内移动，这样最有可能找到最大面积。同时，我们需要维护一个<code>maxarea</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=height.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxarea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> area = min(height[l],height[r])*(r-l);</span><br><span class="line">        maxarea=max(maxarea,area);</span><br><span class="line">        <span class="keyword">if</span>(height[l]&lt;height[r]) l++;</span><br><span class="line">        <span class="keyword">else</span> r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxarea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="075-颜色分类"><a href="#075-颜色分类" class="headerlink" title="075 颜色分类"></a>075 颜色分类</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>典型的快排。采用了三指针，<strong>两个放首尾，<code>index</code>放中间</strong>。要保证<code>index</code>以前的都是有序的，我们构建两个标志<code>zerotail</code>和<code>twohead</code>分别表示<strong>最后一个0的下一个和第一个2的前一个</strong>，比如<code>[0,1,1,2]</code>，<code>zerotail=1</code>，<code>twohead=2</code>。</p>
<p>注意：当<code>nums[index] == 2</code>交换时，<code>index</code><strong>不能盲目前进</strong>，因为不知道被换过来的是1还是2，需要放到下一轮进行检验。（由于我们保证了index以前都是有序的，所以和0做交换是安全的）</p>
<p>注意：去重时，必须要判断<code>twohead &gt;= 0</code>和<code>zerotail &lt; nums.size()</code>，不然会溢出。比如<code>[2]</code>，使得<code>twohead=-1</code>，下一次while就会导致<code>nums[twohead]</code>溢出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> zerotail = <span class="number">0</span>, twohead = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (zerotail &lt; nums.size() &amp;&amp; nums[zerotail] == <span class="number">0</span>) zerotail++;</span><br><span class="line">    <span class="keyword">while</span> (twohead &gt;= <span class="number">0</span> &amp;&amp; nums[twohead] == <span class="number">2</span>) twohead--;</span><br><span class="line">    <span class="keyword">int</span> index = zerotail;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= twohead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">std</span>::swap(nums[zerotail++], nums[index++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">std</span>::swap(nums[twohead--], nums[index]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-同向双指针"><a href="#2-同向双指针" class="headerlink" title="2. 同向双指针"></a>2. 同向双指针</h1><p>也可以称为<strong>滑动窗口法</strong>，使用滑动窗口时考虑三个问题：初始化窗口范围、终止条件、移动条件。</p>
<h2 id="003-无重复字符的最长子串"><a href="#003-无重复字符的最长子串" class="headerlink" title="003 无重复字符的最长子串"></a>003 无重复字符的最长子串</h2><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>利用双指针<code>l</code>和<code>r</code>维护一个set，遇到不一样的就加进来，遇到一样的删尾巴。起始条件<code>r=l=0</code>，终止条件<code>r==s.size()</code></p>
<p>当遇到重复时，并没有将前面的全部擦除，而是一个一个擦，这样很慢，但set没办法，它的迭代器不支持加减运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; cache;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxlen=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r&lt;s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.find(s[r])==cache.end())</span><br><span class="line">        &#123;</span><br><span class="line">            cache.insert(s[r++]);</span><br><span class="line">            maxlen=max(maxlen,r-l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cache.erase(s[l++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209 长度最小的子数组"></a>209 长度最小的子数组</h2><p>给定一个含有 <strong>n</strong> 个正整数的数组和一个正整数 <strong>s ，</strong>找出该数组中满足其和 <strong>≥ s</strong> 的长度最小的连续子数组<strong>。</strong>如果不存在符合条件的连续子数组，返回 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>注意右边的边界，一定要加双判断，不然要越界。是<code>while (sum &lt; s &amp;&amp; right &lt; len)</code>不是if，所以可能会月结，不要搞晕了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>, len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (sum &lt; s &amp;&amp; right &lt; len)</span><br><span class="line">            sum += nums[right++];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, right - left);</span><br><span class="line">            sum -= nums[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-其他双指针"><a href="#3-其他双指针" class="headerlink" title="3. 其他双指针"></a>3. 其他双指针</h1><h2 id="028-实现strStr"><a href="#028-实现strStr" class="headerlink" title="028 实现strStr()"></a>028 实现strStr()</h2><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>这道题本质上应该用KMP算法，但一道easy级别的题目这么搞显然不合理。所以就用笨一点的分离双指针遍历好了。</p>
<p>两个指针，一个负责<code>haystack</code>搜索，找到合适的起始位置后，另一个也启动在<code>needle</code>和<code>haystack</code>一起搜索。</p>
<p>为空时，返回0，为了和C语言以及java中的API相对应。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle == <span class="string">""</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; haystack.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] != needle[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; needle.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i + j] != needle[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.size()) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="088-合并两个有序数组"><a href="#088-合并两个有序数组" class="headerlink" title="088 合并两个有序数组"></a>088 合并两个有序数组</h2><p>给定两个有序整数数组 <em>nums1</em> 和 <em>nums2*，将 *nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使得 <em>num1</em> 成为一个有序数组。初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>从后往前遍历，维护三个指针：<code>i</code>负责<code>nums1</code>的有效位置，<code>j</code>负责<code>nums2</code>，<code>index</code>负责插入位置。</p>
<p>i和j必须要双检查，防止越界。最后要<strong>把剩余的j补上去。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=m<span class="number">-1</span>,j=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> len=nums1.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i]&gt;nums2[j])</span><br><span class="line">            nums1[len--]=nums1[i--];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums1[len--]=nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span>) nums1[len--]=nums2[j--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/19/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%932-%E5%8F%8C%E6%8C%87%E9%92%88/" data-id="ck4o2turj000ou4vyc2rw1fun" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode题目总结1-二分法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/19/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%931-%E4%BA%8C%E5%88%86%E6%B3%95/" class="article-date">
  <time datetime="2019-12-19T09:56:17.000Z" itemprop="datePublished">2019-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/19/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%931-%E4%BA%8C%E5%88%86%E6%B3%95/">Leetcode题目总结1-二分法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-二分法的解决思路"><a href="#1-二分法的解决思路" class="headerlink" title="1. 二分法的解决思路"></a>1. 二分法的解决思路</h1><p>二分法看似简单，实际上有很多问题都比较麻烦，比如：mid取整方式，区间开闭，序列是否有重复元素，会不会越界，会不会死循环······ 在网上参考了许多前辈的写法，各有优劣，但始终不是特别满意。这里主要参照知乎用户<a href="https://www.zhihu.com/people/lightghli" target="_blank" rel="noopener">LightGHLi</a>的写法，算是比较清楚覆盖面比较好的写法。</p>
<p>从问题上说二分查找分三大类：<strong>无重复序列找具体值</strong>，<strong>无重复序列找上下界</strong>，<strong>有重复序列找上下界</strong>。将他们归为四类模板，皆针对<strong>不下降序列</strong>（有重复无重复都可以）。</p>
<p>看起来很复杂，其实记忆方法很简单：</p>
<table>
<thead>
<tr>
<th align="center">情况</th>
<th align="center">条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">求最小的i</td>
<td align="center">mid向下取整，l快r缓，返回r，if(nums[mid] &lt; target) l=mid+1</td>
</tr>
<tr>
<td align="center">求最大的i</td>
<td align="center">mid向上取整，r快l缓，返回l，if(nums[mid] &gt; target) r=mid-1</td>
</tr>
</tbody></table>
<p>取整方式有两种：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid =(l+r) / <span class="number">2</span>; <span class="comment">//向下取整</span></span><br><span class="line"><span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)/<span class="number">2</span>;  <span class="comment">//向上取整</span></span><br></pre></td></tr></table></figure>

<p>快慢方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid]&lt;target) l=mid+<span class="number">1</span>; <span class="comment">//L快</span></span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(nums[mid]&gt;target) r=mid<span class="number">-1</span>; <span class="comment">//R快</span></span><br><span class="line"><span class="keyword">else</span> l=mid;</span><br></pre></td></tr></table></figure>

<p><strong>要注意这种方式必须先判断<code>nums</code>是否为空，否则会越界！return的部分要写在while外面！</strong></p>
<p>如果遇到不是精确的目标数的时候(<code>a[i]&lt;target</code>)，将return处改为大于或小于即可。</p>
<p><strong>下面看一下实例展示：</strong></p>
<p><strong>(1)求最小的i，使得a[i] = key，若不存在，则返回-1</strong>（下界）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l =<span class="number">0</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]&lt;key) l=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[l]==key) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>(2)求最大的i，使得a[i] = key，若不存在，则返回-1</strong>（上界）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]&gt;key) r=mid<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> l=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[l]==target) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>注意：下面这两种需要先判断边界，所谓的i只是指插入位置而已。</p>
<p><strong>(3)求最小的i，使得a[i] &gt; key，若不存在，则返回-1</strong>（上界）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(key&gt;nums[r]) <span class="keyword">return</span> r+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(key&lt;nums[l]) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]&lt;key) l=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[r]&gt;key) <span class="keyword">return</span> r;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>(4)求最大的i，使得a[i] &lt; key，若不存在，则返回-1</strong>（下界）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(key&gt;nums[r]) <span class="keyword">return</span> r;</span><br><span class="line"><span class="keyword">if</span>(key&lt;nums[l]) <span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]&gt;=target) r=mid<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> l=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[l]&lt;target) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<h1 id="2-寻找具体值"><a href="#2-寻找具体值" class="headerlink" title="2. 寻找具体值"></a>2. 寻找具体值</h1><h2 id="033-搜索旋转排序数组"><a href="#033-搜索旋转排序数组" class="headerlink" title="033 搜索旋转排序数组"></a>033 搜索旋转排序数组</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code>，搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。你可以假设数组中<strong>不存在重复</strong>的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>基本模板是：最小i等于key。需要特别注意<code>if(nums[mid]&lt;target&amp;&amp;target&lt;=nums[r])</code><strong>只有一个等</strong>，请参考模板<code>if(nums[mid]&lt;key) l=mid+1;</code>这里也是没取等的，一定要注意！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;nums[r])<span class="comment">//mid右边是有序的</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//target在mid和r之间，只有一个等</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target&amp;&amp;target&lt;=nums[r])</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=mid;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//mid左边是有序的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//target在l和mid之间，有两个等</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l]&lt;=target&amp;&amp;target&lt;=nums[mid])</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[r]==target) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="081-搜索旋转排序数组二"><a href="#081-搜索旋转排序数组二" class="headerlink" title="081 搜索旋转排序数组二"></a>081 搜索旋转排序数组二</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 <code>[0,0,1,2,2,5,6]</code> 可能变为 <code>[2,5,6,0,0,1,2]</code> )。编写一个函数来判断给定的目标值是否存在于数组中。<strong>存在重复元素</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>假设<code>nums=[4,5,6,3,3,3,3]</code>，<code>target=4</code>输入，可知mid为3，r也为3，又因为我们判断<code>if(nums[mid]&lt;nums[r])</code>，所以认为左边是有序的，但<code>[4,5,6,3]</code>并不有序，所以结果错误，如果我们改为<code>if(nums[mid]&lt;=nums[r])</code>就能正常输出。但如果输入数组变成<code>nums=[4,4,4,4,1,2,3]</code>则我们的改动又会出错。</p>
<p>所以，为了防止上述情况的出现，我们要<strong>斩掉两边重复的数字</strong>！我们只是去掉<strong>多余</strong>的重复，所以不需要斩尽杀绝，采用<code>if(n[i]==n[i+1]) i++;</code>而不是<code>if(n[i]=n[i-1]) i++;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]==nums[l+<span class="number">1</span>]) l++;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r]==nums[r<span class="number">-1</span>]) r--;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;nums[r])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target&amp;&amp;target&lt;=nums[r])</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]&lt;=target&amp;&amp;target&lt;=nums[mid])</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[r]==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="074-搜索二维矩阵"><a href="#074-搜索二维矩阵" class="headerlink" title="074 搜索二维矩阵"></a>074 搜索二维矩阵</h2><p>判断 <em>m</em> x <em>n</em> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">matrix &#x3D; [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target &#x3D; 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>||matrix[<span class="number">0</span>].size()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res=search(matrix[i],target,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(res!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="keyword">int</span> target,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;target) l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[r]==target) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="167-两数和—输入有序数组"><a href="#167-两数和—输入有序数组" class="headerlink" title="167 两数和—输入有序数组"></a>167 两数和—输入有序数组</h2><p>给定一个已按照<strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>要注意这道题<code>l=i+1</code>而不是<code>l=i</code>，另外返回<code>vector&lt;int&gt;{i+1,r+1};</code>才符合题目要求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(target&lt;numbers[<span class="number">0</span>]) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> key = target-numbers[i];</span><br><span class="line">        <span class="keyword">int</span> l=i+<span class="number">1</span>,r=numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid]&lt;key) l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(numbers[r]==key) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i+<span class="number">1</span>,r+<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-返回某个位置"><a href="#2-返回某个位置" class="headerlink" title="2. 返回某个位置"></a>2. 返回某个位置</h1><h2 id="034-在排序数组中查找元素的第一和最后一个位置"><a href="#034-在排序数组中查找元素的第一和最后一个位置" class="headerlink" title="034 在排序数组中查找元素的第一和最后一个位置"></a>034 在排序数组中查找元素的第一和最后一个位置</h2><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>注意最后那里，不能写成if-else，否则会报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res&#123; <span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty())</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//search the min i</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[r] == target) res[<span class="number">0</span>] = r;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//search the max i (Notice: reset l and r)</span></span><br><span class="line">    l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[l] == target) res[<span class="number">1</span>] = l;</span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">//不能写为if-else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="035-搜索插入位置"><a href="#035-搜索插入位置" class="headerlink" title="035 搜索插入位置"></a>035 搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>翻译过来就是：找到最小的i，使得a[i] &gt;= key。这种类型需要改动最后return的判断，以及之前需要加上边界判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[r]&lt;target) <span class="keyword">return</span> r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[l]&gt;target) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;target) l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[r]&gt;=target) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="069-X的平方根"><a href="#069-X的平方根" class="headerlink" title="069 X的平方根"></a>069 X的平方根</h2><p>实现 <code>int sqrt(int x)</code> 函数。计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>需要变通一下：将<code>x</code>视为<code>target</code>，将<code>mid*mid</code>视为<code>nums[mid]</code>。这样就变为了：找最大的i使得的<code>a[i]&lt;key</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l=<span class="number">0</span>,r=<span class="number">4396777</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> mid=(l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid&gt;x) r=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l*l&lt;=x) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-未知具体值"><a href="#3-未知具体值" class="headerlink" title="3. 未知具体值"></a>3. 未知具体值</h1><h2 id="153-寻找旋转数组最小值"><a href="#153-寻找旋转数组最小值" class="headerlink" title="153 寻找旋转数组最小值"></a>153 寻找旋转数组最小值</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。找到那个旋转点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>基本思路就是如果<code>nums[mid] &gt; nums[r]</code>则最小值在右边，<code>l</code>往上提，反之<code>r</code>往下拉。由于预设的是所以<code>l=mid+1</code>，最后返回<code>r</code>（其实最后<code>l==r</code>，返回哪一个都一样）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) /<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//assume that </span></span><br><span class="line">        <span class="comment">//there is no dumplicated elements</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[r])</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            r = mid ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162 寻找峰值"></a>162 寻找峰值</h2><p>峰值元素是指其值大于左右相邻值的元素。给定一个输入数组 <code>nums</code>，其中 <code>nums[i] != nums[i+1]</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 3 是峰值元素，你的函数应该返回其索引 2。</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">输出: 1 或 5 </span><br><span class="line">解释: 你的函数可以返回索引 1，其峰值元素为 2；</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果mid&lt;mid+1，峰肯定在右边</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>])</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/19/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%931-%E4%BA%8C%E5%88%86%E6%B3%95/" data-id="ck4o2turf000ju4vycxdqbjpt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ROS基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/18/ROS%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2019-12-18T15:41:30.000Z" itemprop="datePublished">2019-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/18/ROS%E5%9F%BA%E7%A1%80/">ROS基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>结合Tutorial.pdf观看</p>
<p>ROS是一个适用于机器人编程的框架，这个框架把原本松散的零部件耦合在了一起，为他们提供通信架构，相当于应用程序之间的沟通桥梁。</p>
<p>ROS采用了分布式的框架，通过点对点的设计让机器人的进程可以分别运行。</p>
<blockquote>
<p>分布式：将不同功能数据放到不同模块，将相同数据放到不同服务器，他们之间依靠通信网络沟通。</p>
</blockquote>
<h1 id="1-ROS文件系统"><a href="#1-ROS文件系统" class="headerlink" title="1. ROS文件系统"></a>1. ROS文件系统</h1><h2 id="1-1-Catkin编译"><a href="#1-1-Catkin编译" class="headerlink" title="1.1 Catkin编译"></a>1.1 Catkin编译</h2><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909094836.png" alt="img" style="zoom:80%;" />

<p>Catkin是基于CMake的编译构建系统，具有以下特点：</p>
<ul>
<li>Catkin沿用了包管理的传统像<code>find_package()</code>基础结构</li>
<li>扩展了CMake，例如：软件包编译后无需安装就可使用；自动生成 <code>find_package()</code>代码，<code>pkg-config</code>文件；解决了多个软件包构建顺序问题。</li>
</ul>
<p>一个Catkin的软件包（package）必须要包括两个文件：</p>
<ul>
<li><code>package.xml</code>:包括了package的描述信息</li>
<li><code>CMakeLists.txt</code>:构建package所需的CMake文件</li>
</ul>
<p>Catkin工作流程如下：</p>
<ol>
<li>首先在工作空间<code>catkin_ws/src/</code>下递归的查找其中每一个ROS的package。</li>
<li>package中会有<code>package.xml</code>和<code>CMakeLists.txt</code>文件，Catkin(CMake)编译系统 据<code>CMakeLists.txt</code>文件,从而生成makefiles(放在<code>catkin_ws/build/</code>)。</li>
<li>然后make刚刚生成的makefiles等文件，编译链接生成可执行文件(放在<code>catkin_ws/devel</code>)。</li>
</ol>
<p>可以看到，Catkin就是将<code>cmake</code>与<code>make</code>指令做了一个封装从而完成整个编译过程的工具。</p>
<p>实际的使用过程如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd    ~/catkin_ws    #回到工作空间,catkin_make必须在工作空间下执行</span><br><span class="line">sudo catkin_make                #开始编译 </span><br><span class="line">source    ~/catkin_ws/devel/setup.bash    #刷新坏</span><br></pre></td></tr></table></figure>

<p>注意：catkin编译之前必须要回到工作空间目录(work station)，在其他路径下编译不会成功；如果有新的目标文件产生，那么需要刷新环境，是的系统1.2 Package软件包够遭到刚才编译生成的ROS可执行文件。</p>
<p>package是ROS的基本编译单元，任何ROS程序只有组织成package才能编译，所以package也是ROS源代码存放的地方。一个package可以编译出来多个目标文件（ROS可执行程序、动态静态库、头文件等等）。</p>
<p>一个package下常见的文件、路径有：</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909100930.png" alt="img" style="zoom:50%;" />

<p>其中定义package的是CMakeLists.txt和package.xml，这两个文件是package中必不可少的。catkin编译系统在编译前，首先就要解析这两个文件，这两个文件就定义了一个package。</p>
<p>创建package需要在工作空间目录<code>catkin_ws/src</code>，使用<code>catkin_create_pkg</code>命令，用法是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> catkin_create_pkg    package    depends</span></span><br></pre></td></tr></table></figure>

<p>其中package是包名，depends是依赖的包名，可以依赖多个软件包。</p>
<p>例如，新建一个package叫做<code>test_pkg</code>,依赖roscpp、rospy、std_msgs(常用依赖)。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> catkin_create_pkg    test_pkg    roscpp    rospy    std_msgs</span></span><br></pre></td></tr></table></figure>

<p>这样就会在当前路径下新建test_pkg软件包，包括：</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909102134.png" alt="img" style="zoom: 67%;" />

<p><code>catkin_create_pkg</code>帮你完成了软件包的初始化，填充好了<code>CMakeLists.txt</code>和<code>package.xml</code>，并且将依赖项填进了这两个文件中。需要注意的是，需要刷新文件才能找到。</p>
<h2 id="1-3-CMakeList写法"><a href="#1-3-CMakeList写法" class="headerlink" title="1.3 CMakeList写法"></a>1.3 CMakeList写法</h2><p>思路是：这个package的依赖是什么？要生成哪些目标？如何编译？</p>
<p>以turtlesim小海龟这个pacakge为例，可<code>roscd</code>到<code>tuetlesim</code>包下查看，在 <code>turtlesim/CMakeLists.txt</code></p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909105742.png" alt="img" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS ...)</span><br></pre></td></tr></table></figure>

<p>项目依赖的其他软件包，都会自动成为catkin的组件（components）（就CMake而言）。因此可以将这些依赖包指定为catkin的组件，而不必再使用<code>find_package</code>，这样将会变得简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include_directories(include $&#123;catkin_INCLUDE_DIRS&#125; $&#123;Boost_INCLUDE_DIRS&#125;)</span><br></pre></td></tr></table></figure>

<p>头文件地址，配合后面的link链接过程，参数由上一步<code>find_package</code>生成（省略了Boost的find过程）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_message_files(DIRECTORY msg FILES Color.msg Pose.msg)</span><br></pre></td></tr></table></figure>

<p>在被ROS软件包编译和使用之前，ROS中的消息（.msg）、服务（.srv）和操作（.action）文件需要特殊的预处理器编译步骤。这些宏的要点是生成编程语言特定的文件，以便可以在编程语言中使用消息、服务和操作。编译系统将使用所有可用的生成器（例如gencpp、genpy、genlisp）生成绑定。</p>
<p>提供了三个宏来分别处理消息，服务和操作：</p>
<ul>
<li>add_message_files</li>
<li>add_service_files</li>
<li>add_action_files</li>
</ul>
<p>这些宏后面必须调用一个调用生成的宏<code>generate_messages()</code>（不是message专有，通用，只写一次）</p>
<p>示例的命令，是从目标文件的msg子文件下面，添加文件名(FILES) <code>Color.msg</code>和<code>Pose.msg</code>的消息。服务也是同理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_package(CATKIN_DEPENDS geometry_msgs message_runtime std_msgs std_srvs)</span><br></pre></td></tr></table></figure>

<p>catkin_package() 是catkin支持的 CMake 宏指令。用来向编译系统指明 catkin-specific 的信息，而编译系统来生成 pkg-config和CMake files。<strong>必须放在消息、服务和操作之后，链接执行之前</strong>。</p>
<p>该函数有5个参数，这里只用了<code>CATKIN_DEPENDS</code>这一个，在之前的<code>find_package</code>中就已经找到了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_executable(turtlesim_node $&#123;turtlesim_node_SRCS&#125; $&#123;turtlesim_node_MOCS&#125;)</span><br></pre></td></tr></table></figure>

<p>作用是添加一个可执行文件构建目标，可执行文件名字叫做<code>turtlesim_node</code>，源代码由<code>set(turtlesim_node_SRCS ...)</code>设置；mocs是QT相关<code>qt5_wrap_cpp(turtlesim_node_MOCS ${turtlesim_node_HDRS})</code></p>
<p>后面的<code>target_link_libraries</code>则是将node和widgets与之前find的catkin和boost相链接；然后再为node添加依赖<code>turtlesim_gencpp</code></p>
<h1 id="2-ROS通信架构"><a href="#2-ROS通信架构" class="headerlink" title="2. ROS通信架构"></a>2. ROS通信架构</h1><p>ROS的通信方式有以下四种：</p>
<ul>
<li>Topic 主题</li>
<li>Service 服务</li>
<li>Parameter Service 参数服务器</li>
<li>Actionlib 动作库</li>
</ul>
<h2 id="2-1-Node-amp-Master"><a href="#2-1-Node-amp-Master" class="headerlink" title="2.1 Node &amp; Master"></a>2.1 Node &amp; Master</h2><p>在Ros中最小的进程单元是节点(Node)，一个软件包里可以有多个可执行文件，可执行文件在运行之后就成了一个<strong>进程</strong>(process)，这个进程在ROS中就叫做<strong>节点</strong>。从程序的角度来说，node是一个<strong>可执行文件</strong>；从功能角度来说，一个node负责某一个<strong>单独的功能</strong>。</p>
<p>Master是<strong>节点管理器</strong>，由于实际情况中node数量众多，需要一个管理器在整个网络通信架构里管理各种node。node首先在master处进行注册，之后master会将该node纳入整个ROS程序中。 node之间的通信也是先由master进行“牵线”，才能两两的进行点对点通信。当ROS程序启动 时，第一步<strong>首先启动master</strong>，由节点管理器处理依次启动node。</p>
<p>当我们要启动ROS时，输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> roscore</span></span><br></pre></td></tr></table></figure>

<p>此时会启动三个功能：<code>ROS master</code>，<code>rosout</code>，<code>parameter server</code>。这其中<code>rosout</code>负责日志输出的一个节点，其作用是告知用户当前系统的状态，包括输出系统的error、warning等 ，并且将log记录于日志文件中。<code>parameter server</code>是参数服务器，它并不是一个node， 而是存储参数配置的一个服务器。</p>
<p>启动master以后，节点管理器就开始按照系统的安排协调进行启动具体的节点，具体启动node的语句是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">    rosrun    pkg_name    node_name</span></span><br></pre></td></tr></table></figure>

<p><code>rosrun</code>将会寻找<code>pkg_name</code>下的名为<code>node_name</code>的可执行程序。</p>
<p><strong>rosnode</strong>的常用命令如下：</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909133157.png" alt="img" style="zoom:67%;" />

<h2 id="2-2-launch文件"><a href="#2-2-launch文件" class="headerlink" title="2.2 launch文件"></a>2.2 launch文件</h2><p>通常运行一个机器人系统我们需要启动<strong>多个node</strong>，为了方便我们用<strong>launch</strong>的方式来统一启动，命令是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">    roslaunch    pkg_name    file_name.launch</span></span><br></pre></td></tr></table></figure>

<p><code>roslaunch</code>命令首先会自动进行检测系统的<code>roscore</code>有没有运行，也即是确认节点管理器是否在运行状态中，如果<code>master</code>没有启动，那么<code>roslaunch</code>就会首先启动<code>master</code>，然后再按照<code>launch</code>的规则执行。</p>
<p><code>launch</code>文件里已经配置好了启动的规则。所以<code>roslaunch</code>就像是一个启动工 具，减少我们在终端中一条条输入指令的麻烦。</p>
<h2 id="2-3-Topic"><a href="#2-3-Topic" class="headerlink" title="2.3 Topic"></a>2.3 Topic</h2><p>对于<strong>实时性、周期性</strong>的消息，使用topic来传输是最佳的选择。topic是一种<strong>点对点的单向通信方式</strong>，这里的“点”指的是node，也就是说node之 间可以通过topic方式来传递信息。</p>
<p>topic的步骤是：</p>
<ol>
<li>publisher节点和subscriber节点到节点管理器进行注册</li>
<li>publisher发布topic</li>
<li>subscriber在master的指挥下订阅该topic</li>
</ol>
<p>Subscriber接收消息会进行处理，一般这个过程叫做<strong>回调(Callback)</strong>。所谓回调就是提前定义好了一个处理函数（写在代码中），当有消息来就会触发这个处理函数，函数会对消息进行处理。</p>
<p>topic通信的特点是：</p>
<ol>
<li>异步通信。发送时调用publish()方法，发送完成立即返回，不用等待反 馈。</li>
<li>subscriber通过回调函数的方式来处理消息</li>
<li>topic可以同时有多个subscribers，也可以同时有多个publishers</li>
</ol>
<p><strong>Msg</strong></p>
<p>topic有很严格的格式要求，比如摄像头拍摄的rgb图像topic，就必然要遵循ROS中 义好的rgb图像格式，这种<strong>数据格式</strong>就是Message。Message按照定义解释就是topic内容的数据类型，也称之为topic的格式标准，这里和我们平常用到的Massage直观概念有所不同。</p>
<p>基本的msg包括bool、int8、int16、int32等等常用的数据类型，但实际情况中，我们需要重新封装，比如image类型：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std_msg/Header    header                </span><br><span class="line">    uint32                seq                </span><br><span class="line">    time                stamp                </span><br><span class="line">    string                frame_id </span><br><span class="line">uint32                height </span><br><span class="line">uint32                width </span><br><span class="line">string                encoding </span><br><span class="line">uint8                is_bigendian </span><br><span class="line">uint32                step </span><br><span class="line">uint8[]                data</span><br></pre></td></tr></table></figure>

<p>这种结构类似于C语言结构体，我们可以将msg进一步理解为一个<strong>类</strong>，我们每次发布的内容可以理解为<strong>实例化的对象</strong>。</p>
<p>ROS中往往针对不同的传感器、导航系统封装好了许多msg。</p>
<h2 id="2-4-Service"><a href="#2-4-Service" class="headerlink" title="2.4 Service"></a>2.4 Service</h2><p>道topic是ROS中的一种单向的异步通信方式。然而有些时候<strong>单向的通信满足不了通信要求</strong>，比如当一些节点只是临时而 非周期性的需要某些数据，如果用topic通信方式时就会消耗大量不必要的系统资源，造成系统的低效率高功耗。</p>
<p>这种情况下，就需要有另外一种<strong>请求-查询式</strong>的通信模型。这节我们来介绍ROS通信中的另一 种通信方式——service(服务)。</p>
<p>步骤是：</p>
<ol>
<li>请求方（Client）就会发送一个request，阻塞等待。</li>
<li>server处理，反馈回一个reply。</li>
</ol>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909140438.png" alt="img" style="zoom:67%;" />

<p>NodeB是server（应答方），提供了一个服务的接口，叫做/Service，通过这个接口和Clinet通信。</p>
<p>Service是同步通信方式，所谓同步就是说，此时NodeA发布请求后会在原地等待reply，直到 NodeB处理完了请求并且完成了reply，NodeA才会继续执行。这样避免了频繁的消息传递。</p>
<p><strong>Srv</strong></p>
<p>类似msg文件，srv文件是用来描述service数据类型的, service通信的数据格式定义在 <code>*.srv</code>中</p>
<p>举个例子<code>msgs_demo/srv/DetectHuman.srv</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span>    start_detect </span><br><span class="line">---</span><br><span class="line">my_pkg/HumanPose[]    pose_data</span><br></pre></td></tr></table></figure>

<p>该服务例子取自OpenNI的人体检测ROS软件包。它是用来查 询当前深度摄像头中的人体姿态和关节数的。第一行是请求格式，中间用—-隔开，第三行是应答格式。在本例中，请求为是否开始检测，应答为一个数组，数组的每个元素为某个人的姿态。而对于人的姿态<code>HumanPose</code>，其实是一个msg，如下。所以srv<strong>可以嵌套msg在其中</strong>，但它不能嵌套srv。</p>
<p><code>msgs_demo/msg/HumanPose.msg</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header    header </span><br><span class="line">string    uuid </span><br><span class="line">int32    number_of_joints </span><br><span class="line">my_pkg/JointPose[]    joint_data</span><br></pre></td></tr></table></figure>

<h2 id="2-5-Parameter-server"><a href="#2-5-Parameter-server" class="headerlink" title="2.5 Parameter server"></a>2.5 Parameter server</h2><p>除了前文介绍的主题和服务这两种通信方式，另一种特殊的通信方式是参数服务器。于参数服务器是节点存储参数的地方、用于配置参数，全局共享参数。参数服务器使用互联网传输，在节点管理器中运行，实现整个通信过程。参数服务器维护着一个<strong>数据字典</strong>，字典里存储着各种参数和配置。</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909141757.png" alt="img"></p>
<p><strong>每一个key不重复，且每一个key对应着一个value</strong>，这就是字典的映射关系。，我们往往将一些不常用到的参数和配置放入参数服务器里的字典里，这样对这些数据进行读写都将方便高效。</p>
<h2 id="2-6-Action"><a href="#2-6-Action" class="headerlink" title="2.6 Action"></a>2.6 Action</h2><p>Action是对service的一个改进，适合于<strong>长时间通信</strong>。假如利用service通信方式，那么publisher会很长时间接受不到反馈的reply，会致使通信受阻。actionlib通信过程可以<strong>随时被查看过程进度，也可以终止请求</strong>，使得 在一些特别的机制中拥有很高的效率。</p>
<p>通信双方在<strong>ROS Action Protocol</strong>下进行交流通信是通过接口来实现，类似于TCP下的socket套接字接口。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190909142519.png" alt="img" style="zoom: 80%;" />

<p>如上图，客户端会向服务器发送目标指令和取消动作指令,而服务器则可以给客户端发送 实时的状态信息，结果信息，反馈信息等等,从而完成了service没法做到的部分。</p>
<p>动作的内容格式应包含三个部分：<strong>目标、结果、反馈</strong></p>
<ul>
<li>目标：机器人执行一个动作，应该有明确的移动目标信息，包括一些参数的设定，方向、角度、速 度等等。从而使机器人完成动作任务。</li>
<li>结果：当运动最终完成时，动作服务器把本次运动的结果数据发送给客户端，使客户端得到本次动作的全部信息，例如可能包含机器人的运动时长，最终姿势等等。</li>
<li>反馈：在动作进行的过程中，应该有实时的状态信息反馈给服务器的实施者，告诉实施者动作完成的状态，可以使实施者作出准确的判断去修正命令。</li>
</ul>
<p>Action规范文件的后缀名是<code>.action</code>，它的内容格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">    Define the    goal </span></span><br><span class="line">uint32    dishwasher_id        </span><br><span class="line">--</span><br><span class="line"><span class="meta">#</span><span class="bash">    Define the    result </span></span><br><span class="line">uint32    total_dishes_cleaned </span><br><span class="line">--</span><br><span class="line"><span class="meta">#</span><span class="bash">    Define a feedback message </span></span><br><span class="line">float32    percent_complete</span><br></pre></td></tr></table></figure>

<h1 id="3-roscpp"><a href="#3-roscpp" class="headerlink" title="3. roscpp"></a>3. roscpp</h1><p>如roscpp是C++语言ROS接口，我们直接调用它所 提供的函数就可以实现topic、service等通信功能。roscpp位于<code>/opt/ros/kinetic</code>之下，用C++实现了ROS通信。通常我们要调用ROS的C++接口，首先就需要<code>#include</code></p>
<p>roscpp的主要部分包括：</p>
<ul>
<li><code>ros::init()</code> 解析传入的ROS参数，创建node第一步需要用到的函数</li>
<li><code>ros::NodeHandle</code> 和topic、service、param等交互的公共接口</li>
<li><code>ros::master</code> 包含从master查询信息的函数</li>
<li><code>ros::this_nod</code> 包含查询这个进程(node)的函数</li>
<li><code>ros::service</code> 包含查询服务的函数</li>
<li><code>ros::param</code> 包含查询参数服务器的函数，而不需要用到NodeHandle</li>
<li><code>ros::names</code> 包含处理ROS图资源名称的函数</li>
</ul>
<h2 id="3-1-编写消息发布器和订阅器"><a href="#3-1-编写消息发布器和订阅器" class="headerlink" title="3.1 编写消息发布器和订阅器"></a>3.1 编写消息发布器和订阅器</h2><h3 id="创建程序包"><a href="#创建程序包" class="headerlink" title="创建程序包"></a>创建程序包</h3><p>首先需要创建Catkin工作空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p ~/catkin_ws/src <span class="comment">#创建一个目录，-p表示如果不存在就创建否则不创建</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/catkin_ws/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> catkin_make</span></span><br></pre></td></tr></table></figure>

<p>在<code>catkin_ws</code>工作空间内<code>$ cd ~/catkin_ws/src</code></p>
<p>然后创建一个名为<code>beginner_tutorials</code>的新程序包，这个包依赖于std_msg、roscpp和rospy：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> catkin_create_pkg beginner_tutorials std_msgs rospy roscpp</span></span><br></pre></td></tr></table></figure>

<p>这将会创建一个名为<code>beginner_tutorials</code>的文件夹，这个文件夹里面包含一个<a href="http://wiki.ros.org/catkin/package.xml" target="_blank" rel="noopener">package.xml</a>文件和一个<a href="http://wiki.ros.org/catkin/CMakeLists.txt" target="_blank" rel="noopener">CMakeLists.txt</a>文件，这两个文件都已经自动包含了部分在执行<code>catkin_create_pkg</code>命令时提供的信息。</p>
<h3 id="发布器节点"><a href="#发布器节点" class="headerlink" title="发布器节点"></a>发布器节点</h3><p>首先进入之前创建的 beginner_tutorials package 路径下，在这之中创建一个src文件夹：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/src/beginner_tutorials</span><br><span class="line">mkdir -p ~/catkin_ws/src/beginner_tutorials/src</span><br></pre></td></tr></table></figure>

<p>这个文件夹将会用来放置 beginner_tutorials package 的所有源代码。然后创建<code>src/talker.cpp</code> 文件，在其中写发布器源代码，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ros/ros.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"std_msgs/String.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  ros::init(argc, argv, <span class="string">"talker"</span>);</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">  ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(<span class="string">"chatter"</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  ros::<span class="function">Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (ros::ok())</span><br><span class="line">  &#123;</span><br><span class="line">    std_msgs::String msg;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">"hello world "</span> &lt;&lt; count;</span><br><span class="line">    msg.data = ss.str();</span><br><span class="line">    ROS_INFO(<span class="string">"%s"</span>, msg.data.c_str());</span><br><span class="line">    chatter_pub.publish(msg);</span><br><span class="line">    ros::spinOnce();</span><br><span class="line">    loop_rate.sleep();</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面分块解释：</p>
<p>1.用<code>init</code>初始化这个节点，唯一命名为<code>talker</code>，然后为他创建一个句柄<code>n</code>（这里是自动对应上的，一个一个进程只能有一个节点）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros::init(argc, argv, <span class="string">"talker"</span>);</span><br><span class="line">ros::NodeHandle n;</span><br></pre></td></tr></table></figure>

<p>2.告诉 <code>master</code> 我们将要在 <code>chatter</code>（话题名） 上发布 <a href="http://docs.ros.org/api/std_msgs/html/msg/String.html" target="_blank" rel="noopener">std_msgs/String</a> 消息类型的消息。这样 master 就会告诉所有订阅了 <code>chatter</code> 话题的节点，将要有数据发布。第二个参数是发布序列的大小，如果我们发布的消息的频率太高，缓冲区中的消息在大于 1000 个的时候就会开始丢弃先前发布的消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher chatter_pub = n.advertise&lt;std_msgs::<span class="keyword">String</span>&gt;(<span class="string">"chatter"</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>3.<code>ros::Rate</code> 对象可以允许你指定自循环的频率。它会追踪记录自上一次调用 <code>Rate::sleep()</code> 后时间的流逝，并休眠直到一个频率周期的时间。在这个例子中，我们让它以 10Hz 的频率运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="function">Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>4.roscpp 会默认生成一个 SIGINT 句柄，它负责处理 Ctrl-C 键盘操作——使得 <code>ros::ok()</code> 返回 false。如果下列条件之一发生，<code>ros::ok()</code> 返回false：</p>
<ul>
<li>SIGINT 被触发 (Ctrl+C)</li>
<li>被另一同名节点踢出 ROS 网络</li>
<li><code>ros::shutdown()</code> 被程序的另一部分调用</li>
<li>节点中的所有 <code>ros::NodeHandles</code> 都已经被销毁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (ros::ok())</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>5.为<code>msg</code>添加数据成员<code>hello world</code>；用<code>ROS_INFO</code> 和其他类似的函数可以用来代替 <code>printf</code>/<code>cout</code> 等函数；在这个例子中 <code>ros::spinOnce()</code>非必须，因为我们不接受回调。然而，如果程序里包含其他回调函数，加上 <code>ros::spinOnce()</code>这一语句，否则回调函数就永远也不会被调用了。</p>
<p>这是<strong>ROS消息回调处理函数</strong>，在ROS的主循环中，程序需要不断调用<code>ros::spin()</code>或 <code>ros::spinOnce()</code>，<strong>两者区别在于前者调用后不会再返回，也就是你的主程序到这儿就不往下执行了，而后者在调用后还可以继续执行之后的程序。</strong></p>
<p><code>loop_rate.sleep();</code>是调用 <code>ros::Rate</code> 对象来休眠一段时间以使得发布频率为 10Hz。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">  std_msgs::<span class="keyword">String</span> msg;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">  ss &lt;&lt; <span class="string">"hello world "</span> &lt;&lt; count;</span><br><span class="line">  msg.data = ss.str();</span><br><span class="line">  ROS_INFO(<span class="string">"%s"</span>, msg.data.c_str());</span><br><span class="line"></span><br><span class="line">  chatter_pub.publish(msg);</span><br><span class="line">  ros::spinOnce();</span><br><span class="line"></span><br><span class="line">  loop_rate.sleep();</span><br><span class="line">  ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="订阅器节点"><a href="#订阅器节点" class="headerlink" title="订阅器节点"></a>订阅器节点</h3><p>在 <code>beginner_tutorials package</code> 目录下创建 <code>src/listener.cpp</code> 文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ros/ros.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"std_msgs/String.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chatterCallback</span><span class="params">(<span class="keyword">const</span> std_msgs::<span class="keyword">String</span>::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ROS_INFO(<span class="string">"I heard: [%s]"</span>, msg-&gt;data.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::init(argc, argv, <span class="string">"listener"</span>);</span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    ros::Subscriber sub = n.subscribe(<span class="string">"chatter"</span>, <span class="number">1000</span>, chatterCallback);</span><br><span class="line"></span><br><span class="line">    ros::spin();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个回调函数，当接收到 <code>chatter</code> 话题的时候就会被调用。消息是以 <a href="http://www.boost.org/doc/libs/1_37_0/libs/smart_ptr/shared_ptr.htm" target="_blank" rel="noopener">boost shared_ptr</a> 指针的形式传输，这就意味着可以存储它而又不需要复制数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chatterCallback</span><span class="params">(<span class="keyword">const</span> std_msgs::<span class="keyword">String</span>::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ROS_INFO(<span class="string">"I heard: [%s]"</span>, msg-&gt;data.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>告诉 master 我们要订阅 <code>chatter</code> 话题上的消息。当有消息发布到这个话题时，ROS 就会调用 <code>chatterCallback()</code> 函数。第二个参数是队列大小，以防我们处理消息的速度不够快，当缓存达到 1000 条消息后，再有新的消息到来就将开始丢弃先前接收的消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::Subscriber sub = n.subscribe(<span class="string">"chatter"</span>, <span class="number">1000</span>, chatterCallback);</span><br></pre></td></tr></table></figure>

<h3 id="编译节点并测试"><a href="#编译节点并测试" class="headerlink" title="编译节点并测试"></a>编译节点并测试</h3><p>之前创建包时，创建了创建了 <a href="http://wiki.ros.org/catkin/package_manifest" target="_blank" rel="noopener">package.xml</a> 和 <a href="http://wiki.ros.org/catkin/CMakeLists.txt" target="_blank" rel="noopener">CMakeLists.txt</a> 文件，在生成好的<code>CMakeLists.txt</code>后面加入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Build talker and listener</span></span></span><br><span class="line">include_directories(include $&#123;catkin_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">add_executable(talker src/talker.cpp)</span><br><span class="line">target_link_libraries(talker $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(talker beginner_tutorials_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line">add_executable(listener src/listener.cpp)</span><br><span class="line">target_link_libraries(listener $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(listener beginner_tutorials_generate_messages_cpp)</span><br></pre></td></tr></table></figure>

<p>然后运行<code>catkin_make</code>。注意：如果你是添加了新的 package，你需要通过 <code>--force-cmake</code> 选项告诉 catkin 进行强制编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> In your catkin workspace</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> catkin_make</span></span><br></pre></td></tr></table></figure>

<p>按顺序启动并刷新：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> roscore</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> In your catkin workspace</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/catkin_ws</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ./devel/setup.bash</span></span><br></pre></td></tr></table></figure>

<p><strong>注意！</strong>roscore,talker,listener需要开三个不同的terminal，talker和listener开启时都需要刷新。</p>
<p>启动发布器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ./devel/setup.bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun beginner_tutorials talker</span></span><br></pre></td></tr></table></figure>

<p>启动订阅器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ./devel/setup.bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun beginner_tutorials listener</span></span><br></pre></td></tr></table></figure>

<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="img"></p>
<h2 id="3-2-编写简单的服务器和客户端"><a href="#3-2-编写简单的服务器和客户端" class="headerlink" title="3.2 编写简单的服务器和客户端"></a>3.2 编写简单的服务器和客户端</h2><p>首先需要创建一个srv，用来描述服务器数据类型。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure>

<h3 id="编写服务器节点"><a href="#编写服务器节点" class="headerlink" title="编写服务器节点"></a>编写服务器节点</h3><p>创建<code>add_two_ints_server.cpp</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ros/ros.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"beginner_tutorials/AddTwoInts.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(beginner_tutorials::AddTwoInts::Request  &amp;req,</span></span></span><br><span class="line"><span class="function"><span class="params">         beginner_tutorials::AddTwoInts::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  res.sum = req.a + req.b;</span><br><span class="line">  ROS_INFO(<span class="string">"request: x=%ld, y=%ld"</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)req.a, (<span class="keyword">long</span> <span class="keyword">int</span>)req.b);</span><br><span class="line">  ROS_INFO(<span class="string">"sending back response: [%ld]"</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)res.sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::init(argc, argv, <span class="string">"add_two_ints_server"</span>);</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">  ros::ServiceServer service = n.advertiseService(<span class="string">"add_two_ints"</span>, add);</span><br><span class="line">  ROS_INFO(<span class="string">"Ready to add two ints."</span>);</span><br><span class="line">  ros::spin();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们自己创建了一个<code>add</code>函数，这个函数提供两个int值求和的服务，int值从request里面获取，而返回数据装入response内，这些数据类型都定义在srv文件内部，函数返回一个boolean值。</p>
<p><code>Request</code>值从分割线上方获取，<code>Response</code>值从分割线下方获取</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add</span><span class="params">(beginner_tutorials::AddTwoInts::Request  &amp;req,</span></span></span><br><span class="line"><span class="function"><span class="params">         beginner_tutorials::AddTwoInts::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  res.sum = req.a + req.b;</span><br><span class="line">  ROS_INFO(<span class="string">"request: x=%ld, y=%ld"</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)req.a, (<span class="keyword">long</span> <span class="keyword">int</span>)req.b);</span><br><span class="line">  ROS_INFO(<span class="string">"sending back response: [%ld]"</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)res.sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>ros::NodeHandle::advertiseService()</code>来创建<code>ros::ServiceServer</code>。 <code>advertiseService()</code> 工作方式类似 <code>subscribe()</code>函数，提供一个服务名和回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros::ServiceServer service = n.advertiseService(<span class="string">"add_two_ints"</span>, add);</span><br><span class="line">ROS_INFO(<span class="string">"Ready to add two ints."</span>);</span><br></pre></td></tr></table></figure>

<h3 id="编写客户端节点"><a href="#编写客户端节点" class="headerlink" title="编写客户端节点"></a>编写客户端节点</h3><p>在beginner_tutorials包中创建src/add_two_ints_client.cpp文件，并复制粘贴下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ros/ros.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"beginner_tutorials/AddTwoInts.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::init(argc, argv, <span class="string">"add_two_ints_client"</span>);</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_INFO(<span class="string">"usage: add_two_ints_client X Y"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line">  ros::ServiceClient client = n.serviceClient&lt;beginner_tutorials::AddTwoInts&gt;(<span class="string">"add_two_ints"</span>);</span><br><span class="line">  beginner_tutorials::AddTwoInts srv;</span><br><span class="line">  srv.request.a = atoll(argv[<span class="number">1</span>]);</span><br><span class="line">  srv.request.b = atoll(argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">if</span> (client.call(srv))</span><br><span class="line">  &#123;</span><br><span class="line">    ROS_INFO(<span class="string">"Sum: %ld"</span>, (<span class="keyword">long</span> <span class="keyword">int</span>)srv.response.sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ROS_ERROR(<span class="string">"Failed to call service add_two_ints"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>add_two_ints</code> service创建一个client。<code>ros::ServiceClient</code> 对象待会用来调用service。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros::ServiceClient client = n.serviceClient&lt;beginner_tutorials::AddTwoInts&gt;(<span class="string">"add_two_ints"</span>);</span><br></pre></td></tr></table></figure>

<p>实例化一个由ROS编译系统自动生成的service类，并给其request成员赋值。一个service类包含两个成员<code>request</code>和<code>response</code>。同时也包括两个类定义<code>Request</code>和<code>Response</code>。atoll把字符串转换为long long integer</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beginner_tutorials::AddTwoInts srv;</span><br><span class="line">srv.request.a = atoll(argv[<span class="number">1</span>]);</span><br><span class="line">srv.request.b = atoll(argv[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>代码是在调用service。由于service的调用是模态过程（调用的时候占用进程阻止其他代码的执行），一旦调用完成，将返回调用结果。如果service调用成功，<code>call()</code>函数将返回true，<code>srv.response</code>里面的值将是合法的值。如果调用失败，<code>call()</code>函数将返回false，<code>srv.response</code>里面的值将是非法的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (client.call(srv))</span><br></pre></td></tr></table></figure>

<p>还是老规矩，三个terminal启动，注意刷新，注意客户端需要传参</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> roscore</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun beginner_tutorials add_two_ints_server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rosrun beginner_tutorials add_two_ints_client 1 3</span></span><br></pre></td></tr></table></figure>

<p>服务器窗口：</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190910160813.png" alt="img" style="zoom: 67%;" />
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/18/ROS%E5%9F%BA%E7%A1%80/" data-id="ck4o2turs000wu4vybvgf2y1i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SVD解超定方程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/18/SVD%E8%A7%A3%E8%B6%85%E5%AE%9A%E6%96%B9%E7%A8%8B/" class="article-date">
  <time datetime="2019-12-18T15:21:49.000Z" itemprop="datePublished">2019-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/18/SVD%E8%A7%A3%E8%B6%85%E5%AE%9A%E6%96%B9%E7%A8%8B/">SVD解超定方程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-奇异值分解原理"><a href="#1-奇异值分解原理" class="headerlink" title="1. 奇异值分解原理"></a>1. 奇异值分解原理</h1><h2 id="1-1-特征值的数学含义"><a href="#1-1-特征值的数学含义" class="headerlink" title="1.1 特征值的数学含义"></a>1.1 特征值的数学含义</h2><p><strong>对角矩阵</strong>$M$作用在任何一个向量上：<br>$$<br>\begin{bmatrix}3&amp;0\0&amp;1 \end{bmatrix}<br>\begin{bmatrix}x\y \end{bmatrix}<br>=<br>\begin{bmatrix}3x\y \end{bmatrix}<br>$$<br>换言之这个变换让$x$方向拉伸了3倍，$y$方向保持不变，<strong>对角矩阵起到作用是将水平垂直网格作水平拉伸（或者反射后水平拉伸）的线性变换</strong>。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190815150921.png" alt="img" style="zoom:67%;" />

<p>对于一个<strong>一般矩阵</strong>$M=\begin{bmatrix}1&amp;1\0&amp;1 \end{bmatrix}$，我们可以找到一组网格，然后通过<strong>旋转+拉伸</strong>的方法保证变换后的网格依旧互相垂直。</p>
<img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190815151022.png" alt="img" style="zoom:67%;" />

<p><strong>特征向量</strong>的几何含义为：<strong>对于任何的一个矩阵，我们要找到一组两两正交单位向量序列，使得矩阵作用在此向量序列上后得到新的向量序列保持两两正交</strong>。特征值的几何含义为：拉伸<br>$$<br>A=W\Sigma W^{-1}<br>$$<br>其中$W$是这$n$个特征向量张成的$n$维矩阵，一般而言我们会把$W$的这$n$个特征向量标准化，即:<br>$$<br>||w_i||_2=w_i^Tw_i=1<br>$$<br>此时$W$就变为了<strong>标准正交基</strong>，满足：<br>$$<br>W^TW=I,\ W^T=W^{-1}<br>$$<br>这样我们的特征分解表达式可以写成：<br>$$<br>A=W\Sigma W^{T}<br>$$</p>
<h2 id="2-2-奇异值的含义"><a href="#2-2-奇异值的含义" class="headerlink" title="2.2 奇异值的含义"></a>2.2 奇异值的含义</h2><p><strong>特征值需要方阵</strong>，对于一个非方阵而言我们可以通过$M=AA^T$将它变为方阵，对变换后的方阵$M$求特征值的结果就是奇异值。</p>
<p>若$AA^T$的特征值为：<br>$$<br>\lambda <em>{1} \geq \lambda _{2} \geq … \geq \lambda _{r} &gt; \lambda _{r+1} = \cdots = \lambda</em>{m} = 0<br>$$<br>则称$\sigma _{i}=\sqrt {\lambda _{i}}  \quad (i=1, 2, …, r)$为矩阵$A$的<strong>奇异值</strong>（注意这里只有r个）。</p>
<p>存在$m$阶酉矩阵$U$和$n$阶酉矩阵$V$，使得：<br>$$<br>A=UDV^{T}=U<br>    \left[<br>          \begin{matrix}<br>           \Sigma                   &amp;  0_{r \times (n-r)}        \<br>           0_{(m-r) \times r}   &amp;  0_{(m-r) \times (n-r)}  \<br>          \end{matrix}<br>    \right]<br>    V^{T}<br>    \其中, \quad<br>\Sigma =<br>    \left[<br>          \begin{matrix}<br>           \sigma_{1} &amp;                      &amp;                &amp;                          \<br>                             &amp;   \sigma_{2}  &amp;                &amp;                           \<br>                             &amp;                      &amp;   \ddots  &amp;                           \<br>                             &amp;                      &amp;                &amp;   \sigma_{r}       \<br>          \end{matrix}<br>    \right]<br>$$<br>上式中 <strong>D的对角元叫做 A 的奇异值</strong>，<strong>U 中的列向量称为 A 的左奇异向量</strong>，<strong>V 中的列向量称为 A 的右奇异向量</strong>。</p>
<h1 id="2-奇异值分解解线性方程"><a href="#2-奇异值分解解线性方程" class="headerlink" title="2. 奇异值分解解线性方程"></a>2. 奇异值分解解线性方程</h1><h2 id="2-1-解非齐次线性方程组-Ax-b"><a href="#2-1-解非齐次线性方程组-Ax-b" class="headerlink" title="2.1 解非齐次线性方程组($Ax=b$)"></a>2.1 解非齐次线性方程组($Ax=b$)</h2><p>若矩阵的行数大于列数，则为超定方程，需要求最小二乘解，即使得$||Ax-b||<em>{2}$<strong>最小时</strong>的$x$，由2-范数具有酉不变性，有：<br>$$<br>||Ax-b||</em>{2} =<br>   \left| \left|<br>    U<br>    \left[<br>          \begin{matrix}<br>           \Sigma                   &amp;  0_{r \times (n-r)}        \<br>           0_{(m-r) \times r}   &amp;  0_{(m-r) \times (n-r)}  \<br>          \end{matrix}<br>    \right]<br>    V^{T} x-b<br>    \right| \right|<br>    \=<br>   \left| \left|<br>    \left[<br>          \begin{matrix}<br>           \Sigma                   &amp;  0_{r \times (n-r)}        \<br>           0_{(m-r) \times r}   &amp;  0_{(m-r) \times (n-r)}  \<br>          \end{matrix}<br>    \right]<br>    V^{T} x-U^{T}b<br>    \right| \right|<br>$$</p>
<blockquote>
<p>如果范数满足$║A║=║UAV║$对任何矩阵$A$以及酉矩阵$(U,V)$成立，则此范数为酉不变范数。2-范数是酉不变范数。</p>
</blockquote>
<p>要让上述二范数最小，<strong>让里面的内容等于0即可</strong>。所以$Ax=b$的最小二乘解为$\left[         \begin{matrix}            \Sigma                   &amp;  0_{r \times (n-r)}        \            0_{(m-r) \times r}   &amp;  0_{(m-r) \times (n-r)}  \                     \end{matrix}   \right]   V^{T}x = U^{T}b$的最小二乘解。</p>
<p>令$y=V^{H}x，c=U^{H}b$，则原方程可亦表示为:<br>$$<br>\left[<br>      \begin{matrix}<br>           \Sigma                   &amp;  0_{r \times (n-r)}        \<br>           0_{(m-r) \times r}   &amp;  0_{(m-r) \times (n-r)}  \<br>          \end{matrix}<br>\right]<br>y = c<br>$$<br>表达成<strong>矩阵形式</strong>如下：<br>$$<br>\left[<br>          \begin{array}{cccc:c}<br>           \sigma_{1} &amp;                      &amp;               &amp;                       &amp;    \<br>                             &amp;   \sigma_{2}  &amp;               &amp;                       &amp;    \<br>                             &amp;                      &amp;   \ddots  &amp;                       &amp;  0_{r \times (n-r)}  \<br>                             &amp;                      &amp;                &amp;   \sigma_{r}   &amp;     \<br>                             \hdashline<br>                             &amp;                     &amp;  0_{(m-r) \times r}      &amp;    &amp;  0_{(m-r) \times (n-r)}<br>          \end{array}<br>    \right]<em>{m \times n}<br>    \cdot<br>     \left[<br>          \begin{matrix}<br>          y</em>{1}     \<br>          y_{2}     \<br>          \vdots  \<br>          y_{r}      \<br>          \hdashline<br>           \mathcal{Y_{(n-r) \times 1}}     \<br>          \end{matrix}<br>    \right]<em>{n \times 1}<br>    =<br>     \left[<br>          \begin{matrix}<br>          c</em>{1}     \<br>          c_{2}     \<br>          \vdots  \<br>          c_{r}      \<br>          \hdashline<br>           \mathcal{C_{(m-r) \times 1}}     \<br>          \end{matrix}<br>    \right]<em>{m \times 1}<br>$$<br>所以$Dy=c$的最小二乘解为：<br>$$<br>y=[\frac{c</em>{1}}{\sigma <em>{1}}, \frac{c</em>{2}}{\sigma <em>{2}}, \cdots, \frac{c</em>{r}}{\sigma <em>{r}}, \underbrace{0, \cdots, 0}</em>{n-r} ]^{T}<br>$$<br><strong>原方程组</strong>的最小二乘解为：<br>$$<br>x=V^{T}y<br>$$</p>
<h2 id="2-2-解齐次线性方程组-Ax-0"><a href="#2-2-解齐次线性方程组-Ax-0" class="headerlink" title="2.2 解齐次线性方程组($Ax=0$)"></a>2.2 解齐次线性方程组($Ax=0$)</h2><p>2.1的情况是让$||Ax-b||<em>{2}$的值最小，但2.2由于$b=0$所以是让$||Ax||</em>{2}$最小，由于$x=0$是方程的解，而我们一般不想要这个解，所以<strong>增加一个约束</strong>$||x||<em>2=1$，这样问题就变成了：<br>$$<br>min(||Ax||</em>{2})，||x||<em>{2}=1<br>$$<br>又因为：<br>$$<br>||Ax||=||UDV^{T}x||=||DV^{T}x||<br>$$<br>令$y=V^{T}x$，则问题变为：<br>$$<br>min(||Dy||), ||y||=1<br>$$<br>展开以后得到：<br>$$<br>\left[<br>          \begin{array}{cccc:c}<br>           \sigma</em>{1} &amp;                      &amp;               &amp;                       &amp;    \<br>                             &amp;   \sigma_{2}  &amp;               &amp;                       &amp;    \<br>                             &amp;                      &amp;   \ddots  &amp;                       &amp;  0_{r \times (n-r)}  \<br>                             &amp;                      &amp;                &amp;   \sigma_{r}   &amp;     \<br>                             \hdashline<br>                             &amp;                     &amp;  0_{(m-r) \times r}      &amp;    &amp;  0_{(m-r) \times (n-r)}<br>          \end{array}<br>    \right]<em>{m \times n}<br>    \cdot<br>     \left[<br>          \begin{matrix}<br>          y</em>{1}     \<br>          y_{2}     \<br>          \vdots  \<br>          y_{r}      \<br>          \hdashline<br>           \mathcal{Y_{(n-r) \times 1}}     \<br>          \end{matrix}<br>    \right]<em>{n \times 1}<br>    =<br>     \left[<br>          \begin{matrix}<br>          0     \<br>          0     \<br>          \vdots  \<br>          0      \<br>          \hdashline<br>           \mathcal{0</em>{(m-r) \times 1}}     \<br>          \end{matrix}<br>    \right]_{m \times 1}<br>$$<br>因为对角阵$D$的对角元素（奇异值）按递减顺序排列，所以最优解为$y=[0, 0, \cdots, 1]^{T}$（考虑到约束条件）,又因为$x=Vy$，所以最优解是最小奇异值对应的$V$的列向量(<strong>右奇异向量</strong>)，<strong>也就是$V$的最右边一列</strong>。比如下面的结果就是$[a_3,b_3,c_3]^T$<br>$$<br>V=\begin{bmatrix}a_1&amp;a_2&amp;a_3\<br>b_1&amp;b_2&amp;b_3\<br>c_1&amp;c_2&amp;c_3\end{bmatrix}<br>$$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/18/SVD%E8%A7%A3%E8%B6%85%E5%AE%9A%E6%96%B9%E7%A8%8B/" data-id="ck4o2tus20017u4vy3oro4rdp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Sim3变换" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/18/Sim3%E5%8F%98%E6%8D%A2/" class="article-date">
  <time datetime="2019-12-18T14:56:43.000Z" itemprop="datePublished">2019-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/18/Sim3%E5%8F%98%E6%8D%A2/">Sim3变换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>常见的欧式变换由6个自由度($R,T$各三个)，在SLAM问题中，可能会存在尺度的改变，因此自由度就变成了7个，见下图：</p>
<p><img src="https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20190828131603.png" alt="img"></p>
<p>Sim3(<strong>Similarity Transformation</strong>)的提出就是为了解决两个坐标系之间的相似变换问题，只要我们能得到<strong>3对匹配好的点在两个坐标系下的坐标</strong>，我们就能解出相似变换。</p>
<p>从<strong>几何</strong>上理解：在欧式变换中，我们只需要两对匹配的点就可以求解，因为两个点构成向量，通过<strong>比较向量在两个空间的平移量和旋转量</strong>，就可以得到欧式变换的结果。而在相似变换中，通过增加一个点，三个点构成三角形，通过<strong>法向量能计算旋转量</strong>，通过<strong>面积相似性能计算尺度变化</strong>，利用$R,s$将两个面平行，通过<strong>计算面距离得到平移量</strong>。</p>
<p>从<strong>代数</strong>上理解：两组三维点，能构成6个方程，解6个未知数；三组三维点，构成9个方程，超定方程解7个未知数。</p>
<p>在SLAM中主要用于回环检测，因为回环过程中会产生尺度的漂移，需要计算当前帧和候选帧之间的sim3变换。</p>
<h1 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h1><h2 id="2-1-坐标系"><a href="#2-1-坐标系" class="headerlink" title="2.1 坐标系"></a>2.1 坐标系</h2><p>假设3个点在左右两个坐标系下的坐标分别是$r_{l,1},r_{l,2},r_{l,3}$和$r_{r,1},r_{r,2},r_{r,3}$，令$r_{l,1}$和$r_{r,1}$分别为左右两个坐标系的原点，则我们可以算出这两个坐标系的$x,y,z$轴方向的单位向量：</p>
<p>$X$方向：$x_l=r_{l,2}-r_{l,1}$,则单位向量$\hat x_l=x_l/|x_l|$</p>
<p>$Y$方向：$y_l=(r_{l,3}-r_{l,1})-[(r_{l,3}-r_{l,1})·\hat x_l]\hat x_l$ ，则单位向量$\hat y_l=y_l/|y_l|$</p>
<blockquote>
<p>上面式子中$(r_{l,3}-r_{l,1})·\hat x_l$大小为$r_{l,3}-r_{l,1}$在$x$轴的投影（没有方向），再乘以$\hat x_l$得到了方向。做差后得到了与$x$轴垂直的方向。</p>
</blockquote>
<p>$Z$方向：$\hat z_l=\hat x_l \times \hat y_l$</p>
<p>根据所得的坐标系单位向量，可以得到左右两侧坐标系的各个方向单位向量构成的基底矩阵：<br>$$<br>M_l=|\hat x_l \hat y_l \hat z_l| \ M_r=|\hat x_r \hat y_r \hat z_r|<br>$$<br>假设左边坐标系有一个向量 $r_l$ ,那么： $M_l^Tr_l$ 是 $r_l$ 在 $M_l$ 基底下的坐标，左乘 $M_r$ 变成右坐标系： $r_r=M_rM_l^Tr_l$变换为： $R=M_rM_l^T$ </p>
<h2 id="2-2-计算平移量"><a href="#2-2-计算平移量" class="headerlink" title="2.2 计算平移量"></a>2.2 计算平移量</h2><p>设有n个点，在左右坐标系中分别表示为 ${r_{l,i}}$  和 ${r_{r,j}}$ ,我们的目的是找到如下的变换形式： $r_r=sR(r_l)+r_0$，其中$r_0$为平移偏移量。</p>
<p>实际当中，两个坐标系之间的变换不会那么容易计算出精确的变换向量，一般使用最小二乘法来求解。此时，这里的误差为：<br>$$<br>e_i=r_{r,i}-sR(r_{l,i})-r_0<br>$$<br>那么，求解的最小二乘问题变成了求解：<br>$$<br>\sum^n_{i=1}|e_i|^2<br>$$<br>首先计算左右两个坐标系所有点的质心：<br>$$<br>r_l^-=\frac{1}{n}\sum^n_{i=1}r_{l,i}\   r_r^-=\frac{1}{n}\sum^n_{i=1}r_{r,i}<br>$$<br>则每一个点距离质心的距离为：<br>$$<br>r_{l,i}’=r_{l,i}-r^-<em>l \  r</em>{r,i}’=r_{r,i}-r^-<em>r\  \sum</em>{i=1}^n r_{l,i}’=0 \   \sum_{i=1}^nr_{r,i}’=0<br>$$<br>由此得出：<br>$$<br>\begin{eqnarray}<br>&amp;&amp;r_{r,i}’=sR(r_{l,i}’)-r_0’  \ &amp;&amp;\Longrightarrow   r_0’=r_{r,i}’-sR(r_{l,i}’)\<br>&amp;&amp;\Longrightarrow   r_0’=r_{r,i}’-sR(r_{l,i}-\overline r_l)\<br>&amp;&amp;\Longrightarrow   r_0’=r_{r,i}’-sR(r_{l,i})+sR(\overline r_l)\<br>&amp;&amp;\Longrightarrow r_0’=r_0-r_r^-+sR(\overline r_l)\<br>\end{eqnarray}<br>$$<br>优化函数变为：<br>$$<br>\begin{eqnarray}<br>\sum_{i=1}^n|e_i|^2&amp;&amp;=\sum_{i=1}^n|r_{r,i}’-[sR(r_{r,i}’)+r_0’|^2]\<br>&amp;&amp;=\sum_{i=1}^n|r_{r,i}’-sR(r_{l,i}’)|^2-2r_0’\cdot\sum_{i=1}^n[r_{r,i}’-sR(r_{l,i}’)]+n|r_0’|^2<br>\end{eqnarray}<br>$$<br>最后一项明显不为负，所以当最后一项等于0时最小，由此可以计算出<strong>平移量</strong>$t$：<br>$$<br>\begin{eqnarray}<br>t&amp;&amp;=r_0=r_r^–sR(r_l^-)<br>\end{eqnarray}<br>$$</p>
<h2 id="2-3-尺度计算"><a href="#2-3-尺度计算" class="headerlink" title="2.3 尺度计算"></a>2.3 尺度计算</h2><p>旋转尺度不变性： $|R(r_{l,i}’)|^2=|r_{l,i}’|^2$ ，对误差式展开得：<br>$$<br>\sum_{i=1}^n|r’<em>{r,i}|^2-2s\sum</em>{i=1}^nr’<em>{r,i} \cdot R(r’</em>{l,i})+s^2\sum|r’_{l,i}|^2<br>$$<br>将上式写成：<br>$$<br>S_r-2sD+s^2S_l<br>$$</p>
<p> 进一步拆分成：<br>$$<br>(s\sqrt{S_l}-D/\sqrt{S_l})^2+(S_rS_l-D^2)/S_l<br>$$<br>上面的式子只有第一项与s有关，所以当第一项等于0时达到最小，即 $s=D/S_l$ :<br>$$<br>s=\sum_{i=1}^nr’<em>{r,i} \cdot R(r’</em>{l,i})/\sum_{i=1}^n|r’<em>{l,i}|^2<br>$$<br>在误差模型中除一个根号s：<br>$$<br>e_i=\frac{1}{\sqrt{s}}r’</em>{r,i}-\sqrt{s}R(r’_{i,j})<br>$$<br>我们只是求误差的最小值，除以一个系数是没关系的，这样做的好处是最后求得的s与旋转因子无关，并且便于后面求解。</p>
<p>最后得到：<br>$$<br>s=(\sum_{i=1}^n|r’<em>{r,i}|^2/\sum</em>{i=1}^n|r’_{i=1}|^2)^{1/2}<br>$$<br>因此只有在<strong>D取得最大的情况下，误差才会最小</strong>，现在就把问题变为了求D的过程。</p>
<p><strong>引入四元数qq表示旋转</strong>(具体推导见三维刚体运动那一部分)：<br>$$<br>\sum_{i=1}^n r’<em>{r,i} \cdot R(r’</em>{l,i})=<br> \sum_{i=1}^n(q’r’<em>{l,i}q’^*) \cdot r’</em>{r,i}=\sum_{i=1}^n(q’r’<em>{l,i}) \cdot (r’</em>{r,i}q’)<br>$$<br>左边等于：<br>$$<br>q’r’<em>{l,i}=\left[\begin{matrix}    0 &amp; -x’</em>{l,i} &amp; -y’<em>{l,i} &amp; -z’</em>{l,i}\    x’<em>{l,i} &amp; 0 &amp; z’</em>{l,i} &amp; -y’<em>{l,i} \    y’</em>{l,i} &amp; -z’<em>{l,i} &amp; 0 &amp; x’</em>{l,i} \   z’<em>{l,i} &amp; y’</em>{l,i} &amp; -x’<em>{l,i} &amp; 0   \end{matrix}\right]q’=R</em>{l,i}q’<br>$$<br>右边等于：<br>$$<br>r’<em>{r,i}q’=\left[\begin{matrix}    0 &amp; -x’</em>{r,i} &amp; -y’<em>{r,i} &amp; -z’</em>{r,i}\    x’<em>{r,i} &amp; 0 &amp; -z’</em>{r,i} &amp; y’<em>{r,i} \    y’</em>{r,i} &amp; z’<em>{r,i} &amp; 0 &amp; -x’</em>{r,i} \   z’<em>{r,i} &amp; -y’</em>{r,i} &amp; x’<em>{r,i} &amp; 0   \end{matrix}\right]q’= R</em>{r,i}q’<br>$$<br>所以又可以表达为：<br>$$<br>\sum_{i=1}^n(R_{l,i}q’) \cdot (R_{r,i}q’)=\sum_{i=1}^nq’^TR_{l,i}^TR_{r,i}q’=q’^TNq’<br>$$<br>为了求解$N$，先引入一个$M$矩阵：<br>$$<br>M=\sum_{i=1}^nr’<em>{l,i}r’^T</em>{r,i}=\left[\begin{matrix}<br>S_{xx} &amp; S_{xy} &amp; S_{xz}\<br>S_{yx} &amp; S_{yy} &amp; S_{yz} \<br>   S_{zx} &amp; S_{zy} &amp; S_{zz}<br>  \end{matrix}\right]<br>$$<br>则$N$矩阵就可以表示为:<br>$$<br>N=\left[\begin{matrix}<br>(S_{xx}+S_{yy}+S_{zz}) &amp; S_{yz} -S_{zy} &amp; S_{zx}-S_{xz} &amp; S_{xy}-S_{yx}\<br>S_{yz}-S_{zy} &amp; (S_{xx}-S_{yy}-S_{zz}) &amp; S_{xy}+S_{yx} &amp; S_{zx}+S_{xz}\<br>   S_{zx}-S_{xz} &amp; S_{xy}-S_{yx} &amp; (-S_{xx}+S_{yy}-S_{zz}) &amp; S_{yz}+S_{zy}   \<br>   S_{xy} -S_{yx} &amp; S_{zx}+S_{xz} &amp; S_{yz}-S_{zy} &amp;(-S_{xx}-S_{yy}+S_{zz})<br>  \end{matrix}\right]<br>$$<br>引出$M$来就是为了让其中的量来表示$N$，如上式。将$N$进行<strong>特征分解</strong>，求得最大特征值对应的特征向量为四元数表示的旋转。之后平移和尺度关系也能相应求解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/18/Sim3%E5%8F%98%E6%8D%A2/" data-id="ck4o2tus40019u4vyero1dpca" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程4-可变参数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B3-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0/">CPP泛型编程3-非类型的模板参数</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B2-%E7%B1%BB%E6%A8%A1%E6%9D%BF/">CPP泛型编程2-类模板</a>
          </li>
        
          <li>
            <a href="/2019/12/27/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">CPP泛型编程1-函数模板</a>
          </li>
        
          <li>
            <a href="/2019/12/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/">CPP多线程总结4-并发数据结构设计实例</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>