{"meta":{"title":"JR's Blog","subtitle":"直挂云帆济沧海","description":"Jiang Ren的学习笔记","author":"Jiang Ren","url":"jiangren.work","root":"/"},"pages":[{"title":"","date":"2020-07-25T05:20:00.474Z","updated":"2019-12-31T18:32:15.000Z","comments":true,"path":"baidu_verify_edFv81JHUm.html","permalink":"jiangren.work/baidu_verify_edFv81JHUm","excerpt":"","text":"edFv81JHUm"},{"title":"categories","date":"2019-12-30T14:21:12.000Z","updated":"2019-12-30T22:21:28.000Z","comments":false,"path":"categories/index.html","permalink":"jiangren.work/categories/","excerpt":"","text":""},{"title":"tags","date":"2019-12-30T14:20:29.000Z","updated":"2019-12-30T22:21:04.000Z","comments":false,"path":"tags/index.html","permalink":"jiangren.work/tags/","excerpt":"","text":""}],"posts":[{"title":"Objective-C专题：多重继承","slug":"Objective-C专题：多重继承","date":"2020-07-25T05:51:31.000Z","updated":"2020-07-25T06:07:36.460Z","comments":true,"path":"2020/07/25/Objective-C专题：多重继承/","link":"","permalink":"jiangren.work/2020/07/25/Objective-C%E4%B8%93%E9%A2%98%EF%BC%9A%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/","excerpt":"OC不像C++一样支持多重继承，当我们需要从多个父类汲取属性和方法时，需要用到一些特殊的操作。","text":"OC不像C++一样支持多重继承，当我们需要从多个父类汲取属性和方法时，需要用到一些特殊的操作。 1. 组合在ClassC的.h或者.m文件中,声明ClassA和ClassB的实例 @class ClassA,ClassB; @interface ClassC : NSObject @property (nonatomic,strong) ClassA *a; @property (nonatomic,strong) ClassB *b; - (void)sport; @end #import &quot;ClassC.h&quot; #import &quot;ClassA.h&quot; #import &quot;ClassB.h&quot; @implementation ClassC - (void)sport{ [self.a run]; [self.b walk]; } @end 2. 协议将C类需要继承的方法以及属性在ClassA和ClassB中各自声明一份协议，C类遵守这两份协议，同时在C类中实现协议中的方法以及属性。 @protocol ClassADelegate - (void)run; @property (nonatomic,copy) NSString *runDistance; @end @protocol ClassBDelegate - (void)walk; @property (nonatomic,copy) NSString *walkDistance; @end #import &quot;ClassC.h&quot; #import &quot;ClassA.h&quot; #import &quot;ClassB.h&quot; @interface ClassC()&lt;ClassADelegate,ClassBDelegate&gt; @end @implementation ClassC - (void)sport{ [self run]; [self walk]; } - (void)run{ self.runDistance = @&quot;10000&quot;; NSLog(@&quot;今天跑了%@步&quot;,self.runDistance); } - (void)walk{ self.walkDistance = @&quot;5000&quot;; NSLog(@&quot;今天走了%@步&quot;,self.walkDistance); } 3. 消息转发当向某个对象发送消息，但runtime system在当前类以及父类中都找不到对应方法的实现时，runtime system并不会立即报错使程序崩溃，而是依次执行下列步骤： 动态方法解析：向当前类发送resolveInstanceMethod: 信号，检查是否动态向该类添加了方法 快速消息转发：检查该类是否实现了 forwardingTargetForSelector: 方法，若实现了则调用这个方法，若该方法返回nil或者非self，则向该返回对象重新发送消息 标准消息转发：runtime发送methodSignatureForSelector:消息获取Selector对应的方法签名。返回值非空则通过forwardInvocation:转发消息，返回值为空则向当前对象发送doesNotRecognizeSelector:消息，程序崩溃退出。 例子： /* ---------------------- Father.h ---------------------- */ #import &lt;Foundation/Foundation.h&gt; @interface Father : NSObject - (void)work; @end /* ---------------------- Father.m ---------------------- */ #import &quot;Father.h&quot; @implementation Father - (void)work { NSLog(@&quot;I&#39;m working.&quot;); } @end /* ---------------------- Mother.h ---------------------- */ #import &lt;Foundation/Foundation.h&gt; @interface Mother : NSObject - (void)cook; @end /* ---------------------- Mother.m ---------------------- */ #import &quot;Mother.h&quot; @implementation Mother - (void)cook { NSLog(@&quot;I&#39;m cooking.&quot;); } @end /* ---------------------- Son.m ---------------------- */ #import &lt;Foundation/Foundation.h&gt; #import &quot;Father.h&quot; @interface Son : Father //利用OC的继承机制，这里单方面地先继承的Father类 @end /* ---------------------- Son.m ---------------------- */ #import &quot;Son.h&quot; @implementation Son @end 3.1 快速转发对应- (id)forwardingTargetForSelector:(SEL)aSelector;方法，他是Apple提供了一种更为简便的方式进行消息转发。作用：对消息进行重定向。当一个对象无法处理消息时，系统会调用这个方法，可以利用这个方法将消息的接受者替换为其他对象。 /* ---------------------- Son.h ---------------------- */ #import &quot;Mother.h&quot; ... /* ---------------------- Son.m ---------------------- */ #import &quot;Son.h&quot; @interface Son() @property (nonatomic, strong) Mother *mother; @end @implementation Son - (instancetype)init { self = [super init]; if (self != nil) { _mother = [[Mother alloc]init]; } return self; } - (id)forwardingTargetForSelector:(SEL)aSelector { if ([_mother respondsToSelector:aSelector]) { return _mother; } return nil; } @end 上面的代码中，当Son调用Cook方法时，无法处理，因此通过forwardingTargetForSelector重定向给mother。 3.2 标准转发我们还可以利用- (void)forwardInvocation:(NSInvocation *)anInvocation;来进行标准的消息转发，值得注意的是，在调用这个方法之前，系统会先调(id)forwardingTargetForSelector:(SEL)aSelector;这个方法，如果这个方法返回为nil，才会调动标准的消息转发机制。 --------------------- Son.m ---------------------- */ #import &quot;Son.h&quot; @interface Son() @property (nonatomic, strong) Mother *mother; @end @implementation Son - (instancetype)init { self = [super init]; if (self != nil) { _mother = [[Mother alloc]init]; } return self; } - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { NSMethodSignature *methodSignature = [super methodSignatureForSelector:aSelector]; if (methodSignature != nil) return methodSignature; if ([_mother respondsToSelector:aSelector]) { return [_mother methodSignatureForSelector:aSelector]; } return nil; } - (void)forwardInvocation:(NSInvocation *)anInvocation { if ([_mother respondsToSelector:[anInvocation selector]]) { [anInvocation invokeWithTarget:_mother]; } } @end 3.3 对比快速转发和标准转发的区别： 快速消息转发：简单、快速、但仅能转发给一个对象。 标准消息转发：稍复杂、较慢、但转发操作实现可控，可以实现多对象转发。 为什么是快速转发是一对一，标准转发是一对多： 快速转发是return，只能返回一个对象。 标准转发是调用[anInvocation invokeWithTarget:XXX];能够反复调用多次。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"jiangren.work/categories/Objective-C/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"jiangren.work/tags/Objective-C/"},{"name":"面试经验","slug":"面试经验","permalink":"jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"}]},{"title":"面向对象的继承思想","slug":"面向对象的继承思想","date":"2020-07-25T05:33:18.000Z","updated":"2020-07-25T06:06:18.426Z","comments":true,"path":"2020/07/25/面向对象的继承思想/","link":"","permalink":"jiangren.work/2020/07/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF%E6%80%9D%E6%83%B3/","excerpt":"探讨面向对象的两大流派。","text":"探讨面向对象的两大流派。 1. 继承的分类1.1 类继承和原型继承OOP有两大类别：class-based和prototype-based。 对于C++和Java来说，他们的面向对象基于：类和实例， 一个类(class)定义了某一对象集合所具有的特征性属性。类是抽象的，而不是其所描述的对象集合中的任何特定的个体。例如 Employee 类可以用来表示所有雇员的集合。 一个实例(instance)是一个类的实例化。例如， Tom 可以是 Employee 类的一个实例，表示一个特定的雇员个体。实例具有和其父类完全一致的属性，不多也不少。 对于JavaScript来说，它只有对象。基于原型的语言具有所谓原型对象(prototypical object)的概念。原型对象可以作为一个模板，新对象可以从中获得原始的属性。 举例对比： Class-based：假设 Employee 类只有 name 和 dept 属性，而 Manager 是 Employee 的子类并添加了 reports 属性。这时，Manager 类的实例将具有所有三个属性：name，dept和reports。 Prototype-based： 首先，定义Employee构造函数，在该构造函数内定义name、dept属性； 接下来，定义Manager构造函数，在该构造函数内调用Employee构造函数，并定义reports属性。 最后，将一个获得了Employee.prototype(Employee构造函数原型)的新对象赋予manager构造函数，以作为Manager构造函数的原型。之后当你创建新的Manager对象实例时，该实例会从Employee对象继承name、dept属性。 总结： 1.2 哲学思想Class-based强调belongs to，prototype-based强调is a。在后者的思想里，其实本质上没有真正的继承关系，只是声明自己支持某个协议/接口/prototype，然后想办法真的去支持这个协议即可。 在《设计模式：可复用面向对象软件的基础》一书的开头，作者提出了面向对象设计的两大基本原则： Program to an interface, not an implementation. 面向接口而非面向实现 Favor object composition over class inheritance. 使用对象组合而非继承 形象一点说就是：类继承类似于高达模型。模型的零件必须按照正确的方式组装起来，如果装错了，整个体系就搭建不起来。组合更像是乐高积木。各式各样的零件并不只能与指定的零件组合。相反，每一块积木都被设计为可以与其它零件任意组合。 类继承会带来4个问题： 强耦合。父类的方法和属性完全暴露给子类。 多重继承十分复杂。 脆弱的架构。由于强耦合的存在，通常很难对一个使用了“错误”设计的类进行重构，因为有太多既有功能依赖这些既有设计。 大猩猩与香蕉问题。你想要一个香蕉，而你却必须抱着一个拿着香蕉的大猩猩。（只想使用父类的一些属性和方法，却必须拥有整个父类） 晚出现的一些语言，比如go，直接就走了prototype-based的道路。 2. 原型继承举例利用原型继承，实现如下结构： 在原型继承中，第一步是思考如何创建构造器： function Employee () { this.name = &quot;&quot;; this.dept = &quot;general&quot;; } 在 JavaScript 中，会添加一个原型实例作为构造器函数prototype 属性的值，然后将该构造函数原型的构造器重载为其自身。 function Manager() { Employee.call(this); this.reports = []; } Manager.prototype = Object.create(Employee.prototype); function WorkerBee() { Employee.call(this); this.projects = []; } WorkerBee.prototype = Object.create(Employee.prototype); 在使用New创建实例var Tom = new WorkerBee;时，实际上发生了以下事情： 开辟内存，创建一个普通对象 将这个普通对象中的prototype指向WorkerBee.prototype 把这个普通对象设置为执行 WorkerBee 构造函数时 this 的值。 执行完毕后，JavaScript 返回之前创建的对象，通过赋值语句将它的引用赋值给变量 mark。 当访问Tom的属性时， 检查自身是否含有这个属性 顺着原型链检查其中的对象是是否含有这个属性 如果都没有，则返回undefined 3.菱形继承的问题 容易出现二义性的问题： class A{ public: A():a(1){}; void printA(){cout&lt;&lt;a&lt;&lt;endl;} int a; }; class B : public A{ }; class C : public A{ }; class D: public B , public C{ }; D d; d.a=10;////error C2385: 对“a”的访问不明确 C++使用了虚继承的方法来解决：对给定的虚基类，无论该类在派生层次中作为虚基类出现多少次，只继承一个共享的基类子对象。下面的代码中在派生类 D 中就只保留了一份成员变量 m_a，直接访问就不会再有歧义了。 //间接基类A class A{ protected: int m_a; }; //直接基类B class B: virtual public A{ //虚继承 protected: int m_b; }; //直接基类C class C: virtual public A{ //虚继承 protected: int m_c; }; //派生类D class D: public B, public C{ public: void seta(int a){ m_a = a; } //正确 void setb(int b){ m_b = b; } //正确 void setc(int c){ m_c = c; } //正确 void setd(int d){ m_d = d; } //正确 private: int m_d; };","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"jiangren.work/categories/Objective-C/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"jiangren.work/tags/Objective-C/"},{"name":"面试经验","slug":"面试经验","permalink":"jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"}]},{"title":"GoWeb实战2-并发处理马赛克图片","slug":"GoWeb实战2-并发处理马赛克图片","date":"2020-03-02T05:18:48.000Z","updated":"2020-03-02T20:34:42.000Z","comments":true,"path":"2020/03/02/GoWeb实战2-并发处理马赛克图片/","link":"","permalink":"jiangren.work/2020/03/02/GoWeb%E5%AE%9E%E6%88%982-%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E9%A9%AC%E8%B5%9B%E5%85%8B%E5%9B%BE%E7%89%87/","excerpt":"这个项目的任务是在Web中将用户上传的图片马赛克化，为了提升速度，采用并发模式进行。","text":"这个项目的任务是在Web中将用户上传的图片马赛克化，为了提升速度，采用并发模式进行。 1. 马赛克处理函数马赛克意思是：指定文件夹内有数百张图片，用户上传一张图片后，根据相应的条件，将这数百张图片以方块形式映射到用于上传的图片上，形成马赛克效果。 马赛克处理函数分为以下几块： 马赛克图片数据库的构建 图片RGB通道均值计算函数 缩放函数 图片扫描建档函数 映射 计算欧式距离 寻找最近图片 克隆映射 1.1 马赛克图片数据库的构建RGB均值计算函数如下，返回一个三元数组： func averageColor(img image.Image) [3]float64{ bounds:=img.Bounds() r,g,b :=0.0,0.0,0.0 for y:=bounds.Min.Y;y&lt;bounds.Max.Y;y++{ for x:=bounds.Min.X; x&lt;bounds.Max.X;x++{ r1,g1,b1,_:=img.At(x,y).RGBA() r,g,b = r+float64(r1),g+float64(g1),b+float64(b1) } } totalPixels:=float64(bounds.Max.X * bounds.Max.Y) return [3]float64{r/totalPixels,g/totalPixels,b/totalPixels} } 接下来是图片缩放函数，将指定文件夹内的图片资料缩放： func resize(in image.Image,newWidth int) image.NRGBA{ bounds:=in.Bounds() ratio := bounds.Dx()/newWidth out := image.NewNRGBA(image.Rect(bounds.Min.X/ratio, bounds.Min.X/ratio, bounds.Max.X/ratio, bounds.Max.Y/ratio)) for y,j := bounds.Min.Y,bounds.Min.Y;y&lt;bounds.Max.Y;y,j = y+ratio,j+1{ for x, i := bounds.Min.X, bounds.Min.X; x &lt; bounds.Max.X; x, i =x+ratio, i+1 { r,g,b,a := in.At(x,y).RGBA() out.SetNRGBA(i,j,color.NRGBA{uint8(r&gt;&gt;8), uint8(g&gt;&gt;8), uint8(b&gt;&gt;8), uint8(a&gt;&gt;8)}) } } return *out } 然后是图片扫描建档函数，注意包必须引入import _ &quot;image/jpeg&quot;否则无法解析： func tilesDB() map[string][3]float64{ fmt.Println(&quot;Start populating tiles db ...&quot;) db := make(map[string][3]float64) files,_ := ioutil.ReadDir(&quot;tiles&quot;) for _,f:=range files{ name := &quot;tiles/&quot; + f.Name() file,_:=os.Open(name) img,_,_:=image.Decode(file) db[name]=averageColor(img) file.Close() } fmt.Println(&quot;Finished populating tiles db.&quot;) return db } 1.2 映射首先是计算欧式距离，计算两张图片平均RGB之间的距离： func distance(p1 [3]float64,p2 [3]float64) float64{ r2:=(p2[0]-p1[0])*(p2[0]-p1[0]) g2:=(p2[1]-p1[1])*(p2[1]-p1[1]) b2:=(p2[2]-p1[2])*(p2[2]-p1[2]) return math.Sqrt(r2+g2+b2) } 然后需要在资料库中找到最相似的一张图片，找到以后需要在资料库中删除，以防止重复： func nearest(target [3]float64, db *map[string][3]float64) string{ var filename string smallest := 1000000.0 for k,v := range *db{ dist:=distance(target,v) if dist&lt;smallest{ filename,smallest = k,dist } } delete(*db,filename) return filename } 因为需要删除，所以每次生成图片时我们还需要克隆一份资料库，不然下一次资料库就没了。 var TILESDB map[string][3]float64 func cloneTilesDB() map[string][3]float64{ db := make(map[string][3]float64) for k,v:=range TILESDB{ db[k]=v } return db } 2. Web应用Web应用可以分为两部分：上传和结果显示。 2.1 上传上传部分比较简单，将模板解析后，执行相应的请求即可。 func upload(w http.ResponseWriter, r *http.Request){ t,_:=template.ParseFiles(&quot;upload.html&quot;) t.Execute(w,nil) } 2.2 显示显示部分很复杂，代码如下： func mosaic(w http.ResponseWriter, r *http.Request){ t0:=time.Now() r.ParseMultipartForm(10*1024*1024) file,_,_:=r.FormFile(&quot;image&quot;) //FormFile returns the first file for the provided form key. defer file.Close() tileSize, _:=strconv.Atoi(r.FormValue(&quot;tile_size&quot;)) original,_,_:=image.Decode(file)//文件解码 bounds:=original.Bounds() newimage:=image.NewNRGBA(image.Rect(bounds.Min.X, bounds.Min.X, bounds.Max.X, bounds.Max.Y)) db:=cloneTilesDB() sp:=image.Point{0,0} for y:=bounds.Min.Y;y&lt;bounds.Max.Y;y=y+tileSize{ for x:=bounds.Min.X;x&lt;bounds.Max.X;x=x+tileSize{ r,g,b,_:=original.At(x,y).RGBA() color:=[3]float64{float64(r),float64(g),float64(b)} nearest:=nearest(color,&amp;db) file,err := os.Open(nearest) if err!=nil{ fmt.Println(&quot;error:&quot;,err,nearest) } img,_,err:=image.Decode(file) t:=resize(img,tileSize) tile:=t.SubImage(t.Bounds()) tileBounds := image.Rect(x, y, x+tileSize, y+tileSize) draw.Draw(newimage,tileBounds,tile,sp,draw.Src) file.Close() } } buf1 := new(bytes.Buffer) jpeg.Encode(buf1,original,nil) originalStr:=base64.StdEncoding.EncodeToString(buf1.Bytes()) buf2:=new(bytes.Buffer) jpeg.Encode(buf2,newimage,nil) mosaic:=base64.StdEncoding.EncodeToString(buf2.Bytes()) t1 := time.Now() images:=map[string]string{ &quot;original&quot;:originalStr, &quot;mosaic&quot;:mosaic, &quot;duration&quot;:fmt.Sprintf(&quot;%v&quot;,t1.Sub(t0)), } t,_:=template.ParseFiles(&quot;results.html&quot;) t.Execute(w,images) } 大体上分为三部分： 提取上传文件内容 执行马赛克化 将结果重新编码，送入结果模板 （1）提取上传内容 r.ParseMultipartForm(10*1024*1024) file,_,_:=r.FormFile(&quot;image&quot;) //FormFile returns the first file for the provided form key. defer file.Close() tileSize, _:=strconv.Atoi(r.FormValue(&quot;tile_size&quot;)) original,_,_:=image.Decode(file)//文件解码 上传内容以请求的形式放在了http.request中，前面提到过ParseMultipartForm专门用于解析文件，参数是文件的大小限制（这里限制到10MB）。接着从Form中提取图片文件和马赛克大小。然后将文件解码形成图片。 image.Decode函数第二个返回对象是图片的后缀格式，一个字符串。 （2）执行马赛克化 bounds:=original.Bounds() newimage:=image.NewNRGBA(image.Rect(bounds.Min.X, bounds.Min.X, bounds.Max.X, bounds.Max.Y)) db:=cloneTilesDB() sp:=image.Point{0,0} for y:=bounds.Min.Y;y&lt;bounds.Max.Y;y=y+tileSize{ for x:=bounds.Min.X;x&lt;bounds.Max.X;x=x+tileSize{ r,g,b,_:=original.At(x,y).RGBA() color:=[3]float64{float64(r),float64(g),float64(b)} nearest:=nearest(color,&amp;db) file,err := os.Open(nearest) if err!=nil{ fmt.Println(&quot;error:&quot;,err,nearest) } img,_,err:=image.Decode(file) t:=resize(img,tileSize) tile:=t.SubImage(t.Bounds()) tileBounds := image.Rect(x, y, x+tileSize, y+tileSize) draw.Draw(newimage,tileBounds,tile,sp,draw.Src) file.Close() } } 首先要做准备工作：以原图片为基准，新建一个图片容器，同时克隆一份资料库。然后在循环中找到最佳图片，经过大小缩放，裁剪以后，放到新图片中去。 （3）重新编码 buf1 := new(bytes.Buffer) jpeg.Encode(buf1,original,nil) originalStr:=base64.StdEncoding.EncodeToString(buf1.Bytes()) buf2:=new(bytes.Buffer) jpeg.Encode(buf2,newimage,nil) mosaic:=base64.StdEncoding.EncodeToString(buf2.Bytes()) t1 := time.Now() images:=map[string]string{ &quot;original&quot;:originalStr, &quot;mosaic&quot;:mosaic, &quot;duration&quot;:fmt.Sprintf(&quot;%v&quot;,t1.Sub(t0)), } t,_:=template.ParseFiles(&quot;results.html&quot;) t.Execute(w,images) 这一步就是将图片重新编码为二进制字符串，然后送入模板中解析。 3. 并发化并发的思路很简单：将图片分割为4份，分别执行。但注意，这里存在竞争，因为大家在访问资料库时，每次都会删除，所以我们需要用锁锁起来。","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"},{"name":"并发","slug":"并发","permalink":"jiangren.work/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"GoWeb实战1-数据库与服务器的结合应用","slug":"GoWeb实战1-数据库与服务器的结合应用","date":"2020-03-01T07:29:27.000Z","updated":"2020-03-02T20:33:54.000Z","comments":true,"path":"2020/03/01/GoWeb实战1-数据库与服务器的结合应用/","link":"","permalink":"jiangren.work/2020/03/01/GoWeb%E5%AE%9E%E6%88%981-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BB%93%E5%90%88%E5%BA%94%E7%94%A8/","excerpt":"本节是针对前面学到的数据库操作和Web编程的综合应用。","text":"本节是针对前面学到的数据库操作和Web编程的综合应用。 1. 数据库操作用mysql进行测试，测试用数据源如下，其中order_num作为主键。 1.1 连接初始化连接初始化我们需要4块代码： 连接信息 全局变量：指向数据库的指针 初始化函数 一个结构变量，作为数据载体 首先是连接信息： const( userName =&quot;test&quot; password = &quot;asdfg12345&quot; ip =&quot;cdb-axt937vt.gz.tencentcdb.com&quot; port=&quot;10059&quot; dbName = &quot;test&quot; ) 关键词const加上括号，有两个作用： 变量值自增，类似于C++的枚举（这里用不到） 全部设置为常量类型，比较方便 之后我们需要声明一个全局变量DB，作为数据库的指针。 var DB *sql.DB 然后重点就是初始化连接函数： func init(){ connectInfo:=[]string{userName,&quot;:&quot;,password,&quot;@tcp(&quot;,ip,&quot;:&quot;,port,&quot;)/&quot;, dbName, &quot;?charset=utf8&quot;} path := strings.Join(connectInfo,&quot;&quot;) DB,_=sql.Open(&quot;mysql&quot;,path) if err:=DB.Ping(); err !=nil{ fmt.Println(&quot;open database fail!&quot;) return } fmt.Println(&quot;connect success&quot;) } 必须声明为init()，这个函数就会在主函数之前调用。这个函数首先将零散的连接信息拼接成一个字符切片。strings.Join方法将切片的字符串元素拼接起来，比如： string [] tmpStr={abc,def,ghi}; string jn = string.Join(tmpStr，&quot;-&quot;); //jn=&quot;abc-def-ghi&quot; 我们之前已经通过如下语句引入了Mysql驱动： import _&quot;github.com/Go-SQL-Driver/MySQL&quot; 所以DB,_=sql.Open(&quot;mysql&quot;,path)可以直接连接mysql。链结构，还要利用ping来检测连接是否成功。 之后，我们需要针对特定的数据指定相应的结构体来承载数据： type Orders struct{ Order_num int `json:&quot;order_num&quot;` Order_date string `json:&quot;order_date&quot;` Cust_id int `json:&quot;cust_id&quot;` } 1.2 查询查询我们分为两类： 单行查询，指定主键，查询内容 多行查询，返回所有内容 单行查询非常简单，思路是：传入查询的主键，返回查询结果（order结构）和错误。具体步骤是： 新建一个order结构，不要使用:=。 调用查询语句 将查询结果扫描进order结构，同时赋值错误，不要使用：= func QueryOne(id int)(order Orders,err error){ order = Orders{} row := DB.QueryRow(&quot;SELECT order_num, order_date,cust_id FROM orders WHERE order_num=?&quot;,id) err = row.Scan(&amp;order.Order_num,&amp;order.Order_date,&amp;order.Cust_id) return } 主要需要关注查询语句，可以通过order_num=?向其中填值。 多行查询比较特殊，我们调用查询语句后返回的一个特殊的数据结构database/sql.Rows 结构体的Next()函数能够判断，是否存在下一行，因此我们需要循环读取，每次扫描都会清除一行： func QueryMulti()(orders[] Orders,err error){ orders =[]Orders{} rows,err:=DB.Query(&quot;SELECT * FROM orders&quot;) if err!=nil{ fmt.Printf(&quot;Query failed,err:%v\\n&quot;, err) return } i:=0 for rows.Next(){ orders=append(orders, Orders{}) newerr := rows.Scan(&amp;orders[i].Order_num,&amp;orders[i].Order_date,&amp;orders[i].Cust_id) if newerr != nil { fmt.Printf(&quot;Scan failed,err:%v\\n&quot;, err) } i++ } return } 另一个重点是改用切片的形式返回数据，在next循环中切片需要用append添加！ 1.2 修改数据改动数据有三种方式：增加、删除、更新，这三种方法其实大同小异。这里我们需要使用事务来保证原子性，防止并发时的资源竞争。 一般查询使用的是db对象的方法，事务则是使用另外一个对象。sql.Tx对象。使用db的Begin方法可以创建tx对象。 创建Tx对象的时候，会从连接池中取出连接。事务的连接生命周期从Beigin函数调用起，直到Commit和Rollback函数的调用结束。事务也提供了prepare语句的使用方式，但是需要使用Tx.Stmt方法创建。所以在事务开启过程中，是不能使用DB的方法的！ tx, err := db.Begin() db.Exec(query1) //wrong! tx.Exec(query2) tx.commit() func Insert(order Orders)(err error){ tx,err := DB.Begin() if err != nil{ fmt.Println(&quot;tx fail&quot;) return } stmt,err := tx.Prepare(&quot;INSERT INTO orders (`order_num`,`order_date`,`cust_id`) VALUES(?,?,?)&quot;) if err != nil{ fmt.Println(&quot;Prepare fail&quot;) return } res,err:=stmt.Exec(order.Order_num,order.Order_date,order.Cust_id) if err != nil{ fmt.Println(&quot;Exec fail&quot;) return } tx.Commit() fmt.Println(res.LastInsertId()) return } func Delete(id int) (err error){ tx,err := DB.Begin() if err != nil{ fmt.Println(&quot;tx fail&quot;) return } stmt,err := tx.Prepare(&quot;DELETE FROM orders WHERE order_num = ?&quot;) if err != nil{ fmt.Println(&quot;Prepare fail&quot;) return } res,err:=stmt.Exec(id) if err != nil{ fmt.Println(&quot;Exec fail&quot;) return } tx.Commit() fmt.Println(res.LastInsertId()) return } 2. 服务端操作服务端操作我们遵从REST原理：设计那些通过标准的几个动作来操纵资源。假设我们需要三个操作： 获取单行数据GET 获取全部数据MULTIGET 插入数据INSERT 删除数据DELETE 首先是主程序： func main(){ server := http.Server{ Addr:&quot;127.0.0.1:8080&quot;, } http.HandleFunc(&quot;/order/&quot;,handleRequest) server.ListenAndServe() } 这里使用了多路复用器handleRequest，多路复用器会根据请求使用的HTTP方法，把请求转发给相应的CRUD(create, read, update, delete)处理器函数。 func handleRequest(w http.ResponseWriter, r *http.Request){ var err error switch r.Method{ case &quot;GET&quot;: err = handleGet(w,r) case &quot;MULTIGET&quot;: err = handleMultiGet(w,r) case &quot;INSERT&quot;: err = handleInsert(w,r) case &quot;DELETE&quot;: err = handleDelete(w,r) } if err!=nil{ http.Error(w, err.Error(), http.StatusInternalServerError) return } } 下面就是多路复用器CRUD函数的实现： 2.1 查询数据这一类操作，我们只需要发送相应的主键ID，即可操作数据。由于查询结果需要通过响应包返回，所以我们还需要将其转化为JSON格式，完整步骤如下： 从URL中解析出想要查询的主键ID 调用数据库查询函数获取查询结果（order结构体） 将结果转化为JSON格式 封装响应包（头，主体，状态码） func handleGet(w http.ResponseWriter, r *http.Request) (err error){ id, err :=strconv.Atoi(path.Base(r.URL.Path)) if err!=nil{ return } order, err := QueryOne(id) if err!=nil{ return } output, err := json.MarshalIndent(&amp;order, &quot;&quot;, &quot;\\t\\t&quot;) if err != nil { return } w.Header().Set(&quot;Content-Type&quot;,&quot;application/json&quot;) w.Write(output) w.WriteHeader(200) return } 在命令行输入： curl -i -X GET http://127.0.0.1:8080/order/20011 即可查询主键为20011的数据 集体查询不需要解析URL， func handleMultiGet(w http.ResponseWriter, r *http.Request)(err error){ //_, err =strconv.Atoi(path.Base(r.URL.Path)) if err!=nil{ return } orders, err := QueryMulti() if err!=nil{ return } output, err := json.MarshalIndent(&amp;orders, &quot;&quot;, &quot;\\t\\t&quot;) if err != nil { return } w.Header().Set(&quot;Content-Type&quot;,&quot;application/json&quot;) w.Write(output) w.WriteHeader(200) return } 在命令行输入： curl -i -X MULTIGET http://127.0.0.1:8080/order/ 即可查询所有数据。 2.2 删除数据删除数据不需要返回内容，所以更简单： func handleDelete(w http.ResponseWriter, r *http.Request)(err error) { id,err:=strconv.Atoi(path.Base(r.URL.Path)) if err!=nil{ return } err = Delete(id) if err != nil { return } w.WriteHeader(200) return } 使用方法集体查询一样，只是将指令MULTIGET换成DELETE。 2.3 插入数据插入数据有点像查询数据的逆过程： 解析URL，读取JSON数据 解析JSON数据，形成order结构体 调用数据库插入函数 func handleInsert(w http.ResponseWriter, r *http.Request)(err error){ len := r.ContentLength body := make([]byte,len) r.Body.Read(body) var order Orders json.Unmarshal(body,&amp;order) err = Insert(order) if err!=nil{ return } w.WriteHeader(200) return } 请求包的主体BODY是一个二进制数据，所以我们需要创建一个二进制切片来存储。 在命令行输入： curl -i -X INSERT -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;order_date&quot;:&quot;2020-01-01 00:00:00&quot;,&quot;cust_id&quot;:&quot;10086&quot;}&#39; http://127.0.0.1:8080/order/","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"}]},{"title":"CPP面试题目汇总","slug":"CPP面试题目汇总","date":"2020-02-23T05:55:39.000Z","updated":"2020-03-26T12:36:00.000Z","comments":true,"path":"2020/02/23/CPP面试题目汇总/","link":"","permalink":"jiangren.work/2020/02/23/CPP%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/","excerpt":"cpp的内容整理。","text":"cpp的内容整理。 1. 基本概念1.1 string和char数组的区别string的字面值是char数组，可以将string理解为vector&lt;char&gt;。 字符串字面值不能相加： string s5 = &quot;hello&quot; + &quot;, &quot;; // 错误，两个运算对象都不是 string string s1=s2+&quot;1&quot;; //ok 1.2 unsigned类型unsigned类型是unsigned int的简写。范围0-255，超出结果会wrap around环绕。 int x=1e10; //得到一个随机值 unsigned s=257 //得到1 要小心： for (unsigned u = 10; u &gt;= 0; --u) std::cout &lt;&lt; u &lt;&lt; std::endl //死循环 1.3 变量初始化方法初始化的办法有4种： int a=0; int a={0}; int a(0); int a{0}; 花括号初始化成为list initialization，编译器能帮助我们阻止信息丢失。 long double pi=3.1415926535; int a{pi}; //error int a=pi; //ok,but loss information 1.4 引用和指针引用是另一个变量的别名。只能绑定某个对象，不能绑定字面值或者表达式的结果，int &amp;a=10;就是错的。 指针是一个复合类型：改造符*+基本类型。我们可以使用解引用(derefence)运算符来访问对象。注意：**定义的时候 是一个modifier，使用的时候是一个 dereference，概念不一样！** 空指针的意思是：没有任何一个对象和指针绑定。void*是一个特殊的指针类型，可以承载任意类型的对象的地址，但类型时未知的。 double dval =3.14; void* pv = &amp;dval;//pv还是 void*类型 二者区别： 相同点： 都是复合类型（基本类型+改造符或声明符） 都是间接访问 不同点： 指针本身就是一个对象而引用不是，所以指针可以被赋值和拷贝，而引用不能。指针不需要定义时初始化。 一个指针可以指向好几个不同的对象，而引用则被绑死 1.5 类和结构体的区别class class 在堆中分配空间，栈中保存的只是引用 默认是private struct struct 在栈中分配空间 默认是public 1.6 IO特性我们希望IO以流的形式输入输出数据，所以不希望被干扰，因此IO类没有拷贝和赋值函数。 1.8 IO刷新缓冲区的原因 程序跑完，从main中返回 缓冲区满 特殊符号endl，flush，ends结尾 使用unitbuf操作符，默认情况下，unitbuf为cerr默认设置 前面提到了用endl，flush，ends结尾。我们最常用的endl：结束当前行，刷新缓冲区。flush刷新缓冲区，末尾不添加字符，而ends除了刷新缓冲区外，末尾还会添加一个空字符。 注意：程序崩了是不刷新缓冲区的。 1.9 全局变量和局部变量有什么区别？编译器是怎么判断的？全局变量的生命周期伴随主程序（不是主函数）的创建和销毁，局部变量只存在于局部函数内部。 全局变量分配在全局数据段，而局部变量则分配在堆栈里面。 1.10 生成可执行文件的过程 用编辑器编写源代码，如.c文件。 用编译器编译代码生成目标文件，如.o。 用链接器连接目标代码生成可执行文件，如.exe。 1.11 cmake和makefile区别利用make工具可以根据makefile批量处理源文件。而cmake可以读取所有源文件后，自动生成makefile，更加方便。 1.12 int (*s[10])(int) 表示的是什么？int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。 int (*fp)(int a); //fp可以指向如下函数 int myFunction(int a){...} 1.13 联合一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。 union abc { int i; char m; }; union abc a; a.i = 10; 2. 关键词和操作符2.1 externCPP初始化通常分为两个部分： 声明，让程序知道他的名字 定义，实现实体。 用extern关键词来进行声明，这样就不用进行显示初始化。 对比： extern int a; int b; 2.2 constexpr当一个变量声明为const时，我们并不知道它是编译期可知还是运行期可知。 const int a=10; //constant expression const int b=get_size(); //non a constant expression 关键词constexpr就是指编译期可知，潜台词是：告诉编译器我可以是编译期间可知的，尽情的优化我吧。而const专门用来声明不变量，潜台词是：告诉程序员没人动得了我，放心的把我传出去；或者放心的把变量交给我，我啥也不动就瞅瞅。 另一个作用是让类的静态成员在类间能够初始化： class Account { public: static double rate() { return interestRate; } static void rate(double); private: static constexpr int period = 30;// period is a constant } 2.3 sizeof它不是一个关键词，而是一个运算符！！！以位的形式返回表达式结果的大小。 vector&lt;int&gt; a{1,2,3}; auto m = sizeof a; // type is unsigned_int64, m = 32 auto n = sizeof a[0]; //type is the same as above, n=4; 2.4 mutable在成员函数参数列表后加上关键字const后，该函数不允许修改类的数据成员。 char Screen::get() const { return _screen[_cursor]; } 对成员变量加上mutable关键词可以消除const的影响： class Screen { public: void some_member() const; private: mutable size_t access_ctr; } void Screen::some_member() const { ++access_ctr; } 2.5 explicit使用关键词explicit抑制隐式转化： class A{ public: explicit A(int size){} explicit A(const Explicit&amp; ins){} }; int main(){ A test0(15); A test1 = 10;// 无法调用 A test5 = test0;//无法调用 //如果去掉explicit,就都可以调用。 } 2.6 inline声明为内联函数，则： 相当于把内联函数里面的内容写在调用内联函数处； 相当于不用执行进入函数的步骤，直接执行函数体； 优点：省去了代码展开，提高速度；缺点：代码体积膨胀。 2.7 volatile作用：阻止编译器优化，确保编译器总是从内存中读取数据 原因：因为访问寄存器要比访问内存单元快的多，所以编译器一般优化代码，尽量读取寄存器，但在多线程过程中可能会读脏数据。 2.8 typedef structstruct Student{ int a; }stu1;//stu1是一个变量 typedef struct Student2{ int a; }stu2;//stu2是一个结构体类型 auto m = stu1.a; //ok auto n = stu2.a; //error stu2 st; auto n = st.a;//ok 3. new3.1 new和delete的执行过程new的步骤： 分配一块足够大的原始的未命名的内存空间 调用相应的构造函数构造对象，为其传入初值 构造结束后返回该对象的指针 delete步骤： 调用对象的析构函数 编译器释放内存空间 3.2 动态数组有的时候编译时并不能确定数组长度，我们需要通过动态方式分配长度。 int* p = new int[obj.getlen()]; // new运算符返回第一个元素的地址。 delete [] p; // 释放整个数组，new如果带[] 则delete也需要带[] 使用new和delete时，应遵守以下规则 避免使用delete来释放不是new分配的资源； 不要对同一资源delete两次 使用new[]分配资源时，应使用delete[]来释放 可以对空指针delete 3.3 智能指针使用new关键词分配动态内存会返回指向对象的指针。为了避免管理内存的麻烦，引入带有OS机制的智能指针： shared_ptr，允许多个指针指向同一个对象 unique_ptr，对对象拥有唯一所有权，可以移动但不能复制 weak_ptr，和shared_ptr搭配使用检测他是否空悬，每次使用时不会影响指向对象的引用计数 这几个指针的使用规则： 使用shared_ptr: 初始化时，最好用函数分配内存，也可以传统的new分配 shared_ptr&lt;string&gt; p1=make_shared&lt;string&gt;(&quot;hello&quot;); shared_ptr&lt;int&gt; p2=make_shared&lt;int&gt;();//empty shared_ptr&lt;int&gt; p3(new int(10)); reset函数作用 p = std::make_shared&lt;int&gt;(5); p.reset(new int(5));//等价 p = nullptr; p.reset();//等价 使用unique_ptr： 不像shared_ptr那样有函数可以用，unique_ptr必须要用new分配空间： unique_ptr&lt;int&gt; p2(new int(42)); 它不能被拷贝和赋值： unique_ptr&lt;int&gt; p1=new int(42); auto p2(p1);//error auto p3 = p1;//error 但我们可以用reset和release转移 unique_ptr&lt;int&gt; p1(new int(42)); unique_ptr&lt;int&gt; p2(p1.release()); unique_ptr&lt;int&gt; p3(new int(10)); p3.reset(p2.release); 使用release的时候要特别小心，auto会默认推导为普通指针类型，所以需要手动delete，不然就泄露了。 auto p2(p1.release()); //int* 在函数中，我们能够将unique_ptr传递出去： unique_ptr&lt;int&gt; help(A a){ unique_ptr&lt;A&gt; pa(new A(a)); return pa; } 3.4 new和malloc区别总结起来就是两反，两内，两重（反冲累），狗租户(返回类型，失败返回，内存位置，内存大小指定，重新分配内存，重载，构造，数组，互相调用) 1.返回类型 new操作符分配成功是返回的指针类型和预期结果相同，无序进行转化，而malloc返回为void*，需要强制转化 char* p1=static_cast&lt;char&gt;(malloc(10)); 2.失败返回 new分配失败时，抛出bad_alloc异常，而malloc失败时返回NULL。 3.内存位置 new从自由内存区申请(free store)，malloc从堆上申请。自由内存区可以是堆也可以不是，这取决于实现细节，也可以是静态内存区。 4.是否指定内存大小 new分配时无须指定内存块的大小，编译器自行计算，而malloc则需要显式指出内存大小。 5. 是否可以被重载 new和delete可以，malloc不可以 6. 重新分配内存 使用malloc分配的内存后，可以使用realloc函数进行内存重新分配实现内存的扩充。如果原地内存足够则直接扩大，如果不足则重新找一块地方。new不具备重新分配的能力，只能另起炉灶。 7. 构造函数 new会调用构造函数和析构函数，而malloc只是分配内存空间。 8. 处理数组 C++提供了new[]和delete[]来专门处理数组。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。 A * ptr = new A[10];//分配10个A对象 delete [] ptr; malloc需要手动指定数组大小： int * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组 9. 是否可以互相调用 new可以重载调用malloc，而malloc反过来则不行。 4. const4.1 const和#define相比优点是什么？define是宏定义，只是换了一个名字。而使用const时编译器会对const进行类型检查。4.2 const用处（1）变量被指定为const 一个变量被指定为const类型后，不能再赋值： const int bufsize =512; bufsize =100; //error （2）引用被指定为const 对于const变量的引用也不能再赋值： const int ci=1024; const int &amp;rci = ci; rci =42; //error 用const引用来引用non-const值，这样可以修改原值，导致cosnt引用的结果也会改变。但同样的问题，不能修改const引用的结果。 int i=43; const int &amp;ri=i; ri=10; //error i =10; //ok （3）指针指定为const 用法和引用相同，用const指针来指向non-const值，这样可以修改原值： int m=10; const int* ptr = &amp;m; //ok, const pointer to non-const varible m = 20; //ok 4.3 为什么要使用常引用？如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。 4.4 什么是顶层常量和底层常量？使用const修饰指针时，指针的属性有两种状态：const int *,int * const状态很容易混淆。在复制时，顶层常量可以被忽略，而底层常量会被限制： int i = 0; int * const p1 = &amp;i; //顶层const int *x = p1; // 正确，可以忽略p1的顶层const int n = *p1; // 正确 int i = 0; const int * p1 = &amp;i; //底层const int *x = p1; // 错误，*x不具备底层const资格 const int *x2 = p1; // 正确，具备底层const资格 4.5 类的成员函数使用const前面使用const 表示返回值为const；后面加 const表示函数不可以修改class的成员。 const int FunctionConst::getValue(){ return value;//返回值是 const, 使用指针时很有用. } int FunctionConst::getValue2() const{ //此函数不能修改class FunctionConst的成员函数 value value = 15;//错误的, 因为函数后面加 const return value; } 如果返回值是指针时，前面使用const可以防止函数调用表达式作为左值，使得指针的内容被修改。 5.类与对象5.1 类和结构体区别 class class 是引用类型，它在堆中分配空间，栈中保存的只是引用 默认是private struct struct 是值类型，它在栈中分配空间 默认是public 5.2 构造函数中const和引用的初始化class A{ public: A(int ii); private: int i; const int ci; int&amp; ri; } A::A(int ii){ i = ii; //ok ci = ii; //error; ri = ii; //error } const和引用的初始化必须在创建的时候就要完成，所以我们需要用列表初始化： A::A(int ii):i(ii),ci(ii),ri(i){} 5.3 静态成员静态成员不属于任何一个实例化的对象。假如我们有一个银行账户类，每天的利率是一个统一的数值，我们不需要为每个账户都去设置，只需要设置一个静态成员，让所有账户share就行。 由于静态成员独立于实例化对象之外存在，对于静态成员函数来说，他们没有this指针。 静态成员在类外可以使用两种办法访问： 作用域符， r=Account::rate(); 传统办法（对象，引用，类指针） Account ac1; Account ac2; r=ac1.rate(); r=ac2-&gt;rate(); 在类间可以直接访问。 由于静态成员不属于任何一个对象，所以构造函数对他是无效的，我们要初始化一个静态成员得通过函数在类外进行初始化。 使用constexpr或者const可以让他在类间初始化： class Account { public: static double rate() { return interestRate; } static void rate(double); private: static constexpr int period = 30;// period is a constant } 5.4 类的特殊成员函数有5个：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数。 拷贝函数的定义：第一个参数是类的引用 class Foo{ public: Foo();//default Foo(Foo const&amp;);//copy } 拷贝赋值运算符：本质是重载了=运算符，运算符重载可以理解为：返回类型，函数名称，传入参数。赋值运算符通常应该返回一个指向其左侧对象的引用 class Foo{ public: Foo&amp; operator=(Foo const&amp;); } 析构函数：析构时会先执行函数体，成员销毁时时按照生成时的逆序发生的。析构时，先调用派生类析构函数，再调用基类. class A{ public: int i; A(int const&amp; _i) :i(_i) {} ~A(){ cout &lt;&lt; i; } };//先输出i，再销毁 5.5 析构函数注意事项如果要自定义析构，则必须自定义拷贝和赋值。主要是针对浅拷贝和深拷贝的问题。 //深拷贝 HasPtr&amp; operator=(HasPtr const&amp; rhs){ this-&gt;ps = new size_t[num]; this-&gt;num = rhs.num; for(int i=0;i&lt;num;i++) this-&gt;ps[i]=rhs.ps[i]; return this*; } //浅拷贝 HasPtr&amp; operator=(HasPtr const&amp; rhs){ this-&gt;num=rhs.num; this-&gt;ps = rhs.ps; return this*; } 由于两个指针指向同一片内存区域，如果其中一个被释放，则另一个变成野指针。用智能指针可以避免： int* p1 = new int(5); int* p2 = p1; delete p1; //野 shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(5); auto p4 = p3; p3.reset();//ok 5.6 合成构造函数当我们只是传入了一个类的对象，编译器会帮助我们利用这个对象进行合成构造，具体如下： class Sales_data{ public: Sales_data(const Sales_data&amp;); private: std::string bookNo; int units_sold = 0; double revenue = 0.0; }; //与Sales_data的合成拷贝构造函数等价 Sales_data::Sales_data(const Sales_data &amp;orig) : bookNo(orig.bookNo), //使用string的拷贝构造函数 units_sold(orig.units_sold), //拷贝orig.units_sold revenue(orig.revenue) //拷贝orig.revenue {} } 5.7 default和delete使用关键词default以后可以显示地让编译器生成合成构造函数。delete可以禁用某些特殊成员函数。 比如比如Iostream类就不希望有多个对象访问IO相同的IO口。因此我们呢使用=delete禁用拷贝构造和赋值运算符。 5.8 如何区分移动和拷贝的重载？方法1，利用const void push_back(X const&amp;); void push_back(X&amp;&amp;); 方法2，利用引用限定符 class Foo{ public: void sorted()&amp;&amp; {cout &lt;&lt; &quot;&amp;&amp;&quot;&lt;&lt;endl;} void sorted()&amp; {cout &lt;&lt; &quot;&amp;&quot; &lt;&lt; endl;} }; Foo&amp;&amp; retVal(){ Foo f; return std::move(f); } Foo&amp; retFoo(){ Foo f; return f; } int main(){ retVal().sorted(); //&amp;&amp; retFoo().sorted(); //&amp; } 5.9 this指针它指向当前对象，通过它可以访问当前对象的所有成员。 void Student::setname(char *name){ this-&gt;name = name; } 5.10 访问私有成员的办法 类的成员函数访问 友元函数 6. 面向对象6.1 oop特征三大特征：封装、继承、多态 封装：分离接口和实现过程 继承：应用类之间的相似性 多态：函数复用 6.2 虚函数虚函数并不是不实现，纯虚函数virtual void foo()=0;才是不实现（比如shape类中，我实在不想写area的表达过程，就让他成为纯虚函数，方便格式统一）。虚函数主要是用来简便地实现多态的，核心理念就是通过基类访问派生类定义的函数。 多态分两种： 编译时多态，重载 运行时多态，重写（重写是子类对父类的允许访问的方法的实现过程进行重新编写） 当API不会知道实际传进来的指针或引用是哪个类型时，先用一个基类接一下传进来的指针，在运行时根据类型安排虚函数执行。 class BaseItem { public: virtual void itemMethod()=0; }; class ItemA :public BaseItem { public:void itemMethod() override { cout &lt;&lt; &quot;ItemA&quot;&lt;&lt;endl; } }; class ItemB :public BaseItem { public:void itemMethod() override { cout &lt;&lt; &quot;ItemB&quot; &lt;&lt; endl; } }; class ItemC :public BaseItem { public:void itemMethod() override { cout &lt;&lt; &quot;ItemC&quot; &lt;&lt; endl; } }; int main(){ vector&lt;shared_ptr&lt;BaseItem&gt;&gt; ItemCollection; shared_ptr&lt;BaseItem&gt; p; //基类指针指向派生类！ p.reset(new ItemA()); ItemCollection.push_back(p); p.reset(new ItemB()); ItemCollection.push_back(p); p.reset(new ItemC()); ItemCollection.push_back(p); for (auto it : ItemCollection) { it-&gt;itemMethod(); } } C++11中允许使用override关键词显式注明虚函数的重写，如果重写失败就报错(不加的话会误以为一个新函数)(IDE推荐使用override) struct B{ virtual void f1(int) const; virtual void f2(); void f3(); }; struct D1 : B { void f1(int) const override; // ok: f1 matches f1 in the base void f2(int) override; // error: B has no f2(int) function void f3() override; // error: f3 not virtual } 6.3 虚函数表当上行转换时(从派生类到基类)可以通过隐式转化或static_cast完成，但要完成下行转化就需要借助dynamic_cast。虚函数表的作用就是完成上下行转换，实现动态绑定。 每一个包含虚函数的类（不是对象）都有一个自己的虚表 class A { public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2(); private: int m_data1, m_data2; }; 虚表是一个指针数组，其元素是虚函数的指针，每一个元素对应一个虚函数（普通函数不需要经过虚表）。 当某个类生成一个对象时，编译器在类中就添加了一个指针*_vptr，指向虚表 虚表是如何实现动态绑定的呢？ class A { public: virtual void vfunc1(); virtual void vfunc2(); }; class B : public A { public: virtual void vfunc1(); }; class C: public B { public: virtual void vfunc2(); }; 当我们调用的时候: B bObject; A* p = &amp;bObject; p-&gt;vfunc1(); //调用B::vfunc1(); 程序在执行p-&gt;vfunc1();时，我们检查了三大条件： 对象是指针或引用形式 静态类型和动态类型不同 带虚函数的继承体系 所以现在动态类型现在生效。此时，并没有将p完全变为A，而是保留了B的虚函数表，所以我们调用的时候还是按B的虚函数表索引！","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"面试经验","slug":"面试经验","permalink":"jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"}]},{"title":"数据结构面试题目汇总","slug":"数据结构面试题目汇总","date":"2020-02-22T05:56:25.000Z","updated":"2020-03-31T10:42:56.000Z","comments":true,"path":"2020/02/22/数据结构面试题目汇总/","link":"","permalink":"jiangren.work/2020/02/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/","excerpt":"本篇针对的是问答题而不是编程题，所以大部分都是在文字叙述，外加少部分的编程。","text":"本篇针对的是问答题而不是编程题，所以大部分都是在文字叙述，外加少部分的编程。 1. 树1.1 区分完全二叉树、满二叉树、搜索二叉树完全二叉树：假设树有N层，则第1到第N-1层都是满节点 满二叉树：满足完全二叉树，但第N层没有任何节点 二叉搜索树：任意节点的左子树不为空，则左子树的所有值均小于根节点；反之右子树大于根节点。 1.2 什么是平衡二叉树(VAL树)？满足三个条件： 是二叉搜索树 左右子树深度之差不大于1 左右子树分别都是平衡二叉树 1.3 什么是哈夫曼树？给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，则称其为最优二叉树，也叫哈夫曼树。特征是权值较大的结点离根较近。 构建时，先对叶节点的权值排序，然后合并： 1.4 什么是红黑树？特性：自平衡 时间复杂度：普通二叉搜索树的时间复杂度为$O(\\lg n)$到$O(n)$，而红黑树能保持在lgn。最极端的情况：最长子树是最短子树的两倍。 五大原则： 每个节点或者是黑色，或者是红色。 根节点是黑色。 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]** 如果一个节点是红色的，则它的子节点必须是黑色的。 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 维持自平衡的方法：左旋，右旋，变色 1.5 什么是红黑树的左旋右旋？ 左旋动图 右旋动图 代码实现： 节点左旋必须有右孩子，右旋必须有左孩子。 如果N经过旋转变成了根节点，一定要记得将RBTree结构体中的根节点指针root指向N，这是容易出错的地方。 const ( // 左旋 LEFTROTATE bool = true // 右旋 RIGHTROTATE bool = false ) // rotate() true左旋/false右旋 // 若有根节点变动则返回根节点 func (rbnode *RBNode) rotate(isRotateLeft bool) (*RBNode, error) { var root *RBNode if rbnode == nil { return root, nil } if !isRotateLeft &amp;&amp; rbnode.left == nil { return root, errors.New(&quot;右旋左节点不能为空&quot;) } else if isRotateLeft &amp;&amp; rbnode.right == nil { return root, errors.New(&quot;左旋右节点不能为空&quot;) } parent := rbnode.parent var isleft bool if parent != nil { isleft = parent.left == rbnode } if isRotateLeft { grandson := rbnode.right.left rbnode.right.left = rbnode rbnode.parent = rbnode.right rbnode.right = grandson } else { grandson := rbnode.left.right rbnode.left.right = rbnode rbnode.parent = rbnode.left rbnode.left = grandson } // 判断是否换了根节点 if parent == nil { rbnode.parent.parent = nil root = rbnode.parent } else { if isleft { parent.left = rbnode.parent } else { parent.right = rbnode.parent } rbnode.parent.parent = parent } return root, nil } 1.6 红黑树相较于AVL树的优势是什么？AVL树是绝对平衡的二叉树，所有子树都必须满足深度之差为1的强条件，这会对插入删除带来较大的麻烦。而红黑树可以能确保树的最长路径不大于两倍的最短路径的长度(依然可以保证lgn)，虽然查找时性能没有AVL树那么好，但增添和删除更为便捷。 1.7 红黑树和哈希表二者该如何选择？考虑三个方面： 内存：如果内存有限制，使用map能节约内存 数据量：如果数据量较小，使用map比较好。反之，数据量大，map的层数太多，用哈希表比较好。 扩展性：如果数据是静态的，哈希表会比较好。如果需要拓展，则红黑树比较好。 1.8 红黑树在什么情况下可能发生红黑节点冲突？插入操作时，需要解决红红冲突，因为红黑树的一条性质是如果一个节点是红色的，那么其子节点都是黑色的。 1.9 map和unordered_map的底层实现有什么不同？map底层是基于红黑树实现的，因此map内部元素排列是有序的。而unordered_map底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的。 1.10 什么是B-树-是连接符，不读B减，是一种多路搜索树。所有的非终端结点中包含下列信息数据：（n，A0，K1，A1，K2，A2，…，Kn，An）； n 表示结点中包含的关键字的个数，取值范围是：⌈m/2⌉-1≤ n ≤m-1。Ki （i 从 1 到 n）为关键字，且 Ki &lt; Ki+1 ；Ai 代表指向子树根结点的指针，且指针 Ai-1 所指的子树中所有结点的关键字都小于 Ki，An 所指子树中所有的结点的关键字都大于 Kn。 所示就是一棵 4 阶的 B-树，这棵树的深度为 4： 1.11 什么是B+树 B+树所有叶子节点的链表中包含了全部关键字的信息， 及指向含这些关键字记录的指针 叶子节点的链表是有序的 非终端节点只是索引的一部分，节点中仅含有其子树（根节点）中的最大（或最小)关键字 2. 堆栈2.1 什么时候可能发生栈溢出 局部数组过大。解决办法：增大栈空间或者使用动态分配(堆空间) 递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。 指针或者数组越界。 2.2 堆和栈的区别 地址方向：堆是由低地址向高地址扩展；栈是由高地址向低地址扩展 管理方式：堆中的内存需要手动申请和手动释放；栈中内存是由OS自动申请和自动释放 使用效率：堆中频繁调用malloc和free,会产生内存碎片，降低程序效率；而栈由系统分配，不会产生内存碎片 2.3 什么是小根堆和大根堆？小根堆： 若存在左子节点，则根节点的值小于左子节点 若存在右子几点，则根节点的值小于左子节点 大根堆，小于换成大于。 3. 排序3.1 选择排序选择一组数列中最小的一个放到前面去。 func selectSort(b []int) []int { n:=len(b) a:=make([]int,n) copy(a,b) for i:=0;i&lt;n;i++{ min:=i for j:=min+1;j&lt;n;j++{ if a[j]&lt;a[min]{ min=j } } swap(a,i,min) } return a } 选择、插入、希尔都是N^2级别的排序，希尔的平均速度要快于前两种。 3.2 插入排序对于某数n来说，前n-1个数已经完成排序，则n要插入到其中正确的位置。编程时双循环，第一个循环表明确定序列的范围，第二个循环则是将n与n-1，n-2…相比较，确定位置（冒泡） func insertSort(b []int)[]int{ n:=len(b) //切片传进来都是地址，要拷贝 a:=make([]int,n) copy(a,b) for i:=1;i&lt;n;i++{ for j:=i;j&gt;=1;j--{ if a[j-1]&gt;a[j]{ //注意这里的符号 swap(a,j-1,j) } } } return a } void inserSort(vector&lt;int&gt;&amp; a) { int n = a.size(); for (int i = 1; i &lt; n; i++) { for (int j = i; j &gt;= 1; j--) { if (a[j - 1] &gt; a[j]) { swap(a[j - 1], a[j]); } } } } 3.3 希尔排序也就是分组插入排序，编程时三重循环，第一重是步长选择，初始值为length/2，每次迭代都除以2，直到为0；后面两重循环和插入排序一模一样，只不过把i替换为step；比如正常插入排序i=1，把1替换为step即可完成希尔排序。 func shellSort(b []int)[]int{ n:=len(b) a:=make([]int,n) copy(a,b) for step:=n/2;step&gt;=1;step=step/2{ //分组 for i:=step;i&lt;n;i++{ //在不同组内进行 for j:=i;j&gt;=step;j=j-step{ if a[j-step]&gt;a[j] { swap(a, j-step, j) } } } } return a } void shellSort(vector&lt;int&gt;&amp; a) { int n = a.size(); for (int len = n / 2; len &gt;= 1; len = len / 2) { for (int i = len; i &lt; n; i++) { for (int j = i; j &gt;= len; j--) { if (a[j - len] &gt; a[j]) { swap(a[j - len], a[j]); } } } } } 3.4 归并排序 func mergeSort(b []int) []int{ n:=len(b) a:=make([]int,n) copy(a,b) //在排序前，先建好临时数组，避免递归中频繁开辟空间 tmp:=make([]int,n) sort(a,0,n-1,tmp) return a } func sort(a []int,left int, right int, tmp []int){ if left&lt;right{ mid:=(left+right)/2 sort(a ,left,mid,tmp) //左半边归并 sort(a, mid+1,right,tmp) //右半边归并 merge(a,left,mid,right,tmp) } } func merge(a []int,left,mid,right int,tmp []int){ i,j,t:=left,mid+1,0 for i&lt;=mid&amp;&amp;j&lt;=right { //融合的前提是左半边和右半边分别有序 if a[i]&lt;=a[j]{ tmp[t]=a[i];t++;i++ }else{ tmp[t]=a[j];t++;j++ } } //一边比完后，就把剩下的一边全放进去 for i&lt;=mid{ tmp[t]=a[i];t++;i++ } for j&lt;=right{ tmp[t]=a[j];t++;j++ } t=0 for left&lt;=right{//将排好的放回原数组 a[left]=tmp[t];left++;t++ //必须有left！！！！ } } 大O代表的算法法复杂度一样只是说明随着数据量的增加，算法时间代价增长的趋势相同。在公式里各个排序算法的前面都省略了一个c，这个c对于堆排序来说是100，可能对于快速排序来说就是10，但因为是常数级所以不影响大O。 https://blog.csdn.net/qq_39521554/article/details/79364718 void merge(vector&lt;int&gt;&amp; a, int left, int right, int mid) { vector&lt;int&gt; tmp(right - left+1,0); int p1 = left, p2 = mid + 1, index = 0; while (p1 &lt;= mid &amp;&amp; p2 &lt;= right) { tmp[index++] = a[p1] &gt; a[p2] ? a[p2++] : a[p1++]; } while (p1 &lt;= mid) { tmp[index++] = a[p1++]; } while (p2 &lt;= right) { tmp[index++] = a[p2++]; } for (int i = 0; i &lt; tmp.size(); i++) { a[left + i] = tmp[i]; } } void cut(vector&lt;int&gt;&amp; a, int left, int right) { if (left &lt; right) { int mid = (left + right) / 2; cut(a, left, mid); cut(a, mid + 1, right); merge(a, left, right, mid); } } void mergeSort(vector&lt;int&gt;&amp; a) { if (a.size() &lt; 2) return; cut(a, 0, a.size() - 1); } 3.5 快速排序 func quickSort(a []int,left,right int){ if left&lt;right{ i,j:=left,right mid:=(left+right)/2 key:=a[(left+right)/2] //取中间作为pivot，效率更高 for i&lt;=j{ //调序，直到满足条件 for a[i]&lt;key{ //到key时一定会停 i++ } for a[j]&gt;key{ j-- } if i&lt;=j { //交换之前必须检查 a[i], a[j] = a[j], a[i] i++;j-- } } if left&lt;mid-1{ //满足条件时，i一定大于j quickSort(a,left,mid-1) } if right&gt;mid+1{ quickSort(a,mid+1,right) } } } void quickSort(vector&lt;int&gt;&amp; a, int left, int right) { if (left &lt; right) { int i = left, j = right; int mid = (left + right) / 2; int pivot = a[mid]; while (i &lt;= j) { while (a[i] &lt; pivot) { i++; } while (a[j] &gt; pivot) { j--; } if (i &lt;= j) { swap(a[i], a[j]); i++, j--; } } if (left &lt; mid - 1) { quickSort(a, left, mid - 1); } if (right &gt; mid + 1) { quickSort(a, mid + 1, right); } } } 3.6 三项切分快速排序采用了三指针，两个放首尾，index放中间。要保证index以前的都是有序的，我们构建两个标志zerotail和twohead分别表示最后一个0的下一个和第一个2的前一个，比如[0,1,1,2]，zerotail=1，twohead=2。 注意：当nums[index] == 2交换时，index不能盲目前进，因为不知道被换过来的是1还是2，需要放到下一轮进行检验。（由于我们保证了index以前都是有序的，所以和0做交换是安全的） 注意：去重时，必须要判断twohead &gt;= 0和zerotail &lt; nums.size()，不然会溢出。比如[2]，使得twohead=-1，下一次while就会导致nums[twohead]溢出。 void sortColors(vector&lt;int&gt;&amp; nums) { int zerotail = 0, twohead = nums.size() - 1; while (zerotail &lt; nums.size() &amp;&amp; nums[zerotail] == 0) zerotail++; while (twohead &gt;= 0 &amp;&amp; nums[twohead] == 2) twohead--; int index = zerotail; while (index &lt;= twohead) { if (nums[index] == 0) std::swap(nums[zerotail++], nums[index++]); else if (nums[index] == 2) std::swap(nums[twohead--], nums[index]); else index++; } } 3.7 堆排序当堆中某个节点的编号为i时，如果这个节点有左右子树，那么左子树的节点编号为2*i,右子树的节点编号为2*i+1 img 先用buildMaxHeap将数组构建成最大堆（第i层总是比第i+1层大）。因为数组中最大元素总在根节点A[0]处，每次都取出最大值，然后放入res数组。同时维护被破坏的堆。 img int nsize;//因为每次移除根节点，size都会变小，所以需要全局变量掌控 void maxHeap(vector&lt;int&gt;&amp; a, int n) { int leftChild, rightChild, largest; leftChild = 2 * n; rightChild = 2 * n + 1; if (leftChild &lt;= nsize &amp;&amp; a[leftChild - 1] &gt; a[n - 1]) { largest = leftChild; } else { largest = n; } if (rightChild &lt;= nsize &amp;&amp; a[rightChild - 1] &gt; a[largest - 1]) { largest = rightChild; } if (largest != n) { swap(a[n - 1], a[largest - 1]); maxHeap(a, largest); } } void buildHeap(vector&lt;int&gt;&amp; a, int n) { int i = n / 2; for (; i &gt; 0; i--) { maxHeap(a, i); } } void heapSort(vector&lt;int&gt;&amp; a, int n) { nsize = n; int i; buildHeap(a, n); vector&lt;int&gt; res; for (i = nsize; i &gt; 0; i--) { res.push_back(a[0]); a.erase(a.begin()); nsize=nsize-1; maxHeap(a, 1); for (auto x : res) { cout &lt;&lt; x &lt;&lt; &quot;,&quot;; } cout &lt;&lt; endl; } } 3.8 TopK问题（1）分治法 /* * 基于快排Partition函数 * 时间复杂度O（n）空间复杂度O（1）需要改变输入 */ vector&lt;int&gt; getTopK(vector&lt;int&gt; nums, int k){ if (nums.empty() || k &gt; nums.size() || k&lt;=0) return {}; vector&lt;int&gt; ret; int begin = 0, end = nums.size()-1; int idx = Partition(nums,begin,end); while (idx != k-1){ if (idx &lt; k-1){ begin = idx + 1; idx = Partition(nums,begin,end); }else{ end = idx - 1; idx = Partition(nums,begin,end); } } for (int i = 0; i &lt; k; ++i) { ret.push_back(nums[i]); } return ret; } // 返回索引值idx，idx前的元素均大于该处的元素值；idx后的元素均小于该处的元素值 int Partition(vector&lt;int&gt; &amp;nums, int begin, int end){ if (begin &gt; end) return begin; int key = nums[begin]; // 取最后一个值为基准值 while (begin &lt; end){ while (nums[end] &lt;= key &amp;&amp; begin &lt; end) --end; nums[begin] = nums[end]; while (nums[begin] &gt; key &amp;&amp; begin &lt; end) ++ begin; nums[end] = nums[begin]; } nums[begin] = key; return begin; } （2）堆排序 时间复杂度nlg(K)，比分治法n要慢，但是不需要修改输入数据，适用于海量数据。 multiset&lt;T&gt; 容器就像 set&lt;T&gt; 容器，但它可以保存重复的元素，默认用 less&lt;T&gt; 来比较元素，也可以greater&lt;T&gt; vector&lt;int&gt; getTopK(vector&lt;int&gt;&amp; nums, int k){ if (nums.empty() || k &gt; nums.size() || k&lt;1) return {}; vector&lt;int&gt; ret; multiset&lt;int, less&lt;int&gt;&gt; m; // 最小堆，保存最大的K个数 for (int i = 0; i &lt; nums.size(); ++i) { if(m.size()&lt;k){ m.insert(nums[i]); } else{ it = m.begin(); // 如果当前值大于topK的最小元素（最小堆堆顶），替换该值 if (nums[i]&gt; *it){ m.erase(it); m.insert(nums[i]); } } } for (auto x : m) { ret.push_back(x); } return ret; } 4. 哈希4.1 什么是哈希表？又称散列表。通过键-值映射进行访问的表，把键映射到数组的某个下标来加快查找速度。 4.2 哈希表的定址方法有哪些？ 直接法：key=value+C,C是常量 取余法：key=value%C 折叠法：比如value=135790，将value变为13+57+90=160，再去除最高位，得到的60就是key。 4.3 哈希表解决冲突的办法有哪些？ 线性探测：5421 是要插入数据的位置，若被占用就使用5422，以此类推 二次探测：防止聚集，线性探测是x+1,x+2，而二次探测就是x+1,x+4,x+9 再哈希法：消除原始聚集和二次聚集，把关键字用不同的哈希函数再做一遍哈希化，用这个结果作为步长 链地址法：某个数据项的关键字值还是像通常一样映射到哈希表的单元，而数据项本身插入到这个单元的链表中。其中每一条链子都是一个桶。假设桶的个数为17，则将哈希值取17的模即可分配。 4.4 为什么哈希表的桶的个数是质数取合数会导致某些位失效，比如如果桶的个数是2^3=8，那么第4位就会失效： H( 11100 ) = H( 28 ) = 4 H( 10100 ) = H( 20 ）= 4","categories":[{"name":"算法","slug":"算法","permalink":"jiangren.work/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"面试经验","slug":"面试经验","permalink":"jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"}]},{"title":"数据库面试题目汇总","slug":"数据库面试题目汇总","date":"2020-02-20T06:44:06.000Z","updated":"2020-03-26T13:11:06.000Z","comments":true,"path":"2020/02/20/数据库面试题目汇总/","link":"","permalink":"jiangren.work/2020/02/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/","excerpt":"对于关系型数据库，尤其是Mysql的面试内容的汇总，最好和Redis那一部分结合来看。","text":"对于关系型数据库，尤其是Mysql的面试内容的汇总，最好和Redis那一部分结合来看。 1. 数据库基本概念1.1 三个范式范式，即Normal Form，指的是我们在构建数据库所需要遵守的规则和指导方针。 首先要明确的是：满足第三范式，那么就一定满足第二范式、满足第二范式就一定满足第一范式 第一范式：字段是最小的的单元不可再分。即列的原子性。 学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的 第二范式：满足第一范式,表中的字段必须完全依赖于全部主键而非部分主键。 比如一个订单表中有主键（订单id，商品id）和单位价格、折扣、数量、产品名称、产品保质期。保质期只依赖于商品id，不符合第二范式。 第三范式：满足第二范式，非主键外的所有字段必须互不依赖 换句话说：数据只能存在一个表中，消除互相依赖 比如大学学院表中包含了学院id，院领导，院简介，如果在学生信息表中也包括了院领导，院简介这些字段，这就重复了。 1.2 什么是存储过程？存储过程就是一段SQL语句的预编译集合，封装了一组sql语句，实现某些操作，类似于函数的功能。 好处： 将代码封装起来，隐藏复杂的商业逻辑 预编译，执行效率高 可以接受参数，可以回传值 坏处： 针对特定的某种数据库，不兼容，难维护 1.3 什么是视图视图是从一个或多个表导出的虚拟的表，具有普通表的结构，但是不实现数据存储。 作用： 直观 安全性，暴露出视图，然后把不想让用户看到和修改的内容屏蔽掉 独立性，屏蔽了真实表的结构带来的影响。 缺点： 性能差：视图是由一个复杂的多表查询所定义 修改限制： 当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改 1.4 超键、候选键、主键、外键是什么？假设有如下两个表： 学生（学号，姓名，性别，身份证号，班级，教师编号） 教师（教师编号，姓名，工资） 超键：能唯一标识某条数据属性的集合。比如(学号)、(学号+姓名)、(身份证号+性别)等等。 候选键：最小的超键。比如（学号）、（身份证号）。 主键：人为规定的一个候选键，作为数据的身份象征。 外键：用于描述两个表的关系，比如学生表中包含了班主任信息(教师编号)，这个就是外键。 1.5 什么是事务的隔离级别？脏读：一个事务A正在访问并修改数据，他设置了数据但还没有提交，另一个事务B读到了未提交的数据。但是A可能发现出错了回滚了数据，导致B得到的数据是错的。 不可重复读：一个事务正在访问并修改数据，另一个事务多次读取，前后读取的数据并不相同，导致这种读取结果不可复现。 幻读：事务A正在访问并修改数据，另一个事务B也要读取修改，事务B读取时检查数据不存在符合插入条件，但在B插入之前，A插入了数据，B插入时突然发现有问题了，就像见了鬼一样。幻读侧重读-写，不可重复读侧重读-读 事务隔离级别有四个： 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable read × × √ Serializable × × × Read committed要求必须读取已提交的数据。 Repeatable read要求读取过程中，其他事务不能修改(图中第一次读取第二次读取中间都算读取过程)，然而读取-写入却不算在内，因此依然有幻读风险。 Serializable要求按串行读取，效率低。 1.6 MySQL存储引擎有哪些？最常见的是InnoDB和MyISAM Innodb myisam 事务 支持 不支持 外键 支持 不支持 全文本搜索 不支持 支持 使用场景 频繁修改 查询和插入为主 另外还有MEMORY，存储在内存中，速度快，安全性不高。 1.7 关系型数据库和非关系型数据库的区别关系型数据库 优点：易于理解，支持SQL可用于复杂查询 缺点：读写性能差，高并发能力差 非关系型数据库NoSQL 优点：键值对存储，读写性能高；键值对读写，数据没有耦合性，易拓展 缺点：缺乏sql支持，不适用于复杂查询 2. SQL语句2.1 drop、truncate、delete区别 不再需要一张表的时候，用drop 想删除部分数据行时候，用delete，并且带上where子句 保留表而删除所有数据的时候用truncate 2.2 varchar 和 char区别前者可变长度，后者固定长度 2.3 各种joinleft join 左关联，主表在左边，右边为从表。如果左侧的主表中没有关联字段，会用null 填满。right join相反 inner join 内关联只会显示主表和从表相关联的字段，不会出现null cross join则是将两个表的字段两两组合，比如A表有4个，B表有3个，则crossjoin出来就有12个 2.4 SQL约束有哪些 NOT NULL: 用于控制字段的内容一定不能为空（NULL）。 UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。 PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。 FOREIGN KEY: 设置外键约束，假设表1是主表，表2是附表，学号作为外键。那么，如果表2要插入一条数据，表1必须有个学号；同理，如果表1要删除1条数据，表2必须先删除。 CHECK: 用于控制字段的值范围。 3. 索引3.1 什么是索引，什么时候使用索引？索引本身就是一种数据结构，用于加快查找速度，InnoDB和MyISAM都是用的B+树。 经常需要查询，经常使用SELECT和WHERE操作时，可以使用索引 经常做表连接 经常出现在order by、group by、distinct 后面的字段中，可以建立索引 索引的缺点在于：增删改浪费时间，构建索引需要占据空间 3.2 构建索引常用的数据结构有哪些 结构 区别 Hash 只存储对应的哈希值，查找速度快，不能排序,不能进行范围查询 B+ 数据有序,范围查询 3.3 聚集索引和非聚集索引区别？ 索引 区别 聚集索引 数据按索引顺序存储，数据行的物理顺序与列值的顺序相同 非聚集索引 存储指向真正数据行的指针 聚集索引如下 地址 id username score 0x01 1 小明 90 0x02 2 小红 80 0x03 3 小华 92 非聚集索引就不是按照地址存储，每一个都有一个指针，指向不同地方。 3.4 为什么底层用B+树而不是红黑树？ 树 区别 红黑树 增加，删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间 B树也就是B-树 B树，查询性能不稳定，查询结果高度不致，每个结点保存指向真实数据的指针，相比B+树每一层每屋存储的元素更多，显得更高一点。 B+树 B+树相比较于另外两种树,显得更矮更宽，查询层次更浅 3.5 索引失效的条件有哪些？ 在where子句中进行null值判断 SELECT id FROM table WHERE num is null 在建立数据库的时候因尽量为字段设置默认值,如int类型可以使用0,varchar类型使用 &#39;&#39; 避免在where子句中使用or来连接条件,因为如果俩个字段中有一个没有索引的话,引擎会放弃索引而产生全表扫描 避免在where子句中使用like模糊查询 4. 提高性能的方法4.1 SQL语句优化的步骤是什么？（1）发现有问题的SQL 读取MYSQL的慢查询日志，记录在MySQL中响应时间超过阈值的语句，可以查询出执行的次数多占用的时间长的SQL。 （2）通过EXPLAIN关键字分析SQL 使用 EXPLAIN 关键字可以知道MySQL是如何处理你的SQL语句的 （3）进行优化 4.2 优化SQL语句的方法有哪些？（1）选择最有效率的表名顺序 数据库的解析器规则：FROM子句中写在最后的表将被最先处理，因此： 如果是多个表连接查询，将引用最多的表放在最后，优先处理可以加快后续的速度。 （2）where的连接顺序 自右而左的顺序解析WHERE子句 可以过滤掉最大数量记录的条件写在WHERE右边 （3）多使用内部函数提高SQL效率 比如，使用mysql的concat()函数会比使用||来进行拼接快，因为concat()函数已经被mysql优化过了。 （4）建立索引 建立条件，参看3.1 4.3 数据库连接池的作用维护一定数量的连接，减少重新创建连接的时间 4.4 什么是MVCCMVCC，Multi-Version Concurrency Control，多版本并发控制。 使用MVCC时，不会直接用新数据覆盖旧数据，而是将旧数据标记为过时并在别处增加新版本的数据。允许读者读取在他读之前已经存在的数据，即使这些在读的过程中半路被别人修改、删除了，也对先前正在读的用户没有影响。","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"面试经验","slug":"面试经验","permalink":"jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"}]},{"title":"Linux面试题题目汇总","slug":"Linux面试题题目汇总","date":"2020-02-19T05:50:18.000Z","updated":"2020-02-28T16:47:21.000Z","comments":true,"path":"2020/02/19/Linux面试题题目汇总/","link":"","permalink":"jiangren.work/2020/02/19/Linux%E9%9D%A2%E8%AF%95%E9%A2%98%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/","excerpt":"操作系统中和Linux强相关的部分，被放到这一篇来讲。","text":"操作系统中和Linux强相关的部分，被放到这一篇来讲。 1. Linux总体原理1.1 如何理解Linux一切皆文件？Linux访问设备的方式是通过文件访问。在windows中属于文件的东西，在linux中也是文件，在windows中不是文件的东西，比如进程磁盘socket等也被抽象为文件。 文件这个基本概念包含了两重意思： 在 Linux 中，一切都是字节流。意思是：文件只不过是可以读取和写入的普通字节的集合。 在 Linux 中，文件系统是统一的命名空间。每个文件都通过相同的API暴露出来，用户可以通过使用同一组命令操作这些设备 1.2 Linux内核中包含了哪些子系统进程管理系统、内存管理系统、文件系统、网络系统、进程间通信系统 进程管理：操作每个子系统的挂起或恢复 内存管理：负责管理内存资源，提供虚拟内存机制 文件管理：隐藏了硬件的具体细节，为所有的外部设备提供了统一的操作接口(open、read、write、close) 网络：负责管理系统的网络设备 进程间通信系统:包含多种进程间通信的方法，包括：信号量、共享内存、管道等。协助多个进程间的共享资源访问，同步，消息传递等。 1.3 Linux磁盘是如何划分的分为引导块，超级快，i节点表，文件存储区，进程交换区 引导块：存放引导程序，用于启动操作系统 超级块：存放的是文件系统本身的结构信息，比如每个区域的大小，未使用的磁盘信息等 文件存储区：存储文件内容 进程交换区： 当内存中的进程需要扩大占用的内存空间， 而当前内存空间不足时， 则把某些不常用的进程暂时替换到对换区中，在适用的时候又把他们换进内存，解决内存不足和进程之间对内存的竞争问题。 1.4 Linux内存是如何划分的？分为：代码区、数据区、BSS区、堆区、栈区 BSS区用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。 2. Linux技术细节2.1 什么是i节点？I的意思是index，i节点也叫索引节点。linux中，文件查找不是通过文件名称来查找的，而是通过i节点来实现的。每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。 Linux查询文件位置的流程是： 读出这个文件的inode编号 根据inode编号找到inode信息 根据信息，读取文件数据所在的block 2.2 Linux中buffer和cache有何区别？cache：缓存，为了弥补高速设备和低速设备交换数据的速度不匹配，引入的一个中间层，起到加快访问速度的作用。 buffer：缓冲区，目的进行流量整形，把突发的大数量小规模的 I/O 整理成平稳的小数量大规模的 I/O。比如读写时，不能来一点数据就立马读，可以等积攒到一定程度以后，一起读。 2.3 Linux开机过程是什么？操作系统的启动可以分为：引导和启动 BIOS上电自检，确认硬件功能正常。（BIOS:basic IO system） 读取引导文件，加载操作系统内核 运行第一个进程init 进入相应的运行级别（关机，单用户模式，多用户模式，图形模式，重启等等） 进入终端界面，输入账号密码 2.4 谈谈对fork的理解fork函数通过系统调用创建一个（除了PID以外）与原来进程几乎完全相同的进程。拷贝的内容包括栈区、堆区、BSS区、数据区、代码区。 Linux下init进程是所有进程的爹 所有进程都是通过init进程fork出来的。 exec函数的作用就是：装载一个新的程序（可执行映像）覆盖当前进程内存，从而执行不同的任务。 COW是写时复制的意思，由于拷贝完之后，父进程和子进程之间的数据段和堆栈是相互独立的，而如果我们想用exec来装载新的程序，复制的这些数据都是没用的。 因此COW技术允许我们，fork创建出的子进程，与父进程共享内存空间。也就是说，如果子进程不对内存空间进行写入操作的话，内存空间中的数据并不会复制给子进程。（引用而不是复制）。当父子进程有内存写入操作时才进行复制。 2.5 Malloc底层实现机制是什么？Linux将内存划分为5大区，Linux维护一个break指针，这个指针指向堆空间的某个地址。break之前的都是已经映射好的地址，之后的是未映射的，如果访问就会出错： 当我们调用malloc函数时， 它沿着连接表寻找一个大到足以满足用户请求所需要的内存块，然后将内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节） 一部分传给用户，一部分放回到空闲连接表上 用户使用free以后，释放的内存返回到空闲连接表上，空闲连接表会被切成小块 当用户malloc的内存过大，会阻塞，整合空闲连接表形成大块。 2.6 什么是自旋锁，如何实现？自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。 互斥锁等待时会进入休眠状态，而自旋锁因为循环等待的缘故会一直活跃。 好处：减少线程切换的消耗；坏处：忙等 go实现自旋锁： type spinLock uint32 func (sl *spinLock) Lock() { for !atomic.CompareAndSwapUint32((*uint32)(sl), 0, 1) { runtime.Gosched() } } func (sl *spinLock) Unlock() { atomic.StoreUint32((*uint32)(sl), 0) } 抢到锁的gorutine会将sl从0变为1，成功跳过runtime.Gosched()，而没有抢到的则会进入循环，形成自旋。 CAS算法CompareAndSwapUint32(V,A,B)当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作。for就会卡在循环里，直到runtime.Gosched()让出CPU时间轮转片。 3. Epoll3.1 Linux中有哪些事件处理的方式阻塞IO：一个线程只能处理一个流的I/O事件。除非采用多线程，否则效率很低。 非阻塞忙轮询IO：即Non-Blocking Busy Polling，等待某个事件的时候，放弃其他事情，休息，专门等待，称之为阻塞。等待过程中不休息，不断询问事件是否完成，称之为非阻塞忙轮询。可以同时处理多个流，但需要从头到尾轮询，浪费资源。 Select：相当于一位代理，帮我们观察流。但这位代理只会告诉我们此刻是否有IO事件发生，我们却不知道是哪些流，只能无差别轮询。 Epoll：即event poll，不同于无差别轮询，epoll会把哪个流发生什么样的事情通知我们。 3.2 Epoll底层实现是什么？ 红黑树的根节点，存储epoll需要监控的事件 双链表的头部，存储epoll_wait返回给用户的满足条件的事件 当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体： struct eventpoll{ .... /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/ struct rb_root rbr; /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/ struct list_head rdlist; .... }; 每次调用epoll_create方法都会创建一个epoll对象，每一个对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示： struct epitem{ struct rb_node rbn;//红黑树节点 struct list_head rdllink;//双向链表节点 struct epoll_filefd ffd; //事件句柄信息 struct eventpoll *ep; //指向其所属的eventpoll对象 struct epoll_event event; //期待发生的事件类型 } 3.3 Epoll的优势是什么？换句话说select和poll的缺点是什么？ select单个进程能够监视的文件描述为最大为1024，轮询越多，性能越差 Select需要复制大量句柄数据结构，开销巨大。 Select返回整个句柄数组，程序需要遍历数组才能知道哪些句柄发生了什么事件。 触发方式为水平触发，如果程序没有对一个就绪的文件进行IO操作，之后每次Select调用还是会将文件描述符通知给进程。 Poll使用链表保存文件，没有1的限制，但其他三个缺点依然比较明显。 3.4 水平触发和边缘触发的区别是什么？ 水平触发LT：默认方式，支持阻塞和非阻塞。内核告诉你某个fd就位了，如果你不对这个fd进行IO操作，内核会一直通知你。所以这种模式安全性较高。 边缘触发ET：只支持非阻塞，内核只会通知你一次，如果你不操作他也不管你了，速度快 3.5 谈谈什么是惊群，如何避免？多线程在同时阻塞等待同一个事件，当事件发生时所有线程同时唤醒，然而只有一个线程能抢到控制权，其他的醒了又睡。问题主要有两方面： linux内核对线程频繁无效调度，影响性能 为了确保只有一个线程拿到资源需要加锁，影响性能 解决方案： accept：在Linux2.6后，accept函数加入了一个标志位，只会唤醒等待队列上的第一个进程。 epoll：如果Epoll_create在fork之前创建依然有惊群现象，因为所有子进程共享epoll_create()创建的epfd，等待同一个文件描述符的所有进程/线程，都将被唤醒。在epoll: add EPOLLEXCLUSIVE flag 21 Jan 2016补丁中以accept相同的方式解决了。 4. Linux命令1. 如何查看Linux系统有几颗物理CPU和每颗CPU的核数？cat /proc/cpuinfo|grep -c &#39;physical id&#39; cat /proc/cpuinfo|grep &#39;cpu cores&#39;|uniq cat 命令用于连接文件并打印到标准输出设备上。 |grep是正则符号， -c表示统计数量， 正则匹配physical id。 当输入cat /proc/cpuinfo时会显示每个CPU的信息 通过统计physical id出现的次数就能知道有多少颗物理CPU 2. 如何查看系统负载？有两个命令 w uptime 结果如下，其中load average即系统负载，三个数值分别表示一分钟、五分钟、十五分钟内系统的平均负载，即平均任务数。 ➜ jr w 15:08:58 up 31 min, 1 user, load average: 0.00, 0.00, 0.00 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT jr tty7 :0 14:37 31:28 12.04s 0.25s /sbin/upstart --user 3. vmstat命令各项含义➜ jr vmstat procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 3088016 136492 976224 0 0 109 41 53 89 0 1 99 0 0 r即running，表示正在跑的任务数 b即blocked，表示被阻塞的任务数 si表示有多少数据从交换分区读入内存 so表示有多少数据从内存写入交换分区 bi表示有多少数据从磁盘读入内存 bo表示有多少数据从内存写入磁盘","categories":[{"name":"Linux","slug":"Linux","permalink":"jiangren.work/categories/Linux/"}],"tags":[{"name":"面试经验","slug":"面试经验","permalink":"jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"},{"name":"Linux","slug":"Linux","permalink":"jiangren.work/tags/Linux/"}]},{"title":"计算机网络面试题目汇总","slug":"计算机网络面试题目汇总","date":"2020-02-16T05:55:18.000Z","updated":"2020-03-26T15:28:33.000Z","comments":true,"path":"2020/02/16/计算机网络面试题目汇总/","link":"","permalink":"jiangren.work/2020/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/","excerpt":"计算机网络相关的所以题目汇总，应该是网上最全的汇总了。","text":"计算机网络相关的所以题目汇总，应该是网上最全的汇总了。 1. 网络结构1.1 计算机网络有哪些结构？计算机网络一共有3种模型。 OSI七层结构 TCP/IP结构 五层协议结构 OSI是Open Systems Interconnect，也就是开放的互联系统，将复杂的互联网系统划分为不同块，方便处理。实际应用中，并没有采用这个理论模型，而是使用TCP/IP协议的四层模型。而5层模型是一个理论上的网络通信模型，方便教学的时候理解，实际上并不存在。 1.2 计算机网络中各层分别有什么作用？（1）应用层 应用层的任务是通过应用进程间的交互来完成特定网络应用，常见的协议有域名系统DNS，万维网应用的HTTP协议，支持电子邮件的SMTP协议。把应用层交互的数据单元称为报文。 （2）运输层 为两台主机进程之间的通信提供通用的数据传输服务。主要包含两种协议： 传输控制协议 TCP（Transmisson Control Protocol）。提供面向连接的，可靠的数据传输服务。 用户数据报协议 UDP（User Datagram Protocol）。提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。 （3）网络层 使用IP协议。网络层有两个任务： 把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。注意：不要把运输层的用户数据报UDP和网络层的IP数据报弄混。 选择合适的路由，找到目的主机 （4）数据链路层 两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装程帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 （5）物理层 物理层的任务就是透明地传输比特流，换句话说实际电路传送后比特流没有发生变化。 2. TCP/IP协议2.1 描述一下TCP/IP协议的结构 2.3 TCP和UDP的区别？简单来说： TCP：面向连接，面向字节流，可靠，传输慢，有流量控制阻塞控制。 UDP：广播形式不需要连接，面向报文，不可靠，传输快，无流量控制阻塞控制。 解释一下报文和字节流的区别： 字节流：发送次数和接收次数可以不相同，比如向水池倒了20盆水，可以开水龙头一次性全放出。 报文：发送次数和接收次数必须相同。 两者的应用场景： TCP：邮件，远程登录，文件传输等对准确性要求较高的地方 UDP：及时通信，比如QQ，网络电话等。 2.4 三次握手和四次挥手https://jiangren.work/2019/08/01/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86/ 2.5 TCP协议如何保证可靠行（1）采用三次握手四次挥手保证建立的传输信道是可靠的。 （2）采用了ARQ自动重传请求协议数据传输的可靠性。 （3）采用滑动窗口协议进行流量控制 （4）使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制 2.6 TCP协议如何进行流量控制？控制流量的前提当然需要保证正确率，因此首先要引入ARQ协议。 无差错时，A向B发送分组M1，B收到M1后向A回复，A收到回复后，发送下一个M2….. 如果出现差错，B没有收到信息，自然不会回复，A等待超时后，自动重传一个信息M，这就是所谓的ARQ。 停止等待ARQ协议信道利用率太低，所以需要使用连续ARQ协议来进行改善。这个协议会连续发送一组数据包，然后再等待这些数据包的ACK。 连续ARQ协议通常是结合滑动窗口协议来使用的，发送方需要维持一个发送窗口，如下图所示： 位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认，这样就提高了信道利用率。发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。 接收方一般都是采用累积确认的方式。收到几个分组后，对按序到达的最后一个分组发送确认。 下载时我们的速度一般都是由慢变快，原因就是拥塞控制。 2.7 TCP协议如何进行拥塞控制？网络拥塞是指在分组交换网络中传送分组的数目太多时，由于存储转发节点的资源有限而造成网络传输性能下降的情况。 常见的拥塞控制有： 慢开始 拥塞避免 快重传 快恢复 发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。当cwndssthresh时，改用拥塞避免算法。 慢开始：不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。 拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。 快重传：我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。快重传规定：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。 快恢复：主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞），但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。 3. DNS协议和ARP协议为什么这两个要放在一起说呢？因为这两个协议都是用于地址间的转化，都是起到了翻译官的职责。 3.1 DNS解析过程是什么？DNS (Domain Name System) 是 域名系统 的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于 TCP/IP 网络，它从事将主机名或域名转换为实际 IP 地址的工作，类似于翻译官。 DNS查询时优先考虑本地的Host文件和本地的DNS解析器是否保留有缓存映射，如果没有就向上一级请求。依次按照DNS根服务器，DNS顶层服务器，DNS管理方服务器的顺序请求。 所谓递归查询就是变更查询者，迭代查询则没有变更：这个例子中查询者由客户端变为了本地DNS服务器，所以是递归查询。 3.1 什么是MAC地址？MAC地址是数据链路层和物理层使用的地址是硬件地址，IP地址网络层和以上各层使用的地址，是一种逻辑地址。在发送数据时，数据从高层到低层，然后才到通信链路上传输。使用IP地址的IP数据报一旦交给了数据链路层，就被封装成了MAC帧。MAC帧在传送时使用的源地址和目的地址都是硬件地址。 3.2 ARP协议工作机制是什么？ARP（Address Resolution Protocol）即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。 在每台安装有TCP/IP协议的电脑或路由器里都有一个ARP缓存表，表里的IP地址与MAC地址是一对应的，如下表所示。 解析MAC地址时，主机A首先在其ARP高速缓存中查找有无主机B的IP地址。 如果没有就就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址。 收到后在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射。并且采用LRU机制，及时淘汰。 4. HTTP协议4.1 HTTP常见的状态码有哪些？ 4.2 HTTP协议和其他协议之间的关系是什么？HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。如果TCP是高速路，HTTP就是卡车。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们能方便地使用TCP/IP协议。 4.3 解释一下HTTP长连接和短连接短连接：客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。 长连接：客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。有一个保持时间。 4.4 HTTP和HTTPS的区别HTTP：运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份 HTTPS：Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP 4.5 GET和POST的区别 GET用于从服务器获取资源，POST用于更新服务器的资源 GET不会改变服务器的资源，而POST会 GET请求的数据会附在URL之后，比如http:localhost:8080/id=101?，而POST的数据则是放在请求体中。因此，GET不安全，GET的长度受限制。 4.6 Cookie和Session的区别Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。 Cookie实际上是一小段文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。 Session的区别在于，会话状态完全保存在服务器。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session就按照sessionid把这个session检索出来使用。服务器Session常常依赖于Cookie机制检索ID，但Cookie被禁用时也有其他方法比如URL重写机制。 4.7 HTTP请求报文和响应报文的格式请求报文格式： 请求行（请求方法+URI协议+版本） 请求头部 空行 请求主体 GET/sample.jspHTTP/1.1 请求行 Accept:image/gif.image/jpeg, 请求头部 Accept-Language:zh-cn Connection:Keep-Alive Host:localhost User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0) Accept-Encoding:gzip,deflate username=jinqiao&amp;password=1234 请求主体 响应报文： 状态行（版本+状态码+原因短语） 响应首部 空行 响应主体 HTTP/1.1 200 OK Server:Apache Tomcat/5.0.12 Date:Mon,6Oct2003 13:23:42 GMT Content-Length:112 &lt;html&gt; &lt;head&gt; &lt;title&gt;HTTP响应示例&lt;title&gt; &lt;/head&gt; &lt;body&gt; Hello HTTP! &lt;/body&gt; &lt;/html&gt; 4.8 HTTP1.1和2.01.1新功能 支持长链接 通过虚拟站点技术能够使不同域名配置在同一个IP地址的服务器上 2.0新功能 可以使用同一个连接并行发送多个请求和相应，可以承接双向数据流 允许设定数据流中不同资源的优先级，明确资源处理的先后顺序 打破了请求-响应的束缚，除了最初的请求响应外，服务器还能向客户端推送额外的资源（客户端没有明确要求的情况下） 5. IP地址5.1 IP地址的格式是什么？什么是IP地址？IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。 IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。 每个IP地址包括两个标识码（ID） 网络ID 主机ID。 同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。3字节的网络地址 + 1字节主机地址的意思就是：前三段号码为网络号码，剩下的一段号码为本地计算机的号码。 A类地址：1字节的网络地址 + 3字节主机地址，网络地址的最高位必须是0。A类IP地址的地址范围1.0.0.0到127.255.255.255，IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为256^3-2 B类地址：2字节的网络地址 + 2字节主机地址，网络地址的最高位必须是10。B类IP地址地址范围128.0.0.0-191.255.255.255B类IP地址的子网掩码为255.255.0.0，每个网络支持的最大主机数为256^2-2。注：1000 0000=128 C类地址：3字节的网络地址 + 1字节主机地址，网络地址的最高位必须是110。C类IP地址范围192.0.0.0-223.255.255.255每个网络支持的最大主机数为256-2。适用于小规模局域网络。 D类地址：多播地址，用于1对多通信，最高位必须是1110。范围从224.0.0.0到239.255.255.255。 E类地址:为保留地址，最高位必须是“1111” 5.2 单播广播多播的区别是什么？单播：主机间一对一通信。优点：个性化服务，及时响应；缺点：流量压力大。 广播：主机间一对所有通信。优点：布局简单，维护方便，流量负载低。缺点：缺乏个性化服务，无法在Internet宽带上传播。 多播（组播）：主机间一对一组通信。优点：兼具流量负载和个性化的优点，允许在Internet宽带上传播。缺点：与单播协议相比没有纠错机制。 5.3 如何划分子网？划分子网的方法是从主机号借用若干个位作为子网号，而主机号也就相应减少了若干个位。于是两级IP地址在本单位内部就变为三级IP地址：网络号、子网号和主机号。 区分子网号和主机号的办法是：通过子网掩码将网络号和子网号全设为1的IP地址为子网掩码。 假设公司有4个部门，A部门有10台主机，B部门有15台主机，C部门有30台主机，D部门有20台主机。分配了一个总的网段为：192.168.2.0/24。请问该如何划分子网？ 网段前面的数字是我们的网络地址，后面的24表示用24位来表示网络位，用32-24=8位来表示主机位。主机数目不多，可以小型组网，因此采用C类地址(最大254个主机)，默认掩码为225.255.255.0。 首先假设借用主机位2位来划分4个子网，则子网掩码组合为： 11111111.11111111.11111111.00000000 11111111.11111111.11111111.01000000 11111111.11111111.11111111.10000000 11111111.11111111.11111111.11000000 然而全为0和全为1的地址不能用，所以我们需要借用主机位3位，划分8-2=6个子网： 11111111.11111111.11111111.00100000 11111111.11111111.11111111.01000000 11111111.11111111.11111111.01100000 11111111.11111111.11111111.10000000 11111111.11111111.11111111.10100000 11111111.11111111.11111111.11000000 验证一下：最后提供的主机位数是2^5=32，也就是说每个子网最大的主机数是32，符合题目要求。所以子网划分如下： （1）255.255.255.32: 192.168.2.33~ 192.168.2.62 （2）255.255.255.64: 192.168.2.65~ 192.168.2.94 （3）255.255.255.96: 192.168.2.97~ 192.168.2.126 （4）255.255.255.128: 192.168.2.129~ 192.168.2.158 （5）255.255.255.160: 192.168.2.161~ 192.168.2.190 （6）255.255.255.192: 192.168.2.193~ 192.168.2.222 子网掩码是： 11111111.11111111.11111111.11100000 255.255.255.224 6. 网络安全6.1 什么是DDos攻击？DDos全称Distributed Denial of Service，分布式拒绝服务攻击。最基本的DOS攻击过程如下： 客户端向服务端发送请求链接数据包 服务端向客户端发送确认数据包 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认 DDoS则是采用分布式的方法，通过在网络上占领多台“肉鸡”，用多台计算机发起攻击。 DOS攻击现在基本没啥作用了，因为服务器的性能都很好，而且是多台服务器共同作用，1V1的模式黑客无法占上风。对于DDOS攻击，预防方法有： 减少SYN timeout时间。在握手的第三步，服务器会等待30秒-120秒的时间，减少这个等待时间就能释放更多的资源。 限制同时打开的SYN半连接数目。 6.2 什么是XSS攻击？XSS也称 cross-site scripting，跨站脚本。这种攻击是由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的。比如一个存在XSS漏洞的论坛，用户发帖时就可以引入带有＜script＞标签的代码，导致恶意代码的执行。 预防措施有： 前端：过滤 后端：转义，比如go自带的处理器就具有转义功能。 6.3 什么是注入SQL攻击？XSS是将脚本代码注入，而SQL注入攻击顾名思义就是注入SQL语句。 比如代码： username:=r.Form.Get(&quot;username&quot;) password:=r.Form.Get(&quot;password&quot;) sql:=&quot;SELECT * FROM user WHERE username=&#39;&quot;+username+&quot;&#39; AND password=&#39;&quot;+password+&quot;&#39;&quot; 当用户输入myuser&#39; or &#39;foo&#39; = &#39;foo&#39; --，那么SQL就变成了： SELECT * FROM user WHERE username=&#39;myuser&#39; or &#39;foo&#39;==&#39;foo&#39; --&#39;&#39; AND password=&#39;xxx&#39; 在SQL里面--是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。 预防方法： 限制数据库权限，给用户提供仅仅能够满足其工作的最低权限。 对进入数据库的特殊字符（’”\\尖括号&amp;*;等）转义处理。 提供参数化查询接口，不要直接使用原生SQL 7. 综合问题7.1 浏览器中输入URL地址到显示主页的过程是什么？ 7.2 ping命令的具体过程是什么？假设现在有ABCD四台主机，一台路由，子网掩码为255.255.255.0，默认路由为192.168.0.1 在主机 A 上运行Ping 192.168.0.5后, Ping命令会构建一个ICMP协议的数据包，交到网络层的IP协议中。IP层协议将目的地址和源地址打包后，形成IP数据包 获取192.168.0.5的MAC地址 交到数据链路层，添加一些控制信息，构建数据帧 交到物理层，通过以太网访问 主机B收到后， 检查目的地址，不相符就丢弃 将IP数据包提取后送入网络层的IP层协议，IP层检查后将有用的信息提取后送入ICMP协议 ICMP协议马上构建一个ICMP应答包以之前的相同方式发送给主机 根据条件：是否在同一网段内，流程可能有所不同，区别在于MAC的获取方式，具体参见ARP协议。 7.3 负载均衡算法有哪些？多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。 轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势 随机法：随机获取一台，和轮询类似 哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie 加权轮询：根据服务器性能不同加权","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"面试经验","slug":"面试经验","permalink":"jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"}]},{"title":"操作系统面试题目汇总","slug":"操作系统面试题目汇总","date":"2020-02-16T05:55:18.000Z","updated":"2020-02-27T19:54:51.000Z","comments":true,"path":"2020/02/16/操作系统面试题目汇总/","link":"","permalink":"jiangren.work/2020/02/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/","excerpt":"本章包含了操作系统和计算机组成相关的知识信息，Linux部分被专门分出去了。","text":"本章包含了操作系统和计算机组成相关的知识信息，Linux部分被专门分出去了。 1. 总体概念1.1 操作系统的特性是什么？四个特性：并发、共享、虚拟、异步。 同一段时间内(时间片轮转算法)多个程序执行。 系统中的资源可以被内存中多个并发执行的进线程共同使用。 虚拟：通过时分复用以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个。 异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进。（同步就是实时处理，比如打电话，异步就是分时处理，比如发短信） 1.2 操作系统的主要功能有哪些？操作系统的本质是对资源的管理。包括了： 处理器管理：以进程为单位分配资源 存储器管理：也叫内存管理 设备管理：完成所有的IO请求 文件管理：包括磁盘存储空间管理，文件读写管理等等 1.3 什么是用户态与核心态？从整体上讲，操作系统一般可分为内核（kernel）和外壳（shell）两大部分。 当程序运行在3级特权级上时，就可以称之为运行在用户态。反之则是内核态。0级特权直接控制硬件，12级特权是系统程序，包括驱动等等，3级特权是用户程序。 用户态切换到内核态有三种情况： 系统调用：用户态进程主动要求切换到内核态的一种方式。 异常：当前运行进程切换到处理此异常的内核相关程序中 外围设备中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。 2. 线程与进程2.1 线程进程协程的区别对于操作系统来说，一个任务就是一个进程(Process)，比如使用word。而一个进程可能不只干一件事（比如word既要打字又要检查拼写），这种进程内的多个子任务就是线程（Thread）。 具体来说： 进程是操作系统分配资源的单位，而线程是进程的一个实体，是CPU调度和分派的基本单位。 线程没有独立的内存单元，不能够独立执行，必须依存在应用程序中。 引入线程的好处：线程快！创建、终止、切换都很快！ 总结： 一个程序至少有一个进程,一个进程至少有一个线程。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存 虽然线程拥有单独的程序运行入口，出口，但不能独立执行。 协程与线程的区别：协程不再被内核调度，而是交给了程序自己，因此golang中专门引入了GMP模式，设立了专门的逻辑处理器。 2.2 进程有哪些状态，转换条件是什么？就绪状态：进程获得了除CPU之外的一切所需资源 运行状态：一个CPU的一个核只能有一个进程处于运行状态。 阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。 注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件 2.3 进程间通信也就是所谓的IPC(Interprocess communication)问题，主要是指进程间交换数据的方式。 进程是相互独立的，并不需要条件变量、互斥锁这些机制，要锁也是文件锁这种大锁。而线程需要互斥锁的原因是：线程之间的资源室共享的，需要程序员来完成变量级别的同步。 进程间通信分为低级通信和高级通信。 低级通信：信号量 高级通信： 管道 消息队列 共享内存 信号量是一个计数器，防止多个进程将资源拿光，防止某进程正在访问共享资源时，其他进程也访问该资源。 管道是指用于连接一个读进程和一个写进程的一个共享文件，又名pipe文件，以字符流形式将数据写入文件。管道分为无名管道和有名管道： 无名管道是半双工的通信方式，数据只能单向流动，只能在父子进程中流通； 有名管道也是半双工，但是它允许无亲缘关系进程间通信。 消息队列指的是进程间的数据交换是以格式化的消息(Message)为单位的，再由消息组成的链表，形成队列。 共享内存指在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。 2.4 进程间同步多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。进程同步的任务就是对多个相关进程在执行顺序上进行协调。 同步手段有： 临界区 互斥量 信号量 事件： 通过通知操作的方式来保持线程的同步 其中：互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多。 2.5 线程间同步由于线程间的资源可以共享，同步的方式就会更加细致： 互斥量 信号量，只能用于一个资源的互斥访问，不能实现多个资源的多线程互斥问题 读写锁，可以被多个读者拥有，但是只能被一个写者拥有的锁 条件变量，线程 A 等待某个条件并挂起，直到线程 B 设置了这个条件，并通知条件变量，然后线程 A 被唤醒 原子操作 通道 2.6 什么是临界区，如何解决冲突？每个进程中访问临界资源的那段程序称为临界区，一次仅允许一个进程使用的资源称为临界资源。 解决冲突的办法： 如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待； 进入临界区的进程要在有限时间内退出。 如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。 2.7 线程的分类内核级线程：这类线程依赖于内核，又称为内核支持的线程或轻量级进程。无论是在用户程序中的线程还是系统进程中的线程，它们的创建、撤销和切换都由内核实现。比如英特尔i5-8250U是4核8线程，这里的线程就是内核级线程 用户级线程：它仅存在于用户级中，这种线程是不依赖于操作系统核心的。应用进程利用线程库来完成其创建和管理，速度比较快，操作系统内核无法感知用户级线程的存在。 2.8 线程池线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。由于创建和销毁线程都是消耗系统资源的，所以池化技术能提升性能。 go实现线程池如下。创建两个通道，通道queue中传入任务函数，通道result传入结果： 创建结构 初始化 开门接客 关门送客 辅助函数:添加任务、回调 type pool struct{ Queue chan func() error Number int //协程数 Total int //任务数 result chan error finishCallback func() } func (p *pool) Init(number, total int){ p.Queue=make(chan func() error,total) p.Number=number p.Total=total p.result=make(chan error,total) } // 开门接客 func (p *pool) Start(){ // 开启Number个goroutine for i:=0;i&lt;p.Number;i++{ go func(){ for { task, ok := &lt;-p.Queue if !ok { //所有任务已经完成，跳出循环 break } err:=task() //执行任务，每个协程阻塞在此 p.result&lt;-err } }() } // 获得每个work的执行结果 for i:=0;i&lt;p.Total;i++{ res:=&lt;-p.result //阻塞形式 if res!=nil{ fmt.Println(res) } } // main传入回调函数才可以执行 if p.finishCallback!=nil{ p.finishCallback() } } // 关门送客 func (p *pool) Stop() { close(p.Queue) close(p.result) } //添加任务 func (p *pool)addTask(task func() error){ p.Queue&lt;-task } //设置结束回调 func (p *pool) setFinishCallback(callback func()){ p.finishCallback=callback 使用过程： ool := new(GoroutinePool) pool.Init(3, 10) //开启3个协程处理10个任务 for i:=0;i&lt;10;i++{ pool.addTask(func() error{ //从taskName中获取任务要求 return doTask(taskName[i]) }) } isFinish:=false pool.setFinishCallback(func(){ func(isFinish *bool){ *isFinish=true }(&amp;isFinish) }) pool.Start() for{ if isFinished{ break } time.Sleep(time.Millisecond*100) } pool.Stop() fmt.Println(&quot;Finished!&quot;) 3. 内存3.1 逻辑地址、线性地址和物理地址的区别？逻辑地址（Logic Address）是指由程序产生的与段相关的偏移地址部分，因此一个逻辑地址由段标识符和段内偏移量组成，有时也称虚拟地址。比如，在C程序中，可以使用&amp;操作读取指针变量本身的值，实际上这个值就是逻辑地址。逻辑地址和绝对的物理地址不相干。 线性地址（Linear Address）是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。 物理地址（Physical Address）是CPU外部地址总线上的地址，也是地址变换的最终地址。 3.2 寻址方式有哪些？寻址寻的都是物理地址。分三组：立即寻址+寄存器寻址；直接间接寻址；相对寻址+2个基变址寻址。 立即寻址：操作数在指令中给出，作为指令的一部分。 MOV AL,5 寄存器寻址：操作数在CPU内部的寄存器中，指令指定寄存器。不需要访问存储器，所以速度快。 MOV AX,BX 直接寻址：操作数在寄存器中，指令直接包含有操作数的有效地址。 MOV AX,[8054] 间接寻址：存储操作数的寄存器的地址另一个在寄存器中 MOV AX,[SI] 相对寻址：操作数在存储器中，形式为基地址+偏移地址。假设数据段DS地址为5000，DI为3678，最终地址为5000+3678+1223。 MOV AX,[DI+1223H] 基变址绝对寻址：操作数在寄存器中，形式为基地址寄存器+变址寄存器。BX基地址+DI变址得到操作数存放的地址。 MOV AX,[BX][DI] 基变址相对寻址：操作数在存储器中，形式为：基地址寄存器+变址寄存器+偏移地址 MOV AX,[BX+DI-2] 3.3 什么是虚拟内存？多任务会带来进程对内存的操作冲突，需要虚拟内存来解决。假设现在有一块物理内存，操作系统让两个进程共用这一块内存，彼此并不打扰。 3.4 什么是交换空间？操作系统把物理内存(physical RAM)分成一块一块的小内存，每一块内存被称为页(page)。当内存资源不足时，Linux把某些页的内容转移至硬盘上的一块空间上，以释放内存空间。硬盘上的那块空间叫做交换空间(swap space),而这一过程被称为交换(swapping)。物理内存和交换空间的总容量就是虚拟内存的可用容量。 用途： 物理内存不足时一些不常用的页可以被交换出去，腾给系统。 程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。 3.5 什么是分页？把内存空间划分为大小相等且固定的块，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。 访问分页系统中内存数据需要两次的内存访问 (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。 3.6 什么是分段？分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。 分段内存管理当中，地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。 3.7 分页分段的区别是什么？ 属性：页是信息的物理单位，对用户不可见，段是逻辑单位，用户可见。 大小：分页固定，分段不固定 决定权：分页在于系统，分段在于用户 目的：分页有利于资源的利用，分段方便用户管理内存 3.8 有哪些页面置换算法？缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。 有时候操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。 先进先出FIFO：总是选择在主存中停留时间最长（即最老）的一页置换 LRU：选择在最近一段时间里最久没有使用过的页面予以置换 LFU(least frequent)：统计页的使用频率，选择在最近时期使用最少的页面作为淘汰页 4. 系统中断4.1 中断的处理过程 保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈 开中断：以便执行中断时能响应较高级别的中断请求。 中断处理 关中断：保证恢复现场时不被新中断打扰 恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态。 4.2 中断和轮询有什么区别？轮询：CPU对特定设备轮流询问。中断：通过特定事件提醒CPU。 轮询：效率低等待时间长，CPU利用率不高。中断：容易遗漏问题，CPU利用率不高。","categories":[{"name":"Linux","slug":"Linux","permalink":"jiangren.work/categories/Linux/"}],"tags":[{"name":"面试经验","slug":"面试经验","permalink":"jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"},{"name":"Linux","slug":"Linux","permalink":"jiangren.work/tags/Linux/"}]},{"title":"go设计模式","slug":"go设计模式","date":"2020-02-14T02:09:34.000Z","updated":"2020-02-18T14:42:03.000Z","comments":true,"path":"2020/02/14/go设计模式/","link":"","permalink":"jiangren.work/2020/02/14/go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"介绍编程的各种设计模式，用go语言实现。","text":"介绍编程的各种设计模式，用go语言实现。 1. 单例模式单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。简单的说就是希望我们的系统中该类仅仅存在1个或0个该类的实例。 1.1 非并发情况提供了一个GetInstance函数去获取它的实例，根据是否为空来判断究竟应该创建新的还是沿用旧的。用系统时间作为鉴别依据。编写时主要考虑： 实例具有全局性 创建前先判断 type manager struct { t time.Time } func (p manager) manage(){ s:=fmt.Sprintf(&quot;time=%s, managing...&quot;,p.t) fmt.Println(s) } var m *manager func GetInstance() *manager{ if m==nil{ m=new(manager) m.t=time.Now() } return m } func main(){ a:=GetInstance() a.manage() b:=GetInstance() b.manage()//二者输出相同时间，证明单例成功 } 1.2 线程安全老问题：if m==nil语句到m=new(manager)之间并不安全，可能创建多次。 方法一，可以用锁锁一下： var m *manager var mutex sync.Mutex //注意要import sync func GetInstance() *manager{ mutex.Lock() defer mutex.Unlock() if m==nil{ m=new(manager) m.t=time.Now() } return m } 方法二，提高效率可以采用双重锁机制，前者每次都会锁，双重锁机制下只有部分情况才会锁。但双重锁有个问题：new是先创建指针然后分配内存，如果在这中间被if抢先了就会造成误操作，多生成一个manager var m *Manager var lock *sync.Mutex = &amp;sync.Mutex {} func GetInstance() *Manager { if m == nil { lock.Lock() defer lock.Unlock() if m == nil { m = new(manager) } } return m } 方法三，sync.Once，它有一个Do方法，在它中的函数go会只保证仅仅调用一次。跟C++的`std::call_once函数是一个意思。 var m *manager var once sync.Once func GetInstance() *manager{ lambda:=func(){ m=new(manager) } once.Do(lambda) return m } 2. 工厂模式2.1 简单工厂模式定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。 下面看个例子： 项目 说明 Phone 接口，只有一个方法来获取电池容量 type Huawei struct 华为手机构造体 type Xiaomi struct 小米手机构造体 func (p* Huawei) get Battery 华为手机的GetBattery实现 func (p* Xiaomi) get Battery 小米手机的GetBattery实现 type PhoneFactory struct 手机工厂的构造体 func (factory PhoneFactory) CreatePhone(brand string) Phone 手机工厂的CreatePhone实现 注意GetBattery函数不是必须的，这里只是方便演示。要注意工厂生产函数的返回类型，phone的接口类型。 //phone作为接口，统一方法 type Phone interface{ getBattery() } //华为 type Huawei struct{} func (p* Huawei) getBattery(){ fmt.Println(&quot;[Huawei battery]:4500mAn&quot;) } //小米 type Xiaomi struct{} func (p* Xiaomi) getBattery(){ fmt.Println(&quot;[Xiaomi battery]:4400mAn&quot;) } //工厂生产 type PhoneFactory struct { } func (p* PhoneFactory) Creat(brand string) Phone{ switch brand { case &quot;Huawei&quot;: return new(Huawei) case &quot;Xiaomi&quot;: return new(Xiaomi) default: return nil } } func main(){ var phone Phone factory:=new(PhoneFactory) phone=factory.Creat(&quot;Huawei&quot;) phone.getBattery() phone=factory.Creat(&quot;Xiaomi&quot;) phone.getBattery() } 2.2 工厂方法模式 简单工厂需要: 工厂结构体 产品接口 产品结构体 假设餐馆生产面条和米饭，如果只有一个餐馆则简单工厂模式即可解决，但如果有开了分店，有多个工厂，就需要工厂方法模式了。 工厂方法需要: 工厂接口 工厂结构体 产品接口 产品结构体 //Step1. 添加接口 //工厂接口 type FactoryInterface interface { Generate(s string) ProductInterface //继承自产品接口 } // 产品接口 type ProductInterface interface { create() } //Step2. 创建产品结构体及方法 type RiceShopA struct {} type NoodleShopA struct {} type RiceShopB struct {} type NoodleShopB struct {} func (p* RiceShopA) create() { fmt.Println(&quot;A店米饭&quot;) } func (p* NoodleShopA) create() { fmt.Println(&quot;A店面条&quot;) } func (p* RiceShopB) create() { fmt.Println(&quot;B店米饭&quot;) } func (p* NoodleShopB) create() { fmt.Println(&quot;B店面条&quot;) } //Step3. 创建工厂及方法 type shopA struct{} type shopB struct{} func (p* shopA) Generate(s string)ProductInterface{ switch s{ case &quot;rice&quot;: return new(RiceShopA) case &quot;noodle&quot;: return new(NoodleShopA) default: return nil } } func (p* shopB) Generate(s string)ProductInterface{ switch s{ case &quot;rice&quot;: return new(RiceShopB) case &quot;noodle&quot;: return new(NoodleShopB) default: return nil } } func main(){ newshopA:=new(shopA) a:=newshopA.Generate(&quot;rice&quot;) a.create() newshopB:=new(shopB) b:=newshopB.Generate(&quot;noodle&quot;) b.create() } 2.3 抽象工厂模式与工厂方法模式的区别在于：工厂方法模式是一个工厂接口创建了一个方法，一个方法对应了两个工厂结构体，而抽象工厂模式是一个工厂接口创建了两个方法生产。 假设有广东包子铺和祁山包子铺两家，都生产猪肉和三鲜包子： type FactoryInterface interface { CreatePigMeatBuns() ProductInterface // 创建猪肉馅产品 Create3SBuns() ProductInterface // 创建三鲜馅产品 } type ProductInterface interface { Intro() } 然后实现4种产品： type GDPigMeatBuns struct { } func (p GDPigMeatBuns) Intro() { fmt.Println(&quot;广东猪肉馅包子&quot;) } // TODO ... 其他产品实现方法没区别 之后实现工厂： // 齐市包子铺 type QSFactory struct { } func (qs QSFactory) CreatePigMeatBuns() ProductInterface { return QSPigMeatBuns{} } func (qs QSFactory) Create3SBuns() ProductInterface { return QS3SBuns{} } // 广东包子铺 type GDFactory struct { } func (gd GDFactory) CreatePigMeatBuns() ProductInterface { return GDPigMeatBuns{} } func (gd GDFactory) Create3SBuns() ProductInterface { return GD3SBuns{} } 最后实际生产： var f FactoryInterface // 特意以这种方式声明，更好的体会抽象工厂模式的好处 f = new(QSFactory) b := f.CreatePigMeatBuns() b.Intro() 优点: 抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。 缺点: 产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的 3. 策略模式体现的原则是对扩展开放，对修改关闭(开闭原则) ，如果我们要增加一些规则，完全不用修改主业务流程，只需要增加几个策略即可。 假设创建加减乘除方法： //策略接口 type Strategier interface { Compute(num1, num2 int) int } //策略之一：除法 type division struct{} func (p* division) Compute(num1,num2 int) int{ if num2 == 0 { panic(&quot;num2 must not be 0!&quot;) } return num1 / num2 } func NewStrategy(t string)(res Strategier){ switch t { case &quot;d&quot;: res=new(division) default: res=nil } return } func main(){ Strategy:=NewStrategy(&quot;d&quot;) val:=Strategy.Compute(20,10) fmt.Println(val) } 4. 观察者模式多个对象同时观察一个对象，当这个被观察的对象发生变化的时候，这些对象都会得到通知，可以做一些操作。 核心要点： 观察者需要接收观察变化的函数 被观察者要能创建观察者 被观察者要能通知观察者 //创建观察者 type IObserver interface{ Notify() } //创建被观察者 type IObject interface{ AddObserver(observers Observer) NotifyObservers() } type Observer struct{} func (p* Observer) Notify(){ fmt.Println(&quot;已触发观察者&quot;) } type Obeject struct{ Observers []IObserver } func (p* Obeject) AddObserver(observer []IObserver){ p.Observers=append(p.Observers, observer...) } func (p* Obeject) NotifyObserver(){ for k:=range p.Observers{ p.Observers[k].Notify() } } func main(){ // 创建被观察者 s := new(Obeject) // 创建观察者 o := make([]IObserver,0) o=append(o, new(Observer)) o=append(o, new(Observer)) // 为主题添加观察者 s.AddObserver(o) s.NotifyObserver() } 5. 代理模式举两个生活化的例子： 火车票的代理售票点。代售点就是代理，它拥有被代理对象的部分功能 — 售票功能 明星的经纪人，经纪人就是代理，负责为明星处理一些事务。 type seller interface{ sell(consumer string) } type Station struct{ //真正的销售者 stock int //存货 } func (p* Station)sell(consumer string){ if p.stock&gt;0{ p.stock-- fmt.Printf(&quot;火车站，客户：%s买了一张票,剩余：%d \\n&quot;, consumer,p.stock) }else{ fmt.Println(&quot;已售空&quot;) } } type Xiecheng struct{ //携程代理 station *Station //持有一个火车站 } func (p* Xiecheng)sell(consumer string){ if p.station.stock&gt;0{ p.station.stock-- fmt.Printf(&quot;携程网，客户：%s买了一张票,剩余：%d \\n&quot;, consumer,p.station.stock) }else{ fmt.Println(&quot;已售空&quot;) } } func main(){ sta:=Station{3} proxy:=new(Xiecheng) proxy.station=&amp;sta proxy.sell(&quot;Bob&quot;) sta.sell(&quot;Lily&quot;) } 6. 生产者消费者模式6.1 无缓冲** var wg sync.WaitGroup func producer(ch chan&lt;-int){ defer wg.Done() for i:=0;i&lt;3;i++{ ch&lt;-i fmt.Println(&quot;send:&quot;,i) } } func consumer(ch &lt;-chan int){ defer wg.Done() for i:=0;i&lt;3;i++{ v:=&lt;-ch fmt.Println(&quot;received:&quot;,v) } } func main(){ wg.Add(2) ch:=make(chan int) go producer(ch) go consumer(ch) wg.Wait() } 因为channel没有缓冲区，所以当生产者给channel赋值后会进入阻塞状态。消费者取出一次数据后由于没有数据可读，也会进入阻塞。输出如下： send: 0 received: 0 send: 1 received: 1 send: 2 received: 2 如果没有按这个顺序输出，是print输出缓冲区的问题，加个50ms延时即可。 6.2 有缓冲只需要在ch创建时改为 ch := make(chan int, 10) 输出： send: 0 send: 1 send: 2 received: 0 received: 1 received: 2","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"}]},{"title":"Beego框架学习5-独立模块","slug":"Beego框架学习5-独立模块","date":"2020-02-03T07:32:45.000Z","updated":"2020-02-04T09:54:49.000Z","comments":true,"path":"2020/02/03/Beego框架学习5-独立模块/","link":"","permalink":"jiangren.work/2020/02/03/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A05-%E7%8B%AC%E7%AB%8B%E6%A8%A1%E5%9D%97/","excerpt":"介绍Beego的结构模块。","text":"介绍Beego的结构模块。 1. Session1.1 什么是sessionSession的英文意思是会议，在Beego里面用于会话控制。Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。 通常session实现机制都是在客户端放一个session ID (cookie)，然后服务端存储一份session数据与之对应。服务端存储Session的位置可以自由决定，一般有： 内存 cookie 文件 mysql redis 1.2 session的基本配置beego默认不会开启session，所以要先打开，这一步一定要做。 sessionon = true 然后设置session id的名字，这个通常都是保存在客户端cookie里面。 sessionname = &quot;beegosessionID&quot; 此外我们还可以设置session的过期时间和session id(一般保存在cookie中)的过期时间（默认都是3600秒） sessiongcmaxlifetime = 3600 SessionCookieLifeTime = 3600 1.3 session的例子我们一个简单的控制器函数： func (this *MainController) Get() { // 读取session数据 v := this.GetSession(&quot;count&quot;) if v == nil { // 写入session数据 this.SetSession(&quot;count&quot;, int(1)) this.Data[&quot;num&quot;] = 0 } else { // 写入session数据 this.SetSession(&quot;count&quot;, v.(int)+1) this.Data[&quot;num&quot;] = v.(int) } this.TplName = &quot;index.html&quot; } 其中.(int)是只有对接口对象才能执行类型动态转换，在模板中写： &lt;body&gt; &lt;h1&gt;访问次数:&lt;/h1&gt; &lt;p&gt; {{ if .num}} 已经访问了：{{.num}} 次！ {{else}} 还没有访问！ {{end}} &lt;/p&gt; &lt;/body&gt; 只要我们访问localhost:8080/register，就会统计次数，每次刷新都会增加次数。 除此之外，session还有很多其他读写函数： ·SetSession(name string, value interface{}) - 设置session值 GetSession(name string) interface{} - 读取session值 DelSession(name string) - 删除指定session值 SessionRegenerateID() - 生成新的session id DestroySession() - 销毁session 1.4 配置session的存储引擎前面提到的session引擎，默认是内存，这一节介绍其他的存储方法。 （1）文件存储 # 设置session保存到文件中 sessionprovider = &quot;file&quot; # session数据保存目录 sessionproviderconfig = &quot;./data/session&quot; （2）mysql存储 首先还是要mysql驱动， go get github.com/astaxie/beego/session/redis 然后在main.go入口导入redis驱动： import _ &quot;github.com/astaxie/beego/session/redis&quot; 然后 # 设置session存储引擎 sessionprovider = &quot;mysql&quot; # mysql存储引擎配置 sessionproviderconfig = &quot;root:123456@tcp(localhost:3306)/tizi365?charset=utf8&quot; mysql配置格式是：username:password@protocol(address)/dbname?param=value。 （3）redis存储 将session数据保存到redis中，需要先安装redis驱动，然后在main.go文件中导入redis驱动。 配置: # 设置session存储引擎 sessionprovider = &quot;redis&quot; # redis存储引擎配置 # redis配置格式: redis地址,redis连接池最大连接数,redis密码 # redis连接池和redis密码配置，没有保持为空，例子:127.0.0.1:6379 sessionproviderconfig = &quot;127.0.0.1:6379,1000,123456&quot; 安装redis驱动: go get github.com/astaxie/beego/session/redis 在main.go入口文件，导入redis驱动 import _ &quot;github.com/astaxie/beego/session/redis&quot; 2. 日志前导工作： go get github.com/astaxie/beego/logs //安装 import ( //导入 &quot;github.com/astaxie/beego/logs&quot; ) 然后需要设置日志级别： // debug级别 logs.SetLevel(logs.LevelDebug) 下面是常用的日志级别： 由高到底，高于当前日志级别的日志不展示。 LevelDebug - 对应数字 7 LevelInfo - 对应数字 6 LevelWarn - 对应数字 4 LevelError - 对应数字 3 然后是日志输出到文件的配置： logs.SetLogger(&quot;file&quot;, `{&quot;filename&quot;:&quot;app.log&quot;, &quot;level&quot;:6}`) 第二个参数是一个map，可以选用的配置有： 参数名 说明 filename 日志文件名 maxlines 每个文件保存的最大行数，默认值 1000000 maxsize 每个文件保存的最大尺寸，默认值是 1 &lt;&lt; 28, //256 MB daily 是否按照每天 logrotate，默认是 true maxdays 文件最多保存多少天，默认保存 7 天 rotate 是否开启 logrotate，默认是 true level 日志保存的时候的级别，默认是 Trace 级别 perm 日志文件权限 最后是调用不同的日志级别在文件中打印日志： logs.Debug(&quot;这是一条debug日志, 后面是参数 &quot;, 2019,2018) logs.Info(&quot;携带参数1: %s, 参数2: %d&quot;, &quot;tizi365&quot;, 2019) logs.Warn(&quot;可以直接打印map类型数据 &quot;, map[string]int{&quot;key&quot;: 2019}) logs.Error(&quot;参数1&quot;, &quot;参数2&quot;, &quot;后面可以加入任意参数&quot;) 输出日志： 2019/06/30 18:38:23.075 [D] [main.go:29] tizi365 这是一条debug日志, 后面是参数 2019 2018 2019/06/30 18:38:23.149 [I] [main.go:29] tizi365 携带参数1: tizi365, 参数2: 2019 2019/06/30 18:38:23.149 [W] [main.go:29] tizi365 可以直接打印map类型数据 map[key:2019] 2019/06/30 18:38:23.149 [E] [main.go:29] tizi365 参数1 参数2 后面可以加入任意参数","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"},{"name":"Beego","slug":"Beego","permalink":"jiangren.work/tags/Beego/"}]},{"title":"Beego框架学习4-Viewer","slug":"Beego框架学习4-Viewer","date":"2020-02-03T05:52:26.000Z","updated":"2020-02-04T10:41:26.000Z","comments":true,"path":"2020/02/03/Beego框架学习4-Viewer/","link":"","permalink":"jiangren.work/2020/02/03/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A04-Viewer/","excerpt":"介绍MVC之视图viewer。","text":"介绍MVC之视图viewer。 1. 简单的模板应用beego 的视图(view)模板引擎是基于Go原生的模板库（html/template）进行开发的。 用户通过在 Controller 的对应方法中设置相应的模板名称，beego 会自动的在 viewpath 目录下查询该文件并渲染，例如下面的设置，beego 会在 view/admin 下面找 add.tpl 文件进行渲染： func (this *RegController) Get(){ this.TplName = &quot;admin/add.tpl&quot; } 下面举个例子： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;用户个人信息:&lt;/h1&gt; &lt;p&gt; {{ if .user}} 用户名: {{.user.Username}} &lt;br/&gt; 注册时间: {{.user.InitTime}} {{else}} 用户不存在! {{end}} &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 在控制器中写： type User struct { Id int Username string InitTime time.Time } func (this *RegController) Get(){ user:=&amp;User{1,&quot;ming&quot;,time.Now()} this.Data[&quot;user&quot;]=user this.TplName=&quot;index.html&quot; } 网页输出如下： 模板的参数依靠Data这个map传递，如果我们改为this.Data[&quot;users&quot;]那么就将输出：不存在。 2. 模板函数户还可以自定义模板函数： func newfunc(in string)(out string){ out=in+&quot;- 我是新函数&quot; return } beego.AddFuncMap(&quot;newFunction&quot;,newfunc) 然后将模板改为： {{.title | newFunction}} 3. 静态资源处理除了html模板之外，往往还存在js/css/jpg之类的静态资源文件，beego默认静态资源都是保存在static目录，访问静态资源的url是 http://域名/static/资源路径名。 比如如果我们在/static/img下面放了一张cat.jpg，那么我们访问localhost:8080/static/img/cat.jpg就能出现这张图片。 然而URL这样会变得很冗长，也不清晰。我们我们需要通过beego.SetStaticPath函数设置静态资源路由和目录。 // 例: /images/user/1.jpg 实际访问的是 static/images/user/1.jpg beego.SetStaticPath(&quot;/images&quot;,&quot;static/images&quot;) // 通过 /css/资源路径 可以访问static/css目录的内容 beego.SetStaticPath(&quot;/css&quot;,&quot;static/css&quot;)","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"},{"name":"Beego","slug":"Beego","permalink":"jiangren.work/tags/Beego/"}]},{"title":"Beego框架学习3-Controller","slug":"Beego框架学习3-Controller","date":"2020-02-01T03:06:03.000Z","updated":"2020-02-03T13:46:48.000Z","comments":true,"path":"2020/02/01/Beego框架学习3-Controller/","link":"","permalink":"jiangren.work/2020/02/01/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A03-Controller/","excerpt":"本章介绍Beego的控制器。","text":"本章介绍Beego的控制器。 1. 参数配置1.1 修改默认配置beego默认会解析当前应用下的conf/app.conf文件，通过这个文件你可以初始化很多 beego 的默认参数： appname = firstProject httpport = 8080 runmode = dev 也可以在配置文件中配置应用需要用的一些配置信息，例如下面所示的数据库信息： mysqlUser = &quot;test&quot; mysqlPass = &quot;asdfg12345&quot; mysqlIp =&quot;cdb-axt937vt.gz.tencentcdb.com&quot; mysqlPort=&quot;10059&quot; mysqlDbname = &quot;test&quot; 可以通过如下的方式获取设置的配置信息: m:=beego.AppConfig.String(&quot;mysqlUser&quot;) n:=beego.AppConfig.String(&quot;mysqlPass&quot;) 1.2 不同级别的配置根据不同的运行环境，产品的配置可能不同。 可以有不同的 Runmode 的配置，默认优先读取 runmode 下的配置信息，例如下面的配置文件，我们可以把配置分成三份，比如dev，prod，test： appname = beegoDemo runmode = dev [dev] httpport = 9527 [test] httpport = 5566 [prod] httpport = 8082 读取不同模式下配置参数的方法是“模式::配置参数名”，比如： beego.AppConfig.String(&quot;dev::mysqluser&quot;) 2. 路由控制路由指的就是一个url请求由谁来处理，我们知道Go的执行过程如下： 在Beego中默认路由的执行路径是： 在routers包中，我们看到： package routers import ( &quot;beegoDemo/controllers&quot; &quot;github.com/astaxie/beego&quot; ) func init() { beego.Router(&quot;/&quot;, &amp;controllers.MainController{}) } 路由初始化中，我们通过路由注册函数 beego.Router, 注册了一个MainController{}控制器。第一个参数是 URL (用户请求的地址)，这里我们注册的是 /，也就是我们访问的不带任何参数的 URL。 在beego设计中，url请求可以由控制器的函数来处理，也可以由一个单独的函数来处理，因此路由设置由两部分组成：url路由 和 处理函数。beego提供两种设置处理函数的方式: 直接绑定一个函数 绑定一个控制器对象 （RESTful方式） 2.1 处理函数方式2.1.1 直接绑定函数这种方式直接将一个url路由和一个函数绑定起来。可以用闭包来表示路由，所以可以在router里面直接写： beego.Get(&quot;/hel&quot;,func(ctx *context.Context){ ctx.Output.Body([]byte(&quot;hello world&quot;)) }) 这个函数借用了Beego提供的Get接口，但利用闭包重写了方法，输出hello world。 此外还有基本的POST路由： beego.Post(&quot;/alice&quot;,func(ctx *context.Context){ ctx.Output.Body([]byte(&quot;bob&quot;)) }) 所有的支持的基础函数如下所示： beego.Get(router, beego.FilterFunc) beego.Post(router, beego.FilterFunc) beego.Put(router, beego.FilterFunc) beego.Head(router, beego.FilterFunc) beego.Options(router, beego.FilterFunc) beego.Delete(router, beego.FilterFunc) beego.Any(router, beego.FilterFunc) 2.1.2 RESTful路由在beego项目中，RESTful路由方式就是将url路由跟一个控制器对象绑定，然后Get请求由控制的Get函数处理，Post请求由Post函数处理，以此类推。 // url: / 的所有http请求方法都由MainController控制器的对应函数处理 beego.Router(&quot;/&quot;, &amp;controllers.MainController{}) // url: /user 的所有http请求方法都由UserController控制器的对应函数处理 beego.Router(&quot;/user&quot;, &amp;controllers.UserController{}) 接下来看一个例子： （1）在controller中写： package controllers import ( &quot;github.com/astaxie/beego&quot; ) type HelloController struct { beego.Controller } func (hello *HelloController) Get() { hello.Ctx.WriteString(&quot;hello go&quot;) } 这一步中我们声明了一个控制器 HelloController，内嵌了一个beego.Controller，类似于继承的效果。然后为控制器安排了一个方法Get()，输出hello go。 （2）在routers的初始化函数中写： beego.Router(&quot;/hello&quot;, &amp;controllers.HelloController{}) /hello是URL的一部分，可以通过localhost:8080/hello访问。 2.3 路由方式这一部分主要介绍url路由的规则，以下内容都适用于上面介绍的所有路由设置函数。 （1）固定路由 最常见的方式，固定路由指的是url规则是固定的一个url。 beego.Router(&quot;/user&quot;, &amp;controllers.UserController{}) beego.Router(&quot;/shop/order&quot;, &amp;controllers.OrderController{}) beego.Router(&quot;/shop/comment&quot;, &amp;controllers.CommentController{}) （2）正则路由 由正则表达式形成的路由，先看一个例子： 首先在controller中定义一个控制器： type RegExpController struct { beego.Controller } func (this *RegExpController) Get() { this.Ctx.WriteString(fmt.Sprintf(&quot;&lt;p&gt;In RegExp Mode&lt;/p&gt;&quot;)) id := this.Ctx.Input.Param(&quot;:id&quot;) this.Ctx.WriteString(fmt.Sprintf(&quot;id is %s.&lt;br /&gt;&quot;, id)) } 然后在router注册这个控制器，参数可以由:id传递： // 正则路由从path中提取参数 beego.Router(&quot;/RegExp1/?:id&quot;, &amp;controllers.RegExpController{}) // 正则表达式匹配数字，+表示匹配1次或多次 beego.Router(&quot;/RegExp2/?:id([0-9]+)&quot;, &amp;controllers.RegExpController{}) //匹配下划线和字符 beego.Router(&quot;/RegExp3/?:id([\\\\w]+)&quot;, &amp;controllers.RegExpController{}) // http://127.0.0.1:8081/RegExp4/abc123de (id=123) beego.Router(&quot;/RegExp4/abc:id([0-9]+)de&quot;, &amp;controllers.RegExpController{}) 键入不同的URL，会出现不同的结果： 键入：localhost:8080/RegExp1/12a 显示： In RegExp Mode id is 12a. 键入：localhost:8080/RegExp2/12a 显示：404 键入：localhost:8080/RegExp2/13 显示： In RegExp Mode id is 13 （3）自动路由 自动路由指的是通过反射获取到控制器的名字和控制器实现的所有函数名字，自动生成url路由。 假设我们编写了一个UserController控制器，为控制器添加了Login和Logout方法，正常来说，需要在router里面调用beego.Router两次，分别注册，这样非常麻烦。 如果采用自动路由： beego.AutoRouter(&amp;controllers.UserController{}) url自动路由例子: /user/login 调用 UserController 中的 Login 方法 /user/logout 调用 UserController 中的 Logout 方法 3. 获取请求参数我们经常需要获取用户传递的数据，包括 Get、POST 等方式的请求，beego里面会自动解析这些数据。 3.1 默认获取参数的方式beego.Controller基础控制器为我们提供了GetXXX序列获取参数的函数, XXX指的就是返回不同的数据类型。 type HelloController struct { beego.Controller } func (this *HelloController) Get(){ id,_:=this.GetInt(&quot;id&quot;) username:=this.GetString(&quot;username&quot;,&quot;none&quot;) this.Ctx.WriteString(strconv.Itoa(id)) this.Ctx.WriteString(&quot; &quot;) this.Ctx.WriteString(username) } URL输入localhost:8080/hello?id=1&amp;username=clearlove。不仅能在网页上看到输出，还能通过控制台看到： 2020/02/03 12:03:17.185 [D] [server.go:2802] | ::1| 200 | 0s| match| GET /hello r:/hello 3.2 绑定struct方式除了上面一个一个的获取请求参数，针对POST请求的表单数据，beego支持直接将表单数据绑定到一个struct变量。 上一节的Demo采用的是URL传入参数，这次采用Post表单的形式传入。首先在viewer文件夹下生成一个HTML文件register.html： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;注册&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/register&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name =&quot;Name&quot; value=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;password&quot; name =&quot;Pwd&quot; value=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;submit&quot; value=&quot;确认&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt; 然后在控制器中写： type Users struct { Name string Pwd string } func (this *RegController) Get(){ this.TplName=&quot;register.html&quot; } func (this *RegController) Post(){ user:=Users{} err := this.ParseForm(&amp;user) if err!=nil{ fmt.Println(&quot;err:&quot;,err) }else{ this.Ctx.WriteString(&quot;我是结构体\\n&quot;) this.Ctx.WriteString(&quot;Name=&quot;+user.Name+&quot;\\nPwd=&quot;+user.Pwd) } } 这段代码的思路是：首先用户访问localhost:8080/register时，Begoo读取register.html资源。 当用户输入账号密码，点击确认时，触发Post。控制器接收请求，解析到结构体中，然后显示出来。 如同Beego框架学习2中提到的，我们还可以使用标签来控制解析： 比如给属性设置别名： PlayerName string `form:&quot;Name&quot;` 结果还是没变，因为我们写的就是如此， this.Ctx.WriteString(&quot;Name=&quot;+user.PlayerName+...) 同时我们也可以设置不想解析的内容，比如验证码。 type Users struct { Name string Pwd string VerCode string `form:&quot;-&quot;` //忽略验证码 } 3.3 处理Json请求有时候会将json请求参数保存在http请求的body里面，所以我们需要解析body的内容。 处理json参数的步骤： 在app.conf配置文件中，添加CopyRequestBody=true 通过this.Ctx.Input.RequestBody获取请求body的内容 通过json.Unmarshal反序列化json字符串，将json参数绑定到struct变量。 // 如果json字段跟struct字段名不一样，可以通过json标签设置json字段名 type UserForm struct { // 忽略掉Id字段 Id int `json:&quot;-&quot;` // json字段名为username Name string `json:&quot;username&quot;` Phone string } 控制器代码: func (this *UserController) Post() { // 定义保存json数据的struct对象 u := UserForm{} // 获取body内容 body := this.Ctx.Input.RequestBody // 反序列json数据，结果保存至u if err := json.Unmarshal(body, &amp;u); err == nil { // 解析参数失败 } } 4. 响应请求第三章主要描述了如何解析用户的请求，而这一章则是如何返回处理过的请求给用户。 4.1 返回json数据// 如果struct字段名跟json字段名不一样，可以使用json标签,指定json字段名 type User struct { // - 表示忽略id字段 Id int `json:&quot;-&quot;` Username string `json:&quot;name&quot;` Phone string } func (this *UserController) Get() { // 定义需要返回给客户端的数据 user := User{1, &quot;tizi365&quot;, &quot;13089818901&quot;} // 将需要返回的数据赋值给json字段 this.Data[&quot;json&quot;] = &amp;user // 将this.Data[&quot;json&quot;]的数据，序列化成json字符串，然后返回给客户端 this.ServeJSON() } 4.2 返回XML数据// 如果struct字段名跟xml字段名不一样，可以使用xml标签,指定xml字段名 type User struct { // - 表示忽略id字段 Id int `xml:&quot;-&quot;` Username string `xml:&quot;name&quot;` Phone string } func (this *UserController) Get() { // 定义需要返回给客户端的数据 user := User{1, &quot;tizi365&quot;, &quot;13089818901&quot;} // 将需要返回的数据赋值给xml字段 this.Data[&quot;xml&quot;] = &amp;user // 将this.Data[&quot;xml&quot;]的数据，序列化成xml字符串，然后返回给客户端 this.ServeXML() } 4.3 返回网页func (c *MainController) Get() { // 设置模板参数 c.Data[&quot;Website&quot;] = &quot;123.com&quot; c.Data[&quot;Email&quot;] = &quot;asd@demo.com&quot; // 需要渲染的模板， beego会渲染这个模板，然后返回结果 c.TplName = &quot;index.tpl&quot; }","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"},{"name":"Beego","slug":"Beego","permalink":"jiangren.work/tags/Beego/"}]},{"title":"Beego框架学习2-Model","slug":"Beego框架学习2-Model","date":"2020-01-31T05:05:35.000Z","updated":"2020-02-04T09:20:08.000Z","comments":true,"path":"2020/01/31/Beego框架学习2-Model/","link":"","permalink":"jiangren.work/2020/01/31/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A02-Model/","excerpt":"介绍Beego中的model。","text":"介绍Beego中的model。 1. Model介绍beego ORM 是一个强大的 Go 语言 ORM 框架，orm模块主要是处理MVC中的M（models） 对象-关系映射（Object-Relational Mapping，简称ORM）。当我们实现一个应用程序时（不使用O/R Mapping），我们可能会写特别多数据访问层的代码，从数据库保存、删除、读取对象信息，而这些代码都是重复的。而使用ORM则会大大减少重复性代码。 ORM的特性： 支持范围广：支持 Go 的所有类型存储 上手容易：采用简单的 CRUD 风格，允许直接使用 SQL 查询／映射 兼容性好：跨数据库兼容查询 自动 Join 关联表 2. 基本应用2.1 数据库设置首先需要安装orm模块和mysql驱动： // 安装beego orm包 go get github.com/astaxie/beego/orm // 安装mysql驱动 go get github.com/go-sql-driver/mysql 同时，也需要导入包： import ( // 导入orm包 &quot;github.com/astaxie/beego/orm&quot; // 导入mysql驱动 _ &quot;github.com/go-sql-driver/mysql&quot; ) 接下来是配置连接信息，配置过程和GoWeb实战1方法相似： const( userName = &quot;test&quot; password = &quot;asdfg12345&quot; ip =&quot;cdb-axt937vt.gz.tencentcdb.com&quot; port=&quot;10059&quot; dbName = &quot;test&quot; ) func init(){ connectInfo:=[]string{userName,&quot;:&quot;,password,&quot;@tcp(&quot;,ip,&quot;:&quot;,port,&quot;)/&quot;, dbName, &quot;?charset=utf8&amp;parseTime=true&amp;loc=Local&quot;} path:=strings.Join(connectInfo,&quot;&quot;) orm.RegisterDataBase(&quot;default&quot;,&quot;mysql&quot;,path) // 打开调试模式，开发的时候方便查看orm生成什么样子的sql语句 orm.Debug=true } 数据库注册函数的原型如下： func RegisterDataBase(aliasName, driverName, dataSource string, params ...int) error 参数名 说明 aliasName 数据库的别名，用来在 ORM 中切换数据库使用 driverName 驱动名字 dataSource 数据库连接字符串 params 附加参数 常用的附加参数有： 参数名 默认值 说明 charset none 设置字符集，相当于 SET NAMES 语句 loc UTC 设置时区，可以设置为Local，表示根据本地时区走 parseTime false 是否需要将 mysql的 DATE 和 DATETIME 类型值转换成GO的time.Time类型。 readTimeout 0 I/O 读超时时间, sql查询超时时间. 单位 (“ms”, “s”, “m”, “h”), 例子: “30s”, “0.5m” or “1m30s”. timeout 0 连接超时时间，单位(“ms”, “s”, “m”, “h”), 例子: “30s”, “0.5m” or “1m30s”. 2.2 准备工作首先我们创建一个表，用于测试： CREATE TABLE `online_orders` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增ID&#39;, `shop_id` int(10) unsigned NOT NULL COMMENT &#39;店铺id&#39;, `customer_id` int(10) unsigned NOT NULL COMMENT &#39;用户id&#39;, `nickname` varchar(20) DEFAULT NULL COMMENT &#39;用户昵称&#39;, `address` varchar(200) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户地址&#39;, `init_time` datetime NOT NULL COMMENT &#39;创建订单的时间&#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; id为无符号整形，长度最长为10，不允许空NOT NULL，自增。varchar是可变字符串类型。datetime类型用于存储时间，存储方式是： YYYY-MM-DD HH:MM:SS 建完后可以看到： 接下来需要构建结构体承载数据： type Order struct{ Id int ShopId int UserId int `orm:&quot;colunm(customer_id)&quot;` Nickname string Address string InitTime time.Time } ORM中结构体和表明的转化规则是驼峰转蛇形，除了开头以外，遇到大写需要_代替： AuthUser -&gt; auth_user Auth_User -&gt; auth__user DB_AuthUser -&gt; d_b__auth_user 所以，ShopId对应的是shop_id，又因为UserId在表中对应的是customer_id，不匹配，所以需要通过orm标签指定表字段名。 然后我们再为结构体添加一个函数，指定Order结构体默认绑定的表名： func (o *Order) TableName() string { return &quot;orders&quot; } 最后在main函数中，注册模型 orm.RegisterModel(new(Order)) 除了前面提到的用column设置名字外，还有其他有用的参数设置： 忽略字段- 设置自增键auto 设置为主键pk 在数据库默认非空下，允许为空null 比如： type User struct { ... AnyField string `orm:&quot;-&quot;` ... } 2.3 CRUD操作（1）插入数据 单条插入： orm.RegisterModel(new(Order)) o := orm.NewOrm() order:=Order{ ShopId:1, UserId:1002, Nickname:&quot;BOB&quot;, Address: &quot;北京东路&quot;, InitTime:time.Now(), } id,err:=o.Insert(&amp;order) if err != nil { fmt.Println(&quot;插入失败,err:&quot;,err) } else { // 插入成功会返回插入数据自增字段，生成的id fmt.Println(&quot;新插入数据的id为:&quot;, id) } 批量插入： o := orm.NewOrm() orders := []Order{ {ShopId:1, UserId:1001, Nickname:&quot;大锤1&quot;, Address:&quot;深圳南山区&quot;, InitTime: time.Now()}, {ShopId:1, UserId:1002, Nickname:&quot;大锤2&quot;, Address:&quot;深圳南山区&quot;, InitTime: time.Now()}, {ShopId:1, UserId:1003, Nickname:&quot;大锤3&quot;, Address:&quot;深圳南山区&quot;, InitTime: time.Now()}, } // 调用InsertMulti函数批量插入， 第一个参数指的是要插入多少数据 nums, err := o.InsertMulti(3, orders) （2）更新数据 更新所有字段： orm.RegisterModel(new(Order)) o:=orm.NewOrm() order:=Order{} order.Id=1 order.Nickname=&quot;希特&quot; order.Address=&quot;四川资阳&quot; order.InitTime=time.Now() num,err:=o.Update(&amp;order) //shop_id和custom_id将会变为0 if err != nil { fmt.Println(&quot;更新失败,err:&quot;,err) } else { fmt.Println(&quot;更新数据影响的行数:&quot;, num) } 更新指定字段： num, err := o.Update(&amp;order, &quot;Nickname&quot;, &quot;Address&quot;) （3）查询数据 orm.RegisterModel(new(Order)) o:=orm.NewOrm() order:=Order{} // 先对主键id赋值, 查询数据的条件就是where id=2 order.Id=1 err:=o.Read(&amp;order) if err == orm.ErrNoRows { fmt.Println(&quot;查询不到&quot;) } else if err == orm.ErrMissPK { fmt.Println(&quot;找不到主键&quot;) } else { fmt.Println(order.Id, order.Nickname) } （4）删除数据 orm.RegisterModel(new(Order)) o := orm.NewOrm() order := Order{} // 先对主键id赋值, 删除数据的条件就是where id=2 order.Id = 1 if num, err := o.Delete(&amp;order); err != nil { fmt.Println(&quot;删除失败&quot;) } else { fmt.Println(&quot;删除数据影响的行数:&quot;, num) } 3. 高级查询首先重新定义一个用户表 CREATE TABLE `users` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增ID&#39;, `username` varchar(30) NOT NULL COMMENT &#39;账号&#39;, `password` varchar(100) NOT NULL COMMENT &#39;密码&#39;, `city` varchar(50) DEFAULT NULL COMMENT &#39;城市&#39;, `init_time` datetime NOT NULL COMMENT &#39;创建的时间&#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 然后再定义结构体： type User struct{ Id int Username string Password string City string InitTime time.Time } func (o *User) TableName() string{ return &quot;users&quot; } 3.1 过滤查询过滤查询主要用的是QuerySeter，下面是一个简单的条件查询，查询来自武汉的且生成时间晚于2020年的用户： qs:=o.QueryTable(&quot;users&quot;) var users []User num,err:=qs.Filter(&quot;city&quot;,&quot;WUHAN&quot;).Filter((&quot;init_time__gt&quot;, &quot;2020-01-01 22:00:00&quot;).All(&amp;users,&quot;id&quot;,&quot;username&quot;) if err!=nil{ panic(err) } fmt.Println(&quot;结果行数:&quot;, num) 可以看到Filter能连携使用，还能处理大于小于等条件。使用等于条件时： qs.Filter(&quot;id&quot;, 1) // 相当于条件 id = 1 使用不等条件时，用双下划线 __ 作为分隔符，尾部连接操作符： qs.Filter(&quot;id__gt&quot;, 1) // 相当于条件 id &gt; 1 qs.Filter(&quot;id__gte&quot;, 1) // 相当于条件 id &gt;= 1 qs.Filter(&quot;id__lt&quot;, 1) // 相当于条件 id &lt; 1 qs.Filter(&quot;id__lte&quot;, 1) // 相当于条件 id &lt;= 1 qs.Filter(&quot;id__in&quot;, 1,2,3,4,5) // 相当于In语句 id in (1,2,3,4,5) 此外还有其他操作符： exact / iexact 等于，i表示大小写不敏感 contains / icontains 包含，i表示大小写不敏感 gt / gte 大于 / 大于等于 lt / lte 小于 / 小于等于 startswith / istartswith 以…起始 endswith / iendswith 以…结束 in 在其中 isnull 比如： qs.Filter(&quot;Username__icontains&quot;, &quot;大锤&quot;) // 相当于条件 name LIKE &#39;%大锤%&#39; qs.Filter(&quot;profile__age__in&quot;, ids) // WHERE profile.age IN (17, 18, 19, 20) 3.2 复杂查询有的时候我们需要将条件组合起来查询，上面的例子多个Filter函数调用只能生成and连接的查询条件。beego orm为我们提供了Condition对象，用于生成查询条件。 // 创建一个Condition对象 cond := orm.NewCondition() // 组织查询条件, 并返回一个新的Condition对象 cond1 := cond.And(&quot;Id__gt&quot;, 100).Or(&quot;City&quot;,&quot;shenzhen&quot;) // 相当于条件 id &gt; 100 or city = &#39;shenzhen&#39; var users []User qs.SetCond(cond1). // 设置查询条件 Limit(10). // 限制返回数据函数 All(&amp;users) // 查询多行数据 此外还可以连协Count，Group等功能： num, _ := o.QueryTable(&quot;users&quot;).Filter(&quot;Id__gt&quot;, 1).Filter(&quot;Id__lt&quot;, 100).Count() num, err := qs.Filter(&quot;Id__gt&quot;, 1). Filter(&quot;Id__lt&quot;, 100). GroupBy(&quot;City&quot;). // 根据city字段分组 OrderBy(&quot;-InitTime&quot;). // order by字段名前面的减号 - , 代表倒序。 Limit(10). // 限制返回行数 All(&amp;users) 4. 事务// 创建orm对象 o := orm.NewOrm() // 开始事务 o.Begin() // 开始执行各种sql语句，更新数据库，这里可以使用beego orm支持任何一种方式操作数据库 // 例如,更新订单状态 _, err1 := o.QueryTable(&quot;orders&quot;).Filter(&quot;Id&quot;, 1001).Update(orm.Params{ &quot;Status&quot;: &quot;SUCCESS&quot;, }) // 给用户加积分 _, err2 := o.Raw(&quot;update users set points = points + ? where username=?&quot;, &quot;tizi365&quot;, 100).Exec() // 检测事务执行状态 if err1 != nil || err2 != nil { // 如果执行失败，回滚事务 o.Rollback() } else { // 任务执行成功，提交事务 o.Commit() }","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"},{"name":"Beego","slug":"Beego","permalink":"jiangren.work/tags/Beego/"}]},{"title":"Beego框架学习1-Beego介绍","slug":"Beego框架学习1-Beego介绍","date":"2020-01-31T04:35:58.000Z","updated":"2020-02-03T13:46:46.000Z","comments":true,"path":"2020/01/31/Beego框架学习1-Beego介绍/","link":"","permalink":"jiangren.work/2020/01/31/Beego%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01-Beego%E4%BB%8B%E7%BB%8D/","excerpt":"介绍Beego的基本信息。","text":"介绍Beego的基本信息。 1. 什么是Beego1.1 Beego的特点beego是一个快速开发Go应用的HTTP框架，他可以用来快速开发API、Web及后端服务等各种应用。他的优势在于： 简单化：遵从REST设计理念，通过标准的几个动作来操纵资源。此外还可以用bee工具辅助，提高开发效率。 智能化：beego框架封装了路由模块，支持智能路由，智能监控，并可以监控内存消耗，CPU使用以及goroutine的运行状况，方便开发者对线上应用进行监控分析。 模块化：beego根据功能对代码进行解耦封装，形成了Session，Cache，Log，配置解析，性能监控，上下文操作，ORM等独立的模块，方便开发者进行使用。 高性能：采用Go原生的http请求，goroutine的并发效率应付大流量的Web应用和API应用。 1.2 Beego的架构Beego由八个独立模块构建，是一个高度解耦的应用，用户可以不使用beego的http逻辑使用里面的任意模块。 解耦，就是将程序积木化，各个积木块都是独立的，只要他们之间的接口（形状）匹配，就可以灵活地组合在一起。 一个软件系统由多个模块组成，在划分模块时，要把功能关系紧密的放到一个模块中(高内聚)，功能关系远的放到其它模块中。模块之间的联系越少越好，接口越简单越好。 具体框架设计如下： 这些模块的组成运行逻辑如下： 1.3 Beego项目结构一般的 beego 项目的目录如下所示，这是一个典型的MVC架构。 ├── conf │ └── app.conf ├── controllers │ ├── admin │ └── default.go ├── main.go ├── models │ └── models.go ├── static │ ├── css │ ├── ico │ ├── img │ └── js └── views ├── admin └── index.tpl MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写。 Model（模型）表示应用程序核心 View（视图）显示数据（数据库记录） Controller（控制器）处理输入（写入数据库记录 这种设计方法将业务逻辑、数据、界面显示分离的方法组织代码。 2. Beego的安装与运行beego 的安装是典型的 Go 安装包的形式： go get github.com/astaxie/beego 如果需要升级则是： go get -u github.com/astaxie/beego 此外，为了快速开发，还需要安装bee工具： go get github.com/beego/bee 以上内容安装好后，我们可在GOPATH/src/github.com中找到源码，以及在GOPATH/bin中找到bee.exe。此外还需要将GOPATH/bin添加到环境变量中。 如果输入bee version能够出现标志，即说明配置成功。 ______ | ___ \\ | |_/ / ___ ___ | ___ \\ / _ \\ / _ \\ | |_/ /| __/| __/ \\____/ \\___| \\___| v1.10.0 之后在控制台输入bee new projectname即可创建一个新的项目。运行后，在localhost:8080中可以看到如下标志，即说明项目成功运行。","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"},{"name":"Beego","slug":"Beego","permalink":"jiangren.work/tags/Beego/"}]},{"title":"GoWeb编程8-测试","slug":"GoWeb编程8-测试","date":"2020-01-28T06:32:31.000Z","updated":"2020-01-30T12:21:13.000Z","comments":true,"path":"2020/01/28/GoWeb编程8-测试/","link":"","permalink":"jiangren.work/2020/01/28/GoWeb%E7%BC%96%E7%A8%8B8-%E6%B5%8B%E8%AF%95/","excerpt":"本节介绍如何使用go自带的测试包testing以及第三方测试包对程序进行测试。","text":"本节介绍如何使用go自带的测试包testing以及第三方测试包对程序进行测试。 1. 单元测试1.1 基本的测试方法单元测试（unit test），就是一种为验证单元的正确性而设置的自动化测试，一个单元就是程序中的一个模块化部分。一般来说，一个单元通常会与程序中的一个函数或者一个方法相对应。 在Go中，以_test.go作为后缀的文件会被当做测试文件，比如main_test.go会被视为main.go的测试文件。 下面看一个例子，假设我们在main包内，编写了一个JSON解码器函数decode： type Post struct{ Id int `json:&quot;id&quot;` Content string `json:&quot;content&quot;` } func decode(filename string)(post Post,err error){ jsonFile,err := os.Open(filename) if err!=nil{ fmt.Println(&quot;Error opening JSON file:&quot;, err) return } defer jsonFile.Close() decoder:=json.NewDecoder(jsonFile) err = decoder.Decode(&amp;post) if err != nil { fmt.Println(&quot;Error decoding JSON:&quot;, err) return } return } 那么，我们接下来需要创建main_test.go，然后编写： func TestDecode(t *testing.T){ post,err := decode(&quot;post.json&quot;) if err != nil { t.Error(err) } if post.Id != 1 { t.Error(&quot;Wrong id, was expecting 1 but got&quot;, post.Id) } } 测试文件与被测试的源码文件位于同一个包内，它唯一导入并使用的包为testing包。函数TestDecode是一个测试用例，它代表的是对decode函数的单元测试。 testing.T结构拥有几个非常有用的函数： Log——将给定的文本记录到错误日志里面，与fmt.Println类似； Logf——根据给定的格式，将给定的文本记录到错误日志里面，与fmt.Printf类似； Fail——将测试函数标记为“已失败”，但允许测试函数继续执行； FailNow——将测试函数标记为“已失败”并停止执行测试函数。 运行测试用例的方法是，在控制台输入： go test 然后就能看到： D:\\Go_Practice&gt;go test PASS ok _/D_/Go_Practice 4.478s 1.2 跳过部分测试有些API暂时没有实现，或者某些功能现在不用测试，因此我们需要跳过。跳过的办法是调用skip： func TestLongRunningTest(t *testing.T) { if testing.Short() { t.Skip(&quot;Skipping long-running test in short mode&quot;) } time.Sleep(10 * time.Second) } 如果我们使用： go test -short 就能跳过被short引导的部分。 下面是测试部分： 当我们输入go test时，延时函数被执行： PASS ok _/D_/Go_Practice 11.737s 给定short标志后： PASS ok _/D_/Go_Practice 1.756s 1.3 并行测试只要单元测试可以独立地进行，用户就可以通过并行地运行测试用例来提升测试的速度。 在main_test.go文件所在的目录中创建一个名为parallel_test.go的文件，并在文件中键入代码： func TestParallel_1(t *testing.T){ t.Parallel() time.Sleep(1*time.Second) } func TestParallel_2(t *testing.T){ t.Parallel() time.Sleep(2*time.Second) } 这个程序利用time.Sleep函数，以2个测试用例分别模拟了2个需要耗时1s、2s的任务。只要在终端中执行以下命令，Go就会以并行的方式运行测试： go test –v –short –parallel 2 1.4 性能测试性能测试也叫基准测试（benchmarking），和之前的功能测试不同，这种测试的目的是检验程序的性能。 基准测试用例也需要放置到以_test.go为后缀的文件中，并且每个基准测试函数都需要符合以下格式： func BenchmarkXxx(*testing.B) { ... } 比如我们自建一个bench_test.go，然后输入： func BenchmarkDecode(b *testing.B){ for i:=0;i&lt;b.N;i++{ decode(&quot;post.json&quot;) } } 测试程序要做的就是将被测试的代码执行b.N次，以便准确地检测出代码的响应时间，其中b.N的值将根据被执行的代码而改变。 为了运行基准测试用例，用户需要在执行go test命令时使用基准测试标志-bench go test -v -short –bench . 点号表示运行目录下的所有基准测试文件，测试结果如下： === RUN TestDecode --- PASS: TestDecode (0.00s) === RUN TestLongRunningTest --- SKIP: TestLongRunningTest (0.00s) main_test.go:20: Skipping long-running test in short mode === RUN TestParallel_1 === PAUSE TestParallel_1 === RUN TestParallel_2 === PAUSE TestParallel_2 === CONT TestParallel_1 === CONT TestParallel_2 --- PASS: TestParallel_1 (1.00s) --- PASS: TestParallel_2 (2.00s) goos: windows goarch: amd64 BenchmarkDecode-8 31851 40615 ns/op PASS ok _/D_/Go_Practice 5.401s 结果中的31851为测试时b.N的实际值，也就是函数被循环执行的次数。在这个例子中，迭代进行了31851次，并且每次耗费了40615ns，即0.040615ms。 在进行基准测试时，测试用例的迭代次数是由Go自行决定的，测试程序将进行足够多次的迭代，直到获得一个准确的测量值为止。 上面的命令既运行了基准测试，也运行了功能测试。如果需要，用户也可以通过运行标志-run来忽略功能测试。 go test -run x -bench . 2. HTTP测试前面介绍的是如何测试Go的普通程序，这一篇介绍如何进行Web方面的测试。 对Go Web应用的单元测试可以通过testing/httptest包来完成。这个包提供了模拟一个Web服务器所需的设施，用户可以利用net/http包中的客户端函数向这个服务器发送HTTP请求，然后获取模拟服务器返回的HTTP响应。 func TestHandleGet( t *testing.T){ mux:=http.NewServeMux() mux.HandleFunc(&quot;/order&quot;,handleRequest) writer:=httptest.NewRecorder() request,_:=http.NewRequest(&quot;GET&quot;,&quot;order/20005&quot;,nil) mux.ServeHTTP(writer,request) if writer.Code != 200 {// 对记录器记载的响应结果进行检查 t.Errorf(&quot;Response code is %v&quot;, writer.Code) } var order Orders json.Unmarshal(writer.Body.Bytes(),&amp;order) if order.Order_num!=20005{ t.Error(&quot;Cannot retrieve JSON post&quot;) } }","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"}]},{"title":"GoWeb编程6-搭建Web服务","slug":"GoWeb编程6-搭建Web服务","date":"2020-01-26T04:41:21.000Z","updated":"2020-01-27T13:54:56.000Z","comments":true,"path":"2020/01/26/GoWeb编程6-搭建Web服务/","link":"","permalink":"jiangren.work/2020/01/26/GoWeb%E7%BC%96%E7%A8%8B6-%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1/","excerpt":"前面提到了Web应用和Web服务的区别，Web服务就是一个向其他软件程序提供服务的程序。本章将扩展这一定义，并展示如何使用Go语言来编写或使用Web服务。","text":"前面提到了Web应用和Web服务的区别，Web服务就是一个向其他软件程序提供服务的程序。本章将扩展这一定义，并展示如何使用Go语言来编写或使用Web服务。 1. 基于REST的Web服务REST（Representational State Transfer，具象状态传输）是一种设计理念，用于设计那些通过标准的几个动作来操纵资源，并以此来进行相互交流的程序。 在OOP面向对象编程中，人们通过创建称为对象（object）的模型来表示事物，然后定义称为方法（method）的函数并将它们附着到模型之上。REST是以上思想的进化版，但它并不是把函数暴露（expose）为可调用的服务，而是以资源（resource）的名义把模型暴露出来，并允许人们通过少数几个称为动词的动作来操纵这些资源。 在使用HTTP协议实现REST服务时，URL将用于表示资源，而HTTP方法则会用作操纵资源的动词： 2. XML下面介绍go语言是如何实现REST服务的。 2.1 分析XMLXML可以以结构化的形式表示数据，跟HTML一样，都是一种流行的标记语言。 在Go语言里面，用户首先需要将XML的分析结果存储到一些结构里面，然后通过访问这些结构来获取XML记录的数据。 创建一些用于存储XML数据的结构； 使用xml.Unmarshal将XML数据解封（unmarshal）到结构里面 下面举个例子： 首先创建一个XML文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;post id=&quot;1&quot;&gt; &lt;content&gt;Hello World!&lt;/content&gt; &lt;author id=&quot;2&quot;&gt;Sau Sheong&lt;/author&gt; &lt;/post&gt; 在这个XML文件中，包含了一个post结构，由id决定，成员包括了纯粹文本的content和以结构形式出现的author，而author由id决定。 --- post --- id --- content --- author --- id --- author 由此我们在程序中定义结构，用于表示数据： type Post struct{ XMLname xml.Name `xml:&quot;post&quot;` Id string `xml:&quot;id,attr&quot;` Content string `xml:&quot;content&quot;` Author Author `xml:&quot;author&quot;` Xml string `xml:&quot;,innerxml&quot;` } type Author struct { Id string `xml:&quot;id,attr&quot;` Name string `xml:&quot;,chardata&quot;` } Post结构中每个字段的定义后面都带有一段使用反引号（`）包围的信息，这些信息被称为结构标签。 出于创建映射的需要，xml包要求被映射的结构以及结构包含的所有字段都必须是公开的，也就是，它们的名字必须以大写的英文字母开头。以上面展示的代码为例，结构的名字必须为Post而不能是post，至于字段的名字则必须为Content而不能是content。 XML使用的详细规则如下： 通过创建一个名字为XMLName、类型为xml.Name的字段，可以将XML元素的名字存储在这个字段里面（在一般情况下，结构的名字就是元素的名字）。 有模式标志 通过创建一个与XML元素属性同名的字段，并使用&#39;xml:&quot;&lt;name&gt;,attr&quot;&#39;作为该字段的结构标签，可以将元素的&lt;name&gt;属性的值存储到这个字段里面。 通过创建一个与XML元素标签同名的字段，并使用&#39;xml:&quot;,chardata&quot;‘作为该字段的结构标签，可以将XML元素的字符数据存储到这个字段里面。 通过定义一个任意名字的字段，并使用&#39;xml:&quot;,innerxml&quot;‘作为该字段的结构标签，可以将XML元素中的原始XML存储到这个字段里面。 没有模式标志的结构字段将与同名的XML元素匹配。 使用&#39;xml:&quot;a&gt;b&gt;c“‘这样的结构标签可以在不指定树状结构的情况下直接获取指定的XML元素，其中a和b为中间元素，而c则是想要获取的节点元素。 我们按照规则，对结构逐一分析： 根据规则1：分析程序将XML文件中的元素名字post存储到了Post结构体的XMLName字段里面。 根据规则2a：分析程序通过结构标签xml:&quot;id,attr“将XML文件中的id属性的值存储到了Post结构的Id字段里面。 根据规则3：分析程序通过结构标签&#39;xml:&quot;content&quot;&#39;将content子元素包含的字符数据存储到了Post结构的Content字段里面。 根据规则2c：分析程序定义了一个Xml字段，并使用&#39;xml:&quot;,in-nerxml&quot;&#39;作为该字段的结构标签，以此来获得被post元素包含的原始XML： &lt;content&gt;Hello World!&lt;/content&gt; &lt;author id=&quot;2&quot;&gt;Sau Sheong&lt;/author&gt; 根据规则3，子元素author拥有id属性，并且包含字符数据SauSheong，为了正确地构建映射，分析程序专门定义了Author结构： type Author struct { Id string `xml:&quot;id,attr&quot;` Name string `xml:&quot;,chardata&quot;` } 运行后输出： {{ post} 1 Hello World! {2 Sau Sheong} &lt;content&gt;Hello World!&lt;/content&gt; &lt;author id=&quot;2&quot;&gt;Sau Sheong&lt;/author&gt; } 下面展示规则4的使用： &lt; ?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt; post id=&quot;1&quot;&gt; &lt; content&gt;Hello World!&lt; /content&gt; &lt; author id=&quot;2&quot;&gt;Sau Sheong&lt; /author&gt; &lt;!-- 新添加的代码部分 start--&gt; &lt; comments&gt; &lt; comment id=&quot;1&quot;&gt; &lt; content&gt;Have a great day!&lt; /content&gt; &lt; author id=&quot;3&quot;&gt;Adam&lt; /author&gt; &lt; /comment&gt; &lt; comment id=&quot;2&quot;&gt; &lt; content&gt;How are you today?&lt; /content&gt; &lt; author id=&quot;4&quot;&gt;Betty&lt; /author&gt; &lt; /comment&gt; &lt; /comments&gt; &lt;!-- 新添加的代码部分 end--&gt; &lt; /post&gt; 新添加代码定义了一个名为comments的XML子元素，并且这个元素本身也包含多个comment子元素。正常来说分析程序需要获取帖子的评论列表，但为此专门创建一个Comments结构可能会显得有些小题大做了。为了简化实现代码，分析程序将根据规则56对comments这个XML子元素进行跳跃式访问。 首先修改Post结构： type Post struct { XMLName xml.Name `xml:&quot;post&quot;` Id string `xml:&quot;id,attr&quot;` Content string `xml:&quot;content&quot;` Author Author `xml:&quot;author&quot;` Xml string `xml:&quot;,innerxml&quot;` Comments []Comment `xml:&quot;comments&gt;comment&quot;` } 通过结构标签&#39;xml:&quot;comments&gt;comment&quot;&#39;将这个字段映射至名为comment的XML子元素。根据规则5，这一结构标签将允许分析程序跳过XML中的comments元素，直接访问comment子元素。 Comment结构和Post结构非常相似，它的具体定义如下： type Comment struct { Id string `xml:&quot;id,attr&quot;` Content string `xml:&quot;content&quot;` Author Author `xml:&quot;author&quot;` } 这种做法虽然能够很好地处理体积较小的XML文件，但是却无法高效地处理以流（stream）方式传输的XML文件以及体积较大的XML文件。为了解决这个问题，我们需要使用Decoder结构来代替Unmarshal函数，通过手动解码XML元素的方式来解封XML数据，这个过程如图所示。 示例如下： func main() { xmlFile, err := os.Open(&quot;post.xml&quot;) if err != nil { fmt.Println(&quot;Error opening XML file:&quot;, err) return } defer xmlFile.Close() decoder := xml.NewDecoder(xmlFile)//①根据给定的XML数据生成相应的解码器 for {//②每迭代一次解码器中的所有XML数据 t, err := decoder.Token()//③每进行一次迭代，就从解码器里面获取一个token if err == io.EOF { break } if err != nil { fmt.Println(&quot;Error decoding XML into tokens:&quot;, err) return } switch se := t.(type) {//④检查token的类型 case xml.StartElement: if se.Name.Local == &quot;comment&quot; { var comment Comment decoder.DecodeElement(&amp;comment, &amp;se)//⑤将XML数据解码至结构 } } } } 虽然这段代码只演示了如何解码comment元素，但这种解码方式同样可以应用于XML文件中的其他元素。这个新的分析程序会通过Decoder结构，一个元素接一个元素地对XML进行解码，而不是像之前那样，使用Unmarshal函数一次将整个XML解封为字符串。 2.2 创建XMLgo中将结构封装为XML用到了函数marshal。 装程序首先需要创建表示帖子的post结构，并向结构里面填充数据，然后只要调用Marshal函数，就可以根据Post结构创建相应的XML了 func main() { post := Post{ Id: &quot;1&quot;, Content: &quot; Hello World!&quot;,//①创建结构并向里面填充数据 Author: Author{ Id: &quot;2&quot;, Name: &quot;Sau Sheong&quot;, }, } output, err := xml.Marshal(&amp;post) _ = ioutil.WriteFile(&quot;post.xml&quot;, output, 0644) } 这样输出的XML是没有换行的，格式不太好，可以使用MarshalIndent函数。 output, err := xml.MarshalIndent(&amp;post, &quot;&quot;, &quot;\\t&quot;) MarshalIndent函数还接受两个额外的参数，这两个参数分别用于指定添加到每个输出行前面的前缀以及缩进，其中缩进的数量会随着元素的嵌套层次增加而增加。 但是这段输出还没有添加XML声明，我们需要手动添加： err = ioutil.WriteFile(&quot;post.xml&quot;, []byte(xml.Header + string(output)), 0644) 同理，也可以手动使用Encoder编码： encoder := xml.NewEncoder(xmlFile)// 根据给定的XML文件，创建出相应的编码器 encoder.Indent(&quot;&quot;, &quot;\\t&quot;) err = encoder.Encode(&amp;post)// 把结构编码至文件 3. JSON3.1 分析JSONJSON（JavaScript Object Notation）是衍生自JavaScript语言的一种轻量级的文本数据格式，这种格式的主要设计理念是既能够轻易地被人类读懂，又能够简单地被机器读取。 JSON分析的过程和XML非常相似： 创建一些用于包含JSON数据的结构； 通过json.Unmarshal函数，把JSON数据解封到结构里面。 跟映射XML相比，把结构映射至JSON要简单得多，后者只有一条通用的规则：对于名字为&lt;name&gt;的JSON键，用户只需要在结构里创建一个任意名字的字段，并将该字段的结构标签设置为&#39;json:&quot;&lt;name&gt;&quot;&#39;，就可以把JSON键&lt;name&gt;的值存储到这个字段里面。 JSON文件： { &quot;id&quot; : 1, &quot;content&quot; : &quot;Hello World!&quot;, &quot;author&quot; : { &quot;id&quot; : 2, &quot;name&quot; : &quot;Sau Sheong&quot; }, &quot;comments&quot; : [ { &quot;id&quot; : 3, &quot;content&quot; : &quot;Have a great day!&quot;, &quot;author&quot; : &quot;Adam&quot; }, { &quot;id&quot; : 4, &quot;content&quot; : &quot;How are you today?&quot;, &quot;author&quot; : &quot;Betty&quot; } ] } go的json分析程序： type Post struct { Id int `json:&quot;id&quot;`// 定义一些结构，用于表示数据 Content string `json:&quot;content&quot;` Author Author `json:&quot;author&quot;` Comments []Comment `json:&quot;comments&quot;` } type Author struct { Id int `json:&quot;id&quot;` Name string `json:&quot;name&quot;` } type Comment struct { Id int `json:&quot;id&quot;` Content string `json:&quot;content&quot;` Author string `json:&quot;author&quot;` } func main() { jsonFile, err := os.Open(&quot;post.json&quot;) defer jsonFile.Close() jsonData, err := ioutil.ReadAll(jsonFile) var post Post json.Unmarshal(jsonData, &amp;post)//将JSON数据解封至结构 fmt.Println(post) } 为了将JSON键id的值映射到Post结构的Id字段，程序将该字段的结构标签设置成了&#39;json:&quot;id&quot;&#39;，这种设置基本上就是将结构映射至JSON数据所需完成的全部工作。 当然也可以用Decoder手动地将JSON数据解码到结构里面。 jsonFile, err := os.Open(&quot;post.json&quot;) defer jsonFile.Close() decoder := json.NewDecoder(jsonFile)//根据给定的JSON文件，创建出相应的解码器 for {//遍历JSON文件，直到遇见EOF为止 var post Post err := decoder.Decode(&amp;post)//将JSON数据解码至结构 if err == io.EOF { break } fmt.Println(post) } 3.2 创建JSON创建过程和XML类似，首先创建结构，然后调用函数将其封装为JSON数据。 type Post struct {//创建结构并向里面填充数据 Id int `json:&quot;id&quot;` Content string `json:&quot;content&quot;` Author Author `json:&quot;author&quot;` Comments []Comment `json:&quot;comments&quot;` } type Author struct { Id int `json:&quot;id&quot;` Name string `json:&quot;name&quot;` } type Comment struct { Id int `json:&quot;id&quot;` Content string `json:&quot;content&quot;` Author string `json:&quot;author&quot;` } func main() { post := Post{ Id: 1, Content: &quot;Hello World!&quot;, Author: Author{ Id: 2, Name: &quot;Sau Sheong&quot;, }, Comments: []Comment{ Comment{ Id: 3, Content: &quot;Have a great day!&quot;, Author: &quot;Adam&quot;, }, Comment{ Id: 4, Content: &quot;How are you today?&quot;, Author: &quot;Betty&quot;, }, }, } output, err := json.MarshalIndent(&amp;post, &quot;&quot;, &quot;\\t\\t&quot;)//把结构封装为由字节切片组成的JSON数据 err = ioutil.WriteFile(&quot;post.json&quot;, output, 0644) }","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"}]},{"title":"GoWeb编程5-存储数据","slug":"GoWeb编程5-存储数据","date":"2020-01-25T07:41:29.000Z","updated":"2020-01-26T12:40:18.000Z","comments":true,"path":"2020/01/25/GoWeb编程5-存储数据/","link":"","permalink":"jiangren.work/2020/01/25/GoWeb%E7%BC%96%E7%A8%8B5-%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE/","excerpt":"本章介绍go中对数据如何进行持久化，说明如何才能将数据存储到内存、文件、关系数据库以及NoSQL数据库中。","text":"本章介绍go中对数据如何进行持久化，说明如何才能将数据存储到内存、文件、关系数据库以及NoSQL数据库中。 Web应用通常会采取以下手段存储数据： 在程序运行时，将数据存储到内存里面； 将数据存储到文件系统的文件里面； 通过服务器程序前端，将数据存储到数据库里面。 1. 文件存储内存存储无法做到持久化，Go持久化有两种：CSV和gob包。 1.1 CSV文件CSV，即comma separated value，逗号分隔值文本格式。 当你需要用户提供大量数据，但是却因为某些原因而无法让用户把数据填入你提供的表单时，CSV格式就可以派上用场了：你只需要让用户使用电子表格程序（spreadsheet）输入所有数据，然后将这些数据导出为CSV文件，并将其上传到你的Web应用中，这样就可以在获得CSV文件之后，根据自己的需要对数据进行解码。同样地，你的Web应用也可以将用户的数据打包成CSV文件，然后通过向用户发送CSV文件来为他们提供数据。 对Go语言来说，CSV文件可以通过encoding/csv包进行操作。 下面展示如何写入CSV文件： 创建一个名为post.csv的文件 创建一个post切片，作为数据源 使用NewWriter函数创建一个新的写入器writer，并把文件用作参数，将其传递给写入器 利用写入器迭代地写入数据 FLUSH刷新缓冲区 type post struct{ Id int Content string Author string } func main(){ csvFile,err:=os.Create(&quot;post.csv&quot;) if err!=nil{ panic(err) } defer csvFile.Close() allposts:=[]post{ post{Id:1,Content:&quot;hello&quot;,Author:&quot;Bob&quot;}, post{Id:2,Content:&quot;world&quot;,Author:&quot;Tom&quot;}, } writer:=csv.NewWriter(csvFile) for _,post:=range allposts{ line := []string{strconv.Itoa(post.Id),post.Content,post.Author} err := writer.Write(line) if err!=nil{ panic(err) } } writer.Flush() } 下面展示如何读取CSV文件： func main(){ file,err:=os.Open(&quot;post.csv&quot;) if err != nil{ panic(err) } defer file.Close() reader:=csv.NewReader(file) reader.FieldsPerRecord = -1 record ,err :=reader.ReadAll() if err != nil{ panic(err) } var posts []post for _, item:= range record{ id, _ := strconv.ParseInt(item[0], 0, 0) post := post{Id: int(id), Content: item[1], Author: item[2]} posts = append(posts,post) } fmt.Println(posts[0].Id) fmt.Println(posts[0].Content) fmt.Println(posts[0].Author) } 1.2 gob包encoding/gob包用于管理由gob组成的流（stream），这是一种在编码器（encoder）和解码器（decoder）之间进行交换的二进制数据，这种数据原本是为序列化以及数据传输而设计的，但它也可以用于对数据进行持久化。 func store(data interface{}, filename string) {// ① buffer := new(bytes.Buffer) encoder := gob.NewEncoder(buffer) err := encoder.Encode(data) if err != nil { panic(err) } err = ioutil.WriteFile(filename, buffer.Bytes(), 0600) if err != nil { panic(err) } } 存储函数的第一个参数是空接口，而第二个参数则是被存储的二进制文件的名字。空接口参数能够接受任意类型的数据作为值。 store函数会创建一个bytes.Buffer结构，这是是一个拥有Read方法和Write方法的可变长度（variable sized）字节缓冲区，既是读入器也是写入器 把缓冲区传递给NewEncoder函数，以此来创建出一个gob编码器。接着将数据编码到缓冲区里面。 将缓冲区中已编码的数据写入文件。 load方法正好相反： func load(data interface{}, filename string) {// ② raw, err := ioutil.ReadFile(filename) if err != nil { panic(err) } buffer := bytes.NewBuffer(raw) dec := gob.NewDecoder(buffer) err = dec.Decode(data) if err != nil { panic(err) } } 从文件里面读取出未经处理的原始数据 根据这些原始数据创建一个缓冲区，并藉此为原始数据提供相应的Read方法和Write方法 调用NewDecoder函数，为缓冲区创建相应的解码器 使用解码器去解码从文件中读取的原始数据，并最终得到之前写入的真正的数据。 2. Go与SQL以postgres数据库为例，讲解如何利用go对数据库操作。 2.1 连接数据库首先需要创建数据库句柄，程序首先使用Db变量定义了一个指向sql.DB结构的指针，然后使用init()函数来初始化这个变量（Go语言的每个包都会自动调用定义在包内的init()函数）。 func init() { var err error Db, err = sql.Open(&quot;postgres&quot;, &quot;user=gwp dbname=gwp password=gwp sslmode=disable&quot;) if err != nil { panic(err) } } sql.DB结构是一个数据库句柄（handle），它代表的是一个包含了零个或任意多个数据库连接的连接池（pool），这个连接池由sql包管理。程序可以通过调用Open函数，并将相应的数据库驱动名字（driver name）以及数据源名字（data source name）传递给该函数来建立与数据库的连接。 Open函数在执行时并不会真正地与数据库进行连接，真正作用是设置好连接数据库所需的各个结构，并以惰性的方式，等到真正需要时才建立相应的数据库连接。 我们采用第三方程序注册数据库： import ( &quot;fmt&quot; &quot;database/sql&quot; _ &quot;github.com/lib/pq&quot; ) github.com/lib/pq包就是程序导入的Postgres驱动，在导入这个包之后，包内定义的init函数就会被调用，并对其自身进行注册。因为Go语言没有提供任何官方数据库驱动，所以Go语言的所有数据库驱动都是第三方函数库，并且这些库必须遵守sql.driver包中定义的接口。 2.2 创建数据代码如下： func (post *Post) Create() (err error) { statement := &quot;insert into posts (content, author) values ($1, $2) returning id &quot; stmt, err := db.Prepare(statement) if err != nil { return } defer stmt.Close() err = stmt.QueryRow(post.Content, post.Author).Scan(&amp;post.Id) if err != nil { return } return } func和Create之间的括号表明了Create函数是Post结构的一个方法。 （1）定义一条SQL预处理语句 一条预处理语句（prepared statement）就是一个SQL语句模板，这种语句通常用于重复执行指定的SQL语句，用户在执行预处理语句时需要为语句中的参数提供实际值。 在创建数据库记录的时候，Create函数就会使用实际值去替换以下语句中的$1和$2。 创建完后，利用sql.DB结构的Prepare方法记性转化，创建一个指向sql.Stmt接口的引用。 stmt, err := db.Prepare(statement) （2）执行预处理语句 调用预处理语句的QueryRow方法，并把来自接收者的数据传递给该方法，以此来执行预处理语句： err = stmt.QueryRow(post.Content, post.Author).Scan(&amp;post.Id) scan的目的是让数据库的Id和post原有的id同步。Scan可以把数据库取出的字段值赋值给指定的数据结构。它的参数是一个空接口的切片，这就意味着可以传入任何值。通常把需要赋值的目标变量的指针当成参数传入，它能将数据库取出的值赋值到指针值对象上。 2.3 查询数据代码如下： func GetPost(id int) (post Post, err error) { post = Post{} err = Db.QueryRow(&quot;select id, content, author from posts where id = $1&quot;, id) .Scan(&amp;post.Id, &amp;post.Content, &amp;post.Author) return } 假设我们不需要重复使用查询语句，所以就不必邀使用stmt结构。程序通过串联QueryRow方法和Scan方法，将执行查询所得的数据复制到空的Post结构里面。 调用方法如下： readPost, _ := GetPost(1) 也可以一次性获取多个数据 func Posts(limit int) (posts []Post, err error) { rows, err := Db.Query(&quot;select id, content, author from posts limit $1&quot;, limit) if err != nil { return } for rows.Next() { post := Post{} err = rows.Scan(&amp;post.Id, &amp;post.Content, &amp;post.Author) if err != nil { return } posts = append(posts, post) } rows.Close() return } 来执行查询，这个方法会返回一个Rows接口。Rows接口是一个迭代器，程序可以通过重复调用它的Next方法来对其进行迭代并获得相应的sql.Row；当所有行都被迭代完毕时，Next方法将返回io.EOF作为结果。 2.3 更新数据代码如下： func (post *Post) Update() (err error) { _, err = Db.Exec(&quot;update posts set content = $2, author = $3 where id = $1&quot;, post.Id, post.Content, post.Author) return } 直接调用sql.DB结构的Exec方法，原因主要是不需要对对接收者进行任何更新，所以不需要使用SCAN扫描方法，才会选择使用速度更快的Exec方法来执行查询。 Exec方法会返回一个sql.Result和一个可能出现的错误，其中sql.Result记录的是受查询影响的行的数量以及可能会出现的最后插入id。因为更新操作对sql.Result记录的这两项信息都不感兴趣，所以程序会通过将sql.Result赋值给下划线_来忽略它。 调用如下： readPost.Content = &quot;Bonjour Monde!&quot; readPost.Author = &quot;Pierre&quot; readPost.Update() 2.4 删除数据代码如下： func (post *Post) Delete() (err error) { _, err = Db.Exec(&quot;delete from posts where id = $1&quot;, post.Id) return } 3. 数据库关系关系型数据库很重要的一个特征是：它可以在表与表之间建立关系，从而使不同的数据能够以一种一致且易于理解的方式互相进行关联。 按照如下的思路创建数据库表，就可以达到联结的效果： create table posts ( id serial primary key, content text, author varchar(255) ); create table comments ( id serial primary key, content text, author varchar(255), post_id integer references posts(id) ); comments表的大部分列都跟posts表一样，主要区别在于comments表多了一个额外的post_id列：这个post_id会作为外键（foreign key），对posts表的主键id进行引用。","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"}]},{"title":"GoWeb编程4-内容展示","slug":"GoWeb编程4-内容展示","date":"2020-01-25T04:17:03.000Z","updated":"2020-01-27T13:42:19.000Z","comments":true,"path":"2020/01/25/GoWeb编程4-内容展示/","link":"","permalink":"jiangren.work/2020/01/25/GoWeb%E7%BC%96%E7%A8%8B4-%E5%86%85%E5%AE%B9%E5%B1%95%E7%A4%BA/","excerpt":"Web页面的展示依靠的是模板技术，Web模板就是一些预先设计好的 HTML 页面，模板引擎会通过重复地使用这些页面来创建一个或多个 HTML 页面。","text":"Web页面的展示依靠的是模板技术，Web模板就是一些预先设计好的 HTML 页面，模板引擎会通过重复地使用这些页面来创建一个或多个 HTML 页面。 1. Go的模板引擎Go 语言的模板引擎也是介于无逻辑模板引擎和嵌入逻辑模板引擎之间的一种模板引擎。 Go 的模板都是文本文档（其中 Web 应用的模板通常都是 HTML ），它们都嵌入了一些称为动作（ action ）的指令。 从模板引擎的角度来说，模板就是嵌入了动作的文本，而模板引擎则通过分析并执行这些文本来生成出另外一些文本。 1.1 模板的使用过程模板中的动作默认使用两个大括号包围。下面就是一个简单的模板： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;Go Web Programming&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {{ . }} &lt;/body&gt; &lt;/html&gt; 代码的模板来源于一个名为 tmpl.html 的模板文件。用户可以拥有任意多个模板文件， 并且这些模板文件可以使用任意后缀名，但它们的类型必须是可读的文本格式。 因为 上面这段模板的输出将是一个HTML文件，所以我们使用了.html作为模板文件的后缀名。 func process(w http.ResponseWriter, r *http.Request){ t,_:=template.ParseFiles(&quot;tmpl.html&quot;) t.Execute(w,&quot;hello world&quot;) } func main(){ server:=http.Server{ Addr: &quot;127.0.0.1:8080&quot;, } http.HandleFunc(&quot;/process&quot;,process) server.ListenAndServe() } 上面的代码展示了使用模板的两个关键步骤： 调用模板引擎分析模板 将数据填入模板引擎，充实动作 ResponseWriter 和数据会一起被传入 Execute 方法中，这样一来，模板引擎在生成 HTML 之后就可以把该HTML文件传给 ResponseWriter了。 1.2 对模板进行语法分析当用户调用 ParseFiles 函数的时候， Go会创建一个新的模板，并将用户给定的模板文件的名字用作这个新模板的名字： t,_ :=template.ParseFiles(&quot;tmpl.html&quot;) //等价于 t := template.New(&quot;tmpl.html&quot;) t,_ := t.ParseFiles(&quot;tmpl.html&quot;) ParseFiles函数可以接受任意数量的文件作为参数，会将他们合并视为一个模板集合。 我们也可以使用ParseGlob进行全局模板分析，读取所有html文件。 t,_ := template.ParseGlob(&quot;*.html&quot;) 1.3 执行模板但如果模板不止一个，那么当对模板集合调用 Execute 方法的时候， Execute方法只会执行模板集合中的第一个模板。 t, _ := template.ParseFiles(&quot;t1.html&quot;,&quot;t2.html&quot;) t.Execute(w,&quot;Hello!&quot;) 如果想执行另一个，就需要使用函数ExecuteTemplate： t.ExecuteTemplate(w, &quot;t2.html&quot;,&quot;Hello&quot;) 2. 动作2.1 条件动作条件动作会根据参数的值来决定对多条语句中的哪一条语句进行求值。最简单的条件动作的格式如下： {{ if arg }} some content {{ end }} 这个动作的另一种格式如下： {{ if arg }} some content {{ else }} other content {{ end }} 下面的Demo中，我们会在服务器上面创建一个处理器，这个处理器会随机0-10之间的整数，然后通过判断这个随机整数是否大于5。 func process(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(&quot;tmpl.html&quot;) rand.Seed(time.Now().Unix()) t.Execute(w, rand.Intn(10) &gt; 5) } 将模板文件的body改为： &lt;body&gt; {{ if . }} Number is greater than 5! {{ else }} Number is 5 or less! {{ end }} &lt;/body&gt; 2.2 迭代动作迭代动作可以对数组、切片、映射或者通道进行迭代，而在迭代循环的内部，点.则会被设置为当前被迭代的元素，就像这样： {{ range array }} Dot is set to the element {{ . }} {{ end }} 下面是一个使用了迭代动作的例子： &lt;body&gt; &lt;ul&gt; {{ range . }} &lt;li&gt;{{ . }}&lt;/li&gt; {{ end}} &lt;/ul&gt; &lt;/body&gt; 下面是模板处理器： func process(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(&quot;tmpl.html&quot;) daysOfWeek := []string{&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;} t.Execute(w, daysOfWeek) } 在网页中，会以无序列表的形式展示周一到周日： 下面展示了一个具有备选结果的迭代动作： &lt;body&gt; &lt;ul&gt; {{ range . }} &lt;li&gt;{{ . }}&lt;/li&gt; {{ else }} &lt;li&gt; Nothing to show &lt;/li&gt; {{ end}} &lt;/ul&gt; &lt;/body&gt; 2.3 设置动作设置动作允许用户在指定的范围之内为点.设置值。比如，在以下代码中： {{ with arg }} Dot is set to arg {{ end }} 介于with arg和end之间的点将被设置为参数arg的值，比如： &lt;body&gt; &lt;div&gt;The dot is {{ . }}&lt;/div&gt; &lt;div&gt; {{ with \"world\"}} Now the dot is set to {{ . }} {{ end }} &lt;/div&gt; &lt;div&gt;The dot is {{ . }} again&lt;/div&gt; &lt;/body&gt; 传入的还是hello，但是经过设置动作后，点的内容被替换为world。 2.4 包含动作包含动作（include action）允许用户在一个模板里面包含另一个模板，从而构建出嵌套的模板。包含动作的格式为template &quot;name&quot;，其中name参数为被包含模板的名字。 &lt;body&gt; &lt;div&gt; This is t1.html before&lt;/div&gt; &lt;div&gt;This is the value of the dot in t1.html - [{{ . }}]&lt;/div&gt; &lt;hr/&gt; {{ template \"t2.html\" }} &lt;hr/&gt; &lt;div&gt; This is t1.html after&lt;/div&gt; &lt;/body&gt; &lt;div style=&quot;background-color: yellow;&quot;&gt; This is t2.html&lt;br/&gt; This is the value of the dot in t2.html - [{{ . }}] &lt;/div&gt; 下面展示了处理器： func process(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(&quot;t1.html&quot;, &quot;t2.html&quot;) t.Execute(w, &quot;Hello World!&quot;) } 结果如下： 3. 函数、变量与管道3.1 变量与管道用户还可以在动作中设置变量。变量以美元符号$开头，就像这样： $variable := value 利用变量，我们可以实现迭代动作的一个变种： {{ range $key, $value := . }} The key is {{ $key }} and the value is {{ $value }} {{ end }} 模板中的管道（pipeline）是多个有序地串联起来的参数、函数和方法，它的工作方式和语法跟Unix的管道也非常相似： {{ p1 | p2 | p3 }} 管道允许用户将一个参数的输出传递给下一个参数，而各个参数之间则使用|分隔。 &lt;body&gt; {{ 12.3456 | printf \"%.2f\" }} &lt;/body&gt; 上面的代码就是一个利用管道原理格式化的例子。 3.2 函数Go函数也可以用作模板的参数：Go模板引擎内置了一些非常基础的函数。需要注意的是，Go的模板引擎函数都是受限制的：尽管这些函数可以接受任意多个参数作为输入，但它们只能返回一个值，或者返回一个值和一个错误。 为了创建一个自定义模板函数，用户需要： 创建一个名为FuncMap的映射，并将映射的键设置为函数的名字，而映射的值则设置为实际定义的函数； 将FuncMap与模板进行绑定。 举个例子：在编写Web应用的时候，用户常常需要将时间对象或者日期对象转换为ISO8601格式的时间字符串或者日期字符串，又或者将ISO8601格式的字符串转换为相应的对象。 func formatDate(t time.Time) string { layout := &quot;2006-01-02&quot; return t.Format(layout) } func process(w http.ResponseWriter, r *http.Request) { funcMap := template.FuncMap { &quot;fdate&quot;: formatDate } t := template.New(&quot;tmpl.html&quot;).Funcs(funcMap) t, _ = t.ParseFiles(&quot;tmpl.html&quot;) t.Execute(w, time.Now()) } 首先定义了一个名为formatDate的函数，它接受一个Time结构作为输入，然后以年-月-日的形式返回一个ISO8601格式的字符串。 在之后的处理器中，程序将名字fdate映射至formatDate函数。 序使用template.New函数创建了一个名为tmpl.html的模板。以程序直接以串联的方式调用模板的Funcs方法。 在html文件中，通过管道使用自定义函数： &lt;body&gt; &lt;div&gt;The date/time is {{ . | fdate }}&lt;/div&gt; &lt;/body&gt; 4. 上下文感知4.1 什么是上下文感知所谓上下文感知就是对被显示的内容实施正确的转义：如果模板显示的是HTML格式的内容，那么模板将对其实施HTML转义；如果模板显示的是JavaScript格式的内容，那么模板将对其实施JavaScript转义；诸如此类。除此之外，Go模板引擎还可以识别出内容中的URL或者CSS样式。 比如： t, _ := template.ParseFiles(&quot;tmpl.html&quot;) content := `I asked: &lt;i&gt;&quot;What&#39;s up?&quot;&lt;/i&gt;` t.Execute(w, content) 上下文感知模板： &lt;body&gt; &lt;div&gt;{{ . }}&lt;/div&gt; &lt;div&gt;&lt;a href=&quot;/{{ . }}&quot;&gt;Path&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a href=&quot;/?q={{ . }}&quot;&gt;Query&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a onclick=&quot;f(&#39;{{ . }}&#39;)&quot;&gt;Onclick&lt;/a&gt;&lt;/div&gt; &lt;/body&gt; 根据动作所在位置，输出结果将变为： 4.2 防御XSS攻击XXS也称 cross-site scripting，跨站脚本。这种攻击是由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的。 举个例子，如果有一个存在持久性 xss 漏洞的论坛，它允许用户在论坛上面发布帖子或者回复，并且其他用户也可以阅读这些帖子以及回复，那么攻击者就可能会在他发布的内容中引入带有＜script＞标签的代码。 因为论坛即使在内容带有＜script＞标签的情况下，仍然会原原本本地向用户显示这些内容，所以用户将在毫不知情的情况下，使用自己的权限去执行攻击者发布的恶意代码。 预防这一攻击的常见方法就是在显示或者存储用户传入的数据之前，对数据进行转义。 假设我们想要通过一个HTML表单发送数据： &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;Go Web Programming&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/process&quot; method=&quot;post&quot;&gt; Comment: &lt;input name=&quot;comment&quot; type=&quot;text&quot;&gt; &lt;hr/&gt; &lt;button id=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 为了防止XSS攻击，我们使用如下模板： &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;Go Web Programming&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;{{ . }}&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 然后将模板和表单都绑定到处理器： http.HandleFunc(&quot;/process&quot;, process) http.HandleFunc(&quot;/form&quot;, form) 当我们访问form时，将以下内容输入到表单的文本框里面，然后按下Submit按钮： &lt;script&gt;alert(&#39;Pwnd!&#39;);&lt;/script&gt; 由于go的模板引擎的防护，将漏洞成功转义： 4.3 不转义如果真的想要允许用户输入HTML代码或者JavaScript代码，并在显示内容时执行这些代码，可以使用Go提供的“不转义HTML”机制：只要把不想被转义的内容传给template.HTML函数，模板引擎就不会对其进行转义。 func process(w http.ResponseWriter, r *http.Request) { t, _ := template.ParseFiles(&quot;tmpl.html&quot;) t.Execute(w, template.HTML(r.FormValue(&quot;comment&quot;))) }","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"}]},{"title":"GoWeb编程3-处理Web请求","slug":"GoWeb编程3-处理Web请求","date":"2020-01-23T06:09:59.000Z","updated":"2020-01-25T12:19:57.000Z","comments":true,"path":"2020/01/23/GoWeb编程3-处理Web请求/","link":"","permalink":"jiangren.work/2020/01/23/GoWeb%E7%BC%96%E7%A8%8B3-%E5%A4%84%E7%90%86Web%E8%AF%B7%E6%B1%82/","excerpt":"本节讨论如何利用go处理客户端发来的请求。","text":"本节讨论如何利用go处理客户端发来的请求。Request结构体作为客户端请求的载体，其中HTML作为Request请求的主体，而传入服务器后需要利用相关的响应方法对请求进行相应。Cookie是辅助响应的手段，用于保存状态。 学习的是如何使用 Go 提供的工具来处理请求，以及如何把响应回传给客户端。 1. 请求方法1.1 Request结构Request 结构表示一个由客户端发送的 HTTP 请求报文，包括： URL字段 Header字段 Body字段 Form，PostForm字段和MultipartForm字段 虽然 HTTP 请求报文是由一系列文本行组成的，但 Request 结构并不是完全按照报文逐字逐句定义的。 实际情况是，这个结构只包含了报文在经过语法分析之后，其中较为重要的信息。 1.2 请求URLRequest结构体中包含的URL字段指向了一个url.URL结构体： type URL struct { Scheme string Opaque string // 编码后的不透明数据 User *Userinfo // 用户名和密码信息 Host string // host或host:port ath string RawQuery string // 编码后的查询字符串，没有&#39;?&#39; Fragment string // 引用的片段（文档位置），没有&#39;#&#39; } URL的一般格式是： scheme:// [user info@] host/path [?query] [#fragment] 而scheme之后不带斜线的URL会被解释为： scheme:opaque[?query] [#fragment ] 当我们输入http://www.example.com/post?id=123&amp;thread_id=456这个id=123&amp;thread_id=456就是查询字段RawQuery 1.3 请求头部请求和响应的首部都使用 Header 类型描述，这种类型使用一个映射来表示 HTTP 首部中的多个键值对。 Header 类型拥有 4 种基本方法，这些方法可以根据给定的键执行添加、 删除、获取和设置值等操作。 下面展示了读取头部的方法： func headers(w http.ResponseWriter, r *http.Request){ h := r.Header fmt.Fprintln(w,h) } func main(){ server:=http.Server{ Addr: &quot;127.0.0.1:8080&quot;, } http.HandleFunc(&quot;/headers&quot;,headers) server.ListenAndServe() } 在浏览器会输出： map[ Accept:[text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9] Accept-Encoding: [gzip, deflate, br] Accept-Language: [zh,en-US;q=0.9,en;q=0.8,zh-CN;q=0.7] Connection: [keep-alive] Cookie: [_ga=GA1.1.1969723589.1578322265; _xsrf=2|86b77755|fdefd0fe22a4955aac4be46f30abdbfe|1578603653; ...省略] Sec-Fetch-Mode: [navigate] Sec-Fetch-Site: [none] Sec-Fetch-User: [?1] Upgrade-Insecure-Requests: [1] User-Agent: [Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36] ] 通过这些，我们能知道头部的所有信息，当然我们也能返回特定的信息： h:=r.Header[&quot;Accept-Encoding&quot;] 1.4 请求主体请求和响应的主体都由 Request 结构的 Body 字段表示，这个字段是一个 io.Read Closer 接口，该接口既包含了： Reader接口：接口拥有 Read 方法，这个方法接受一个字节切片为输入，并在执行之后返回被读取内容的字节数以及一个可选的错误作为结果； Closer接口：这个方法不接受任何参数，但会在出错时返回一个错误。 下面是一个demo： func body(w http.ResponseWriter, r *http.Request){ len := r.ContentLength body :=make([]byte,len) r.Body.Read(body) fmt.Fprintln(w,string(body)) } func main(){ server:=http.Server{ Addr: &quot;127.0.0.1:8080&quot;, } http.HandleFunc(&quot;/body&quot;,body) server.ListenAndServe() } 由于GET请求并不包含BODY，所以我们访问时，控制台没有任何输出。所以如果我们想要测试这个服务器，就需要通过HTML表单发送 POST 请求。这里我们不用表单，用cURL命令来测试： curl -id &quot;first_name=11&amp;last_name=22&quot; 127.0.0.1:8080/body 在控制台可以看到： HTTP/1.1 200 OK Date: Thu, 23 Jan 2020 14:53:52 GMT Content-Length: 27 Content-Type: text/plain; charset=utf-8 first_name=11&amp;last_name=22 2. HTML表单2.1 什么是表单POST 请求都是通过HTML表单发送的，这些表单看上去通常会是下面这个样子： &lt;form action=”/process ” method=”post”&gt; &lt;input type=”text” name=”first name” /&gt; &lt;input type=”text” name=”last name&quot;/&gt; &lt;input type=”submit”/&gt; &lt;/form&gt; &lt;form＞标签可以包围文本行、文本框、单选按钮、复选框以及文件上传等多种HTML表单元素， 而用户则可以把想要传递给服务器的数据输入到这些元素里面。当用户按下发送按钮、又或者通过某种方式触发了表单的发送操作之后，用户在表单中输入的数据就会被发送至服务器。 表单的编码属性由enctype属性的值设置，有两种： application/x-www-form-urlencoded multipart/form-data 第一种，浏览器将把 HTML 表单中的数据编码为一个连续的“长查询字符串”（ long query string ）：在这个字符串中，不同的键值对将使用＆符号分隔，而键值对中的键和值则使用等号＝分隔。 first_name=sau%20sheong&amp;last_name=chang 第二种，表单中的数据将被转换成一条 MIME 报文 (Multipurpose Internet Mail Extensions)：表单中的每个键值对都构成了这条报文的一部分，并且每个键值对都带有它们各自的内容类型以及内容配置（ disposition ） 。 ------WebKitFormBoundaryMPNjKpe09cLiocMw Content-Disposition : f orm-data ; name=”first name&quot; sau sheong ------WebKitFormBoundaryMPNjKpe09cLiocMw Content- Disposition: form-data; name=”l ast name” chang ------WebKitFormBoundaryMPNjKpe09cLiocMw-- 除了post外也可以通过get发送表单 &lt;form action=”/process ” method=”get&quot;&gt; ... &lt;/form&gt; 2.2 Form字段为了提取表单的键值对数据，我们需要对表单进行处理，net/http库提供了许多函数能够满足需求。通过调用 Request 结构提供的方法，用户可以将 URL、Body数据提取到该结构的 Form, PostForm 和 MultipartForm 等字段当中。 过程如下： 调用 ParseForm 方法或者 ParseMultipartForm 方法，对请求进行语法分析。 根据步骤 l 调用的方法，访问相应的 Form 字段、 PostForm 字段或 MultipartForm 字段。 举个例子： func process(w http.ResponseWriter, r *http.Request){ r.ParseForm() fmt.Fprintln(w,r.Form) fmt.Println(&quot;收到了&quot;) } func main(){ server:=http.Server{ Addr: &quot;127.0.0.1:8080&quot;, } http.HandleFunc(&quot;/process&quot;,process) server.ListenAndServe() } 然后我们创建一个html文件，包含了： &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;Go Web Programming&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;http://localhost:8080/process?hello=world&amp;thread=123&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;hello&quot; value=&quot;sau sheong&quot;/&gt; &lt;input type=&quot;text&quot; name=&quot;post&quot; value=&quot;456&quot;/&gt; &lt;input type=&quot;file&quot; name=&quot;uploaded&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 用浏览器打开这个html文件，点击提交，可以在浏览器看到： map[hello:[world] thread:[123]] 在控制台可以看到“收到了”的消息提醒。 2.3 PostForm字段当我们写入r.Form[&quot;post&quot;]时返回一个切片456，但是当我们输入r.Form[&quot;hello&quot;]时却返回了world而不是sau sheong。这是因为hello同时出现在表单和 URL 两个地方的键。 &lt;input type=&quot;text&quot; name=&quot;hello&quot; value=&quot;sau sheong&quot;/&gt; action=&quot;http://localhost:8080/process?hello=world&amp;thread=123&quot; 面对这种情况，我们需要改为r.PostForm语句。 2.4 MultipartForm字段前面的字段针对application/x-www-form-urlencoded类型，而对于另一种multipart/form-data类型，需要使用MultipartForm字段。 r.ParseMultipartForm(1024) fmt.Fprintln (w,r.MultipartForm) 的第一行代码说明了我们想要从 multipart 编码的表单里面取出多少字节的数据，而第二行语句则会打印请求的 MultipartForm 字段。 MultipartForm字段只包含表单键值对，不包含URL键值对。 它也不是一个单映射，而是两个映射的组合：第一个键为字符串，值为字符串组成的切片，第二个映射为空，用来记录用户上传的文件。 此外还有FormValue和PostFormValue，他们只会从Form结构中取出给定键的第一个值： fmt.Fprintln(w, r.ForrnValue (&quot;hello&quot; )) 上面的代码将输出sau sheong。 对比： 2.5 文件multipart/form-data编码，通常用于实现文件上传功能，这种功能需要用到 file 类型的 input 标签: &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;Go Web Programming&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;http://localhost:8080/process?hello=world&amp;thread=123&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;hello&quot; value=&quot;sau sheong&quot;/&gt; &lt;input type=&quot;text&quot; name=&quot;post&quot; value=&quot;456&quot;/&gt; &lt;input type=&quot;file&quot; name=&quot;uploaded&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 为了能够接收表单上传的文件，处理器函数也需要做相应的修改： func process(w http.ResponseWriter, r *http.Request){ r.ParseMultipartForm(1024) fileHeader:= r.MultipartForm.File[&quot;uploaded&quot;][0] file,err := fileHeader.Open() if err == nil { data, err:=ioutil.ReadAll(file) if err == nil{ fmt.Fprintln(w,string(data)) } } } 文件处理步骤可以总结为： 执行ParseMultipartForm方法解析字段； 从MultipartForm字段的File字段中提取出文件头FileHeader； 通过open打开这个文件； 用ioutil函数将文件内容读取到一个字节数组中。 3. 响应方法响应时需要用到ResponseWriter接口，处理器可以通过这个接口创建HTTP响应。 我们知道ServeHTTP接收ResponseWriter接口和一个指向Request结构的指针作为参数。之所以要用指针传递而不是值传递，是为了探测对Request结构的修改情况。而ResponseWriter看起来像传值，但实际上它是response这个非导出结构的接口，也是传引用。 ResponseWriter 接口拥有以下 3 个方法： Write WriteHeader Header 3.1 WriteWrite方法接受一个字节数组作为参数，并将数组中的字节写入HTTP响应的主体中。 func writeExample(w http.ResponseWriter, r *http.Request){ str:= `&lt;html&gt; &lt;head&gt;&lt;title&gt;Go Web&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;h1&gt;Hello world&lt;/h1&gt;&lt;body&gt; &lt;/html&gt;` w.Write([]byte(str)) } func main(){ server:=http.Server{ Addr: &quot;127.0.0.1:8080&quot;, } http.HandleFunc(&quot;/write&quot;,writeExample) server.ListenAndServe() } 注意这段Demo使用 ` 符号，用于多行字符串。我们用命令行输入: curl -i localhost:8080/write 可以得到响应： HTTP/1.1 200 OK Date: Fri, 24 Jan 2020 10:35:59 GMT Content-Length: 82 Content-Type: text/html; charset=utf-8 &lt;html&gt; &lt;head&gt;&lt;title&gt;Go Web&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;h1&gt;Hello world&lt;/h1&gt;&lt;body&gt; &lt;/html&gt; 3.2 WriteHeader注意：WriteHeader并不能用于设置响应的头部(Header)。WriteHeader 方法接受一个代表 HTTP 响应状态码的整数作为参数， 并将这个整数用作 HTTP 响应的返回状态码；在调用这个方法之后，用户可以继续对 ResponseWriter 进行写人，但是不能对响应的首部做任何写入操作。 如果用户在调用 Write 方法之前没有执行过 WriteHeader 方法，那么程序默认会使用 200 OK作为响应的状态码。 注意别忘了使用 HandleFune 方法将新处理器绑定到 DefaultServeMux多路复用器里面！ 比如，你编写了一个API，但尚未完全实现，所以希望返回一个 501 Not Implemented 状态码： func writeExample(w http.ResponseWriter, r *http.Request){ str:= `&lt;html&gt; &lt;head&gt;&lt;title&gt;Go Web&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;h1&gt;Hello world&lt;/h1&gt;&lt;body&gt; &lt;/html&gt;` w.Write([]byte(str)) } func writeHeaderExample(w http.ResponseWriter, r *http.Request){ w.WriteHeader(501) fmt.Fprintln(w, &quot;TO DO&quot;) } func main(){ server:=http.Server{ Addr: &quot;127.0.0.1:8080&quot;, } http.HandleFunc(&quot;/write&quot;,writeExample) http.HandleFunc(&quot;/writeheader&quot;,writeHeaderExample) server.ListenAndServe() } 通过 cURL 访问刚刚添加的新处理器： curl -i localhost:8080/writeheader 我们将得到以下响应： HTTP/1.1 501 Not Implemented Date: Fri, 24 Jan 2020 10:57:32 GMT Content-Length: 6 Content-Type: text/plain; charset=utf-8 TO DO 3.3 Header过调用 Header 方法可以取得一个由首部组成的映射，修改这个映射就可以修改首部，修改后的首部将被包含在 HTTP 响应里面， 并随着响应一向发送至客户端。 func headerExample(w http.ResponseWriter, r *http.Request){ w.Header().Set(&quot;Location&quot;,&quot;http://google.com&quot;) w.WriteHeader(302) } func main(){ ... http.HandleFunc(&quot;/redirect&quot;,headerExample) server.ListenAndServe() } 那么cURL响应将得到以下结果： HTTP/1.1 302 Found Location: http://google.com Date: Fri, 24 Jan 2020 11:04:47 GMT Content-Length: 0 除了将状态码设置成了 302 之外， 它还给响应添加了一个名为 Location 的首部，并将这个首部的值设置成了重定向的目的地。 需要注意的是，因为 WriteHeader 方法在执行完毕之后就不允许再对首部进行写入了，所以用户必须先写入 Location 首部，然后再写入状态码。 现在，如果我们在浏览器里面访问这个处 理器， 那么浏览器将被重定向到 Google。 4. Cookiecookie 是一种存储在客户端的、体积较小的信息，这些信息最初都是由服务器通过 HTTP 响应报文发送的。 每当客户端向服务器发送一个 HTTP 请求时， cookie 都会随着请求被一同发送至服务器。 cookie 的设计本意是要克服 HTTP 的无状态性，虽然 cookie 并不是完成这一目的的唯一方法，但它却是最常用也最流行的方法之一：整个计算机行业的收入都建立在 cookie机制之上，对互联网广告领域来说，更是如此:)。 4.1 Go中的Cookiecookie 在 Go 语言里面用 Cookie 结构表示： type Cookie struct { Name string Value string Path string // optional Domain string // optional Expires time.Time // optional RawExpires string // for reading cookies only MaxAge int Secure bool HttpOnly bool Raw string Unparsed []string // Raw text of unparsed attribute-value pairs } cookie根据是否含有Expires信息分为两种： 会话cookie，或者叫临时cookie。在浏览器关闭的时候就会自动被移除。 持久cookie，存在直到指定的过期时间来临或者被手动删除为止。 Expires 宇段和 MaxAge 字段都可以用于设置 cookie 的过期时间： Expires，什么时候到期 MaxAge，能活多少秒 4.2 将cookie发送至浏览器完整的步骤是： 创建一个cookie结构体 用Cookie 结构的 String 方法将结构体序列化 使用set设置cookie func setCookie(w http.ResponseWriter, r *http.Request){ c1:= http.Cookie{ Name: &quot;first_cookie&quot;, Value: &quot;Go web&quot;, Path: &quot;&quot;, Domain: &quot;&quot;, Expires: time.Time{}, RawExpires: &quot;&quot;, MaxAge: 0, Secure: false, HttpOnly: true, SameSite: 0, Raw: &quot;&quot;, Unparsed: nil, } w.Header().Set(&quot;Set-Cookie&quot;,c1.String()) //w. Header() . Add (&quot;Set-Cookie”, c1. String ()) 也可以 } func main(){ server:=http.Server{ Addr: &quot;127.0.0.1:8080&quot;, } http.HandleFunc(&quot;/set_cookie&quot;,setCookie) server.ListenAndServe() } 除了 Set 方法和 Add 方法之外 ，Go语言还提供了一种更为快捷方便的 cookie 设置方法: http.SetCookie(w, &amp;c1) 4.3 从浏览器获取cookie添加： func getCookie(w http.ResponseWriter, r *http.Request){ h:=r.Header[&quot;Cookie&quot;] fmt.Fprintln(w,h) } http.HandleFunc(&quot;/get_cookie&quot;,getCookie) 当我们进入这个网页时，会显示一大堆cookie信息。如果用户想要取得单独的键值对格式的 cookie，就需要进行分析，go提供了一些分析方法： func getCookie(w http.ResponseWriter, r *http.Request){ c1,err:=r.Cookie(&quot;first_cookie&quot;) if err!=nil{ fmt.Fprintln(w,&quot;Can not find the cookie&quot;) } cs := r.Cookies() fmt.Fprintln(w,c1) fmt.Fprintln(w,cs) } func main(){ server:=http.Server{ Addr: &quot;127.0.0.1:8080&quot;, } http.HandleFunc(&quot;/set_cookie&quot;,setCookie) http.HandleFunc(&quot;/get_cookie&quot;,getCookie) server.ListenAndServe() } 先进入网页/set_cookie，然后进入/get_cookie。第一行显示我们设置的cookie，后面的为所有cookie。 first_cookie=&quot;Go web&quot; [_ga=GA1.1.193589.15722265 _xsrf=2|86b77755|fdefd0aac4be46f30abdbfe|1578603653 username-localhost- ... 8889|44:OTJhZmZiMjM5OTJiNGY2Y4MTAxNDdkM2UxM2U=|f8d50574e991203f0303f948b092ad1786a2f79c5ecbee1db10cf4c first_cookie=&quot;Go web&quot;] 4.4 利用cookie实现闪现消息当某个条件被满足时，在页面上显示一条临时出现的消息，然而当用户在刷新页面之后就不会再看见相同的消息了一一我们把这种临时出现的消息称为问现消息（ flash message ）。比如论坛发帖时，因为某种原因失败了，需要弹出失败消息。 func setMessage(w http.ResponseWriter,r *http.Request){ msg:=[]byte(&quot;hello world!&quot;) c :=http.Cookie{ Name: &quot;flash&quot;, Value: base64.URLEncoding.EncodeToString(msg), } http.SetCookie(w,&amp;c) } func showMessage(w http.ResponseWriter,r *http.Request){ c,err:=r.Cookie(&quot;flash&quot;) if err!=nil{ if err==http.ErrNoCookie{ fmt.Fprintln(w,&quot;No message&quot;) } }else{ rc:=http.Cookie{ Name: &quot;flash&quot;, Expires: time.Unix(1,0), MaxAge: -1, } http.SetCookie(w,&amp;rc) val,_:=base64.URLEncoding.DecodeString(c.Value) fmt.Fprintln(w,string((val))) } } func main(){ server:=http.Server{ Addr: &quot;127.0.0.1:8080&quot;, } http.HandleFunc(&quot;/set_message&quot;,setMessage) http.HandleFunc(&quot;/show_message&quot;,showMessage) server.ListenAndServe() } 首先set_message这一段，其实跟之前的set_cookie比较类似，主要区别在于编码：对消息使用了 Base64URL 编码，以此来满足响应首部对 cookie 值的 URL 编码要求。 再来看show_message这一段，思路是： 尝试获取指定的 cookie ， 如果没找到就返回错误 找到后，创建一个同名cookie，将 MaxAge 值设置为负数，并且将 Expires 值也设置成 一个已经过去的时间； 使用 SetCookie 方法将刚刚创建的同名 cookie 发送至客户端。 对原来的cookie解码，显示消息。 由于新的消息同名，所以会顶替掉原来的cookie，又因为时间是过期时间，会将这个cookie清除，以此来达到闪现的目的。当我们刷新页面时，hello world消失。","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"}]},{"title":"GoWeb编程2-接收Web请求","slug":"GoWeb编程2-接收Web请求","date":"2020-01-22T06:04:09.000Z","updated":"2020-01-23T13:51:40.000Z","comments":true,"path":"2020/01/22/GoWeb编程2-接收Web请求/","link":"","permalink":"jiangren.work/2020/01/22/GoWeb%E7%BC%96%E7%A8%8B2-%E6%8E%A5%E6%94%B6Web%E8%AF%B7%E6%B1%82/","excerpt":"要学习的是如何使用 Go 语言去创建一个 Web 服务器，以及如何处理客 户端发送的请求。","text":"要学习的是如何使用 Go 语言去创建一个 Web 服务器，以及如何处理客 户端发送的请求。 前面一章展示了一个Web编程的Demo，本章着重处理细节。 1. 使用Go构建服务器GoWeb编程这本书里提到了一个非常有趣的观点：货物崇拜编程(cargo cult programming) 货物崇拜一词指二战期间太平洋某些原住民社会中产生的信仰。他们会建造模仿飞机形状的模型和形似飞机跑道的设施，期待能够召唤飞机，像战争时代一样给他们带来物资。 这个名词常指不熟练的或没经验的程序员从某处拷贝代码到另一处，却並未了解其代码是如何工作的，或者不清楚在新的地方是否需要这段代码。 所以在goweb编程中，不应该局限于成熟框架的使用，而是应该深入理解作用机理，避免货物崇拜。 net/http标准库构成如下： go构建的服务器处理请求的过程是： 创建服务器的函数时http.ListenAndServe(&quot;网络地址&quot;,nil)。这个函数传入的网络地址如果为空，则默认使用80端口进行连接；如果处理器参数为nil，则服务器将使用默认的多路复用器DefaultServeMux 最简单的Web服务器如下： import &quot;net/http&quot; func main(){ http.ListenAndServe(&quot;&quot;,nil) } 在浏览器端口输入localhost:80，会进入一个页面，显示404，表明服务器创建成功，但是还没有添加页面。 用户还可以通过 Server 结构对服务器进行更详细的配置，包括为请求读取操作设置超时时间等。 func main(){ server:=http.Server{ Addr: &quot;127.0.0.1:8080&quot;, Handler: nil, } server.ListenAndServe() } 2. 处理器和处理函数之前的代码中，我们启动了一个 Web 服务器，访问这个服务器只会获得一个 404HTTP 响应代码。出现这一问题的原因在于我们尚未为服务器编写任何处理器，所以服务器的多路复用器在接收到请求之后找不到任何处理器来处理请求，因此它只能返回一个 404 响应。 2.1 处理请求在 Go 语言中， 一个处理器就是一个拥有 ServeHTTP 方法的接口，这个函数接收两个参数： ResponseWriter接口 指向Request结构的指针 ServeHTTP(http.ResponseWriter, *http.Request) 在之前ListenAndServe中，输入nil默认采用多路复用器DefaultServeMux。这个复用器是ServeMux结构的实例，它也拥有ServeMux结构的实例，也是Handler处理器结构的实例。 我们可以实现一个自己的处理器： type MyHandler struct{} func (h *MyHandler) ServeHTTP(w http.ResponseWriter,r *http.Request){ fmt.Fprintf(w,&quot;hello&quot;) } func main(){ server:=http.Server{ Addr: &quot;127.0.0.1:8080&quot;, Handler: &amp;MyHandler{}, } server.ListenAndServe() } 解释一下，func后面的括号表示此函数属于括号中的结构。比如， type Mutatable struct { a int b int } func (m Mutatable) StayTheSame() { m.a = 5 m.b = 7 } 这个处理器的问题是：当我们输入localhost:8080/xxsak之类的其他网页URL时，依然弹出hello world，正常来说应该弹出404才对。这是因为：处理器代替原本正在使用的默认多路复用器。 这意味着服务器不会再通过 URL 匹配来将请求路由至不同的处理器，而是直接使用同一个处理器来处理所有请求，因此无论浏览器访问什么地址，服务器返回的都是同样的 Hello World 响应。 2.2 使用多个处理器为了避免上述的问题，我们不再在 Server 结构的 Handler 字段中指定处理器，而是让服务器使用默认的 DefaultServeMux 作为处理器， 然后通过 http.Handle 函数将处理器绑定至 DefaultServeMux。 通过下面的程序我们能实现： 输入localhost:8080/hello，弹出hello 输入localhost:8080/world，弹出world 输入其他地址，弹出404 type hellohander struct{} func (h *hellohander) ServeHTTP(w http.ResponseWriter,r *http.Request){ fmt.Fprintf(w,&quot;hello&quot;) } type worldhander struct{} func (h *worldhander) ServeHTTP(w http.ResponseWriter,r *http.Request){ fmt.Fprintf(w,&quot;world&quot;) } func main(){ server:=http.Server{ Addr: &quot;127.0.0.1:8080&quot;, } http.Handle(&quot;/hello&quot;,&amp;hellohander{}) http.Handle(&quot;/world&quot;,&amp;worldhander{}) server.ListenAndServe() } 2.3 处理器函数http的处理器函数相当于一个转换器：将一个带有正确签名的函数f转换成一个带有方法f的Handler，比如： func world(w http.ResponseWriter,r *http.Request){ fmt.Fprintf(w,&quot;world&quot;) } http.HandleFunc(&quot;/world&quot;,world) 2.4 串联多个处理器和处理器函数前面介绍了，在 Go 语言里面，程序可以将一个 函数传递给另一个函数，又或者通过标识符去引用一个具名函数。这意味着，程序可以像图展示的那样，将函数 fl 传递给另一个函数口，然后在函数 f2 执行完某些操作之后调用 fl 。 平时有些工作，诸如如日志记录、安全检查和错误处理等，需要我们加到正常代码中处理，这被称为横切关注点。但我们又不希望这些操作和正常的代码搅和在一起。 为此，我们可以使用串联（ chaining ）技术分隔代码中的横切关注点。 下面这段代码，log函数接受一个HandlerFunc函数，然后又返回一个HandlerFunc函数，通过反射机制，反射出调用log的函数是谁。此时log函数相当于一个检验器。 当用户进入localhost:8080/world时，控制台输出Handler function called -main.world。 func world(w http.ResponseWriter,r *http.Request){ fmt.Fprintf(w,&quot;world&quot;) } func log(h http.HandlerFunc) http.HandlerFunc{ return func(w http.ResponseWriter,r *http.Request){ name := runtime.FuncForPC(reflect.ValueOf(h).Pointer()).Name() fmt.Println( &quot;Handler function called -&quot;+ name) h(w,r) } } func main(){ server:=http.Server{ Addr: &quot;127.0.0.1:8080&quot;, } http.Handle(&quot;/world&quot;,log(world)) server.ListenAndServe() } 当然我们也可以串联起更多函数。 串联多个函数可以让程序执行更多动作，这种做法有时候也称为管道处理（ pipeline processing） 比如，我们写一个验证用于身份的函数： func protect(h http.HandlerFunc) http.HandlerFunc{ return func(w http.ResponseWriter, r *http.Request){ ... //保护 h(w,r) } } http.HandleFunc(&quot;/hello&quot;,protect(log(hello))) 串联处理器的方法实际上和串联处理器 函数的方法是非常相似的。 type HelloHandler struct{} func (h HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request){ fmt.Fprintf(w, &quot;Hello!&quot;) } func log(h http.Handler) http.Handler{ return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request){ fmt.Printf(&quot;Handler called-%T\\n&quot;,h) h.ServeHTTP(w,r) }) } hello : = HelloHandler{} http.Handle (&quot;/hello&quot;, log (hello)) 传入log一个handler，在里面直接经过HandlerFunc函数处理得到一个Handler，这样就可以直接在http.Handle内执行。注意http.HandleFunc和http.HandlerFunc目测可以直接混用。 3.5 ServeMux和DefaultServeMux前面介绍了多路复用器，它负责接收HTTP请求并根据请求中的统一资源定位符URL将请求重新定向到正确的处理器。 ServeMux包含了一个map，通过map将URL映射到处理器，正如之前所说，ServeMux结构也实现了ServeHTTP方法，他也是一个处理器： DefaultServeMux是ServeMux的一个实例，当用户没有为 Server 结构指定处理器时，服务器就会使用 DefaultServeMux 作为 ServeMux 的默认实例。 当匹配不成功时，比如输入/lalalal，会进行层级下降，最终落到根URL上，也就是indexHanlder，输出404。但是当我们输入/world/123123，并不会落在/world上，这是因为程序在绑定 helloHandler 时使用的 URL 是／hello 而不是 /hello／。 如果被绑定的 URL 不是以／结尾，那么它只会与完全相同的 URL 匹配。","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"}]},{"title":"GoWeb编程1-Web的基础知识 - go","slug":"GoWeb编程1-Web的基础知识","date":"2020-01-22T05:23:33.000Z","updated":"2020-01-23T13:52:13.000Z","comments":true,"path":"2020/01/22/GoWeb编程1-Web的基础知识/","link":"","permalink":"jiangren.work/2020/01/22/GoWeb%E7%BC%96%E7%A8%8B1-Web%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"主要介绍web和http协议。","text":"主要介绍web和http协议。 1. Web简介1.1 什么是web严格来说，Web分为Web应用和Web服务。Web 应用应该是：它会对客户端发送的 HTTP 请求做出响应，并通过 HTTP 响应将 HTML 回传至客户端。 一个Web应用至少需要两个条件： 这个程序必须向发送命令请求的客户端返回 HTML，而客户端则会向用户展示渲染后的 HTML 这个程序在向客户端传送数据时必需使用 HTTP 协议 在这个定义的基础上，如果一个程序不是向用户渲染并展示HTML，而是向其他程序返回某 种非 HTML 格式的数据，那么这个程序就是一个为其他程序提供服务的 Web 服务。 1.2 Web的基本原理我们平时使用的浏览器本身就是一个客户端，平时的上网过程是： 输入URL时，浏览器回去请求DNS服务器。DNS服务器返回相应的域名对应的IP 浏览器通过IP寻址找到对应的服务器，要求建立TCP连接。 随后浏览器发送HTTP请求包。 服务器收到后，返回HTTP响应包。 浏览器接收并渲染响应包。 全部完成后，与服务器断开TCP连接 那么Web的工作原理可以被归纳为4个方面： TCP/IP协议建立的TCP连接 客户端发送HTTP协议请求包 服务器发送HTTP协议响应包 客户端解释HTML文档，在屏幕上渲染结果。 1.3 URL和DNS解析URL (Uniform Resource Locator) 是 统一资源定位符 的英文缩写，用于描述一个网络上的资源，基本格式如下 scheme://host[:port#]/path/.../[?query-string][#anchor] scheme 方案，指定底层使用的协议(例如：http, https, ftp) host HTTP 服务器的 IP 地址或者域名 port# HTTP 服务器的默认端口是 80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/ path 访问资源的路径 query-string 发送给 http 服务器的数据 anchor 锚 DNS (Domain Name System) 是 域名系统 的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于 TCP/IP 网络，它从事将主机名或域名转换为实际 IP 地址的工作，类似于翻译官。 DNS查询时优先考虑本地的Host文件和本地的DNS解析器是否保留有缓存映射，如果没有就向上一级请求。依次按照DNS根服务器，DNS顶层服务器，DNS管理方服务器的顺序请求。 所谓递归查询就是变更查询者，迭代查询则没有变更：这个例子中查询者由客户端变味了本地DNS服务器，所以是递归查询。 2. HTTP2.1 什么是HTTPHTTP是OSI的应用层协议，Web页面中的所有数据通过这个协议传输。 HTTP 是一种无状态、由文本构成的请求，响应（ request-response ）协议，这种协议使用的是客户端－服务器（ client-server ）模型 无状态协议的意思是：服务器唯一知道的就是客户端会向服务器发送请求，而服务器则会向客户端返回响应，并且后续发生的请求对之前发生过的请求一无所知。 其他协议，比如FTP和Telnet这类面向连接的协议则会在客户端和服务器之间创建一个持续存在的通信通道。 另外一点，HTTP也是以纯文本方式而不是二进制方式发送和接收协议数据的。这样做是为了让开发者可以在元需使用专门的协议分析工具的情况下，弄清楚通信中正在发生的事情，从而更容易进行故障排查。 2.2 HTTP请求前面提到，HTTP是一个请求-响应协议，协议涉及的所有事情都从一个请求开始。 格式构成是： 一个请求行request-line 头部header 一个空行 报文主体body 比如，其中Get就是请求方法，之后是URI（Uniform Resource Identifier），以及HTTP版本。 GET /Protocols/rfc2616/ rfc2616.ht ml HTTP/ 1.1 Host : www.w3.org User-Agent : Mozilla/5.0 &lt;!DOCTYPE html PUBLIC ”-//W3C//DTD XHTML 1.0 Strict//EN” 在HTTP协议中定义了许多请求方法： GET 命令服务器返回指定的资源 HEAD 与 GET 方法的作用类似，唯一的不同在于这个方法不要求服务器返回报文的主体。只取得头部。 PUT 命令服务器将报文主体中的数据设置为 URI 指定的资源。 DELETE 命令服务器删除 URI 指定的资源 TRACE 命令服务器返回请求本身。 通过这个方法，客户端可以知道介于它和服务器 之间的其他服务器是如何处理请求的。 OPTIONS 一命令服务器返回它支持的 HTTP 方法列表 CONNECT 命令服务器与客户端建立一个网络连接 PATCH 命令服务器使用报文主体中的数据对 URI 指定的资源进行修改。 2.3 HTTP响应HTTP 响应报文是对 HTTP 请求报文的回复。 跟 HTTP 请求一样， HTTP 响应也是由一系列 文本行组成的，其中包括： 一个状态行 响应头部 一个空行 一个可选的报文主体 HTTP 响应的组织方式跟 HTTP 请求的组织方式是完全相同的。 200 OK Date : Sat, 22 Nov 2014 12 : 58:58 GMT Server: Apache/2 Last-Modified: Thu, 28 Aug 2014 21:01:33 GMT Content-Length: 33115 Content-Type: text/html; charset=iso-8859- 1 &lt;!DOCTYPE html PUBLIC ”-//W3C//DTD XHTML 1.0 Strict//EN” ”http://www.w3.org/ TR/xhtmll/DTD/xhtmll-strict.dtd” &gt; &lt;html xmlns= ’ http: //www.w3 . org/1999/ xhtml ’ &gt; &lt;head&gt;&lt;title&gt;Hypertext Transfer Protocol -- HTTP/1 .1&lt;/title&gt;&lt;/ head&gt;&lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 首行包含了状态码，共计5种类型： 3. 使用go编写一个web程序import ( &quot;fmt&quot; &quot;net/http&quot; &quot;strings&quot; &quot;log&quot; ) func sayhelloName(w http.ResponseWriter, r *http.Request) { r.ParseForm() // 解析参数，默认是不会解析的 fmt.Println(r.Form) // 这些信息是输出到服务器端的打印信息 fmt.Println(&quot;path&quot;, r.URL.Path) fmt.Println(&quot;scheme&quot;, r.URL.Scheme) fmt.Println(r.Form[&quot;url_long&quot;]) for k, v := range r.Form { fmt.Println(&quot;key:&quot;, k) fmt.Println(&quot;val:&quot;, strings.Join(v, &quot;&quot;)) } fmt.Fprintf(w, &quot;Hello world!&quot;) // 这个写入到 w 的是输出到客户端的 } func main() { http.HandleFunc(&quot;/&quot;, sayhelloName) // 设置访问的路由 err := http.ListenAndServe(&quot;:9090&quot;, nil) // 设置监听的端口 if err != nil { log.Fatal(&quot;ListenAndServe: &quot;, err) } } 当我们在浏览器输入http://localhost:9090后就可以看到Hello World，并在服务器窗口看到： map[] path / scheme [] map[] path /favicon.ico scheme [] 如果输入http://localhost:9090/?url_long=111&amp;url_long=222，（问号用于分割URL和传输数据）得到的结果是： map[url_long:[111 222]] path / scheme [111 222] key: url_long val: 111222 map[] path /favicon.ico scheme []","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"}]},{"title":"go并发","slug":"go并发","date":"2020-01-19T06:45:53.000Z","updated":"2020-01-30T13:17:29.000Z","comments":true,"path":"2020/01/19/go并发/","link":"","permalink":"jiangren.work/2020/01/19/go%E5%B9%B6%E5%8F%91/","excerpt":"go语言并发的基础知识","text":"go语言并发的基础知识 1. Go的并发方式1.1 并发与并行首先要明确线程与进程的区别。这个问题真的是老生常谈了，在开始之前最好还是复习一遍： 对于操作系统来说，一个任务就是一个进程(Process)，比如打开浏览器，使用word。而一个进程可能不只干一件事（比如word既要打字又要检查拼写），这种进程内的多个子任务就是线程（Thread）。 具体来说： 进程是操作系统分配资源的单位，而线程是进程的一个实体，是CPU调度和分派的基本单位。 线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 多进程与多线程：现代操作系统一般都是多进程的，他可以同时运行多个任务，一般来说一个CPU核对应一个进程，如果开启的进程比较多就需要使用时间片轮转进程调度算法。它的思想简单介绍如下：在操作系统的管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，这样用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。 引入线程的好处： 在进程内创建、终止线程比创建、终止进程要快； 同一进程内的线程间切换比进程间的切换要快。 对于其他编程语言来说，当涉及到并发任务时： 其他语言：会在物理处理器上调度线程来运行 go语言：会在逻辑处理器上调度goroutine来运行 go语言运行时默认会给每个可用的物理处理器分配一个逻辑处理器，逻辑处理器会用于执行所有被创建的goroutine。 如果创建一个goroutine 并准备运行，这个 goroutine 就会被放到调度器的全局运行队列中等待执行。排队排到时，放入逻辑处理器中执行 有时，正在运行的 goroutine 需要执行一个阻塞的系统调用，如打开一个文件。当这类调用发生时，线程和 goroutine 会从逻辑处理器上分离，该线程会继续阻塞，等待系统调用的返回。 与此同时，这个逻辑处理器就失去了用来运行的线程。所以，调度器会创建一个新线程，并将其绑定到该逻辑处理器上 并发（concurrency）不是并行（parallelism），并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情。 如果希望强化Go的并行能力，需要使用多个逻辑处理器，调度器会将 goroutine 平等分配到每个逻辑处理器上。当然前提是处理器有多个核心，否则无论如何也打不到真正的并行。 1.2 goroutine下面这一套代码展示了如何用两个goroutine打印5000以内的质数： import ( &quot;fmt&quot; &quot;runtime&quot; &quot;sync&quot; ) // wg is used to wait for the program to finish. var wg sync.WaitGroup // main is the entry point for all Go programs. func main() { // Allocate 1 logical processors for the scheduler to use. runtime.GOMAXPROCS(1) // Add a count of two, one for each goroutine. wg.Add(2) // Create two goroutines. fmt.Println(&quot;Create Goroutines&quot;) go printPrime(&quot;A&quot;) go printPrime(&quot;B&quot;) // Wait for the goroutines to finish. fmt.Println(&quot;Waiting To Finish&quot;) wg.Wait() fmt.Println(&quot;Terminating Program&quot;) } // printPrime displays prime numbers for the first 5000 numbers. func printPrime(prefix string) { // Schedule the call to Done to tell main we are done. defer wg.Done() next: for outer := 2; outer &lt; 5000; outer++ { for inner := 2; inner &lt; outer; inner++ { if outer%inner == 0 { continue next } } fmt.Printf(&quot;%s:%d\\n&quot;, prefix, outer) } fmt.Println(&quot;Completed&quot;, prefix) } 首先，调用了runtime包的GOMAXPROCS函数，设定调度器可以使用的逻辑处理器数量。然后通过WaitGroup等待两个goroutine完成工作。通过go关键词，激发两个函数。在函数中使用defer关键词，保证每个goroutine一旦结束就调用Done方法。 基于调度器的内部算法，一个正运行的 goroutine 在工作结束前，可以被停止并重新调度。调度器这样做的目的是防止某个 goroutine 长时间占用逻辑处理器。 因此跟我们运行时，结果如下： Create Goroutines Waiting To Finish B:2 B:3 ... B:4583 //切换至A A:2 A:3 ... 如果我们使用GOMAXPROCS函数创建了两个逻辑处理器，这会使得gorountine并行运行，结果交替输出： Create Goroutines Waiting To Finish B:2 A:2 A:3 B:3 B:5 ... 这是多核计算机下的运行结果，如果是单核就没有交替输出的效果。 1.3 goroutine性能利用go自带的bench测试函数，对goroutine性能进行评估。 在main中编写如下函数，注意千万不要在其中打印print，因为性能测试会运行很多遍。 func printPrime(prefix string) { next: for outer := 2; outer &lt; 1000; outer++ { for inner := 2; inner &lt; outer; inner++ { if outer%inner == 0 { continue next } } } } func prime1(){ printPrime(&quot;Serial&quot;) } func prime2(){ go printPrime(&quot;Concurrency&quot;) } 然后编写main_test.go文件： func BenchmarkPrint1(b *testing.B) {//对顺序执行的函数进行基准测试 for i := 0; i &lt; b.N; i++ { prime1() } } func BenchmarkGoPrint1(b *testing.B) {//对以goroutine形式执行的函数进行基准测试 for i := 0; i &lt; b.N; i++ { prime2() } } 执行命令： go test -run x -bench . -cpu 1 输出结果如下： BenchmarkPrint1 1701 780275 ns/op BenchmarkGoPrint1 10000 247311 ns/op 1.4 等待goroutine前面我们用到了等待组（Wait-Group）的机制，目的就是避免程序结束时，goroutine还没有结束。它的运作方式非常简单直接： 声明一个等待组； 使用Add方法为等待组的计数器设置值； 当一个goroutine完成它的工作时，使用Done方法对等待组的计数器执行减一操作； 调用Wait方法，该方法将一直阻塞，直到等待组计数器的值变为0。 比如： func Prime1(wg *sync.WaitGroup){ .... wg.Done() } func Prime2(wg *sync.WaitGroup){ .... wg.Done() } func main(){ var wg sync.WaitGroup wg.Add(2) go Prime1(&amp;wg) go Prime2(&amp;wg) wg.Wait() } 首先定义一个名为wg的WaitGroup变量，然后通过调用wg的Add方法将计数器的值设置成2；在此之后，程序会分别调用prime1和prime2这两个goroutine，而这两个goroutine都会在末尾对计数器的值执行减一操作。之后程序会调用等待组的Wait方法，并因此而被阻塞，这一状态将持续到两个goroutine都执行完毕并调用Done方法为止。 2. 竞争下面的代码是一个竞争，通过Gosched函数让goroutine从当前线程退出，给其他goroutine运行的机会。 package main import ( &quot;fmt&quot; &quot;runtime&quot; &quot;sync&quot; ) var ( counter int wg sync.WaitGroup ) func main() { wg.Add(2) go incCounter(1) go incCounter(2) wg.Wait() fmt.Println(&quot;Final Counter:&quot;, counter) } func incCounter(id int) { defer wg.Done() for count := 0; count &lt; 2; count++ { value := counter runtime.Gosched() //退出 value++ counter = value } } 为了解决这个问题，我们可以使用竞争检测工具： go build -race // 用竞争检测器标志来编译程序 Go_practice.exe ================== WARNING: DATA RACE Read at 0x00000061ad08 by goroutine 8: main.incCounter() D:/Go_Practice/main.go:40 +0x80 Previous write at 0x00000061ad08 by goroutine 7: main.incCounter() D:/Go_Practice/main.go:49 +0xa1 Goroutine 8 (running) created at: main.main() D:/Go_Practice/main.go:26 +0x90 Goroutine 7 (finished) created at: main.main() D:/Go_Practice/main.go:25 +0x6f ================== Final Counter: 4 Found 1 data race(s) 2.1 锁1.4.1 原子函数原子函数能够以很底层的加锁机制来同步访问整型变量和指针。将之前不安全的代码，改为： func incCounter(id int) { defer wg.Done() for count := 0; count &lt; 2; count++ { atomic.AddInt64(&amp;counter, 1). runtime.Gosched() } } 原子函数数会同步整型值的加法， 方法是强制同一时刻只能有一个 goroutine 运行并完成这个加法操作。另外两个有用的原子函数是LoadInt64和StoreInt64。这两个函数提供了一种安全地读 和写一个整型值的方式。 1.4.2 互斥锁互斥锁用于在代码上创建一个临界区，保证同一时间只有一个 goroutine 可以 执行这个临界区代码。 package main import ( &quot;fmt&quot; &quot;runtime&quot; &quot;sync&quot; ) var ( counter int wg sync.WaitGroup mutex sync.Mutex ) func main() { wg.Add(2) go incCounter(1) go incCounter(2) wg.Wait() fmt.Printf(&quot;Final Counter: %d\\n&quot;, counter) } func incCounter(id int) { defer wg.Done() for count := 0; count &lt; 2; count++ { mutex.Lock() { value := counter runtime.Gosched() value++ counter = value } mutex.Unlock() } } 2.2 通道相较于上面提到的两种传统的共享机制，Go提供了通道这种数据结构，使得并发更加简单。 当一个资源需要在 goroutine 之间共享时，通道在 goroutine 之间架起了一个管道，可以通过通道共享 内置类型、命名类型、结构类型和引用类型的值或者指针。 // 无缓冲的整型通道 unbuffered := make(chan int) // 有缓冲的字符串通道 buffered := make(chan string, 10) 使用&lt;-一元操作符从通道中提取或发送数据： // 有缓冲的字符串通道 buffered := make(chan string, 10) // 通过通道发送一个字符串 buffered &lt;- &quot;Gopher // 从通道接收一个字符串 value := &lt;-buffered （1）无缓冲的通道 无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。如果两个goroutine 没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。这 下面是模拟两个选手打网球，利用chan int传递球： import( &quot;fmt&quot; &quot;math/rand&quot; &quot;sync&quot; &quot;time&quot; ) var wg sync.WaitGroup func init(){ rand.Seed(time.Now().UnixNano()) } func main(){ court:=make(chan int) wg.Add(2) go player(&quot;Bob&quot;,court) go player(&quot;Joy&quot;,court) court &lt;- 1 wg.Wait() } func player(name string,court chan int){ defer wg.Done() for{ ball,ok:=&lt;-court if !ok{ fmt.Printf(&quot;Player %s Won\\n&quot;, name) return } n:=rand.Intn(100) if n%13 ==0{ fmt.Printf(&quot;Player %s Missed\\n&quot;, name) close(court) return } fmt.Printf(&quot;Player %s Hit %d\\n&quot;, name, ball) ball++ court&lt;-ball } } （2）有缓冲的通道 有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。 Select关键词 Go拥有一个特殊的关键字select，它允许用户从多个通道中选择一个通道来执行接收或者发送操作。select关键字就像是专门为通道而设的switch语句。 func callerA(c chan string) { c &lt;- &quot;Hello World!&quot; } func callerB(c chan string) { c &lt;- &quot;Hola Mundo!&quot; } func main() { a, b := make(chan string), make(chan string) go callerA(a) go callerB(b) for i:=0;i&lt;5;i++ { select { case msg := &lt;-a: fmt.Printf(&quot;%s from A\\n&quot;, msg) case msg := &lt;-b: fmt.Printf(&quot;%s from B\\n&quot;, msg) //新添加的分支 default: fmt.Println(&quot;Default&quot;) } } } 运行goroutine后，会向两个通道传入字符，根据通道是否有字符，select选择性执行： Default Hola Mundo! from B Hello World! from A Default Default 当一个goroutine取出无缓冲通道中唯一的值之后，无缓冲通道将变为空，之后任何尝试从空通道获取值的goroutine都会被阻塞并进入休眠状态。需要为select语句添加一个默认分支，让select语句在所有可选通道都已被阻塞的情况下执行默认分支即可。","categories":[{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"},{"name":"并发","slug":"并发","permalink":"jiangren.work/tags/%E5%B9%B6%E5%8F%91/"},{"name":"多线程","slug":"多线程","permalink":"jiangren.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Redis的简单应用场景总结","slug":"Redis的简单应用场景总结","date":"2020-01-16T08:15:22.000Z","updated":"2020-01-16T16:27:04.000Z","comments":true,"path":"2020/01/16/Redis的简单应用场景总结/","link":"","permalink":"jiangren.work/2020/01/16/Redis%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93/","excerpt":"总结redis应用场景。","text":"总结redis应用场景。 1. 缓存比如我要从数据库查看最新的5000条评论： SELECT comments FROM user ORDER BY time DESC LIMIT 5000 这样的操作随着数据的增加会变得越来越慢，因为要进行排序操作。而且这种排序本身不应该发生：因为我们存的时候是按时间存进去的。 我们可以使用redis的列表对象来实现，此时列表由Linkedlist数据结构实现。 每次新评论发表时，我们会将它的ID添加到一个Redis列表LPUSH latest.comments，然后将列表裁剪到5000，LTRIM latest.comments 0 5000 每次我们需要获取最新评论的项目范围时，我们调用一个函数来完成(使用伪代码)： FUNCTION get_latest_comment(num_items): id_list=redis.lrange(&quot;latest.comments&quot;,0,num_items-1) IF id_list&lt;num_items id_list = MySQL(&quot;SELECT ... ORDER BY time LIMIT ...&quot;) END RETURN id_list END 只有超过了5000这个限制时，才会去访问数据库。 2. 排行榜选手报名参加活动，观众可以对选手进行投票，每个观众对同一名选手只能投一票，活动期间最多投四票。后台需要提供以下接口： 接口1：返回TOP 10的选手信息及投票数 接口2：返回活动总参与选手数及总投票数 接口3：对于每个选手，返回自己的投票数，排名，距离上一名差的票数 如果是Mysql方案，需要建立一个表来记录投票信息。这个表在入表时首先就需要判断是否重复刷票，有两种方法 在查询时需要组合查询：将投票表和选手信息表组合，统计投票信息，然后排序输出。耗时较长。 新建一个排行榜表，每隔一段时间做组合查询，维护这个表。缺乏实时性。 redis方案可以采用有序集合对象，我们创建一个有序集合vote_activity，然后使用ZINCRBY key increment memeber命令给指定成员的分数加上增量increment， redis&gt; ZINCRBY vote_activity 1 Bob &quot;1&quot; redis&gt; ZINCRBY vote_activity 1 Tim &quot;1&quot; redis&gt; ZINCRBY vote_activity 1 Bob &quot;2&quot; 有序列表入队时，按分值排好序了，我们可以方便的用ZSCORE key member查询分数。 redis&gt; zscore vote_activity Bob &quot;2&quot; 以及获取某人的排名，获取前10名，获取前10名分数等等， #获取Alice排名(从高到低，zero-based) redis&gt; zrevrank vote_activity Alice (integer) 0 #获取前10名(从高到低) redis&gt; zrevrange vote_activity 0 9 1) &quot;Alice&quot; 2) &quot;Bob&quot; #获取前10名及对应的分数(从高到低) redis&gt; zrevrange vote_activity 0 9 withscores 1) &quot;Alice&quot; 2) &quot;2&quot; 3) &quot;Bob&quot; 4) &quot;1&quot; 3. 消息队列一般来说，消息队列有两种场景：一种是发布者订阅者模式；一种是生产者消费者模式。利用redis这两种场景的消息队列都能够实现。定义： 生产者消费者模式：生产者生产消息放到队列里，多个消费者同时监听队列，谁先抢到消息谁就会从队列中取走消息；即对于每个消息只能被最多一个消费者拥有。（常用于处理高并发写操作） 发布者订阅者模式：发布者生产消息放到队列里，多个监听队列的消费者都会收到同一份消息；即正常情况下每个消费者收到的消息应该都是一样的。（常用来作为日志收集中一份原始数据对多个应用场景） 发布者订阅者模式可以直接使用pub/sub指令实现。 生产者消费者模式分两种： 普通的 带有优先级的 普通模式下使用brpop指令，可以以阻塞的形式返回数据列表中新添加的参数： while(true) { List&lt;string&gt; msgs = redis.brpop(BLOCK_TIMEOUT,listKey); Handle(msgs); } 如果是优先级模式，当优先级不是很多是，可以分为两组： while(true) { List&lt;string&gt; msgs = redis.brpop([&#39;high_task_queue&#39;, &#39;low_task_queue&#39;],0); Handle(msgs); } brpop命令可以输入多个键，如果同时都有元素可读，读先输入的那个键。 如果优先级划分很多，就需要再用列表排序的办法了（有序集合不好，因为没有阻塞模式）。假如有1000个优先级，我们可以先分组，分为10组，每组按优先级顺序排列，查找时二分查找。 4. 时间轴所谓时间轴系统就是典型的微博模式：用户在自己的主页可以看到其关注的博主发表的信息列表（按时间排序）；而其它用户可以一个用户的个人主页看到这个人发布的信息列表（按时间排序）。 解决方案主要有两种： 推模式：某人发布内容之后推送给所有粉丝，空间换时间，瓶颈在写入； 拉模式：粉丝从自己的关注列表中读取内容，时间换空间，瓶颈在读取； 以推模式为例： （1）博主发布博文 我们创建一个哈希对象post，键为博文ID，值为博文内容字符串。存储博文。 redis&gt; HSET post 4396 &quot;hahahahah&quot; 再使用一个列表，按先后顺序存储该博主的博文： redis&gt;LPUSH Dasima 4396 然后使用一个集合，存储该博主的所有粉丝，利用SMEMBERS获取这些粉丝的名单。 redis&gt; SMEMBERS Dasima 每一个粉丝拥有一个timeline列表，存取所有推送博文的ID。之后对所有粉丝的推送列表进行写入。 （2）用户读取博文推送 利用LRANGE从推送中拉取一定数量的博文，根据拉到的博文ID，读取哈希表的内容。 redis&gt;LRANGE timeline 0 30 redis&gt;HGETALL(4396) 5. 实现分布式锁（1）什么是分布式锁？ 对于单进程的程序，采用普通锁即可防止竞争，而对于多进程分布式系统来说需要采用分布式锁来保证一致性。 （2）redis如何实现分布式锁 在 Redis 2.6.12 版本开始，set命令增加了三个参数，替换以前的setnx命令： EX：设置键的过期时间（单位为秒） PX：设置键的过期时间（单位为毫秒） NX | XX：当设置为NX时，仅当 key 存在时才进行操作，设置为XX时，仅当 key 不存在才会进行操作 我们可以以此实现简单的分布式锁： set key &quot;lock&quot; EX 1 XX 如果这个操作返回false，说明 key 的添加不成功，也就是当前有人在占用这把锁。而如果返回true，则说明得了锁，便可以继续进行操作，并且在操作后通过del命令释放掉锁。并且即使程序因为某些原因并没有释放锁，由于设置了过期时间，该锁也会在 1 秒后自动释放，不会影响到其他程序的运行。 del &quot;lock&quot;","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"}]},{"title":"Redis面试常见基本问题","slug":"Redis面试常见基本问题","date":"2020-01-16T08:11:46.000Z","updated":"2020-03-26T14:50:21.000Z","comments":true,"path":"2020/01/16/Redis面试常见基本问题/","link":"","permalink":"jiangren.work/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/","excerpt":"redis的原理性问题总结。","text":"redis的原理性问题总结。 1.基础1.1 什么是Redis？Redis的全称是：Remote Dictionary Server，本质上是一个 Key-Value 类型的内存数据库。 整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据保存在硬盘。因为是纯内存操作，Redis 的性能非常出色。 1.2 Redis的优劣势？优势： 纯内存读写操作，性能好。 单线程，不用担心竞争 特性丰富，支持发布订阅、过期、sentinel等功能。 劣势： 容量受物理内存限制，不能用作海量数据的高性能读写。 1.3 Redis和Memcached比较Memcached早年被很多公司使用，现在内存越来越便宜，基本都是用Redis。Redis被认为是Memcached的替代者，优势有： memcached值均为简单字符串，redis支持更丰富的类型 redis性能更好（速度快，内存大）Memcached内存限制为1MB，而Redis可以达到1GB redis可以持久化 Memcached集群功能不好，没有原生集群模式 劣势有： redis只是用一个核，而memcached使用多核，在大数据处理上，memecached效率要好一些。 1.4 Redis支持哪些数据类型对象： 字符串对象，支持int、raw、embstr编码 int针对整数 raw较长的字符串，分为redisObject和sdshdr embstr较短的字符串，redisObject和sdshdr同时分配，挨在一起 列表对象，支持ziplist和linkedlist编码 ziplist压缩列表每个节点(entry)只保存一个列表元素 linkedlist双端链表，嵌套编码，链表下面还嵌入了字符类型 哈希对象，支持ziplist和hashtable 集合对象，支持intset和hashtable intset 编码时，元素将被密集得堆叠在位上 有序集合对象，支持ziplist和skiplist skiplist 编码的有序集合对象使用 zset 结构作为底层实现， 一个 zset 结构同时包含一个字典和一个跳跃表 起作用主要是跳跃表，字典是辅助加速用。字典的键记录了元素的成员，而值则保存了元素的分值。通过字典，能实现$O(1)$复杂度的查找给定成员分值。 2. 缓存相关2.1 什么是缓存雪崩？首先，为什么要使用缓存？ 缓存区域的大小是有限的，为了避免数量膨胀，redis采取了过期删除策略。但是如果缓存数据设置的过期时间是相同的，会导致这些缓存同时失效，所有请求全部跑向数据库，造成巨大冲击。这就是缓存雪崩。 发生的原因可能是： Redis挂掉。 由于过期键时间问题，导致同时失效。 2.2 如何解决缓存雪崩？对于过期键失效问题： 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。 对于redis挂掉的问题： 主从服务器+sentinel+集群模式，保证有继承人存在，及时推举。 如果redis真的挂了，可以设置本地缓存+限流 事发后，利用持久化特性，尽快从磁盘上加载数据，恢复缓存。 2.3 什么是缓存穿透？缓存穿透是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。 2.4 如何解决缓存穿透？ 使用布隆过滤器 当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个较短的过期时间 布隆过滤器的原理解释https://zhuanlan.zhihu.com/p/43263751。 2.5 如何解决缓存与数据库双写不一致？在写更新数据时，我们要进行两步操作：删除缓存和更新数据库（一般不使用更新缓存，都是直接删除），现在的问题就是：这两步先做哪一个？ 先更新数据库，再删除缓存 先删除缓存，再更新数据库 如果是1，则 当原子性破坏时（更新了库，没删缓存），导致数据不一致 并发场景出现问题的概率较低，仅发生在缓存失效时 线程A查询数据库，得到旧值 线程B将新值写入数据库 线程B删除缓存 线程A将查到的旧值写入缓存 为什么说发生概率低呢？ 仅发生在缓存失效时 写入数据库的操作一般比较慢，c一般会慢于d。 如果是2，则： 原子性被破坏时，不影响一致性 并发时，问题很大 线程A删除缓存 线程B查询时缓存不存在，于是到数据库取了一个旧值 线程B将旧值写入缓存 线程A将新值写入数据库 如何保证并发下的一致呢？ 将删除缓存、修改数据库、读取缓存等的操作积压到队列里边，实现串行化。 3. 线程模型3.1 为什么Redis是单线程？首先CPU的性能并不是瓶颈，主要考虑本地内存和网络带宽。其次，单线程可以避免线程切换的资源消耗和竞争问题，有利于性能提升。 3.2 介绍一下IO多路复用IO多路复用的原理是：存在一个接线员，当有客户连接时，接线员接收连接，分派到制定执行函数，然后接着监听。这样就可以避免处理某一个连接而阻塞其他用户的情况。 Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll这些I/O多路复用函数库来实现的。由于IO复用程序提供了统一的接口，所以底层实现方法可以互换。 3.3 介绍一下redis线程模型的处理流程Redis网络事件处理器称为文件事件处理器（file event handler），包括： 套接字 IO复用程序 文件事件分派器 事件处理器 事件处理器包括： 连接应答处理器 命令请求处理器 命令回复处理器 详情参见事件处理器讲解 4. 数据删除与淘汰机制4.1 介绍一下redis的过期删除策略（1）惰性删除 放着不管，每次从键空间获取时检查是否过期，过期就删除。 对CPU最友好，但浪费内存。如果数据库中有很多过期键，而这些过期键永远也不会被访问的话，他们就会永远占据空间，可视为内存泄漏。比如一些和时间有关的数据（日志）。 （2）定期删除 每隔一段时间，程序检查一次数据库，删除过期键。 对CPU和内存是一种折中。通过选择较为空闲的时间点来处理过期键，减少CPU压力。同时也能及时释放内存，避免内存泄漏。 在redis中由周期函数severCron负责，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。他会记录检查进度，在下一次检查时接着上一次的进度进行处理。比如说，如果当前函数在遍历10号数据库时返回了，那么下次就会从11号数据库开始工作。 4.2 介绍一下Redis的内存淘汰机制惰性删除和定期删除依然可能保留大量过期键，这时候需要用到内存淘汰机制。内存淘汰机制有6个： noeviction：eviction是驱逐的意思，当内存不足以容纳新写入数据时，新写入操作会报错。 allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key :ok_hand::ok_hand: allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key。 volatile-lru：[ˈvɒlətaɪl]易挥发的，易丢失的。当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key。 volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。:ok_hand: volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。:ok_hand: 4.3 写一个LRU算法我的博客有总结，是一道Leetcode题目，C++版本： Leetcode146-LRU缓存机制 5. Redis高并发和高可用5.1 Redis的高并发是如何实现的？首先从程序编写的角度上来说， Redis是纯内存数据库，读写速度快， 采用了非阻塞IO复用， 采用了优秀的数据结构设计， 然后，从布局架构上来说，实现高并发主要依靠主从架构（单线程多进程），比如单机写数据，多机查数据。单机能达到几万QPS(queries per sec)，多个从实例能达到10W的QPS。 更进一步，可以采用集群，不仅能实现高并发，还能容纳大量数据。 5.2 Redis的高可用是如何实现的？高可用性指系统无中断地执行其功能的能力。Redis实现高可用依靠的是Sentinel哨兵机制。Sentinel本质上只是一个运行在特殊模式下的Redis服务器，是一个进程。 Sentinel作用： 监控Redis整体是否正常运行。 某个节点出问题时，通知给其他进程（比如他的客户端）。 主服务器下线时，在从服务器中选举出一个新的主服务器。 Sentinel互相监督： Sentinel和服务器之间建立hello频道连接 Sentinel在hello频道发送信息时会被其他Sentinel发现，达到握手的目的。 发现后，Sentinel之间建立连接，形成环形网络。 Sentinel监督下线： 按频率向所有创建连接的实例发送PING，查看是否回复PONG来判断是否在线，不回复则标记为主观下线状态。 向其他Sentinel询问，如果足够数量的Sentinel也标记为下线状态，则改为客观下线。 Sentinel应对服务器下线的补救措施： （1）选举领头的Sentinel 过程：一个Sentinel向另一个Sentinel发送设置请求命令。最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝。 如果有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel。 （2）故障转移 从已下线的主服务器的从服务器中拔举一个作为主服务器。标准：偏移量最大 让已下线主服务器属下的所有从服务器改为复制新的主服务器 将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。 6. 多机架构6.1 Redis有哪些多机架构？不考虑中间件，原生的架构有主从复制架构和集群架构。 6.2 介绍一下复制过程Redis中复制有新老两版。 老版：分为同步和命令传播两个阶段。 老版： 在同步阶段： 从机向主机发送SYNC命令 主机收到后，执行BGSAVE生成RDB文件，并使用缓冲区记录现在开始执行的所有写操作。 将RDB文件发给从服务器 将缓冲区内容发送给从服务器 在命令传播阶段： 主服务器将自己执行的写命令发送给从服务器，让他执行相同的命令 缺陷： 初次复制效果较好，但断线后重连复制效率很低，需要全部重录RDB文件。 新版： 分为完整重同步和部分重同步，前者和旧版一样。部分重同步有三个部分： 主从服务器的复制偏移量 主服务器的复制积压缓冲区 服务器的运行ID 主服务器和从服务器会分别维护一个复制偏移量，通过对比偏移量来知道主从服务器是否处于一致状态： 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。 复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列。当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面。同时，主服务器也会向积压缓冲区添加偏移量。重新上线时根据偏移量决定如何重同步： 下线后，数据长度超过了缓冲区，导致溢出，说明下线时间太长，执行完全重同步。 否则，部分重同步。 而主服务器ID则帮助重新上线的从服务器识别， 如果ID和从服务器记录的相同，则表示之前同步的主服务器就是这个，执行部分重同步。 如果ID不同，则表明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，执行完整重同步操作。 6.3 介绍一下集群集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能，保证高可用性。 集群的结构是：多个节点（node）组成一个集群，节点是Redis中数据存储的单位，在刚开始的时候，每个节点都是相互独立的。通过CLUSTER MEET命令相互握手，组成集群。 集群数据的存储方式是：集群的整个数据库被分一万多个槽（slot），数据库中的每个键都属于槽的其中一个。当所有槽都有节点在处理时，集群处于上线状态。 6.4 集群的通信方式是怎样的？集群依靠消息通信，消息有5种：MEET, PING, PONG, FAIL, PUBLISH。 Redis集群中的各个节点通过Gossip协议来交换各自关于不同节点的状态信息，其中Gossip协议由MEET、PING、PONG三种消息实现。 所谓Gossip是八卦消息的意思，在Redis中，发送每次发送MEET、PING、PONG消息时，发送者都从自己的已知节点列表中随机选出两个节点（可以是主节点或者从节点），保存到一个特殊结构体中。 接受者接收到MEET、PING、PONG消息时，根据保存的两个节点是否认识来选择进行哪种操作： 不认识，说明接收者第一次接触被选中节点，则接收者与被选中节点握手 认识，根据结构信息进行更新。 比如A节点发送的PING给B，携带了CD两个节点，然后B回复PONG携带了EF两个节点，这样就完成了ABCDEF六个节点的信息交换。每个节点按照周期向不同节点传播PING-PONG信息，就能完成整个集群的状态更新。 如果节点很多，则Gossip消息比较慢，而主节点下线的消息需要立即通知给所有人。FAIL消息的正文只包含已下线的节点名称，直接通知给所有已知节点。 接收到PUBLISH命令的节点不仅会向channel频道发送消息message，它还会向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会向channel频道发送message消息。 也就是说，向集群发送PUBLISH，会导致集群所有节点都向channel发送message消息。 6.5 集群分片的原理是什么?Redis引入了哈希槽的概念，通过槽指派的方式存储数据。 Redis集群有$2^{14}=16384$个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽slot = CRC16(key) &amp; 16383，集群的每个节点负责一部分hash槽。 使用哈希槽的好处就在于可以方便的添加或移除节点。 当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了； 当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了。 CRC16算法能分配65535个槽位，但作为包发送太臃肿，一般情况下一个redis集群不会有超过1000个master节点，所以采用$1/4$ 6.6 集群扩容和收缩是怎么实现的？集群的伸缩是通过重新分片的方式实现的，重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。 重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。 //以下可以略 重新分片由redis-trib负责，步骤如下： trib向源节点发送命令，包含了执行迁移的槽slot，要迁移键的数量count。 源节点返回属于槽slot的count个键。 对于每个返回键，trib向源节点发送一个MIGRATE命令 源节点根据MIGRATE命令将键迁移到目标节点， 如果多槽，则分别对不同槽执行多次。 7. 持久化7.1 为什么采用持久化？持久化有两个作用：方便主从复制和灾难恢复。 由于Redis的数据全都放在内存而不是磁盘里面，如果Redis挂了，没有配置持久化的话，重启的时候数据会全部丢失。所以需要将数据写入磁盘，本地化保存。 7.2 持久化的方式有哪些？有RDB持久化和AOF持久化。 RDB持久化： 将数据库状态以RDB文件格式保存。可以采用SAVE命令阻塞服务器进程，也可以用BGSAVE命令fork一个子进程。 通过周期性函数serverCron不断的判断保存条件，如果条件满足就保存。 AOF持久化： AOF(Append Only File)记录Redis服务器所执行的写命令。AOF实现原理是命令追加和文件写入同步， 命令追加：服务器执行完一个命令后，会以协议格式将命令追加到服务器状态aof_buf缓冲区的结尾 文件写入同步：服务器每次结束一个事件循环之前都考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面。 AOF还原时需要建立一个不带网络连接的伪客户端，因为Redis的命令只能在客户端上下文中执行。 7.3 AOF的重写是什么意思？随着时间的增长，AOF文件的大小将会越来越大。通过重写，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件保存的数据库状态完全相同，但新的文件体积更小。 重写的策略是：从数据库中读取键现在的值，然后用一条命令去记录键值对。相当于折叠命令，只求最终结果。 此外，子进程AOF重写时，主进程也在写命令，导致两者状态不一致。因此，Redis服务器设置了一个AOF重写缓冲区，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。 7.4 AOF和RDB优劣势比较RDB 优势：完整，恢复迅速 劣势：消耗资源大，每次保存的间隔周期长，丢失数据多 AOF 优势：保存间隔短，丢失数据少，系统资源消耗少。保存格式清晰，适合误操作的恢复。 劣势：恢复速度较慢，需要建立伪客户端，如果发生崩溃的情况需要尽快恢复，最好采用RDB。重写后数据保存不一定完整，可能有BUG。 8. 事务8.1 什么是事务？Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能。事务将一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求。 8.2 Redis中事务是如何实现的？事务从开始到结束经历三个阶段： 事务开始 事务入队 事务执行 通过MULTI命令可以将执行该命令的客户端从非事务状态切换至事务状态，在是事务状态下， 如果客户端发送EXEC，DISCARD，WATCH，MULTI这四个命令，则立即执行。 如果发送的是其他命令，则放到事务队列里面，向客户端返回QUEUED回复。 每个Redis客户端都有自己的事务状态结构体，每个结构体中又包含了一个事务队列和已入队命令计数器。在事务队列中包含了具体的命令cmd。 当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。过程是： 创建空白回复队列 抽取一条命令，读取参数、参数个数以及要执行的函数 行命令，取得返回值 将返回值追加到1中的队列末尾，重复步骤2 完成后，清除事务标志，回到非事务状态，同时清空计数器和释放事务队列。 8.3 事务中的乐观锁是什么？乐观锁，也称CAS(check and set)，属于无罪推定原则，每次别人拿数据都假定他不修改，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。 悲观锁则是每次读取都会加锁。 Redis中通过WATCH来实现，它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否被其他客户修改过，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。 8.4 WATCH命令的原理是什么？每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端。 对数据库执行修改命令时，会对字典进行检查。查看当前命令修改的键是否在watched_keys字典中，如果有，且事务标志被打开，表示该客户端的事务安全性已经被破坏。将REDIS_DIRTY_CAS标识打开。 在EXEC命令执行时，检查REDIS_DIRTY_CAS标志是否打开判断是否应该执行。 8.5 解释一下事务的ACID性质所谓ACID性质是指：有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、耐久性（Durability）。 原子性：事务在执行前用WATCH检查，命令有没有被插入执行过。 一致性：入队错误：事务入队时命令格式不正确，则Redis拒绝执行；执行错误：执行时操作不正确，会被服务器识别，并做错误处理，所以这些出错命令不会对数据库做任何修改；停机后根据持久化，也能还原为一致状态。 隔离性：单线程，且事务不会被打断，串行的方式保证不同事务的隔离性（不保证键不会冲突） 耐久性：不一定，得看哪种持久化，只有always模式下的AOF才有。（每次执行命令都会调用同步函数）","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"面试经验","slug":"面试经验","permalink":"jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"}]},{"title":"Redis设计与实现12-Lua脚本","slug":"Redis设计与实现12-Lua脚本","date":"2020-01-08T03:27:51.000Z","updated":"2020-01-12T16:35:47.000Z","comments":true,"path":"2020/01/08/Redis设计与实现12-Lua脚本/","link":"","permalink":"jiangren.work/2020/01/08/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B012-Lua%E8%84%9A%E6%9C%AC/","excerpt":"Redis提供了非常丰富的指令集，官网上提供了200多个命令。但是某些特定领域，需要扩充若干指令原子性执行时，仅使用原生命令便无法完成，所以需要Lua脚本进行补充。","text":"Redis提供了非常丰富的指令集，官网上提供了200多个命令。但是某些特定领域，需要扩充若干指令原子性执行时，仅使用原生命令便无法完成，所以需要Lua脚本进行补充。Redis客户端可以使用Lua脚本，直接在服务器端原子地执行多个Redis命令。 比如，使用EVAL命令可以对脚本进行求值 redis&gt; EVAL &quot;return 1+1&quot; 0 (integer) 2 使用Lua的原因主要有： 拓展原生指令集功能。 减少网络开销。多个指令集同时发出，作为整体执行。 原子操作。对事务功能的一个替代，避免竞争。 复用。发送的脚本会以函数形式保存在Redis中，其他客户端也能使用。 1. Lua环境Redis在服务器内嵌了一个Lua环境（environ-ment），并对这个Lua环境进行了一系列修改，从而确保这个Lua环境可以满足Redis服务器的需要。 步骤如下： 创建一个基础的Lua环境 载入多个函数库到Lua环境里面，让Lua脚本可以使用这些函数库来进行数据操作 创建全局表格redis，这个表格包含了对Redis进行操作的函数。 使用Redis自制的随机函数来替换Lua原有的带有副作用的随机函数，从而避免在脚本中引入副作用。 创建排序辅助函数，Lua环境使用这个辅佐函数来对一部分Redis命令的结果进行排序，从而消除这些命令的不确定性。 创建redis.pcall函数的错误报告辅助函数，这个函数可以提供更详细的出错信息。 对Lua环境中的全局环境进行保护，防止用户在执行Lua脚本的过程中，将额外的全局变量添加到Lua环境中。 将完成修改的Lua环境保存到服务器状态的lua属性中，等待执行服务器传来的Lua脚本。 （1）创建Lua环境 在最开始的这一步，服务器首先调用Lua的C API函数lua_open，创建一个新的Lua环境。因为lua_open函数创建的只是一个基本的Lua环境，为了让这个Lua环境可以满足Redis的操作要求，接下来服务器将对这个Lua环境进行一系列修改。 （2）载入函数库 Redis修改Lua环境的第一步，就是将以下函数库载入到Lua环境里面： 基础库：包含了Lua核心函数 表格库：用于处理表格的通用函数 字符串库 数学库：标准C语言数学库的接口 调试库：钩子函数和取得钩子函数，还包括元数据相关函数 Lua CJSON库：用于处理UTF-8编码的JSON格式 Lua cmsgpack库：用于处理MessagePack格式的数据 （3）创建redis表格 服务器将在Lua环境中创建一个redis表格（table），并将它设为全局变量。这个redis表格包含以下函数： 用于执行Redis命令的redis.call和redis.pcall函数。 用于记录Redis日志（log）的redis.log函数 用于计算SHA1校验和的redis.sha1hex函数。 用于返回错误信息的redis.error_reply函数和redis.status_reply函数。 （4）自制随机函数替代Lua原有的随机函数 为了保证相同的脚本可以在不同的机器上产生相同的结果，Redis要求所有传入服务器的Lua脚本，以及Lua环境中的所有函数，都必须是无副作用（side effect）的纯函数（pure func-tion）。 副作用是指：函数使用时除了返回值以外还破坏了系统环境，比如全局变量。 Redis使用自制的函数替换了math库中原有的math.random函数和math.randomseed函数，替换之后的两个函数有以下特征： 对于相同的seed来说，math.random总产生相同的随机数序列 除非在脚本中使用math.randomseed显式地修改seed，否则每次运行脚本时，Lua环境都使用固定的math.random-seed（0）语句来初始化seed。 （5）创建排序辅助函数 另一个可能产生不一致数据的地方是那些带有不确定性质的命令。比如对于一个集合键来说，因为集合元素的排列是无序的，所以即使两个集合的元素完全相同，它们的输出结果也可能并不相同。 为了消除这些命令带来的不确定性，服务器会为Lua环境创建一个排序辅助函数__redis__compare_helper，当Lua脚本执行完一个带有不确定性的命令之后，程序会使用__redis__compare_helper作为对比函数自动调用table.sort函数对命令的返回值做一次排序，以此来保证相同的数据集总是产生相同的输出。 如果我们在Lua脚本中对fruit集合和anotherfruit集合执行SMEMBERS命令，那么两个脚本将得出相同的结果： redis&gt; EVAL &quot;return redis.call(&#39;SMEMBERS&#39;, KEYS[1])&quot; 1 anotherfruit 1) &quot;apple&quot; 2) &quot;banana&quot; 3) &quot;cherry&quot; redis&gt; EVAL &quot;return redis.call(&#39;SMEMBERS&#39;, KEYS[1])&quot; 1 fruit 1) &quot;apple&quot; 2) &quot;banana&quot; 3) &quot;cherry&quot; （6）创建redis.pcall函数的错误报告辅助函数 服务器将为Lua环境创建一个名为__redis__err__handler的错误处理函数，当脚本调用redis.pcall函数执行Redis命令，并且被执行的命令出现错误时，__re-dis__err__handler就会打印出错代码的来源和发生错误的行数，为程序的调试提供方便。 （7）保护Lua的全局环境 确保传入服务器的脚本不会因为忘记使用local关键字而将额外的全局变量添加到Lua环境里面。 如果误操作，程序会报错： redis&gt; EVAL &quot;x = 10&quot; 0 (error) ERR Error running script (call to f_df1ad3745c2d2f078f0f41377a92bb6f8ac79af0): @enable_strict_lua:7: user_script:1: Script attempted to create global variable &#39;x&#39; 试图获取一个不存在的全局变量也会引发一个错误 不过Redis并未禁止用户修改已存在的全局变量，所以在执行Lua脚本的时候，必须非常小心，以免错误地修改了已存在的全局变量。 redis&gt; EVAL &quot;redis = 10086; return redis&quot; 0 (integer) 10086 （8）将Lua环境保存到服务器状态的lua属性里面 最后的这一步，服务器会将Lua环境和服务器状态的lua属性关联起来 2. Lua环境协作组件2.1 伪客户端伪客户端负责处理Lua脚本中包含的所有Redis命令。Lua脚本使用redis.call函数或者redis.pcall函数执行一个Redis命令，需要完成以下步骤： redis.call函数或者redis.pcall函数想要执行的命令传给伪客户端。 伪客户端将命令传递给命令执行器 命令执行器执行，将结果返回给伪客户端 伪客户端接受结果，返回给Lua环境 Lua环境在接收到命令结果之后，将该结果返回给redis.call函数或者redis.pcall函数。 接收到结果的redis.call函数或者redis.pcall函数会将命令结果作为函数返回值返回给脚本中的调用者。 2.2 lua_script字典这个字典的键为某个Lua脚本的SHA1校验和（checksum），而字典的值则是SHA1校验和对应的Lua脚本： struct redisServer { // ... dict *lua_scripts; // ... }; Redis服务器会将所有被EVAL命令执行过的Lua脚本，以及所有被SCRIPT LOAD命令载入过的Lua脚本都保存到lua_scripts字典里面。 如果客户端给服务器发送以下命令： redis&gt; SCRIPT LOAD &quot;return &#39;hi&#39;&quot; &quot;2f31ba2bb6d6a0f42cc159d2e2dad55440778de3&quot; redis&gt; SCRIPT LOAD &quot;return 1+1&quot; &quot;a27e7e8a43702b7046d4f6a7ccf5b60cef6b9bd9&quot; redis&gt; SCRIPT LOAD &quot;return 2*2&quot; &quot;4475bfb5919b5ad16424cb50f74d4724ae833e72&quot; 3. Lua相关命令的实现3.1 EVAL命令EVAL命令有三个参数： Lua脚本 脚本中使用键的个数 键参数和脚本参数 比如，下面的例子中，2表示有两个键，名字为Key1和key2，first和second为脚本参数。 -&gt; EVAL &quot;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&quot; 2 key1 key2 first second 1) &quot;key1&quot; 2) &quot;key2&quot; 3) &quot;first&quot; 4) &quot;second&quot; 下面的例子中，比较了两种不同的用法： -&gt; EVAL &quot;return redis.call(&#39;set&#39;,&#39;foo&#39;,&#39;bar&#39;)&quot; 0 OK -&gt; EVAL &quot;return redis.call(&#39;set&#39;,KEYS[1],&#39;bar&#39;)&quot; 1 foo OK EVAL命令实现的过程分三步： 根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数。 将客户端给定的脚本保存到lua_scripts字典 执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本 （1）定义脚本函数 服务器首先要做的就是在Lua环境中，为传入的脚本定义一个与这个脚本相对应的Lua函数。Lua函数的名字为&quot;_f&quot;+SHA1校验和，而函数的体（body）则是脚本本身。 function f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91() return &#39;hello world&#39; end 使用函数来保存客户端传入的脚本可以让Lua环境保持清洁：减少了垃圾回收的工作量，并且避免了使用全局变量。 （2）脚本保存到lua_scripts字典 首先服务器向lua_stripts字典中添加一个键值对，键为Lua脚本的SHA1校验和，值为Lua脚本本身（一个字符串） （3）执行脚本函数 执行过程如下： 将EVAL命令中传入的键名（key name）参数和脚本参数分别保存到KEYS数组和ARGV数组，然后将这两个数组作为全局变量传入到Lua环境里面。 为Lua环境装载超时处理钩子（hook），这个钩子可以在脚本出现超时运行情况时，让客户端通过SCRIPT KILL命令停止脚本，或者通过SHUTDOWN命令直接关闭服务器。 执行脚本函数 卸载钩子 结果保存到客户端状态的输出缓冲区里面，等待服务器将结果返回给客户端。 对Lua环境执行垃圾回收操作。 3.2 EVALSHA命令的实现只要脚本对应的函数曾经在Lua环境里面定义过，那么即使不知道脚本的内容本身，客户端也可以根据脚本的SHA1校验和来调用脚本对应的函数，从而达到执行脚本的目的，这就是EVALSHA命令的实现原理。 举个例子，当服务器执行完以下EVAL命令之后： redis&gt; EVAL &quot;return &#39;hello world&#39;&quot; 0 &quot;hello world&quot; 当客户端执行以下EVALSHA命令时： redis&gt; EVALSHA &quot;5332031c6b470dc5a0dd9b4bf2030dea6d65de91&quot; 0 &quot;hello world&quot; 3.3 脚本管理命令的实现除了EVAL命令和EVALSHA命令之外，Redis中与Lua脚本有关的命令还有四个，它们分别是SCRIPT FLUSH命令、SCRIPT EXISTS命令、SCRIPT LOAD命令、以及SCRIPT KILL命令。 （1）SCRIPT FLUSH 释放并重建lua_scripts字典，关闭现有的Lua环境并重新创建一个新的Lua环境。 （2）SCRIPT EXISTS 检查校验和对应的脚本是否存在于服务器中 （3）SCRIPT LOAD Load和EVAL比较相似，区别在于Load装载后并不执行。 redis&gt; SCRIPT LOAD &quot;return &#39;hi&#39;&quot; &quot;2f31ba2bb6d6a0f42cc159d2e2dad55440778de3&quot; 执行后，服务器创建此函数，于是我们可以： redis&gt; EVALSHA &quot;2f31ba2bb6d6a0f42cc159d2e2dad55440778de3&quot; 0 &quot;hi&quot; （4）SCRIPT KILL 如果服务器设置了lua-time-limit配置选项，那么在每次执行Lua脚本之前，服务器都会在Lua环境里面设置一个超时处理钩子（hook）。 一旦钩子发现脚本的运行时间已经超过了lua-time-limit选项设置的时长，钩子将定期在脚本运行的间隙中，查看是否有SCRIPT KILL命令或者SHUTDOWN命令到达服务器。达到类似于中断的效果。","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"}]},{"title":"Redis设计与实现11-事务","slug":"Redis设计与实现11-事务","date":"2020-01-07T05:54:21.000Z","updated":"2020-01-15T13:01:49.000Z","comments":true,"path":"2020/01/07/Redis设计与实现11-事务/","link":"","permalink":"jiangren.work/2020/01/07/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B011-%E4%BA%8B%E5%8A%A1/","excerpt":"Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能。事务将一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求。","text":"Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能。事务将一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求。 redis-&gt;MULTI OK redis-&gt;SET &quot;name&quot; &quot;hellp&quot; QUEUED redis-&gt;GET &quot;name&quot; QUEUED redis-&gt;EXEC 1)OK 2)&quot;hellp&quot; 1. 事务的实现一个事务从开始到结束会经历三个阶段： 事务开始 命令入队 事务执行 （1）事务开始 通过MULTI命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的flags属性中打开REDIS_MULTI标识来完成的。 当一个客户端已经处于非事务状态时，这个客户端发送的命令会被服务器执行。然而当切换到事务状态后，服务器会根据这个客户端发来的不同命令执行不同的操作： 如果客户端发送EXEC，DISCARD，WATCH，MULTI这四个命令，则立即执行。 如果发送的是其他命令，则放到事务队列里面，向客户端返回QUEUED回复。 （2）命令入队 事务的关键实现在于命令入队，每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性里面： typedef struct redisClient { //... multiState mstate; //... } 而事务状态结构体又包含了一个事务队列，以及一个已入队命令的计数器。 typedef struct multiState { // 事务队列，FIFO顺序 multiCmd *commands; // 已入队命令计数 int count; } multiState; 事务队列是一个结构体，实现了队列数据结构，执行FIFO先进先出的策略。真实结构是一个数组。 typedef struct multiCmd { // 参数 robj **argv; // 参数数量 int argc; // 命令指针 struct redisCommand *cmd; } multiCmd; 事务结构具体的包含逻辑是：客户端-&gt;事务状态multiState-&gt;事务队列multiCmd-&gt;具体命令cmd （3）执行事务 当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。 创建空白回复队列 抽取一条命令，读取参数、参数个数以及要执行的函数 执行命令，取得返回值 将返回值追加到1中的队列末尾，重复步骤2 完成所有命令后，将清除REDIS_MULTI标志，让客户端变为非事务状态，同时清零入队命令计数器，并释放事务队列。 2. WATCH命令的实现WATCH可以别翻译为监视器。WATCH命令是一个乐观锁（optimistic locking）。 悲观锁：有罪推定原则，每次有人操作数据时都会假定他要修改，每次都会上互斥锁。 乐观锁：无罪推定原则，每次别人拿数据都假定他不修改，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。 它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。 redis-&gt; WATCH &quot;name&quot; OK redis-&gt; MULTI OK redis-&gt; SET &quot;name&quot; &quot;peter&quot; QUEUED redis-&gt; EXEC (nil) 上面的例子中，WATCH监视器发现了其他客户端事务修改了name的值，因此拒绝执行该事务，返回空回复。 比如我们可以通过WATCH来解决自增冲突的问题： WATCH mykey val = GET mykey val = val + 1 MULTI SET mykey $val EXEC 2.1 监视原理每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端： typedef struct redisDb { // ... // 正在被WATCH命令监视的键 dict *watched_keys; // ... } redisDb; 下图说明：c1和c2客户端正在监视键”name”，c3客户端正在监视”age”…. 2.2 监视触发对数据库执行修改命令时，比如SET、LPUSH、SADD、ZREM、DEL、FLUSHDB等等，在执行之后都会调用multi.c/touchWatchKey函数对watched_keys字典进行检查。查看当前命令修改的键是否在watched_keys字典中，如果有，则客户端的REDIS_DIRTY_CAS标识打开，表示该客户端的事务安全性已经被破坏。 2.3 判断事务是否安全当服务器接收到一个客户端发来的EXEC命令时，服务器会根据这个客户端是否打开了REDIS_DIRTY_CAS标识来决定是否执行事务。 如果标志被打开，则说明哨兵监视的键中被修改过了，所以当前提交的事务不再安全，拒绝执行客户端提交的事务。 反之，是安全的，继续执行。 3. 事务的ACID性质所谓ACID性质是指：有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、耐久性（Durability）。 （1）原子性 所谓原子性就是某个操作不可再分，比如汇编语言里面的MOV DST,SRC。事务的定义就是：将多个命令打包成一个实现，要么全部执行，要么都不执行。在命令入队的时候，用WATCH进行检查，不符合要求就直接返回。 Redis的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制（rollback）。作者认为Redis追求简单高效，回滚机制太复杂。 回滚(rollback)是指当事务中某一条命令执行出错时，意味着前面的命令可能也不安全，这时候就会释放掉前面的操作，恢复到执行事务之前的状态。MySQL数据库支持回滚操作。 （2）一致性 “一致”指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。Redis保证一致性的方法如下： 入队错误：事务入队时命令格式不正确，则Redis拒绝执行 执行错误：执行时操作不正确，会被服务器识别，并做错误处理，所以这些出错命令不会对数据库做任何修改 服务器停机：停机分三种情况， 无持久化：重启后清空，数据总是一致的 RDB模式：根据RDB恢复数据，还原为一致状态 AOF模式：根据AOF恢复数据，还原为一致状态 （3）隔离性 隔离性也可被理解为不存在竞争。即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响。 因为Redis使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断。这种串行的方式保证了事务也总是具有隔离性的。 （4）耐久性 事务的耐久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质（比如硬盘）里面了，即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。 Redis事务只是简答包裹了一组Redis命令，耐久性由持久化实现。前面提到持久化分不同的情况 RDB模式下，只有特定条件被满足时才会执行BGSAVE，不具有耐久性。 AOF模式根据appendfsync选项来决定 always，每次执行命令后都会调用同步函数，具有耐久性。 everysec，每一秒才会同步到硬盘，不具有耐久性。 no，程序会交由操作系统来决定何时将命令数据同步到硬盘。不具有耐久性。 总的来说，Redis事务一定具有原子性，一致性和隔离性，但只有在特定条件下才具有耐久性。","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"}]},{"title":"Redis设计与实现10-发布与订阅","slug":"Redis设计与实现10-发布与订阅","date":"2020-01-07T04:46:10.000Z","updated":"2020-01-07T13:53:58.000Z","comments":true,"path":"2020/01/07/Redis设计与实现10-发布与订阅/","link":"","permalink":"jiangren.work/2020/01/07/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B010-%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/","excerpt":"Redis的发布与订阅功能由PUBLISH、SUBSCRIBE、PSUB-SCRIBE等命令组成。本章主要介绍这些命令的实现原理。","text":"Redis的发布与订阅功能由PUBLISH、SUBSCRIBE、PSUB-SCRIBE等命令组成。本章主要介绍这些命令的实现原理。 通过执行SUBSCRIBE命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者（subscriber）：每当有其他客户端向被订阅的频道发送消息（message）时，频道的所有订阅者都会收到这条消息。 假如ABC三个客户端都执行了： SUBSCRIBE &quot;news.it&quot; 那么这三个客户端都成了”news.it”频道的订阅者， 向”news.it”频道发送消息”hello”，那么”news.it”的三个订阅者都将收到这条消息。 除了订阅频道之外，客户端还可以通过执行PSUBSCRIBE命令订阅一个或多个模式，从而成为这些模式的订阅者：每当有其他客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，它还会被发送给所有与这个频道相匹配的模式的订阅者。 1. 订阅与退订1.1 频道的订阅与退订Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端。 看下图，不同客户端订阅了不同频道： 订阅的原理是：服务器将客户端与被订阅频道在pubsub_channels字典中进行关联。 假如客户端10086执行命令： SUBSCRIBE &quot;news.sport&quot; &quot;news.movie&quot; 服务器完成两件事： 将10086添加到sport链表后面 新增一个键”news.movie” 退订就是在链表中删除客户端信息，如果退订后某个键没有任何客户端，则程序将从pubsub_channels字典中删除频道对应的键。 1.2 模式的订阅与退订类似地，服务器也将所有模式的订阅关系都保存在服务器状态的pubsub_patterns属性。 与频道不同的是，这是一个链表，链表中的每个节点都包含着一个pubsubPattern结构，这个结构的pattern属性记录了被订阅的模式，而client属性则记录了订阅模式的客户端： typedef struct pubsub_Pattern { // 订阅模式的客户端 redisClient *client; // 被订阅的模式 robj *pattern; } pubsubPattern; 下面举一个例子： 客户端7正在订阅模式”music.*” 客户端8正在订阅模式”book.*” 客户端9正在订阅模式”news.*” 订阅模式时，服务器会对每个被订阅的模式执行以下两个操作： 新建一个pubsubPattern结构，将结构的pattern属性设置为被订阅的模式，client属性设置为订阅模式的客户端。 将pubsubPattern结构添加到pubsub_patterns链表的表尾。 退订时，在pubsub_patterns链表中查找并删除。 2. 发布消息发布消息有两个动作： 将消息发送给所有channel的订阅者。 如果有一个或多个模式与频道channel匹配，则同时将消息发送给模式的订阅者。 对于频道订阅者，首先服务器要在pubsub_channels中找到相对应的channel(一个链表)，然后顺着这个链表，将消息发送给所有客户端。 对于模式订阅者，服务器会在pubsub_patterns链表中找到与channel频道相匹配的模式，然后将消息发送给订阅了这些模式的所有客户端。 3. 查看订阅消息PUBSUB命令是Redis 2.8新增加的命令之一，客户端可以通过这个命令来查看频道或者模式的相关信息，比如某个频道目前有多少订阅者，又或者某个模式目前有多少订阅者。本节介绍这个命令的实现方法。 3.1 PUBSUB CHANNELSPUBSUB CHANNELS[pattern]子命令用于返回服务器当前被订阅的频道，其中pattern参数是可选的： 不给定，则返回所有被订阅的所有频道。 给定，与pattern模式相匹配的频道。 比如： redis&gt; PUBSUB CHANNELS 1) &quot;news.it&quot; 2) &quot;news.sport&quot; 3) &quot;news.business&quot; 4) &quot;news.movie&quot; redis&gt; PUBSUB CHANNELS &quot;news.[is]*&quot; 1) &quot;news.it&quot; 2) &quot;news.sport&quot; 3.2 PUBSUB NUMSUBPUBSUB NUMSUB[channel-1 channel-2...channel-n]子命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量。 这个子命令是通过在pubsub_channels字典中找到频道对应的订阅者链表，然后返回订阅者链表的长度。 3.3 PUBSUB NUMPATPUBSUB NUMPAT子命令用于返回服务器当前被订阅模式的数量。 通过返回pubsub_patterns链表的长度来实现的。注意一下频道数量的查找逻辑是：频道字典-&gt;频道订阅者链表-&gt;数量；而模式数量的查找逻辑是：模式链表-&gt;数量。","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"}]},{"title":"Redis设计与实现9-集群","slug":"Redis设计与实现9-集群","date":"2020-01-06T10:17:06.000Z","updated":"2020-01-12T16:19:09.000Z","comments":true,"path":"2020/01/06/Redis设计与实现9-集群/","link":"","permalink":"jiangren.work/2020/01/06/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B09-%E9%9B%86%E7%BE%A4/","excerpt":"Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。","text":"Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。 1. 节点1.1 节点是什么节点时Redis中数据存储的单位。一个Redis集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。 使用CLUSTER MEET命令来完成，该命令的格式如下： CLUSTER MEET &lt;ip&gt; &lt;port&gt; 当前节点发送CLUSTER MEET命令，可以与ip和port所指定的节点进行握手（handshake），当握手成功时，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中。 1.2 启动节点一个节点就是一个运行在集群模式下的Redis服务器，Redis服务器在启动时会根据cluster-enabled配置选项是否为yes来决定是否开启服务器的集群模式: 1.3 集群数据结构clusterNode结构保存了一个节点的当前状态，比如节点的创建时间、节点的名字、节点当前的配置纪元、节点的IP地址和端口号等等。每个节点都会使用一个clusterNode结构来记录自己的状态，并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的clusterNode结构，以此来记录其他节点的状态： struct clusterNode { // 创建节点的时间 mstime_t ctime; // 节点的名字，由 40 个十六进制字符组成 // 例如 68eef66df23420a5862208ef5b1a7005b806f2ff char name[REDIS_CLUSTER_NAMELEN]; // 节点标识 // 使用各种不同的标识值记录节点的角色（比如主节点或者从节点）， // 以及节点目前所处的状态（比如在线或者下线）。 int flags; // 节点当前的配置纪元，用于实现故障转移 uint64_t configEpoch; // 节点的 IP 地址 char ip[REDIS_IP_STR_LEN]; // 节点的端口号 int port; // 保存连接节点所需的有关信息 clusterLink *link; // ... }; clusterNode 结构的 link 属性是一个 clusterLink 结构， 该结构保存了连接节点所需的有关信息， 比如套接字描述符， 输入缓冲区和输出缓冲区： typedef struct clusterLink { // 连接的创建时间 mstime_t ctime; // TCP 套接字描述符 int fd; // 输出缓冲区，保存着等待发送给其他节点的消息（message）。 sds sndbuf; // 输入缓冲区，保存着从其他节点接收到的消息。 sds rcvbuf; // 与这个连接相关联的节点，如果没有的话就为 NULL struct clusterNode *node; } clusterLink; 假设现在有三个独立的节点127.0.0.1:7000、127.0.0.1:7001、127.0.0.1:7002，将他们创立为集群后，数据结构如下： 总的来说： clusterState保存集群状态，每个节点都保存着一个这样的状态，记录了它们眼中的集群的样子。 clusterNode保存了某个节点的状态，同时通过指针指向其他节点，达到关联的目的 clusterLink保存了和其他节点通信的信息。 1.4 实现CLUSTER MEET命令向A发送命令，希望A和B形成集群，则： 节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。 根据命令给定的IP和端口，节点A向B发送一条MEET消息 B收到以后，为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。 B向A返回一条PONG消息 A收到PONG后向B返回一条PING B收到PING后，握手完成。 2. 槽指派Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。 当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。 换句话说，只有完全分配了16384个槽才会进入上线状态。 2.1 当前节点的槽指派信息clusterNode结构的slots属性和numslot属性记录了节点负责处理哪些槽： struct clusterNode { // ... unsigned char slots[16384/8]; int numslots; // ... }; slots属性是一个二进制位数组（bit array），这个数组的长度为16384/8=2048个字节，共包含16384个二进制位。通过判断二进制的01状态来判断，此槽是否属于。 下图表示这个节点负责处理槽0至7， 因为数组自带索引，所以取出某个槽是否使用的时间复杂的为$O(1)$。 2.2 传播节点的槽指派信息一个节点除了会将自己负责处理的槽记录在clusterNode结构的slots属性和numslots属性之外，它还会将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽。 当节点A通过消息从节点B那里接收到节点B的slots数组时，节点A会在自己的clusterState.nodes字典中查找节点B对应的clusterNode结构，并对结构中的slots数组进行保存或者更新。 因此，集群中的每个节点都会知道数据库中的16384个槽分别被指派给了集群中的哪些节点。 在clusterState中有一个myself指针，指向当前节点clusterNode，这个结构中包含了一个二进制数组，记录当前节点的槽指派情况。而clusterState中还有一个clusterNode *slots[REDIS_CLUSTER_SLOTS];，记录了其他节点的槽指派情况。例如 slots[i] = clusterNode_A 表示槽 i 由节点 A 处理 2.3 集群所有槽的指派信息clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息： typedef struct clusterState { // ... clusterNode *slots[16384]; // ... } clusterState; 每个数组都是指向clusterNode结构的指针： 如果指向NULL，表示尚未指派给任何节点。 如果指向某一个clusterNode，则表示槽i指派给了某一个节点。 如果只将槽指派信息保存在各个节点的clusterNode.slots数组里，会出现一些无法高效地解决的问题，而clusterState.slots数组的存在解决了这些问题： 如果想知道某个槽是否被指派以及被指派给了谁，需要遍历所有clusterNode结构。 通过clusterState保存的数组，可以以$O(1)$的时间取得结果。 2.4 槽的保存方式节点还会用clusterState结构中的slots_to_keys跳跃表来保存槽和键之间的关系: typedef struct clusterState { // ... zskiplist *slots_to_keys; // ... } clusterState; slots_to_keys跳跃表每个节点的分值（score）都是一个槽号，而每个节点的成员（member）都是一个数据库键： 3. MOVED错误前面提到，指派完槽以后，集群会进入上线状态，此时客户端可以向集群中的节点发送数据命令。 当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己： 如果指派给自己，执行 否则，返回MOVED错误，并将客户端指向正确的节点。 比如，date键所在的槽正好是节点7000负责，正常执行。 127.0.0.1:7000&gt; SET date &quot;2013-12-31&quot; OK 如果是如下的情况，客户端会被自动转到正确的节点。 127.0.0.1:7000&gt; SET msg &quot;happy new year!&quot; -&gt; Redirected to slot [6257] located at 127.0.0.1:7001 OK 127.0.0.1:7001&gt; GET msg &quot;happy new year!&quot; 要完成上面的操作，需要至少两步： 判断槽是否自己负责 MOVED错误的实现方法 3.1 判断槽是否自己负责键属于哪个槽需要用到CRC-16校验的办法： slot_number = CRC16(key)&amp;16383 这样就可以计算出一个介于0至16383之间的整数作为键key的槽号。 当节点计算出键所属的槽i之后，节点就会检查自己在clusterState.slots数组中的项i，判断键所在的槽是否由自己负责： 如果clusterState.slots[i]等于clusterState.myself，那么说明槽i由当前节点负责，节点可以执行客户端发送的命令。 反之，则记下指向clusterNode结构所记录的IP和端口号 3.2 MOVED错误实现MOVED错误的格式为： MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt; 其中slot为键所在的槽，而ip和port则是负责处理槽slot的节点的IP地址和端口号。 当客户端接收到节点返回的MOVED错误时，客户端会根据MOVED错误中提供的IP地址和端口号，转向至负责处理槽slot的节点，并向该节点重新发送之前想要执行的命令。 127.0.0.1:7000&gt; SET msg &quot;happy new year!&quot; -&gt; Redirected to slot [6257] located at 127.0.0.1:7001 OK 4. 重新分片Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。 重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。 Redis集群的重新分片操作是由Redis的集群管理软件redis-trib负责执行的，Redis提供了进行重新分片所需的所有命令，而redis-trib则通过向源节点和目标节点发送命令来进行重新分片操作。 重新分配步骤如下： 如果重新分片涉及多个槽，那么redis-trib将对每个给定的槽分别执行上面给出的步骤。 5. ASK错误正在重新分片时，属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面。 当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时： 槽在自己这里，执行客户端命令。 槽不在，返回ASK错误，指引客户端转向正在导入槽的目标节点。 下面讲解ASK错误的实现原理： 5.1 关键命令（1）CLUSTER SETSLOT IMPORTING命令的实现 clusterState结构的importing_slots_from数组记录了当前节点正在从其他节点导入的槽： typedef struct clusterState { // ... clusterNode *importing_slots_from[16384]; // ... } clusterState; 如果importing_slots_from[i]的值不为NULL，而是指向一个clusterNode结构，那么表示当前节点正在从clusterNode所代表的节点导入槽i。 在对集群进行重新分片的时候，向目标节点发送命令： CLUSTER SETSLOT &lt;i&gt; IMPORTING &lt;source_id&gt; 假如，客户端向节点7003发送命令： # 9dfb... 是节点7002 的ID 127.0.0.1:7003&gt; CLUSTER SETSLOT 16198 IMPORTING 9dfb4c4e016e627d9769e4c9bb0d4fa208e65c26OK （2）CLUSTER SETSLOT MIGRATING命令的实现 clusterState结构的migrating_slots_to数组记录了当前节点正在迁移至其他节点的槽： typedef struct clusterState { // ... clusterNode *migrating_slots_to[16384]; // ... } clusterState; 同理，如果索引i不为NULL，则表示当前节点正在将槽i迁移至目标节点。 在对集群进行重新分片的时候，向源节点发送命令： CLUSTER SETSLOT &lt;i&gt; MIGRATING &lt;target_id&gt; 可以将源节点clusterState.migrating_slots_to[i]的值设置为target_id所代表节点的clusterNode结构。 5.2 ASKING命令通过migrating_slots_to这个数组，我们知道当前节点的某个键是否正在迁移。如果是则返回ASK错误。 ASK 16198 127.0.0.1:7003 接到ASK错误的客户端会根据错误提供的IP地址和端口号，转向至正在导入槽的目标节点，然后首先向目标节点发送一个ASKING命令，之后再重新发送原本想要执行的命令。 ASKING命令的目的就是打开REDIS_ASKING标识，而且是一次性的打开，意味着使用完后会被关闭。 ASK错误和MOVED错误的区别： 相同点：都会导致客户端转向 不同点： MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点：在客户端收到关于槽i的MOVED错误之后，客户端每次遇到关于槽i的命令请求时，都可以直接将命令请求发送至MOVED错误所指向的节点。 ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施：在客户端收到关于槽i的ASK错误之后，客户端只会在接下来的一次命令请求中将关于槽i的命令请求发送至ASK错误所指示的节点，但这种转向不会对客户端今后发送关于槽i的命令请求产生任何影响，客户端仍然会将关于槽i的命令请求发送至目前负责处理槽i的节点，除非ASK错误再次出现。 6. 节点的复制与故障转移和主从服务器的关系非常相似，不过在集群模式下服务器被替换为节点。Redis集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。 6.1 设置从节点向一个节点发送命令： CLUSTER REPLICATE &lt;node_id&gt; 可以让接收命令的节点成为node_id所指定节点的从节点，并开始对主节点进行复制，步骤如下： （1）修改指针指向 接收到该命令的节点首先会在自己的clusterState.nodes字典中找到node_id所对应节点的clusterNode结构，并将自己的clusterState.myself.slaveof指针指向这个结构，以此来记录这个节点正在复制的主节点： struct clusterNode { // ... // 如果这是一个从节点，那么指向主节点 struct clusterNode *slaveof; }; （2）修改标识 然后节点会修改自己在clusterState.myself.flags中的属性，关闭原本的REDIS_NODE_MASTER标识，打开REDIS_NODE_SLAVE标识。 （3）调用复制代码 根据clusterState.my-self.slaveof指向的clusterNode结构所保存的IP地址和端口号，对主节点进行复制。因为节点的复制功能和单机Redis服务器的复制功能使用了相同的代码，所以让从节点复制主节点相当于向从节点发送命令SLAVEOF。 一个节点成为从节点，并开始复制某个主节点这一信息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点。 集群中的所有节点都会在代表主节点的clusterNode结构的slaves属性和numslaves属性中记录正在复制这个主节点的从节点名单： struct clusterNode { // ... // 正在复制这个主节点的从节点数量 int numslaves; // 一个数组 // 每个数组项指向一个正在复制这个主节点的从节点的clusterNode结构 struct clusterNode **slaves; //.... } 6.2 故障检测集群中的每个节点都会定期地向集群中的其他节点发送PING消息，如果接收PING消息的节点没有在规定的时间内返回PONG，那么发送PING消息的节点就会将接收PING消息的节点标记为疑似下线（probable fail，PFAIL） 集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息，例如某个节点是处于在线状态、疑似下线状态（PFAIL），还是已下线状态（FAIL）。 当一个主节点A通过消息得知主节点B认为主节点C进入了疑似下线状态时，主节点A会在自己的clusterState.nodes字典中找到主节点C所对应的clusterNode结构，并将主节点B的下线报告（failure report）添加到clusterNode结构的fail_reports链表里面： struct clusterNode { // ... // 一个链表，记录了所有其他节点对该节点的下线报告 list *fail_reports; // ... }; 如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线（FAIL），将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。 6.3 故障转移当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤： 从已下线主节点中选出一个从节点 从节点执行SLAVEOF no one命令，成为新的主节点 新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。 新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点。 新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。 7. 消息集群中的各个节点通过发送和接收消息（message）来进行通信，节点发送的消息主要有以下五种： MEET消息：当发送者接到客户端发送的CLUSTER MEET命令时，发送者会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群里面。 PING消息：集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对这五个节点中最长时间没有发送过PING消息的节点发送PING消息，以此来检测被选中的节点是否在线。 PONG消息：当接收者收到发送者发来的MEET消息或者PING消息时，为了向发送者确认这条MEET消息或者PING消息已到达，接收者会向发送者返回一条PONG消息。另外，一个节点也可以通过向集群广播自己的PONG消息来让集群中的其他节点立即刷新关于这个节点的认识。 FAIL消息：当一个主节点A判断另一个主节点B已经进入FAIL状态时，节点A会向集群广播一条关于节点B的FAIL消息，所有收到这条消息的节点都会立即将节点B标记为已下线。 PUBLISH消息：当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。 7.1 消息的结构一条消息由消息头（header）和消息正文（data）组成 每个消息头都由一个cluster.h/clusterMsg结构表示： // 用来表示集群消息的结构（消息头，header） typedef struct { //... // 消息的长度（包括这个消息头的长度和消息正文的长度） uint32_t totlen; // 消息的类型 uint16_t type; // 消息正文包含的节点信息数量 // 只在发送 MEET 、 PING 和 PONG 这三种 Gossip 协议消息时使用 uint16_t count; // 消息发送者的配置纪元 uint64_t currentEpoch; // 如果消息发送者是一个主节点，那么这里记录的是消息发送者的配置纪元 // 如果消息发送者是一个从节点，那么这里记录的是消息发送者正在复制的主节点的配置纪元 uint64_t configEpoch; // 节点的复制偏移量 uint64_t offset; // 消息发送者的名字（ID） char sender[REDIS_CLUSTER_NAMELEN]; / // 消息发送者目前的槽指派信息 unsigned char myslots[REDIS_CLUSTER_SLOTS/8]; // 如果消息发送者是一个从节点，那么这里记录的是消息发送者正在复制的主节点的名字 // 如果消息发送者是一个主节点，那么这里记录的是 REDIS_NODE_NULL_NAME // （一个 40 字节长，值全为 0 的字节数组） char slaveof[REDIS_CLUSTER_NAMELEN]; // 消息发送者的端口号 uint16_t port; /* Sender TCP base port */ // 消息发送者的标识值 uint16_t flags; /* Sender node flags */ // 消息发送者所处集群的状态 unsigned char state; /* Cluster state from the POV of the sender */ // 消息标志 unsigned char mflags[3]; // 消息的正文（或者说，内容） union clusterMsgData data; } clusterMsg; datas属性指向联合cluster.h/clusterMsgData，也就是消息的正文 nion clusterMsgData { /* PING, MEET and PONG */ struct { // 每条消息都包含两个 clusterMsgDataGossip 结构 clusterMsgDataGossip gossip[1]; //gossip八卦，小道消息，闲话的意思 } ping; /* FAIL */ struct { clusterMsgDataFail about; } fail; /* PUBLISH */ struct { clusterMsgDataPublish msg; } publish; //... }; 7.2 消息的实现（1）Gossip消息的实现 gossip是八卦，小道消息，闲话的意思，专指MEET、PING、PONG这几个消息。这三种消息的正文都由两个cluster.h/clusterMsgDataGossip结构组成。 因为MEET、PING、PONG三种消息都使用相同的消息正文，所以节点通过消息头的type属性来判断一条消息是MEET消息、PING消息还是PONG消息。 每次发送MEET、PING、PONG消息时，发送者都从自己的已知节点列表中随机选出两个节点（可以是主节点或者从节点），并将这两个被选中节点的信息分别保存到两个clusterMsg-DataGossip结构里面。 接受者接收到MEET、PING、PONG消息时，根据保存的两个节点是否认识来选择进行哪种操作： 不认识，说明接收者第一次接触被选中节点，则接收者与被选中节点握手 认识，根据结构信息进行更新。 比如A节点发送的PING给B，携带了CD两个节点，然后B回复PONG携带了EF两个节点，这样就完成了ABCDEF六个节点的信息交换。每个节点按照周期向不同节点传播PING-PONG信息，就能完成整个集群的状态更新。 （2）FAIL消息的实现 Gossip协议传播速度很慢，而主节点下线的消息需要立即通知给所有人。 FAIL消息的正文由cluster.h/clusterMsgDataFail结构表示，这个结构只包含一个nodename属性，该属性记录了已下线节点的名字： typedef struct { char nodename[REDIS_CLUSTER_NAMELEN]; } clusterMsgDataFail; 因为集群里的所有节点都有一个独一无二的名字，所以FAIL消息里面只需要保存下线节点的名字，接收到消息的节点就可以根据这个名字来判断是哪个节点下线了。 （3）PUBLISH消息的实现 当客户端向集群中的某个节点发送命令： PUBLISH &lt;channel&gt; &lt;message&gt; 接收到PUBLISH命令的节点不仅会向channel频道发送消息message，它还会向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会向channel频道发送message消息。 也就是说，向集群发送PUBLISH &lt;channel&gt; &lt;message&gt;，会导致集群所有节点都向channel发送message消息。","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"}]},{"title":"Redis设计与实现8-Sentinel","slug":"Redis设计与实现8-Sentinel","date":"2020-01-06T05:27:28.000Z","updated":"2020-01-12T15:49:20.000Z","comments":true,"path":"2020/01/06/Redis设计与实现8-Sentinel/","link":"","permalink":"jiangren.work/2020/01/06/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B08-Sentinel/","excerpt":"Sentinel（哨岗、哨兵）是Redis的高可用性（high avail-ability）解决方案：由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）对主从服务器进行监视。","text":"Sentinel（哨岗、哨兵）是Redis的高可用性（high avail-ability）解决方案：由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）对主从服务器进行监视。 所谓Sentinel[‘sentɪnl]的高可用性指系统无中断地执行其功能的能力。Sentinel的主要功能是： 监控Redis整体是否正常运行。 某个节点出问题时，通知给其他进程（比如他的客户端）。 主服务器下线时，在从服务器中选举出一个新的主服务器。 1. 启动与初始化启动命令： $ redis-sentinel /path/to/your/sentinel.conf $ redis-server /path/to/your/sentinel.conf --sentinel 一个Sentinel启动时，需要执行以下步骤： 初始化服务器 将普通Redis服务器使用的代码替换成Sentinel专用代码。 初始化Sentinel状态 根据给定的配置文件，初始化Sentinel的监视主服务器列表 创建连向主服务器的网络连接 （1）初始化服务器 Sentinel本质上只是一个运行在特殊模式下的Redis服务器，所以启动Sentinel的第一步，就是初始化一个普通的Redis服务器。 由于Sentinel执行的工作和普通的Redis服务器执行的工作不同，所以初始化也不相同。首先先来回忆一下普通服务器的初始化过程： 初始化服务器状态结构 载入配置选项 初始化服务器数据结构 还原数据库状态 执行事件循环 而Sentinel初始化时，并不会使用AOF和RDB来还原数据库，此外很多命令比如WATCH,EVAL等都不会使用。 （2）使用Sentinel专用代码 主要分两部分：端口和命令集 普通Redis服务器使用redis.h/REDIS_SERVERPORT常量的值作为服务器端口： #define REDIS_SERVERPORT 6379 而Sentinel则使用sentinel.c/REDIS_SENTINEL_PORT常量的值作为服务器端口： #define REDIS_SENTINEL_PORT 26379 普通Redis服务器使用redis.c/redisCom-mandTable作为服务器的命令表。而Sentinel则使用sentinel.c/sentinelcmds作为服务器的命令表。 sentinelcmds命令表也解释了为什么在Sentinel模式下，Redis服务器不能执行诸如SET、DBSIZE、EVAL等等这些命令，因为服务器根本没有在命令表中载入这些命令。PING、SEN-TINEL、INFO、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE和PUNSUBSCRIBE这七个命令就是客户端可以对Sentinel执行的全部命令了。 （3）初始化Sentinel状态 在应用了Sentinel的专用代码之后，接下来，服务器会初始化一个sentinel.c/sentinelState结构，也就是Sentinel状态。服务器的一般状态仍然由redis.h/redisServer结构保存。 （4）初始化Sentinel状态的masters属性 Sentinel状态中的masters字典记录了所有被Sentinel监视的主服务器的相关信息，其中： 字典的键是被监视主服务器的名字。 而字典的值则是被监视主服务器对应的sentinel.c/sentinelRedisInstance结构。 每个sentinelRedisInstance结构（后面简称“实例结构”）代表一个被Sentinel监视的Redis服务器实例（instance），这个实例可以是主服务器、从服务器，或者另外一个Sentinel。 对Sentinel状态的初始化将引发对masters字典的初始化，而masters字典的初始化是根据被载入的Sentinel配置文件来进行的。 （5）创建连向主服务器的网络连接 Sentinel会创建两个连向主服务器的异步网络连接： 一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复。 另一个是订阅连接，这个连接专门用于订阅主服务器的__sentinel__:hello频道。 Redis目前的发布与订阅功能中，被发送的信息都不会保存在Redis服务器里面，如果在信息发送时，想要接收信息的客户端不在线或者断线，那么这个客户端就会丢失这条信息。因此，为了不丢失__sentinel__:hello频道的任何信息，Sentinel必须专门用一个订阅连接来接收该频道的信息。 因为Sentinel需要与多个实例创建多个网络连接，所以Sentinel使用的是异步连接。 2. 获取服务器信息2.1 获取主服务器信息Sentinel默认会以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。 会收到类似以下内容的回复： #Server ... run_id:7611c59dc3a29aa6fa0609f841bb6a1019008a9c ... # Replication role:master... slave0:ip=127.0.0.1,port=11111,state=online,offset=43,lag=0 slave1:ip=127.0.0.1,port=22222,state=online,offset=43,lag=0 slave2:ip=127.0.0.1,port=33333,state=online,offset=43,lag=0 ... # Other sections 通过分析主服务器返回的INFO命令回复，Sentinel可以明确：主服务器本身的信息，从服务器的信息。之后进行更新： 根据run_id域和role域记录的信息，更新Sentinel主服务器的实例结构。 返回的从服务器信息，则会被用于更新主服务器实例结构的slaves字典，这个字典记录了主服务器属下从服务器的名单。 2.2 获取从服务器信息当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的命令连接和订阅连接。 在创建命令连接之后，Sentinel在默认情况下，会以每十秒一次的频率通过命令连接向从服务器发送INFO命令，并获得类似于以下内容的回复： # Server ... run_id:32be0699dd27b410f7c90dada3a6fab17f97899f ... # Replication role:slave master_host:127.0.0.1 master_port:6379 master_link_status:up slave_repl_offset:11887 slave_priority:100 # Other sections ... 利用这些信息更新从服务器的实例结构： 2.3 接收主从服务器的频道当Sentinel与一个主服务器或者从服务器建立起订阅连接之后，Sentinel就会通过订阅连接，向服务器发送以下命令： SUBSCRIBE __sentinel__:hello Sentinel对__sentinel__:hello频道的订阅会一直持续到Sentinel与服务器的连接断开为止。 对于每个与Sentinel连接的服务器，Sentinel既通过命令连接向服务器的__sentinel__:hello频道发送信息，又通过订阅连接从服务器的__sentinel__:hello频道接收信息 假设现在有sentinel1、sentinel2、sentinel3三个Sentinel在监视同一个服务器，那么当sentinel1向服务器的__sentinel__:hello频道发送一条信息时，所有订阅了__sen-tinel__:hello频道的Sentinel都会收到这条信息。 3. Sentinel互相监督3.1 Sentinel字典Sentinel为主服务器创建的实例结构中的sentinels字典保存了除Sentinel本身之外，所有同样监视这个主服务器的其他Sentinel的资料。 当一个Sentinel接收到其他Sentinel发来的信息时，会提取出两方面信息： 与Sentinel有关的参数：源Sentinel的IP，port，ID和配置参数 与主服务器有关的参数：源Sentinel正在监视的主服务器的名字，IP，端口号和配置参数。 提取以后，Sentinel会在自己的Sentinel状态的masters字典中查找相应的主服务器实例结构，检查源Sentinel的实例结构是否存在： 存在，则更新 不存在，则创建 Sentinel可以通过分析接收到的频道信息来获知其他Sentinel的存在，并通过发送频道信息来让其他Sentinel知道自己的存在，监视同一个主服务器的多个Sentinel可以自动发现对方。 3.2 连接其他Sentinel当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，还会创建一个连向新Sentinel的命令连接，而新Sentinel也同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的多个Sentinel将形成相互连接的环形网络。 注意：Sentinel之间只会创建命令连接，但不会创建订阅。Sentinel需要通过接收主服务器或者从服务器发来的频道信息来发现未知的新Sentinel，所以才需要建立订阅连接。相互已知的Sentinel只要使用命令连接来进行通信就足够了。 4. 检测下线状态4.1 检测主观下线状态Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过实例返回的PING命令回复来判断对方是否在线。 当对方超过一段时间不向Sentinel回复时（比如超时5000毫秒）则Sentinel1就会将对方标记为主观下线。 4.2 检查客观下线状态当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态。当Sentinel从其他Sentinel那里接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作。 5. 下线后的补救5.1 选举Sentinel领袖一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。 选举策略： 候选人：所有在线的Sentinel 选举过程：一个Sentinel向另一个Sentinel发送设置请求SENTINEL is-master-down-by-addr命令 胜选条件： 局部领头Sentinel：先到先得，最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sen-tinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝。 领头Sentinel：如果有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel。 重选条件：如果没有过半，则再次投票，知道选出过半的为止。 5.1 故障转移在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤： 从已下线的主服务器的从服务器中拔举一个作为主服务器。 让已下线主服务器属下的所有从服务器改为复制新的主服务器 将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。 （1）选出新的主服务器 选择的标准是：状态良好、数据完整的从服务器。在满足基本连接需求后，判断偏移量，选出偏移量最大（保存最新数据）的从服务器作为新的主服务器。然后向这个从服务器发送SLAVEOF no one命令，将这个从服务器转换为主服务器。 在发送SLAVEOF no one命令之后，领头Sentinel会以每秒一次的频率（平时是每十秒一次），向被升级的从服务器发送INFO命令，并观察命令回复中的角色（role）信息，当被升级服务器的role从原来的slave变为master时，领头Sentinel就知道被选中的从服务器已经顺利升级为主服务器了。 （2）修改复制目标 之后需要让已下线主服务器属下的所有从服务器去复制新的主服务器，这一动作可以通过向从服务器发送SLAVEOF命令来实现。 （3）将旧的主服务器变为从服务器 当原来的主服务器重新上线时，Sentinel就会向它发送SLAVEOF命令，让它成为新主服务器的从服务器。","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"}]},{"title":"Redis设计与实现7-复制","slug":"Redis设计与实现7-复制","date":"2020-01-06T03:03:18.000Z","updated":"2020-01-12T15:39:31.000Z","comments":true,"path":"2020/01/06/Redis设计与实现7-复制/","link":"","permalink":"jiangren.work/2020/01/06/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B07-%E5%A4%8D%E5%88%B6/","excerpt":"本章将介绍2.8以前的老版复制功能和2.8以后的新版复制功能，讲解机制和优劣势。","text":"本章将介绍2.8以前的老版复制功能和2.8以后的新版复制功能，讲解机制和优劣势。 在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）。搞清楚关系，如果服务器A输入指令SLAVEOF，则A变成B的从服务器。 进行复制中的主从服务器双方的数据库将保存相同的数据，概念上将这种现象称作“数据库状态一致”，或者简称“一致”。比如，在主服务器上执行命令， 127.0.0.1:6379&gt; SET msg &quot;hello world&quot; OK 则同时可以在从服务器上获取msg键的值， 127.0.0.1:12345&gt; GET msg &quot;hello world&quot; 1. 旧版复制1.1 旧版复制的实现Redis的复制功能分为同步（sync）和命令传播（commandpropagate）两个操作： 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。 命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。 （1）同步 从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤： 从服务器向主服务器发送SYNC命令 主服务器收到后，执行BGSAVE命令，生成RDB文件，并使用缓冲区记录现在开始执行的所有写命令。 将RDB文件发送给从服务器，从服务器收到后更新 主服务器将缓冲区的内容发送给从服务器，从服务器收到后更新。 BGSAVE命令会增加一个子进程，负责创建RDB文件。 （2）命令传播 主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。 1.2 旧版复制的缺陷在Redis中，从服务器对主服务器的复制可以分为以下两种情况： 初次复制：从服务器以前没有复制过任何主服务器，或者要复制的主服务器和上一次复制的主服务器不同。 断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。 初次复制效果挺好的，但断线后重新复制效率就很低。因为执行SYNC命令是非常消耗资源的行为。 2. 新版复制2.1 新版复制功能的实现Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作。 PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式： 完整重同步用于初次复制，和SYNC命令完全一致 部分重同步，将断线后的命令发送给从服务器。 要实现部分重同步，需要完成三个部分： 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。 主服务器的复制积压缓冲区（replication backlog）。 服务器的运行ID（run ID）。 （1）复制偏移量 主服务器和从服务器会分别维护一个复制偏移量： 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。 通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态： 如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的。 相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态。 （2）复制积压缓冲区 复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面。 与此同时，主服务器也会向积压缓冲区添加偏移量， 当服务器重新连接上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作： offset偏移量之后的数据仍然存在于复制积压缓冲区中，主服务器执行部分重同步操作 反之，偏移量之后的数据已不存在于复制积压缓冲区，则执行完整重同步。 复制积压缓冲区作为一个限制性容器保证了复制的高效性： 如果断线时间短，错过的命令少，则直接调用偏移量为从服务器补上命令 反之，则直接完全重同步。 （3）服务器运行ID 每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID，运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成。 当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来。 当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID： 如果ID相同，则表示之前同步的主服务器就是这个，执行部分重同步。 如果ID不同，则表明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，执行完整重同步操作。 2.2 PSYNC命令的实现PSYNC命令的调用方法有两种： 如果是初次复制，则从服务器发送PSYNC?-1命令，主动请求主服务器进行完整重同步。 如果已经复制过，则从服务器发送PSYNC&lt;runid&gt;&lt;offset&gt;命令。即：上一次复制的主服务器ID+当前的复制偏移量。 根据情况，接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种： （1）如果主服务器返回+FULLRESYNC &lt;runid&gt; &lt;offset&gt;回复，那么表示主服务器将与从服务器执行完整重同步操作。从服务器将ID保存起来，在下一次PSYNC命令时使用，同时将offset的值当做自己的初始化偏移量。 （2）如果主服务器返回+CONTINUE回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了。 （3）如果主服务器返回-ERR回复，那么表示主服务器的版本低于Redis2.8，它识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作。 2.3 新版复制的完整流程本节主要展示新版复制操作的全过程，假设主服务器IP地址为127.0.0.1端口号为6379，从服务器IP为127.0.0.1端口号12345. （1）设置主服务器地址和端口 当客户端向从服务器发送以下命令时： 127.0.0.1:12345&gt; SLAVEOF 127.0.0.1 6379 OK 从服务器首先要做的就是将客户端给定的主服务器IP地址127.0.0.1以及端口6379保存到服务器状态的masterhost属性和masterport属性里面： struct redisServer{ //... char *masterhost; int masterport; //... }; （2）建立套接字连接 从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接 此时，从服务器变为了主服务器的客户端。从服务器同时具备服务器和客户端的两个身份。 （3）发送PING命令 连接成功后，从服务器立马发送一个PING命令，主要作用是： 检查套接字读写是否正常 检查主服务器能否正常处理命令 回复有三种可能： 主服务器返回了命令回复，但从服务器不能再规定的时间内读出，表明主从之间网络连接不佳。从服务器断开并重新创建连向主服务器的套接字。 主服务器返回一个错误，表示主服务器暂时无法处理请求（比如正在处理一个超时运行脚本），从服务器断开并重新创建连向主服务器的套接字。 从服务器收到PONG回复，表示主从之间连接正常。 （4）身份验证 收到pong的回复后，下一步是确定是否进行身份验证：如果从服务器设置了masterauth选项，那么进行身份验证；反之则不进行。 （5）发送端口信息 从服务器向主服务器发送从服务器的监听端口号。主服务器在接收到这个命令之后，会将端口号记录在从服务器所对应的客户端状态的slave_listening_port属性中： typedef struct redisClient { // ... // 从服务器的监听端口号 int slave_listening_port; // ... } redisClient; （6）同步 在这一步，从服务器将向主服务器发送PSYNC命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态。 在同步操作执行之前，只有从服务器是主服务器的客户端，但是在执行同步操作之后，主服务器也会成为从服务器的客户端。 （7）命令传播 主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了。 4. 心跳检测在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令： REPLCONF ACK &lt;replication_offset&gt; 其中replication_offset是从服务器当前的复制偏移量。发送REPLCONF ACK命令对于主从服务器有三个作用： 检测主从服务器的网络连接状态。 辅助实现min-slaves选项。 检测命令丢失。 （1）检测连接状态 如果主服务器超过一秒钟没有收到从服务器发来的REPLCONF ACK命令，那么主服务器就知道主从服务器之间的连接出现问题了。 （2）辅助实现min-slaves选项 Redis的min-slaves-to-write和min-slaves-max-lag两个选项可以防止主服务器在不安全的情况下执行写命令。 举个例子，如果我们向主服务器提供以下设置： min-slaves-to-write 3 min-slaves-max-lag 10 那么在从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，主服务器将拒绝执行写命令。 （3）检测命令丢失 假如主服务器的向从服务器发送的传播命令因为网络问题丢失，会导致二者偏移量不一致。这是心跳检测命令会侦察到这种情况，于是主服务器会补发。","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"}]},{"title":"Redis设计与实现6-客户端与服务器","slug":"Redis设计与实现6-客户端与服务器","date":"2020-01-06T02:09:16.000Z","updated":"2020-01-12T15:15:49.000Z","comments":true,"path":"2020/01/06/Redis设计与实现6-客户端与服务器/","link":"","permalink":"jiangren.work/2020/01/06/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B06-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"介绍Redis服务器与客户端。","text":"介绍Redis服务器与客户端。 1. 客户端Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，处理他们的请求。 通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。 对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h/redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息。 在服务器中，用一个链表保存客户端的所有状态 struct redisServer { // ... // 一个链表，保存了所有客户端状态 list *clients; // ... }; 1.1 客户端属性（1）套接字描述符 客户端状态的fd属性记录了客户端正在使用的套接字描述符。根据客户端类型不同，fd的值可以是-1或大于-1的整数： 伪客户端为-1：伪客户端用于处理的AOF文件或Lua脚本，而不是网络。 普通客户端为大于-1的整数。 执行CLIENT list命令会列出所有连接到服务器的普通客户端。 redis&gt; CLIENT list addr=127.0.0.1:53428 fd=6 name= age=1242 idle=0 ... addr=127.0.0.1:53469 fd=7 name= age=4 idle=4 ... （2）名字 默认情况下客户端是没有名字的，比如上面的例子中name处就是空白。使用CLIENT setname命令可以为客户端设置一个名字，让客户端的身份变得更清晰。 typedef struct redisClient { //... robj *name; //... }redisClient; 如果客户端没有名字，那么相应客户端状态的name属性指向NULL指针；相反，如果有名字，那么name属性将指向一个字符串对象。 （3）标志 客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态： typedef struct redisClient { // ... int flags; // ... } redisClient; 比如REDIS_BLOCKED标志表示客户端正在被BRPOP、BLPOP等命令阻塞。flag可以是单个标志，也可以是多个标志的组合。比如： flags=REDIS_SLAVE | REDIS_PRE_PSYNC; （4）输入缓冲区 客户端状态的输入缓冲区用于保存客户端发送的命令请求： typedef struct redisClient { // ... sds querybuf; // ... } redisClient; 保存方式和AOF类似，比如SET key value被转化为如下的SDS值： *3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nkey\\r\\n$5\\r\\nvalue\\r\\n （5）命令与命令参数 在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得出的命令参数以及命令参数的个数分别保存到客户端状态的argv属性和argc属性： typedef struct redisClient { // ... robj **argv; int argc; // ... } redisClient; argv属性是一个数组，数组中的每个项都是一个字符串对象，其中argv[0]是要执行的命令，而之后的其他项则是传给命令的参数。 （6）命令的实现函数 当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器将根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数。 命令表是一个字典结构，键是SDS结构，保存了命令的名字，值是redisCommand结构，保存了： 实现函数 命令标志 命令的参数个数 命令的总执行次数 总消耗时长 当程序在命令表中成功找到argv[0]所对应的redisCommand结构时，客户端状态的cmd指针指向这个结构： typedef struct redisClient { // ... struct redisCommand *cmd; // ... } redisClient; 服务器就可以使用cmd属性所指向的redisCommand结构，以及argv、argc属性中保存的命令参数信息，调用命令实现函数，执行客户端指定的命令。 （7）输出缓冲区 命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的： 固定大小的缓冲区用于保存那些长度比较小的回复，比如OK、简短的字符串值、整数值、错误回复等等。 可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。 （8）身份验证 客户端状态的authenticated属性用于记录客户端是否通过了身份验证： typedef struct redisClient { // ... int authenticated; // ... } redisClient; 为0表示没有通过验证，为1表示通过。如果没有通过，除了AUTH命令之外，客户端发送的所有其他命令都会被服务器拒绝执行。 redis&gt; SET msg &quot;hello world&quot; (error) NOAUTH Authentication required. 当客户端通过AUTH命令成功进行身份验证之后，客户端状态authenticated属性的值就会从0变为1. （9）时间 客户端还有几个和时间有关的属性： typedef struct redisClient { // ... time_t ctime; time_t lastinteraction; time_t obuf_soft_limit_reached_time; // ... } redisClient; ctime属性记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒。 lastinteraction属性记录了客户端与服务器最后一次进行互动（interaction）的时间。（收或者发命令） obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制（soft limit）的时间 1.2 创建与关闭客户端（1）普通客户端 所谓普通客户端是指客户端通过网络与服务器连接，客户端使用connect函数连接到服务器时就会调用连接事件处理器。 之后，会将新客户端的状态添加到clients链表的末尾。 关闭的原因可能有很多种 客户端进程退出或被杀死 客户端向服务器发送了带有不符合协议格式的命令请求 如果客户端成为了CLIENT KILL命令的目标 客户端空转超时 客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1 GB） 如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小 除了超过1GB大小的硬性限制外，还有软性限制，用到了之前提到的obuf_soft_limit_reached_time属性。 如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的obuf_soft_limit_reached_time属性记录下客户端到达软性限制的起始时间。之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端 （2）Lua脚本的伪客户端 服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中： struct redisServer { // ... redisClient *lua_client; // ... }; Lua脚本会一直存在于服务器生命周期，只有服务器被关闭时他才会停止。 服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端。 2. 服务器2.1 命令请求的执行过程在处理SET KEY VALUE的过程中，客户端和服务器共需要执行以下操作： 客户端向服务器发送命令请求SET KEY VALUE 服务器接收并处理，产生回复命令OK 服务器发送OK给客户端 客户端接收到命令，并打印给用户 （1）发送命令请求 用户在客户端键入一个请求时，客户端会将命令请求转换为协议格式，然后通过套接字发送给服务器。 （2）读取命令请求 当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作： 读取套接字中的协议请求，并保存在客户端状态的输入缓冲区内 分析命令，提取命令参数和个数，存在argv和argc属性中 调用命令执行器 （3）命令执行器 前面提到过，命令执行器会在命令表中查找命令，并将找到的结果保存在客户端状态cmd中。 字典的键是一个命令的字符串格式，值则是一个redisCommand结构： 下表展示了slags属性可以使用的标识和意义： 比如set执行时，就会： 现在已经成功完成了：连接所需函数，参数，参数个数。但在真正执行之前还需要进行检查： 检查客户端状态cmd是否指向NULL 根据redisCommand结构的arity属性，检查参数个数是否正确 检查身份验证 检查内存占用 如果当前客户端正在SUBSCRIBE命令订阅频道，则只接受订阅命令，其他命令会被拒绝。 服务器因Lua脚本超时并阻塞，服务器只会执行关闭命令，其他会被拒绝。 如果客户端正在执行事务，则服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中。 如果打开了监视器功能，服务器会把将要执行的命令发送给监视器。 在执行命令时，先找到客户端状态指针client，然后找到命令字典cmd，然后查找命令的函数指针proc client-&gt;cmd-&gt;proc(client); 处理完毕后，产生回复，保存在输出缓冲区里面，之后实现函数还会为客户端的套接字关联命令回复处理器，这个处理器负责将命令回复返回给客户端。 2.2 severCron函数Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。severCorn函数的常见功能如下： （1）更新服务器时间缓存 Redis服务器中有不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存： struct redisServer { // ... // 保存了秒级精度的系统当前UNIX时间戳 time_t unixtime; // 保存了毫秒级精度的系统当前UNIX时间戳 long long mstime; }; 因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性，所以这两个属性记录的时间的精确度并不高。 （2）更新LRU时钟 LRU是Least Recent Used，原理如下： 服务器状态中的lruclock属性保存了服务器的LRU时钟，这个属性和上面介绍的unixtime属性、mstime属性一样，都是服务器时间缓存的一种。 struct redisServer { // ... // 默认每10秒更新一次的时钟缓存， // 用于计算键的空转（idle）时长。 unsigned lruclock:22; //... }; 每个Redis对象都会有一个lru属性，这个lru属性保存了对象最后一次被命令访问的时间： typedef struct redisObject { // ... unsigned lru:22; // ... } robj; 当服务器要计算一个数据库键的空转时间（也即是数据库键对应的值对象的空转时间），程序会用服务器的lruclock属性记录的时间减去对象的lru属性记录的时间。 由于是10秒更新一次，所以时钟并不是实时的，这个LRU时间只是一个模糊的估算值。 （3）更新服务器每秒执行命令次数 serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒钟处理的命令请求数量。 trackOperationsPerSecond函数每次运行，都会根据ops_sec_last_sample_time记录的上一次抽样时间和服务器的当前时间，以及ops_sec_last_sample_ops记录的上一次抽样的已执行命令数量和服务器当前的已执行命令数量，计算出两次trackOperationsPerSecond调用之间，服务器平均每一毫秒处理了多少个命令请求，然后将这个平均值乘以1000，这就得到了服务器在一秒钟内能处理多少个命令请求的估计值，这个估计值会被作为一个新的数组项被放进ops_sec_samples环形数组里面。 （4）更新内存峰值记录 服务器状态中的stat_peak_memory属性记录了服务器的内存峰值大小： struct redisServer { // ... // 已使用内存峰值 size_t stat_peak_memory; // ... }; 每次serverCron函数执行时，程序都会查看服务器当前使用的内存数量，并与stat_peak_memory保存的数值进行比较，如果当前使用的内存数量比stat_peak_memory属性记录的值要大，那么就替换峰值。 （5）处理SIGTERM信号 在启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识。 每次serverCron函数运行时，程序都会对服务器状态的shutdown_asap属性进行检查，并根据属性的值决定是否关闭服务器。 （6）管理客户端资源 serverCron函数每次执行都会调用clientsCron函数，检查： 客户端服务器连接超时（长时间没有互动），程序将释放这个客户端。 客户端在上一次执行命令后，输入缓冲区大小超过一定长度，程序会释放客户端当前的输入缓冲区。 （7）管理数据库资源 serverCron函数每次执行都会调用databasesCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作。参见Redis中的定期检查) （8）执行被延迟的BGREWRITEAOF 在服务器执行BGSAVE命令的期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后。 每次serverCron函数执行时，函数都会检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行，如果这两个命令都没在执行，且有被延迟的BGREWRITEAOF，则执行。 （9）将AOF缓冲区内容写入AOF文件 （10）关闭输出缓冲区超限的客户端 （11）增加cronloops计数 服务器状态的cronloops属性记录了serverCron函数执行的次数，每执行一次就增加计数。作用是：在复制模块中实现“每执行serverCron函数N次就执行一次指定代码”的功能。 2.3 服务器初始化服务器初始化要完成以下几个任务： 初始化服务器状态结构 载入配置选项 初始化服务器数据结构 还原数据库状态 执行时间循环 （1）初始化服务器状态结构 创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。 初始化server变量的工作由redis.c/initServerConfig函数完成，主要工作： 设置服务器ID 设置服务器运行默认频率 设置配置文件路径 设置运行架构 设置默认端口号 设置RDB持久化和AOF持久化条件 初始化LRU时钟 创建命令表 （2）载入配置选项 完成初始化服务器状态结构后，所有变量会被附上默认的值，但是实际上用户可能修改了某些参数。此时，载入用户的配置选项，替换掉那些被修改后的默认值。 （3）初始化服务器数据结构 除了在之前执行initServerConfig函数初始化server状态时，程序只创建了命令表一个数据结构，在这个阶段还需要创建其他数据结构： server.client链表，记录了所有与服务器相连的客户端状态结构。 server.db数组，数组中包含了所有数据库。 server.pubsub_channels字典，保存模式订阅信息的server.pubsub_patterns链表。 server.lua，用于执行Lua脚本的Lua环境 server.slowlog，用于保存慢查询日志。 服务器到现在才初始化数据结构的原因在于，服务器必须先载入用户指定的配置选项，然后才能正确地对数据结构进行初始化。 （4）还原数据库状态 在完成了对服务器状态server变量的初始化之后，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。 如果启用了AOF持久化功能，则会使用AOF来还原，否则用RDB文件还原。 （5）执行事件循环 在初始化的最后一步，服务器将打印出以下日志： [5244] 21 Nov 22:43:49.084 * The server is now ready to accept connections on port 6379 开始执行事件循环，意味着服务器现在开始可以接受客户端的连接请求了。","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"}]},{"title":"Redis设计与实现5-事件","slug":"Redis设计与实现5-事件","date":"2020-01-05T05:17:25.000Z","updated":"2020-01-12T14:46:54.000Z","comments":true,"path":"2020/01/05/Redis设计与实现5-事件/","link":"","permalink":"jiangren.work/2020/01/05/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B05-%E4%BA%8B%E4%BB%B6/","excerpt":"Redis是一个事件驱动程序，前面提到，服务器需要处理文件事件和时间事件。","text":"Redis是一个事件驱动程序，前面提到，服务器需要处理文件事件和时间事件。 文件事件：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。 时间事件：些操作会在给定的时间点进行，对这类定时操作的抽象就是时间事件。 1. 文件事件Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler） Reactor模式用于高并发，依靠事件驱动。传统的线程连接中，IO连接后需要等待客户的请求。而事件驱动中，IO可以干别的事情，等客户发来请求后再处理。 在Redis中， 文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。 虽然文件事件处理器以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis内部单线程设计的简单性。 1.1 构成文件事件处理器的四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。 前面提到，文件事件是对套接字操作的抽象，当一个套接字准备好后，就会产生一个文件事件。 尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。只有当上一个套接字处理完毕后，复用程序才会向分派器传送下一个套接字。 1.2 IO多路复用程序的实现Redis的I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c。 ae表示A simple event-driven programming library，一个简单的事件驱动程序库 由于IO复用程序提供了统一的接口，所以底层实现方法可以互换。 1.3 事件类型I/O多路复用程序可以同时监听多个套接字的ae.h/AE_READABLE和ae.h/AE_WRITABLE这两种事件，这两类事件和套接字操作之间的对应关系如下： 客户端对套接字执行write操作，客户端对服务器的监听套接字执行connect操作。此时套接字对服务器变为可读状态，就会产生AE_READABLE事件。 客户端对套接字执行read操作。此时套接字对服务器变为可写状态，就会产生AR_WRITABLE事件。 虽然是可以同时处理这两种事件，但优先处理可写事件。 1.4 事件处理器事件处理器有很多，最常用的是通信的连接应答处理器、命令请求处理器和命令回复处理器。 （1）连接应答处理器 networking.c/acceptTcpHandler函数是Redis的连接应答处理器，具体实现为sys/socket.h/accept函数的包装。 当Redis服务器进行初始化的时候，程序会将连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来，当有客户端用sys/socket.h/connect函数连接服务器监听套接字的时候，套接字就会产生AE_READABLE事件，引发连接应答处理器执行。 （2）命令请求处理器 networking.c/readQueryFromClient函数是Redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容，具体实现为unistd.h/read函数的包装。 和上面一样，当客户端通过连接应答处理器成功连接到服务器后，服务器会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，引发命令请求处理器执行。 （3）命令回复处理器 networking.c/sendReplyToClient函数是Redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令通过套接字返回给客户端，具体实现为unistd.h/write函数的包装。 当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE事件，引发命令回复处理器执行。 2. 时间事件Redis时间事件分为两类： 定时事件：程序在指定时间后执行一次。 周期性事件：每隔一段时间就执行，循环往复。 一个时间事件主要由以下三个属性组成： id：服务器为时间事件创造全局唯一ID作为识别，新事件比旧事件号码要大。 when：毫秒级UNIX时间戳，记录时间事件到达时间。 timeProc：时间事件处理器，到时间后处理事件。 2.1 构成服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。 因为新的事件总是放在表头，所以三个时间事件分别按逆序ID排列： 注意，我们说保存时间事件的链表为无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序。 2.2 APIae.c/aeCreateTimeEvent函数接受一个毫秒数milliseconds和一个时间事件处理器proc作为参数，将一个新的时间事件添加到服务器。 ae.c/aeDeleteFileEvent函数接受一个时间事件ID作为参数，然后从服务器中删除该ID所对应的时间事件。 ae.c/aeSearchNearestTimer函数返回到达时间距离当前时间最接近的那个时间事件。 ae.c/processTimeEvents函数是时间事件的执行器，这个函数会遍历所有已到达的时间事件，并调用这些事件的处理器。已到达指的是，时间事件的when属性记录的UNIX时间戳等于或小于当前时间的UNIX时间戳。 2.3 severCron函数持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，这些定期操作由redis.c/serverCron函数负责执行，它的主要工作包括： 更新服务器统计信息，包括事件、内存占用等情况 清理过期键值对 关闭和清理失效的客户端连接 AOF和RDB持久化操作 如果sever是主服务器，则对从服务器进行定期同步 如果是集群模式，对集群进行定期同步和连接测试 cron在unix中表示计划任务，计时程序 默认频率是100毫秒一次，用户可以在redis.conf中修改hz选项来改变。 2.3 事件的调度与执行因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理什么文件，以及花多少时间来处理它们等等。事件的调度和执行由ae.c/aeProcessEvents函数负责。 对事件处理的原则是： 如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。 对两种事件处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此需要尽可能地减少程序的阻塞时间，并在有需要时主动让出执行权。（比如写入字节太长，命令回复处理器就会break跳出，将余下的数据留到下次） 由于不能抢占，时间事件到达后需要等待文件事件处理完成，所以一般会稍晚于到达时间。","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"}]},{"title":"Redis设计与实现4-RDB和AOF持久化","slug":"Redis设计与实现4-RDB持久化和AOF持久化","date":"2020-01-04T06:10:19.000Z","updated":"2020-01-12T14:28:35.000Z","comments":true,"path":"2020/01/04/Redis设计与实现4-RDB持久化和AOF持久化/","link":"","permalink":"jiangren.work/2020/01/04/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B04-RDB%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8CAOF%E6%8C%81%E4%B9%85%E5%8C%96/","excerpt":"持久化的意思是将数据永久保存在磁盘中。Redis采用RDB和AOF两种策略。","text":"持久化的意思是将数据永久保存在磁盘中。Redis采用RDB和AOF两种策略。 1. RDB持久化将服务器中的非空数据库以及它们的键值对统称为数据库状态。下图三个非空数据库，以及其中的键值对就是该服务器的数据库状态。 在Redis中，只有将数据保存在内存磁盘里才会永久保存，如果服务器进程退出，服务器中的数据库状态就会消失。为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面。 RDB持久化产生的RDB文件(Redis Database)是一个经过压缩的二进制文件，该文件可以被还原为数据库状态，所以即使服务器停机，服务器的数据还是被安全保存在硬盘中。 1.1 RDB文件的创建与载入有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE (BackGround SAVE)。SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求： redis&gt; SAVE //等待直到RDB文件创建完毕 OK 而BGSAVE命令会增加一个子进程，负责创建RDB文件。 redis&gt; BGSAVE //派生子进程，并由子进程创建RDB文件 Background saving started BGSAVE执行时，会阻止SAVE、其他BGSAVE和BGREWRITEAOF这三个命令执行，防止竞争。 创建RDB文件的实际工作由rdb.c/rdbSave函数完成，SAVE命令和BGSAVE命令会以不同的方式调用这个函数。 Redis并没有载入RDB文件的命令，只要服务器启动时检测到RDB文件存在，他就会自动载入。比如下面日志的第二条： 1.2 自动间隔性保存由于BGSAVE可以不阻塞服务器执行，所以我们可以设置条件，让服务器每隔一段时间自动保存。举个例子： save 900 1 save 300 10 save 60 10000 这些条件的意思是：900秒内对数据库至少进行了1次修改，300秒内对数据库进行了10次修改…. 服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性： struct redisServer { // ... // 记录了保存条件的数组 struct saveparam *saveparams; // ... }; saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件： struct saveparam { // 秒数 time_t seconds; // 修改数 int changes; }; 除了设置保存条件的saveparams数组外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性： dirty计数器记录自上一次SAVE和BGSAVE以后，服务器对数据库状态进行了多少次修改（包括增删改） lastsave则是一个时间戳，记录了上一次执行保存的时间。 当服务器执行修改命令一次以后，dirty计数器就加一。如果是一次性修改多个元素，计数器此时加N redis-&gt;SADD database0 apple orange watermelon Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。 执行完以后，dirty清0，lastsave更新。 1.3 RDB文件结构完整的RDB文件如下， RDB是一个二进制文件而不是文本文件。 广义来说，所有文件都是二进制文件。狭义来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等；二进制文件是基于值编码的文件，也可以理解为自定义编码。 开头的REDIS占5个字节，这5个字符用于检查是不是RDB文件。 db_version长度为4字节，值被解析为RDB版本，比如”0006”就代表第6版。 database部分包含着多个数据库的键值对数据，根据大小不同，长度有所不同。 EOF占1个字节，结束位标志。 check_sum是占8字节，保存校验和。服务器在载入时会根据读入的实际数据计算出一个数来和校验值比较，以此来检查是否有损坏。 1.3.1 database部分每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分，如图所示。 SELECTDB，1字节，当读取到此值时，程序知道接下来要读入一个数据库号码。 db_number，1、2、5字节，保存数据库号码。 key_value_pairs，保存键值对，包括过期时间。 1.3.2 key_value_pairs部分不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成， 带有过期时间的键值对在RDB中的结构如下 EPIRETIME_MS，1字节，告诉程序接下来读取一个以毫秒为单位的过期时间。 ms，8字节带符号整数，记录一个以毫秒为单位的UNIX时间戳。 1.3.3 value部分（1）字符串对象 如果TYPE的值为REDIS_RDB_TYPE_STRING，那么value保存的就是一个字符串对象，字符串对象的编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW。 如果是INT，则表示对象是一个长度不超过32位的整数，保存方式如下： 其中，ENCODING的值可以是REDIS_RDB_ENC_INT8、REDIS_RDB_ENC_INT16或者REDIS_RDB_ENC_INT32三个常量的其中一个，它们分别代表RDB文件使用8位、16位或者32位来保存整数值integer。 如果是RAW格式，则说明对象是一个字符串值，有压缩和不压缩两种方法来保存。对于没有压缩的字符串，保存格式如下： 压缩后的字符串，保存格式如下： REDIS_RDB_ENC_LZF，表明已被LZF算法压缩 compressed_len，被压缩后的字符串长度 origin_len，原来的长度 compressed_string，被压缩后的字符串 （2）列表对象 如果TYPE的值为REDIS_RDB_TYPE_LIST，那么value保存的就是一个REDIS_ENCODING_LINKEDLIST编码的列表对象，RDB文件保存这种对象的结构如图所示。 每一个列表项都是一个字符串对象，所以程序会以字符串对象的方式来保存。 结构中，3表示列表长度，5表示第一个列表项长度为5，内容为”hello”。 （3）集合对象 如果TYPE的值为REDIS_RDB_TYPE_SET，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象，RDB文件保存这种对象的结构如图所示。 图中elem代表集合的元素，每个集合元素都是一个字符串对象。 和列表一样，4代表集合大小，5代表元素长度，值为”apple”。 （4）哈希表对象 如果TYPE的值为REDIS_RDB_TYPE_HASH，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象，RDB文件保存这种对象的结构如图所示。 例子如下， 哈希表长度为2，第一个键值对，键长度为1的字符串”a”，值为5的字符串”apple”。 （5）有序集合对象 如果TYPE的值为REDIS_RDB_TYPE_ZSET，那么value保存的就是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象，RDB文件保存这种对象的结构如图所示。 比如： 大小为2，第一个元素是长度为2的字符串”pi”，分值被转换为长度为4的字符串”3.14”。 （6）INTSET编码的集合 如果TYPE的值为REDIS_RDB_TYPE_SET_INTSET，那么value保存的就是一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件里面。 （7）ZIPLIST编码的列表、哈希表和有序集合 如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，那么value保存的就是一个压缩列表对象，保存策略和上面一一样：先转化为字符串对象。 2. AOF持久化RDB持久化记录的是数据库本身，而AOF(Append Only File)则记录Redis服务器所执行的写命令。 假如使用如下命令: redis&gt; SET msg &quot;hello&quot; OK 则AOF记录形式如下： *2\\r\\n$6\\r\\nSELECT\\r\\n$1\\r\\n0\\r\\n *3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nmsg\\r\\n$5\\r\\nhello\\r\\n 2.1 AOF实现原理AOF如其名所示，Append Only File，AOF持久化功能的实现可以分为命令追加（append）、文件写入与同步（sync） （1）命令追加 如果AOF被打开，则服务器执行完一个命令后，会以协议格式将命令追加到服务器状态aof_buf缓冲区的结尾： struct redisServer { // ... sds aof_buf; // AOF缓冲区 // ... }; 比如执行了SET KEY VALUE后，会将以下协议内容加载到aof_buf缓冲区： *3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nKEY\\r\\n$5\\r\\nVALUE\\r\\n （2）AOF文件的写入与同步 Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。 服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面。 这个函数的行为有服务器配置的appendfsync选项来设置，默认为everysec： 默认情况下，距离上次同步过了一秒钟，则服务器会将aof_buf内容写入AOF文件中。 2.2 AOF文件的载入与数据还原因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。 AOF还原数据库的步骤如下： 创建一个不带网络连接的伪客户端（fake client）：因为Redis的命令只能在客户端上下文中执行。 从AOF中读出一条命令。 使用伪客户端执行被读出的写命令。 重复23步 2.3 AOF重写随着时间的增长，AOF文件的大小将会越来越大。为了解决这个问题，Redis提供了AOF重写功能。 重写后，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件保存的数据库状态完全相同。 如果要保存一个键值对，我们其实只关心它当前的状态。所以重写策略是：首先从数据库中读取键现在的值，然后用一条命令去记录键值对，用到了aof_rewrite函数。 比如，对list进行RPUSH操作填入”A”、”B”、”C”，然后再LPOP一次，我们操作了4次，但其实用RPUSH list A B这一条指令就可以代替。 aof_rewrite函数包含了大量写入操作，调用时会导致线程被长时间阻塞，所以Redis将AOF重写放入子进程里。 还有一个问题：子进程AOF重写时，主进程也在写命令，导致两者状态不一致。因此，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。 换句话说，子进程执行AOF期间，服务器进程需要： 执行客户端指令 将执行后的命令追加到AOF缓冲区 将执行后的命令追加到AOF重写缓冲区 子进程执行完AOF后，向父进程发送一个信号。父进程接收后： 将AOF重写缓冲区的内容写入AOF文件中，保证一致性。 对新AOF文件改名，原子的(atomic)覆盖现有AOF文件。 在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"}]},{"title":"Redis设计与实现3-数据库","slug":"Redis设计与实现3-数据库","date":"2020-01-04T01:59:28.000Z","updated":"2020-01-12T13:51:54.000Z","comments":true,"path":"2020/01/04/Redis设计与实现3-数据库/","link":"","permalink":"jiangren.work/2020/01/04/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B03-%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"本章将对Redis服务器的数据库实现进行介绍，介绍键空间、过期键，数据库通知的实现方法。","text":"本章将对Redis服务器的数据库实现进行介绍，介绍键空间、过期键，数据库通知的实现方法。 1. 数据库的切换Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库： struct redisServer { // ... redisDb *db; int dbnum; // ... }; 初始化时，程序会根据当前服务器的dbnum属性来决定建立数据库的个数，默认创建16个。 每个Redis客户端都有自己的目标数据库，当客户端执行读写命令时，就需要切换数据库。 默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。 redis&gt; SET msg &quot;hello world&quot; OK redis&gt; GET msg &quot;hello world&quot; redis&gt; SELECT 2 OK redis[2]&gt; GET msg (nil) 在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针： typedef struct redisClient { // ... //记录客户端当前正在使用的数据库 redisDb *db; // ... } redisClient; 如果某个客户端的目标数据库为1号数据库，那么这个客户端所对应的客户端状态和服务器状态之间的关系如图： 通过修改指针，使他指向服务器中不同的数据库，从而达到切换的目的。 2. 数据库键空间2.1 键空间结构Redis是一个键值对数据库服务器，每个数据库都是一个redis.h/redisDb结构。其中dict字典保存了数据库中所有的键值对，我们将这个字典称为键空间(key space)。 typedef struct redisDb { // ... // 数据库键空间，保存着数据库中的所有键值对 dict *dict; // ... } redisDb; 键空间的键就是数据库的键，每个键是一个字符串对象。键空间的值就是数据库的值，可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的一种。 当我们输入以下命令时： redis&gt; SET message &quot;hello world&quot; OK redis&gt; RPUSH alphabet &quot;a&quot; &quot;b&quot; &quot;c&quot; (integer)3 redis&gt; HSET book name &quot;Redis in Action&quot; (integer) 1 redis&gt; HSET book author &quot;Josiah L. Carlson&quot; (integer) 1 redis&gt; HSET book publisher &quot;Manning&quot; (integer) 1 数据库的键空间结构如下： 2.2 键空间的增删改查（1）添加和修改键 添加新键值对和修改键值的操作是一样的，区别在于键是新的是旧的。 对象 命令 字符串对象 SET date 2020/1/1MSET date1 19 date2 20 哈希对象 HSET book name C++primer HMSET fruit name apple size large 列表对象 LSET cloth 0 shirtLPUSH food potato RPUSH brand appleLRANGE level 0 5 集合对象 SADD occupation firefighter 有序集合 ZADD grade 87 Tom 65 Terry （2）删除键 对象 命令 字符串对象 DEL date 哈希对象 HDEL myhash field1 myhash field2 列表对象 BLPOP list1 100BRPOP list1 150LPOP list2LREM list3 -2 “hello” 集合对象 SPOP food “rice”SREM food “noodle” 有序集合 ZREM website google.comZREMRANGEBYLEX drink [sprit (cocoZREMRANGEBYRANK salary 0 2ZREMRANGEBYSCORE salary 1500 3500 POP在删除的同时，会返回结果，打印到控制台，而REM则是单纯的删除。BLPOP在移除元素时，如果列表没有元素则会等待至超时或发现元素为止。 有序集合范围删除中，LEX表示键， [ ( 表示区间开闭。而ZREMRANGEBYRANK salary 0 2表示删除salary最高的三个。 （3）查询键 对象 命令 字符串对象 GET timeMGET time1 time2 哈希对象 HGET site baiduHMGET site baidu googleHGETALL siteHKEYS site 列表对象 LINDEX mylist 2LRANGE mylist 0 2 集合对象 SISMEMBER myset1 “hello” 有序集合 … HGET是根据键返回值，HGETALL则返回所有键值对，HKEYS返回所有键。列表对象根据主要根据下标返回结果。 3. 过期键3.1 设置过期时间通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键： redis&gt; SET key value OK redis&gt; EXPIRE key 5 (integer) 1 redis&gt; GET key // 5秒之内 &quot;value&quot; redis&gt; GET key // 5秒之后 (nil) 与前面相似，客户端可以通过EXPIREAT命令或PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。过期时间由UNIX时间戳表示。 而TTL命令和PTTL命令则返回一个键的剩余生存时间。 所有的命令在Redis中最终都会转化为PEXPIREAT执行。 在RedisDb结构中，在键空间之外，有一个expires字典专门保存所有键的过期时间，我们称之为过期字典。过期字典保存的值是long long 类型整数，保存一个毫秒精度的UNIX时间戳。 typedef struct redisDb { // ... // 过期字典，保存着键的过期时间 dict *expires; // ... } redisDb; 虽然键空间和过期时间都有相同的键，但他们以指针形式指向同一个键，不会造成空间浪费。 3.2 过期键的删除策略通过过期字典知道了哪些键已经过期，那么过期的键什么时候会被删除呢？删除策略有三种： 定时删除：在设置键的过期时间的同时，创建一个定时器（timer），定时结束后删除。 惰性删除：放着不管，每次从键空间获取时检查是否过期，过期就删除。 定期删除：每隔一段时间，程序检查一次数据库，删除过期键。 （1）定时删除 定时删除有利于内存管理，但对CPU不友好。如果过期键太多，删除会占用相当一部分CPU。 所以策略应该是：当有大量命令请求服务器处理时，并且服务器内存充足，就应该优先将CPU资源安排在处理客户端请求上，而不是删除过期键。 创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为$O(N)$，并不能高效地处理大量时间事件。 （2）惰性删除 对CPU最友好，但浪费内存。如果数据库中有很多过期键，而这些过期键永远也不会被访问的话，他们就会永远占据空间，可视为内存泄漏。 一些和时间有关的数据，比如日志，在某个时间点后，他们的访问就会很少。如果这类过期数据大量积压，会造成严重的内存浪费。 （3）定期删除 定期删除是一种折中，通过选择较为空闲的时间点来处理过期键，减少CPU压力。同时也能及时释放内存，避免内存泄漏。 在Redis中，实际使用的是惰性删除和定期删除这两种。 （1）Redis中的惰性删除 存在于db.c/expireIfNeeded函数。所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查： 过期，函数将输入键删除 不过期，函数不动作 （2）Redis中的定期删除 过期键的定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。 全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次检查时接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次就会从11号数据库开始工作。 如果所有数据库都被检查了一遍，则current_db将会被置0，然后开始新一轮检查。 4. 数据库通知通知是Redis2.8新增的功能，可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。 4.1 订阅通知订阅有两种模式： 订阅某一个键，返回键的所有操作 订阅某一个操作，返回执行这个操作的键 情况1，从0号数据库订阅了键message的消息。如果此时有其他客户端操作了message，则会将消息通知到此处。 127.0.0.1:6379&gt; SUBSCRIBE _ _keyspace@0_ _:message Reading messages... (press Ctrl-C to quit) 1) &quot;subscribe&quot; // 订阅信息 2) &quot;__keyspace@0__:message&quot; 3) (integer) 1 1) &quot;message&quot; //执行SET命令 2) &quot;_ _keyspace@0_ _:message&quot; 3) &quot;set&quot; 1) &quot;message&quot; //执行EXPIRE命令 2) &quot;_ _keyspace@0_ _:message&quot; 3) &quot;expire&quot; 情况2，客户端订阅了0号数据库中的DEL命令。 127.0.0.1:6379&gt; SUBSCRIBE _ _keyevent@0_ _:del Reading messages... (press Ctrl-C to quit) 1) &quot;subscribe&quot; // 订阅信息 2) &quot;_ _keyevent@0_ _:del&quot; 3) (integer) 1 1) &quot;message&quot; //键key执行了DEL命令 2) &quot;_ _keyevent@0_ _:del&quot; 3) &quot;key&quot; 1) &quot;message&quot; //键number执行了DEL命令 2) &quot;_ _keyevent@0_ _:del&quot; 3) &quot;number&quot; 4.2 发送通知发送数据库通知的功能是由notify.c/notifyKeyspaceEvent函数实现，函数声明如下： void notifyKeyspaceEvent(int type,char *event,robj *key,int dbid); type参数是发送的通知的类型，event、keys和dbid分别是事件的名称、产生事件的键，以及产生事件的数据库编号，函数会根据type参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。 比如SADD命令的实现函数中，通知的发送方式是 void saddCommand(redisClient* c) { //... if(added) { //...添加成功，发送通知 notifyKeyspaceEvent(REDIS_NOTIFY_SET,&quot;add&quot;,c-&gt;argv[1],c-&gt;db-&gt;id); //... } } 当SADD命令成功地向集合添加了一个集合元素之后，命令就会发送通知，该通知的类型为REDIS_NOTIFY_SET（表示这是一个集合键通知），名称为sadd（表示这是执行SADD命令所产生的通知）。 发布时调用的notifyKeyspaceEvent函数逻辑是： 检查服务器是否允许发送此类通知，如果不允许就返回 是否允许发送键空间通知（4.1提到的情况1），允许就发送 是否允许发送键事件通知（4.2提到的情况2），允许就发送","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"}]},{"title":"Redis设计与实现2-对象","slug":"Redis设计与实现2-对象","date":"2020-01-03T03:01:39.000Z","updated":"2020-01-07T12:47:04.000Z","comments":true,"path":"2020/01/03/Redis设计与实现2-对象/","link":"","permalink":"jiangren.work/2020/01/03/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B02-%E5%AF%B9%E8%B1%A1/","excerpt":"前一章介绍了Redis的主要数据结构，但Redis并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统","text":"前一章介绍了Redis的主要数据结构，但Redis并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统 ，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象。 使用对象有两个好处： 执行命令前，根据对象类型来判断是否可以执行此命令。 针对不同使用场景，为对象设置多种不同的数据结构实现，达到优化的目的。 此外，对象系统还引入了引用计数实现内存回收机制，以及对象共享。 1. 对象的类型与编码Redis 中的每个键值对的键和值都是一个对象，每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性： typedef struct redisObject { // 类型 unsigned type:4; // 编码 unsigned encoding:4; // 指向底层实现数据结构的指针 void *ptr; ... } robj; 结构体的冒号表示位域，表示该变量占用的二进制位数 对象的 type 属性记录了对象的类型，属性的值如下表所示： 类型常量 对象的名称 REDIS_STRING 字符串对象 REDIS_LIST 列表对象 REDIS_HASH 哈希对象 REDIS_SET 集合对象 REDIS_ZSET 有序集合对象 对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是上表中的其中一个。 所以，当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；同理，当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”。 对象的 ptr 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 encoding 属性决定。encoding 属性如下表所示： 编码常量 编码所对应的底层数据结构 REDIS_ENCODING_INT long 类型的整数 REDIS_ENCODING_EMBSTR embstr 编码的简单动态字符串 REDIS_ENCODING_RAW 简单动态字符串 REDIS_ENCODING_HT 字典 REDIS_ENCODING_LINKEDLIST 双端链表 REDIS_ENCODING_ZIPLIST 压缩列表 REDIS_ENCODING_INTSET 整数集合 REDIS_ENCODING_SKIPLIST 跳跃表和字典 2. 字符串对象2.1 编码方式字符串对象的编码可以是 int 、 raw 或者 embstr 。 （1）如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。 （2）如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。 （3）如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。 embstr 编码是专门用于保存短字符串的一种优化编码方式。这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象，区别在于： raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构。 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间。 由于减少了内存分配的次数，以及将零散的内存整合到一起，这种编码的字符串对象比起 raw 编码能够更好地利用缓存带来的优势。 如果保存浮点数，则会先转化为字符串类型保存。比如保存3.14就会先转化为&quot;3.14&quot;。下表是值和对应的编码类型 值 编码 可以用 long 类型保存的整数。 int 可以用 long double 类型保存的浮点数。 embstr 或者 raw 字符串值，长度太大没办法用 long 类型表示的整数。 embstr 或者 raw 2.2 编码转换编码之间也会有互相转换的情况。对于 int 编码的字符串对象来说，如果因为命令导致这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw 。 redis&gt; SET number 10086 OK redis&gt; OBJECT ENCODING number &quot;int&quot; redis&gt; APPEND number &quot; is a good number!&quot; (integer) 23 redis&gt; GET number &quot;10086 is a good number!&quot; redis&gt; OBJECT ENCODING number &quot;raw&quot; 因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 ， 所以 embstr 编码的字符串对象实际上是只读的。当修改embstr 编码的字符串对象， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令。 redis&gt; SET msg &quot;hello world&quot; OK redis&gt; OBJECT ENCODING msg &quot;embstr&quot; redis&gt; APPEND msg &quot; again!&quot; (integer) 18 redis&gt; OBJECT ENCODING msg &quot;raw&quot; 3. 列表对象3.1 编码方式列表对象的编码可以是 ziplist 或者 linkedlist。 如同前面提到的，压缩列表每个节点(entry)只保存一个列表元素。下面例子中，我们输入数字1，字符”three”和数字5， redis&gt; RPUSH numbers 1 &quot;three&quot; 5 (integer) 3 如果使用的不是 ziplist 编码， 而是 linkedlist双端链表 编码， 那么 这其实是一个嵌套编码，Redis使用了一个带有 StringObject 来表示一个字符串对象，编码方式如同上面提到的那三种。如果编码对象时字符串值，展开后就是： 3.2 编码转换当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码： 列表对象保存的所有字符串元素的长度都小于 64 字节； 列表对象保存的元素数量小于 512 个； 当上述条件任意一个不满足时，就会执行转换操作： 原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面， 对象的编码也会从 ziplist 变为 linkedlist 。 4. 哈希对象4.1 编码方式哈希对象的编码可以是 ziplist 或者 hashtable 。 ziplist 编码时，每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此： 保存了同一键值对的两个节点总是紧挨在一起， 键前值后。 先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。 比如： redis&gt; HSET profile name &quot;Tom&quot; (integer) 1 redis&gt; HSET profile age 25 (integer) 1 redis&gt; HSET profile career &quot;Programmer&quot; (integer) 1 hashtable 编码时， 哈希对象中的每个键值对都使用一个字典键值对来保存： 字典的每个键都是一个字符串对象， 对象中保存了键值对的键； 字典的每个值都是一个字符串对象， 对象中保存了键值对的值。 比如，上面的例子改为hashtable 编码 4.2 编码转换当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码： 哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节； 哈希对象保存的键值对数量小于 512 个； 和列表对象一样，不满足条件时原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面， 对象的编码也会从 ziplist 变为 hashtable 。 5. 集合对象Redis中集合和列表结构相似，但集合具有唯一性，列表不具有。 5.1 编码方式集合对象的编码可以是 intset 或者 hashtable 。 intset 编码时，元素将被密集得堆叠在位上，比如 redis&gt; SADD numbers 1 3 5 (integer) 3 另一方面， hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL 。 5.2 编码的转换当集合对象可以同时满足以下两个条件时， 对象使用 intset 编码： 集合对象保存的所有元素都是整数值； 集合对象保存的元素数量不超过 512 个； 当使用 intset 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在整数集合中的所有元素都会被转移并保存到字典里面， 并且对象的编码也会从 intset 变为 hashtable 。 6. 有序集合对象6.1 编码方式有序集合的编码可以是 ziplist 或者 skiplist 。 ziplist 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。 redis&gt; ZADD price 8.5 apple 5.0 banana 6.0 cherry (integer) 3 skiplist 编码的有序集合对象使用 zset 结构作为底层实现， 一个 zset 结构同时包含一个字典和一个跳跃表： typedef struct zset { zskiplist *zsl; dict *dict; } zset; 起作用主要是跳跃表，字典是辅助加速用。字典的键记录了元素的成员，而值则保存了元素的分值。通过字典，能实现$O(1)$复杂度的查找给定成员分值。 有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 double 类型的浮点数。 虽然 zset 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。 6.2 编码转换当有序集合对象可以同时满足以下两个条件时， 对象使用 ziplist 编码： 有序集合保存的元素数量小于 128 个； 有序集合保存的所有元素成员的长度都小于 64 字节； 不能满足以上两个条件的有序集合对象将使用 skiplist 编码。 7. 内存回收、对象共享和空转时长对象中包括了一个引用计数器： typedef struct redisObject { // ... // 引用计数 int refcount; // ... } robj; 对象的引用计数信息会随着对象的使用状态而不断变化： 在创建一个新对象时， 引用计数的值会被初始化为 1 ； 当对象被引用时，计数值+1； 当对象不再被引用时，计数值-1； 当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。 函数 作用 incrRefCount 将对象的引用计数值增一。 decrRefCount 将对象的引用计数值减一， 当对象的引用计数值等于 0 时， 释放对象。 resetRefCount 将对象的引用计数值设置为 0 ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。 通过引用机制，还能实现对象共享。共享只针对整数值对象，不针对包含字符串的对象。 假设键 A 创建了一个包含整数值 100 的字符串对象作为值对象， 如果这时键 B 也要创建一个同样保存了整数值 100 的字符串对象作为值对象， 那么服务器有以下两种做法： 为键 B 新创建一个包含整数值 100 的字符串对象； 让键 A 和键 B 共享同一个字符串对象； 以上两种方法很明显是第二种方法更节约内存。在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤： 将数据库键的值指针指向一个现有的值对象； 将被共享的值对象的引用计数增一。 Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。 为什么 Redis 不共享包含字符串的对象？ 判断是否共享时要检验共享对象和目标对象是否相同。复杂度如下， 共享对象 复杂度 保存整数值字符串对象 $O( 1)$ 保存字符串值的字符串对象 $O(N)$ 包含了多个值的对象（列表或哈希） $O(N^2)$ redisObject 结构包含的最后一个属性为 lru 属性， 该属性记录了对象最后一次被命令程序访问的时间： typedef struct redisObject { // ... unsigned lru:22; // ... } robj; OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的： redis&gt; SET msg &quot;hello world&quot; OK # 等待一小段时间 redis&gt; OBJECT IDLETIME msg (integer) 20 注意OBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 lru 属性。这类似于std::weak_ptr的作用。 当内存满时，空转时长较长的键会被优先释放。","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"}]},{"title":"Redis设计与实现1-数据结构","slug":"Redis设计与实现1-数据结构","date":"2020-01-02T02:30:29.000Z","updated":"2020-01-07T12:47:02.000Z","comments":true,"path":"2020/01/02/Redis设计与实现1-数据结构/","link":"","permalink":"jiangren.work/2020/01/02/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"由于C语言的缺陷，Redis自身创建了许多有用的数据结构，包括：简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表。","text":"由于C语言的缺陷，Redis自身创建了许多有用的数据结构，包括：简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表。 1. 简单动态字符串传统C语言的字符串以空字符结尾，而Redis自己重新构建了一种新的字符串结构，命名为简单动态字符串(simple dynamic string, SDS)。 在Redis中，C字符串只会用在一些无须修改的地方，比如打印常量： redisLog(REDIS_WARNING,&quot;Redis is now ready to exit, bye bye...&quot;); 如果是需要修改的地方，会使用SDS来表示： redis&gt; RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot; (integer) 3 Redis 将在数据库中创建一个新的键值对，其中： key是一个字符串对象，底层保存了一个字符串fruits的SDS。 value是一个列表对象，列表包含了三个字符串对象，由SDS实现。 1.1 SDS的定义SDS是一个结构体，定义在sds.h/sdshdr中 struct sdshdr { // 记录 buf 数组中已使用字节的数量 // 等于 SDS 所保存字符串的长度 int len; // 记录 buf 数组中未使用字节的数量 int free; // 字节数组，用于保存字符串 char buf[]; }; 下面给出了一个示例，free为0代表所有空间都被使用，len长度为5，表示SDS保存的字符串长度为5，buf就是字符串实体。 保存空字符的1字节空间不计算在len属性内。遵循空字符结尾这一惯例的好处是， SDS 可以直接重用一部分 C 字符串函数库里面的函数。 比如我们不需要对SDS专门设置打印函数。 printf(&quot;%s&quot;,s-&gt;buf); 1.2 SDS 与 C 字符串的区别C 语言使用的简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求。主要有以下几个弊端。 （1）C字符串获取长度的能力有限 C字符串需要依靠遍历获取长度，时间复杂度$O(N)$，而SDS本身记录了len，所以时间复杂度$O (1)$，常数时间。 （2）杜绝缓冲区溢出 由于C字符串不记录长度，当我们拼接两个字符串的时候，容器可能因为空间不足发生溢出。redis中的sdscat将在执行拼接操作前检查长度是否充足，若不足则先拓展空间，再拼接。 （3）减少修改字符串时带来的内存重分配次数 C字符串类似于数组，每次修改大小都会重新分配以此内存。Redis的分配原理类似于std::vector，通过空间预分配的办法优化字符串增加，分配规则如下： 若len比较小（小于1MB），则free是len一样大。如果修改后len为13字节，则free也为13字节，buf实际长度为13+13+1=27字节。 若len比较大（大于1MB），则每次free只会有1MB，比如修改后len为30MB，则free为1MB，总长度为30MB+1MB+1byte。 此外，使用惰性空间释放来优化字符串缩短。当缩短时，将释放的空间放入free中保存起来，等待使用。 （4）二进制安全 C字符串以空字符\\0结尾，使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。我们希望有一种使用空字符来分割多个单词的特殊数据格式。换句话说，数据写入时什么样，读取时就是什么样。 SDS利用len来判断是否结束，而不是空字符\\0 2. 链表链表随机读写能力差，但增删和重排能力较强。C语言没有链表结构，所以Redis自制了一个。 链表节点定义在adlist.h/listNode，如下： typedef struct listNode { // 前置节点 struct listNode *prev; // 后置节点 struct listNode *next; // 节点的值 void *value; } listNode; 这是一个双端链表。 虽然可以多个Node组成链表，但是为了方便，Redis设计了adlist.h/list 来持有链表。 typedef struct list { // 表头节点 listNode *head; // 表尾节点 listNode *tail; // 链表所包含的节点数量 unsigned long len; // 节点值复制函数 void *(*dup)(void *ptr); // 节点值释放函数 void (*free)(void *ptr); // 节点值对比函数 int (*match)(void *ptr, void *key); } list; Redis 的链表实现的特性可以总结如下： 双端 无环，表头和结尾都指向NULL 带有表头表位指针，访问$ O (1)$ 自带链表长度计数器 多态：使用void*来保存节点值，有泛型编程内味了。 3. 字典在字典中， 一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些关联的键和值就被称为键值对。字典中的每个键必须保证都是独一无二的。C并没有这样的结构，所以Redis自己实现了。 3.1 字典的实现Redis 字典所使用的哈希表由 dict.h/dictht 结构定义： typedef struct dictht { // 哈希表数组 dictEntry **table; // 哈希表大小 unsigned long size; // 哈希表大小掩码，用于计算索引值 // 总是等于 size - 1 unsigned long sizemask // 该哈希表已有节点的数量 unsigned long used; } dictht; table 是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针。 哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对： typedef struct dictEntry { // 键 void *key; // 值 union { void *val; uint64_t u64; int64_t s64; } v; // 指向下个哈希表节点，形成链表 struct dictEntry *next; } dictEntry; v 属性则保存着键值对中的值， 值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。 next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。 下图中，键的索引值都是2，通过链表的形式完成了冲突的规避。 上面提到的是哈希表和哈希表节点的实现，现在来说真正的字典结构。Redis 中的字典由 dict.h/dict 结构表示： typedef struct dict { // 类型特定函数 dictType *type; // 私有数据 void *privdata; // 哈希表 dictht ht[2]; // rehash 索引 // 当 rehash 不在进行时，值为 -1 int rehashidx; /* rehashing not in progress if rehashidx == -1 */ } dict; 其中type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的。 type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数。 privdata 属性则保存了需要传给那些类型特定函数的可选参数。 typedef struct dictType { // 计算哈希值的函数 unsigned int (*hashFunction)(const void *key); // 复制键的函数 void *(*keyDup)(void *privdata, const void *key); // 复制值的函数 void *(*valDup)(void *privdata, const void *obj); // 对比键的函数 int (*keyCompare)(void *privdata, const void *key1, const void *key2); // 销毁键的函数 void (*keyDestructor)(void *privdata, void *key); // 销毁值的函数 void (*valDestructor)(void *privdata, void *obj); } dictType; 哈希表数组ht包含了两个元素， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。 除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。 下图展示了一个普通状态下（没有rehash）的字典 3.2 哈希算法 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。 Redis 计算哈希值和索引值的方法如下： // 使用字典设置的哈希函数，计算键 key 的哈希值 hash = dict-&gt;type-&gt;hashFunction(key); // 使用哈希表的 sizemask 属性和哈希值，计算出索引值 // 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1] index = hash &amp; dict-&gt;ht[x].sizemask; 举个例子，假如想要将键值对k0 和 v0 添加到下面的字典中。 假设计算出的hash值是8，则index为 index = hash &amp; dict-&gt;ht[0].sizemask = 8 &amp; 3 = 0; 至于Redis的哈希值计算方法，使用的是 MurmurHash2。这种算法的优点在于， 即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。 3.3 Rehash随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。 再哈希的关键在于重新分配哈希表的大小，分配的原则如下： 如果执行拓展操作ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 $2^n$，比如原表大小为4，则 ht[0].used * 2结果为8，而8刚好是$2^3$，所以新的大小是8。 如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的$2^ n$ 完成分配后，将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面，然后 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。 决定是否再Hash的要素来自于负载因子，计算方法如下： //负载因子 = 哈希表已保存节点数量 / 哈希表大小 load_factor = ht[0].used / ht[0].size 3.4 渐进式Rehash如果键值对很多，则将ht[0]重新hash到ht[1]上，则会导致服务器在一段时间内停止服务。为了避免这种问题，需要分多次渐进式的慢慢映射。 关键点在于维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。 在 rehash 进行期间， 每次对字典执行增删改查， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。 完成后程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。 渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个增删改查上， 从而避免了集中式 rehash 而带来的庞大计算量。 4. 跳跃表4.1 什么是跳跃表我们知道链表随机读写的能力很差，当增删改查的时候，如果要找到目标元素就需要遍历链表。假设某个数据结构是有序的，我们就会想到用二分法来快速查找，但链表是没有索引的，所以我们需要添加。 可以继续向上拓展层数： 但是我们的链表不是静态的，增加和删除会破坏二分结构，所以我们就不强制要求 1:2 了，一个节点要不要被索引，建几层的索引，都在节点插入时由随机决定。 现在假设节点 17 是最后插入的，在插入之前，我们需要搜索得到插入的位置： 4.2 跳跃表的实现Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。 在zskiplist中level 记录目前跳跃表内最大层数（表头不算），length记录包含的节点数量（表头不算）。 zskiplistNode 结构包含以下属性： 层：每一层有两个属性 前进指针用于访问位于表尾方向的其他节点 跨度则记录了前进指针所指向节点和当前节点的距离。 后退指针(bw)：指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。 分值(score)：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。用于从小到大排列。如果分值相同，则成员对象小的排在前面。 成员对象（obj）：各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。 typedef struct zskiplistNode { // 后退指针 struct zskiplistNode *backward; // 分值 double score; // 成员对象 robj *obj; // 层 struct zskiplistLevel { // 前进指针 struct zskiplistNode *forward; // 跨度 unsigned int span; } level[]; } zskiplistNode; （1）层 每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。 下图展示了三个高度为 1 层、 3 层和 5 层的节点 （2）前进指针 前进指针分属于不同的层，level[i].forward，用于从表头向表尾方向访问节点。 （3）跨度 跨度也分属不同的层，指向 NULL 的所有前进指针的跨度都为 0， 因为它们没有连向任何节点。 跨度实际上是用来计算位次（rank）的： 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。 下图的例子中，查找分值为3.0的节点，由于只经过了一个层，跨度为3，所以跳跃表中的排位为3。 使用一个 zskiplist 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理。 typedef struct zskiplist { // 表头节点和表尾节点 struct zskiplistNode *header, *tail; // 表中节点的数量 unsigned long length; // 表中层数最大的节点的层数 int level; } zskiplist; 5. 整数集合当一个集合中只包含整数，并且元素的个数不是很多的话，redis 会用整数集合作为底层存储，它可以节省很多内存。 5.1 整数集合的实现整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。 每个 intset.h/intset 结构表示一个整数集合： typedef struct intset { // 编码方式 uint32_t encoding; // 集合包含的元素数量 uint32_t length; // 保存元素的数组 int8_t contents[]; } intset; contents 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 从小到大有序地排列，不包含任何重复项。 虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值： encoding 为 INTSET_ENC_INT16，int16_t 类型的数组，范围$[-2^{16},2^{16}-1]$ encoding INTSET_ENC_INT32 ， 是一个 int32_t 类型的数组。 encoding 为 INTSET_ENC_INT64 ， 是一个 int64_t 类型的数组 下图展示了一个示例： 5.2 升级每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合元素的类型长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。 过程如下： 根据新类型，扩展整数集合底层数组的空间大小， 并为新元素分配空间 将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素有序放置。 将新元素添加到底层数组里面。 假设想要在16位编码的intset中插入32位的65535数据，原来的集合是这样的： 需要扩容为$32\\times4=128$位，新intset结构会扩容成这样： 剩下就需要对元素重排。 先将3移动到新intset结构的索引2的位置上，然后将2移动到索引1的位置，然后将1移动到索引0的位置。最后再讲65535移动到索引3的位置。 5.3 降级整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。 即使我们将集合里唯一一个真正需要使用 int64_t 类型来保存的元素 4294967295 删除了， 整数集合的编码仍然会维持 INTSET_ENC_INT64。 6. 压缩列表压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值或长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。 6.1 压缩列表的构成压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。 属性 类型 长度 作用 zlbytes uint32_t 4字节 整个压缩列表占用内存字节数 zltail uint32_t 4字节 记录表尾节点距离表起始地址有多少个字节 zllen uint16_t 2字节 记录节点数量 entryX 不定 节点 zlend uint8_t 1字节 用于标记末端 下面展示了一个例子： zlbytes 属性的值为 0x50 （十进制 80）， 表示压缩列表的总长为 80 字节。 zltail 属性的值为 0x3c （十进制 60），如果一个指向压缩列表起始地址的指针 p ， 那么只要用指针 p 加上偏移量 60 ， 就可以计算出表尾节点 entry3 的地址。 zllen 属性的值为 0x3 （十进制 3）， 表示压缩列表包含三个节点。 6.2 压缩列表的节点构成每个压缩列表节点可以保存一个字节数组或者一个整数值， 其中， 字节数组可以是以下三种长度的其中一种： 长度小于等于63($2^6-1$)字节的字节数组； 长度小于等于 16383 ($2^{14}-1$)字节的字节数组； 长度小于等于 4294967295 ($2^{32}-1$)字节的字节数组； 而整数值则可以是以下六种长度的其中一种： 4 位长，介于 0 至 12 之间的无符号整数； 1 字节长的有符号整数； 3 字节长的有符号整数； int16_t 类型整数； int32_t 类型整数； int64_t 类型整数。 每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成。 （1）previous_entry_length 以字节为单位， 记录了压缩列表中前一个节点的长度。这个属性的长度可以是1字节或5字节，如果前一个小于254则使用1字节，反之使用5字节（ 其中属性的第一字节会被设置为 0xFE（十进制值 254）， 而之后的四个字节则用于保存前一节点的长度） 程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。进而可以回溯到表头。 （2）encoding 节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度。编码由8位组成。 如果是字符类型，则开头两位00,01,10分别表示1字节，2字节，5字节，后6位表示字符串长度。 保存每个元素是1个字节的数组，长度11。 如果是整数类型，则开头必是11，然后从第6位开始往低位开始计数： 每个元素int16_t，值为10086 6.3 连锁更新每个节点的 previous_entry_length 属性都记录了前一个节点的长度： 如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性需要用 1 字节长的空间来保存这个长度值。 如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性需要用 5 字节长的空间来保存这个长度值。 假设现在有一些长度为252字节的节点，他们在previous_entry_length中保存为1字节。现在插入了一个260字节的新节点，new 将成为 e1 的前置节点。 因为 e1 的 previous_entry_length 属性仅长 1 字节， 它没办法保存新节点 new 的长度， 所以程序将对压缩列表执行空间重分配操作， 并将e1 节点的 previous_entry_length 属性从原来的 1 字节长扩展为 5 字节长。 由于previous_entry_length 的变化，导致e1的长度也发生了变化$252+4=256&gt;254$，所以导致e2也必须更新它的previous_entry_length 。这就是连锁更新。 除了添加节点外，删除节点也会导致连锁更新，若删除一个260字节的节点，则后一个节点长度也会变化。如果很不凑巧，小于254，则又会引起后序效应。 连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配操作， 而每次空间重分配的最坏复杂度为$O(N)$ ， 所以连锁更新的最坏复杂度为 $O(N^2)$ 。","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"},{"name":"数据结构","slug":"数据结构","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"CPP泛型编程4-可变参数模板","slug":"CPP泛型编程4-可变参数模板","date":"2019-12-30T05:48:06.000Z","updated":"2019-12-30T21:26:51.000Z","comments":true,"path":"2019/12/30/CPP泛型编程4-可变参数模板/","link":"","permalink":"jiangren.work/2019/12/30/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/","excerpt":"介绍泛型模板中的可变参数模板。","text":"介绍泛型模板中的可变参数模板。 1. 可变参数模板示例在C++11以后，模板可以接收任意数量的参数，因此被称作可变参数的模板(variadic templates). 下面展示一段非常精妙的代码： void print () {} // 没有参数时将调用此函数 template&lt;typename T, typename... Types&gt; void print (T firstArg, Types... args) { std::cout &lt;&lt; firstArg &lt;&lt; &#39; &#39;; // 打印第一个实参 print(args...); // 调用print()打印其余实参 } int main() { std::string s(&quot;world&quot;); print(3.14, &quot;hello&quot;, s); // 3.14 hello world } 这段代码采用了递归的办法进行打印，每次递归都会减少参数个数。需要注意 Types... args必须在三点后面打空格，有点类似于CV符，引用的那种感觉。 args...可以被视为一个打包的参数 每次进入print函数，都会将args...分为一个单一的firstArg和一个新的打包参数args... 必须要准备一个空函数以防止没有参数时将调用此函数 上例也可以如下实现，如果两个函数模板只有尾置参数包不同，会优先匹配没有尾置参数包的版本。 template&lt;typename T&gt; void print (T x) { std::cout &lt;&lt; x &lt;&lt; &#39; &#39;; } template&lt;typename T, typename... Types&gt; void print (T firstArg, Types... args) { print(firstArg); print(args...); } 3. sizeof…在C++11中，引入了一个新的sizeof...运算符来应对可变参数，它的形式非常有趣：这是一个由标点符号和字符共同组建的一个运算符，它的作用就是算出可变参数的数量： template&lt;typename T, typename... Types&gt; void print (T firstArg, Types... args) { std::cout &lt;&lt; sizeof...(args) &lt;&lt; &#39;\\n&#39;; // print number of remaining args } 你可能会想到利用这个特性来处理前面的例子中比较麻烦的递归结尾，但这样会报错：实例化后的代码是否能发挥作用是在运行时决定，而实例化的调用是否合法是编译时决定。听起来有点绕，简单来说就是模板编译时，会无视if里面的判断条件，实例化print，直到出现print( )里面为空的情况。然后就是报错。 template&lt;typename T, typename... Types&gt; void print (T firstArg, Types... args) { std::cout &lt;&lt; firstArg &lt;&lt; &#39;\\n&#39;; if (sizeof...(args) &gt; 0) { // sizeof...(args)==0时会出错 print(args...); // 因为print(args...)仍将被初始化，而此时没有实参 } } 4. 折叠表达式C++17新引入的语法糖，非常有用，值得学习！ 折叠表达式的作用就是：使用二元运算符计算剩余参数包里面的参数。举个例子： template&lt;typename... T&gt; auto foldSum (T... s) { return (... + s); // ((s1 + s2) + s3) ... } 注意一下如果参数包为空，则表达式会被判定为非法。 折叠表达式的运算规则如下： foldSum(1, 2, 3, 4, 5); // 假如实参是12345 (... + s)：((((1 + 2) + 3) + 4) + 5) (s + ...)：(1 + (2 + (3 + (4 + 5)))) (0 + ... + s)：(((((0 + 1) + 2) + 3) + 4) + 5) (s + ... + 0)：(1 + (2 + (3 + (4 + (5 + 0))))) 除了上面的求和，求累积外，还有其他用法。 struct Node { int val; Node* left; Node* right; Node(int i = 0) : val(i), left(nullptr), right(nullptr) {} }; template&lt;typename T, typename... Ts&gt; Node* traverse(T root, Ts... paths) { return (root -&gt;* ... -&gt;* paths); // root -&gt;* paths1 -&gt;* paths2 ... } void main() { Node* node2 = traverse(root, left, right); //左子节点，左子节点的右子节点 } （2）使用折叠表达式简化打印所有参数的可变参数模板 template&lt;typename... Ts&gt; void print(const Ts&amp;... args) { (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; &#39;\\n&#39;; } 如果想用空格分隔参数包元素，需要使用一个包裹类来提供此功能 template&lt;typename T&gt; class AddSpace { const T&amp; ref; // 构造函数中的实参的引用 public: AddSpace(const T&amp; r): ref(r) {} friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; os, AddSpace&lt;T&gt; s) { return os &lt;&lt; s.ref &lt;&lt; &#39; &#39;; // 输出传递的实参和一个空格 } }; template&lt;typename... Args&gt; void print(Args... args) { (std::cout &lt;&lt; ... &lt;&lt; AddSpace(args)) &lt;&lt; &#39;\\n&#39;; } 5. 可变参数表达式前面说到可变参数的本质也是参数，既然如此我们就可以针对他进行相关的运算。 比如比如让每个元素翻倍后传递给再打印： template&lt;typename... Args&gt; void print(const Args&amp;... args) { (std::cout &lt;&lt; ... &lt;&lt; args); } template&lt;typename... T&gt; void printDoubled (const T&amp;... args) { print (args + args...); } 注意参数包的省略号不能直接接在数值字面值后: template&lt;typename... T&gt; void addOne(const T&amp;... args) { print (args + 1...); // 错误 1...是带多个小数点的字面值，不合法 print (args + 1 ...); // OK print ((args + 1)...); // OK } 6. 可变参数索引以索引形式访问： template&lt;typename... Args&gt; void print(const Args&amp;... args) { (std::cout &lt;&lt; ... &lt;&lt; args); } template&lt;typename C, typename… Idx&gt; void printElems (C const&amp; coll, Idx… idx) { print (coll[idx]…); } int main() { std::vector&lt;std::string&gt; v{ &quot;good&quot;, &quot;times&quot;, &quot;say&quot;, &quot;bye&quot; }; printElems(v, 2, 0, 3); // say good bye：等价于print(v[2], v[0], v[3]); } 非类型模板参数也可以声明为参数包: template&lt;std::size_t... N, typename C&gt; void printIdx(const C&amp; c) { print(c[N]...); } std::vector&lt;std::string&gt; v{ &quot;good&quot;, &quot;times&quot;, &quot;say&quot;, &quot;bye&quot; }; printIdx&lt;2, 0, 3&gt;(v);","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"CPP泛型编程3-非类型的模板参数","slug":"CPP泛型编程3-非类型的模板类参数","date":"2019-12-30T02:57:58.000Z","updated":"2019-12-30T21:25:44.000Z","comments":true,"path":"2019/12/30/CPP泛型编程3-非类型的模板类参数/","link":"","permalink":"jiangren.work/2019/12/30/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B3-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0/","excerpt":"在模板中使用非类型参数。","text":"在模板中使用非类型参数。 1. 非类型的类模板参数在类的模板参数列表中，不一定是都是类型，或者适配器，也可以是一个数。 我们可以通过非类型的类模板指定固定长度的栈，这样做的好处是避免动态的内存管理。下面的代码中，我们通过指定Maxsize来创建array从而进一步固化内存，限制栈的长度。 template&lt;typename T, std::size_t Maxsize&gt; class Stack { std::array&lt;T, Maxsize&gt; v; std::size_t n; public: Stack(); void push(const T&amp;); void pop(); const T&amp; top() const; bool empty() const { return n == 0; } std::size_t size() const { return n; } }; //使用 Stack&lt;int, 20&gt; intStack; // 20个int的Stack 当我们在使用的时候，需要针对Maxsize来做一些改善，比如在push时，就需要考虑上限问题，同时也要更新参数。 template&lt;typename T, std::size_t Maxsize&gt; void Stack&lt;T, Maxsize&gt;::push(const T&amp; x) { assert(n &lt; Maxsize); // 确定Stack未满 v[n] = x; ++n; } 2. 非类型的函数模板参数你也可以在函数模板中直接定义参数，比如： template&lt;int val, typename T&gt; T addvalue(T x) { return x+Val; } 可以用来作函数的谓语，和lambda表达式一样（虽然我觉得并没有lambda好用） std::vector&lt;int&gt; v{ 0, 1, 2}; std::vector&lt;int&gt; v2(3); std::transform(v.begin(), v.end(), v2.begin(), addValue&lt;1, int&gt;); for (auto x : v2) std::cout &lt;&lt; x; // 123 在C++17中允许将非类型模板参数定义为auto，以接收任何允许作为非类型模板参数的类型。 emplate&lt;typename T, auto Maxsize&gt; class Stack { std::array&lt;T, Maxsize&gt; v; size_type n; public: using size_type = decltype(Maxsize); Stack(); void push(const T&amp;); void pop(); const T&amp; top() const; bool empty() const { return n == 0; } size_type size() const { return n; } }; C++14中允许auto作为返回类型: // 如果在类外定义size成员函数要写为 template &lt;typename T, auto Maxsize&gt; typename Stack&lt;T, Maxsize&gt;::size_type Stack&lt;T, Maxsize&gt;::size() const { return n; } // C++14中可写为 template &lt;typename T, auto Maxsize&gt; auto Stack&lt;T, Maxsize&gt;::size() const { return n; }","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"CPP泛型编程2-类模板","slug":"CPP泛型编程2-类模板","date":"2019-12-29T11:57:46.000Z","updated":"2019-12-30T21:24:45.000Z","comments":true,"path":"2019/12/29/CPP泛型编程2-类模板/","link":"","permalink":"jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B2-%E7%B1%BB%E6%A8%A1%E6%9D%BF/","excerpt":"泛型编程中对类使用模板。","text":"泛型编程中对类使用模板。 1. 简单使用类模板以stack为例，展示类模板的特性，先写出一个stack的样例。与函数模板一样，类模板也需要在前面加上模板声明。需要注意的是，类的成员函数的实现可以不放在类中，放在外面也需要加上模板声明。 template &lt;typename T&gt; class stack{ private: vector&lt;T&gt; elems; public: void push(T const&amp; elem); void pop(); T const&amp; top(); bool empty(){return elems.empty()}; }; template&lt;typename T&gt; void stack&lt;T&gt;::push(T const&amp; elem) { elems.push_back(elem); } template&lt;typename T&gt; void stack&lt;T&gt;::pop() { assert(!elems.empty()); elems.pop_back(); } template&lt;typename T&gt; T const&amp; stack&lt;T&gt;::top() { assert(!elems.empty()); return elems.back(); } 我们可以继续为其添加拷贝构造函数和赋值运算符： stack(stack&lt;T&gt; const&amp;); stack&lt;T&gt;&amp; operator=(stack&lt;T&gt; const&amp;); 通过上面这个例子，我们熟悉类类模板的一些特性。使用类模板时必须要 显式地特化模板参数(specify the template arguments explictly) Stack&lt; int&gt; intStack;// stack of ints Stack&lt;std::string&gt; stringStack; // stack of string 当然也可以使用using或typedef来简化： using IntStack = Stack&lt;int&gt;; typedef Stack&lt;int&gt; IntStack 类模板可以实现部分使用(partial usage)，这意味着模板参数只需要提供必要的操作，而不是所有。下面这个例子中模板类stack中包含了一个printOn函数，而pair类型不能与printOn相适应，但我们依然可以创建并执行一些必要的操作，但不能使用printOn.（因为无法使用操作符&lt;&lt;） template&lt;typename T&gt; class Stack { ... void printOn(std::ostream&amp;) const; }; template &lt;typename T&gt; void Stack&lt;T&gt;::printOn(std::ostream&amp; os) const { for (const T&amp; x : v) os &lt;&lt; x &lt;&lt; &#39; &#39;; } Stack&lt;std::pair&lt;int, int&gt;&gt; s; // std::pair没有定义operator&lt;&lt; s.push({1, 2}); // OK s.push({3, 4}); // OK std::cout &lt;&lt; s.top().first &lt;&lt; s.top().second; // 34 s.printOn(std::cout); // 错误：元素类型不支持operator&lt;&lt; 类模板也可以使用默认实参。当然这并不意味着传入的参数被强制规定为std::vector，而是作为一种选择，&lt;Stack&gt; doubleStack;这样依然是ok的。 template&lt;typename T, typename Cont = std::vector&lt;T&gt;&gt; class Stack { private: Cont v; public: void push(const T&amp; x); void pop(); const T&amp; top() const; bool empty() const; }; 2. 友元假设我们重载&lt;&lt;运算符来替代printOn函数： template&lt;typename T&gt; class Stack { ... void printOn(std::ostream&amp; os) const { for (const T&amp; x : v) os &lt;&lt; x &lt;&lt; &#39; &#39;; } friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Stack&lt;T&gt;&amp; stack) { stack.printOn(os); return os; } }; 但是，如果将友元的定义和实现放在类外就会出一些问题： template&lt;typename T&gt; class Stack { ... friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Stack&lt;T&gt;); }; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Stack&lt;T&gt;&amp; stack) // 错误：类模板参数T不可见 { stack.printOn(os); return os; } 由于友元并不属于这个类，所以没法享受到类型推导的成果，自然就会报错。这个问题的解决方案有很多，我挑选了一种我认为比较好的办法：隐式声明一个新的函数模板，并使用不同的模板参数 template&lt;typename T&gt; class Stack { … template&lt;typename U&gt; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Stack&lt;U&gt;&amp;); }; // 类外定义 template&lt;typename U&gt; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Stack&lt;U&gt;&amp; stack) { stack.printOn(os); return os; } 3. 特化与偏特化特化(specify)，可以直接指定模板的类型，标志是template&lt;&gt;。由于是直接指定的方式，所以声明模板类型时就不必要再添东西了。 template&lt;&gt; class Stack&lt;std::string&gt; { std::deque&lt;std::string&gt; v; public: void push(const std::string&amp;); void pop(); std::string const&amp; top() const; bool empty() const; }; void Stack&lt;std::string&gt;::push(const std::string&amp; x) { v.emplace_back(x); } 在上面的例子中，我们直接指定stack为string类型。注意在类外定义的时候，也必须带上string。 偏特化(partial specify)，在已经声明某一个模板的前提下，再对他进行声明。 （1）指定指针 #include &quot;stack1.h&quot; //非常重要 template&lt;typename T&gt; class Stack&lt;T*&gt; { std::vector&lt;T*&gt; v; public: void push(T*); T* pop(); T* top() const; bool empty() const; }; template&lt;typename T&gt; void Stack&lt;T*&gt;::push(T* x) { v.emplace_back(x); } ... Stack&lt; int*&gt; ptrStack; //用法展示 ptrStack.push(new int{42}); 必须要在stack1.h中声明成如下形式，否则无法通过编译。 template&lt;typename T,typename M&gt; class Stack { }; （2）指定部分模板参数 template&lt;typename T1, typename T2&gt; class A {}; // 偏特化：两个模板参数有相同类型 template&lt;typename T&gt; class A&lt;T, T&gt; {}; // 偏特化：第二个模板参数类型为int template&lt;typename T&gt; class A&lt;T, int&gt; {}; // 偏特化：两个模板参数都是指针类型 template&lt;typename T1, typename T2&gt; class A&lt;T1*, T2*&gt; {}; A&lt;int, double&gt; a; // A&lt;T1, T2&gt; A&lt;double, float&gt; b; // A&lt;T, T&gt; A&lt;double, int&gt; c; // A&lt;T, int&gt; A&lt;int*, double*&gt; d; // A&lt;T1*, T2*&gt; 要注意避免歧义性错误： A&lt;int, int&gt; e; // 错误：同时匹配A&lt;T, T&gt;和A&lt;T, int&gt; A&lt;int*, int*&gt; f; // 错误：同时匹配A&lt;T, T&gt;和A&lt;T1*, T2*&gt; 4. 模板化聚合当一个类的对象拥有另一个类的对象时就发生类聚合。这种聚合不依赖与继承、友元等关系存在。 struct C { int a; }; struct D { double b; C c; }; 事实上，聚合类也能作为模板存在： template&lt;typename T&gt; struct A { T x; std::string s; }; 这样可以为了参数化值而定义一个聚合: A&lt;int&gt; a; a.x = 42; a.s = &quot;initial value&quot;;","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"EffectiveModernCPP笔记8-并发API","slug":"EffectiveModernCPP笔记8-并发API","date":"2019-12-29T04:42:49.000Z","updated":"2019-12-30T21:07:26.000Z","comments":true,"path":"2019/12/29/EffectiveModernCPP笔记8-并发API/","link":"","permalink":"jiangren.work/2019/12/29/EffectiveModernCPP%E7%AC%94%E8%AE%B08-%E5%B9%B6%E5%8F%91API/","excerpt":"介绍并发的注意事项。","text":"介绍并发的注意事项。 写在前面：什么是同步函数与异步函数？ 同步函数：当一个函数是同步执行时，那么当该函数被调用时不会立即返回，直到该函数所要做的事情全都做完了才返回。 异步函数：如果一个异步函数被调用时，该函数会立即返回尽管该函数规定的操作任务还没有完成。 具体来说，当一个线程调用同步函数时（例如读文件），如果函数没有完成操作，则此线程会被挂起，直到该函数完成了规定的操作，这个线程才会被重新调度。 相反，当一个线程调用异步函数时，该函数会立即返回，即使当前的任务并没有完成，这样线程就会执行此异步函数之后的下一条语句。异步函数没做完的工作会通过另一个线程完成（可能是异步函数中新创建的，也可能是系统中已经准备好的） 异步函数执行完毕后，如何通知线程？ 调用线程需要使用等待函数来确定异步函数何时完成了任务。因此在线程调用异步函数之后立即调用一个“等待函数”挂起调用线程，一直等到异步函数执行完其所有的操作之后，再执行线程中的下一条指令。 异步调用与多线程的关系？ 操作系统把 CPU 处理时间划分成许多短暂时间片，在时间 T1 执行一个线程的指令，到时间 T2 又执行下一线程的指令，各线程轮流执行，结果好象是所有线程在并肩前进。这样，编程时可以创建多个线程，在同一期间执行，各线程可以“并行”完成不同的任务。 有了多线程的支持，可以采用异步调用，调用方和被调方可以属于两个不同的线程，调用方启动被调方线程后，不等对方返回结果就继续执行后续代码。被调方执行完毕后，通过某种手段通知调用方：结果已经出来，请酌情处理。 Item 35:Prefer task-based programming to thread based.通常来说要执行异步函数有两种选择： 创建一个thread int doAsyncWork(); std::thread t(doAsyncWork); 创建一个task auto fut = std::async(doAsyncWork); // &quot;fut&quot; for &quot;future&quot; task通常要比thread好，原因如下： 基于task的代码往往更少。 基于task更容易得到函数的返回值：调用future的get方法。 future的get方法还能拿到函数抛出的异常，而thread中如果函数抛了异常，进程就挂掉了。 易于实现调度均衡 通常来说，task好处的前三点比较好理解，第四点怎么理解呢？ 首先我们要搞清楚它们之间更本质的差别在于，基于task的方法有着更高的抽象层次，而无需关心底层的线程管理。下面是C++中”线程”的三种不同层次的概念： 硬件线程：真正的运算线程，目前每个CPU核可以提供一个或多个线程。比如，因特尔i7-8550U就是4核8线程架构。 软件线程（OS线程）：OS提供的线程，OS会负责管理和调度这些线程。通常OS线程可以远多于硬件线程。 std::thread：C++标准库提供的线程类，底层对应一个OS线程。这些情况下std::thread没有对应的OS线程：刚刚构造好时；已经调用过join；已经调用过detach。 创建过多的OS线程会导致系统过载，大量资源消耗在线程调度和切换上。避免系统过载是一件困难的事情，我们很难知道OS线程和硬件线程之间的合适比例。如果我们基于task来开发，把这些问题丢给task，丢给C++标准库，这样就能更好解决问题。 当然，std::async没办法解决GUI线程的问题，因为调度器不知道你的哪个线程对响应时间的要求最低。此时你可以指定std::launch::async来确保你的函数运行在另一个线程中。 Item 36:Specify std::launch::async if asynchronicity is essential.std::async有三种模式： std::launch::async：f必须异步执行，比如在另一个线程。写为std::async(std::launch::async,f) std::launch::deferred：f只在对应的future的get或wait被调用时才执行，且是同步执行。如果没有人调用对应的get或wait。 std::launch::async|std::launch::defered: 也可以写为std::async(f)。这是默认策略，有调度器自动决定是异步还是同步。 默认策略的问题在于： 无法预测f是否与当前线程并发执行，因为调度器有可能选择std::launch::deferred。 无法预测f是否在调用get或wait的另一个线程执行。 可能无法预测f是否会执行。 下面的代码可能会出现问题： using namespace std::literals; void f() { std::this_thread::sleep_for(1s); } auto fut = std::async(f); while (fut.wait_for(100ms) != std::future_status::ready) { ... } 如果f在另一个线程运行，则没有问题。如果f是deferred状态，则fut.wait_for就会一直返回std::future_status::deferred，导致循环永不结束。因为我们无法掌握调度器的状况，导致它有可能把它定为lauch或者deferred。 为了解决这个问题，最好检查future是不是deferred，如果是，就不进循环。但我们没办法直接询问future是不是deferred，需要用wait_for来绕一下： auto fut = std::async(f); if (fut.wait_for(0s) == std::future_status::deferred) { ... } else { while (fut.wait_for(100ms) != std::future_status::ready) { ... } ... } 上述场景的要点在于，当满足以下条件时，使用std::async的默认策略才是好的： task不需要与调用get或wait的线程并发执行。 无所谓访问哪个局部线程变量（TLS）。 要么能确保有人会调用future的get或wait，要么f执不执行都可以。 调用了wait_for或wait_until的代码要保证能处理deferred。 如果没办法保证以上几点，你需要确保你的task运行在另一个线程中，就指定std::launch::async： auto fut = std::async(std::launch::async, f); Item 37:Make std::threads unjoin able on all paths每个std::thread对象都处于两种状态下：可join、不可join。可join的std::thread对应一个可运行或运行中的底层线程，例如被阻塞、未调度或已运行完成的线程都是可join的。我们可以通过线程的成员函数joinable()来判断。这些情况下都是不可以join的： 默认构造状态的std::thread：不对应底层线程。 被移动过的std::thread：底层线程现在由其它std::thread管理。 已调用过join的std::thread：底层线程已结束。 已调用过detach的std::thread：detach会切断std::thread和底层线程的联系。 下面给一个例子： constexpr auto tenMillion = 10&#39;000&#39;000; bool doWork(std::function&lt;bool(int)&gt; filter, int maxVal = tenMillion) { std::vector&lt;int&gt; goodVals; std::thread t([&amp;filter, maxVal, &amp;goodVals] { for (auto i = 0; i &lt;= maxVal; ++i) { if (filter(i)) { goodVals.push_back(i); } } }); auto nh = t.native_handle(); // use t&#39;s native handle to set t&#39;s priority ... if (conditionsAreSatisfied()) { t.join(); performComputation(goodVals); // computation was performed return true; } return false; // computation was not performed } 这段代码我们用一个过滤器过滤一下容器，然后送入performComputation计算，由于我们需要取得线程的底层句柄来设置优先级，因此我们用thread而不是async。 上面这段代码，如果最后走到了false分支，或中间抛了异常，就会遇到构造了一个可join的std::thread的问题，程序就会终止。可以改进的一点是在开始设置t为暂停状态。 我们可以通过包装一个RAII类来实现所有情况下的std::thread都不可join。 class ThreadRAII { public: enum class DtorAction {join, detach}; ThreadRAII(std::thread&amp;&amp; t, DtorAction a) : action(a), t(std::move(t)) {} ~ThreadRAII() { if (t.joinable()) { if (action == DtorAction::join) { t.join(); } else { t.detach(); } } } std::thread&amp; get() {return t;} private: DtorAction action; std::thread t; }; 需要注意： 构造函数只接受std::thread的右值，因为std::thread只能移动不能复制。 在ThreadRAII的析构函数中，在调用t.join()或t.detach()前，需要先调用t.joinable()，因为有可能t已经被移动过了。 应用ThreadRAII到我们前面的代码中： bool doWork(std::function&lt;bool(int)&gt; filter, int maxVal = tenMillion) { std::vector&lt;int&gt; goodVals; ThreadRAII t( std::thread([&amp;filter, maxVal, &amp;goodVals] { for (auto i = 0; i &lt;= maxVals; ++i) { if (filter(i)) { goodVals.push_back(i); } } }), ThreadRAII::DtorAction::join ); auto nh = t.get().native_handle(); ... if (conditionsAreSatisfied()) { t.get().join(); performComputation(goodVals); return true; } return false; }","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"CPP泛型编程1-函数模板","slug":"CPP泛型编程1-函数模板","date":"2019-12-29T01:57:34.000Z","updated":"2019-12-30T21:24:05.000Z","comments":true,"path":"2019/12/29/CPP泛型编程1-函数模板/","link":"","permalink":"jiangren.work/2019/12/29/CPP%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/","excerpt":"泛型编程中，对函数使用模板。","text":"泛型编程中，对函数使用模板。 1. 基本概念函数模板的格式如下所示： template&lt;typename T&gt; T max (T a, T b) { return b &lt; a ? a : b; } 含义是一目了然的事情，但是需要注意： 传入的ab必须支持运算符&lt; ab必须是可以拷贝的，否则没法返回 具体的使用实例如下： template&lt;typename T&gt; T max (T a, T b) { return b &lt; a ? a : b; } int main() { int i = 42; std::cout &lt;&lt; ::max(1, i) &lt;&lt; &#39;\\n&#39;; double f1 = 3.14; double f2 = -3.14; std::cout &lt;&lt; ::max(f1, f2) &lt;&lt; &#39;\\n&#39;; std::string s1 = &quot;mathematics&quot;; std::string s2 = &quot;math&quot;; std::cout &lt;&lt; ::max(s1, s2) &lt;&lt; &#39;\\n&#39;; } 需要注意两点： 传入的参数类型必须一致，否则会报错，比如::max(5.5,1)，解决这个问题可以用::max(5.5,1)进行隐式转化 最好使用::标识符，确保函数max()是属于全局空间，避免和std::max()混淆 我们在编译时，把模板T推导为int的过程叫做实例化(instantiation)，而int这个具体的类型就叫做模板的实例(instance)。 同时需要注意void也是合法的模板参数之一！ template&lt;typename T&gt; T foo(T*) { } void* vp = nullptr; foo(vp); // OK: deduces void foo(void*) 另外一个很重要的点是模板的双重编译(Two-phase Translation)，实际上模板在编译检查时经历了两个阶段： 在没有实例化时，称为定义时(definition time)。这时编译器会主要检查语法错误，未定义行为，静态声明等等问题。 实例化时(instantiation time)，编译器会将模板实例带入重新检查一遍是否合法。 2. 参数推断这一部分原书讲的比较简单，其实”Effective Modern C++”讲的挺好的，我之前也做了笔记，这里我直接照搬那本书上的内容。 在做之前我们先明确几个术语，下面的示范代码包含了： param，形参 paramtype，形参的类型，这里是const T&amp; expr，实参，expression的缩写 CV符，const，volatile 引用符，&amp; template&lt;typename T&gt; void f(const T&amp; param); int expr = 0; f(expr); // call f with an int 然后我们分几种情况讨论： （1）左值引用 步骤： 忽略expr中paramtype包含的部分得到T 将T与paramtype配对的到param template&lt;typename T&gt; void f(T&amp; param); // param is a reference int x = 27; // x is an int const int cx = x; // cx is a const int const int&amp; rx = x; // rx is a reference to x as a const int f(x); // T is int, param&#39;s type is int&amp; f(cx); // T is const int, // param&#39;s type is const int&amp; f(rx); // T is const int, // param&#39;s type is const int&amp; ////////////////////////////// template&lt;typename T&gt; void f(const T&amp; param); // param is now a ref-to-const int x = 27; // as before const int cx = x; // as before const int&amp; rx = x; // as before f(x); // T is int, param&#39;s type is const int&amp; f(cx); // T is int, param&#39;s type is const int&amp; f(rx); // T is int, param&#39;s type is const int&amp; //////////////////////////////////// //指针也适用这个原则 template&lt;typename T&gt; void f(T* param); // param is now a pointer int x = 27; // as before const int *px = &amp;x; // px is a ptr to x as a const int f(&amp;x); // T is int, param&#39;s type is int* f(px); // T is const int, // param&#39;s type is const int* （2）右值引用 步骤： 如果expr是左值，T和param都被推为左值并加上引用(不管有没有统统加上引用符) 如果是右值，T不变，param加上&amp;&amp;。 示例： template&lt;typename T&gt; void f(T&amp;&amp; param); int x = 27; // as before const int cx = x; // as before const int&amp; rx = x; // as before f(x); // x is lvalue, so T is int&amp;, // param&#39;s type is also int&amp; f(cx); // cx is lvalue, so T is const int&amp;, // param&#39;s type is also const int&amp; f(rx); // rx is lvalue, so T is const int&amp;, // param&#39;s type is also const int&amp; f(27); // 27 is rvalue, so T is int, // param&#39;s type is therefore int&amp;&amp; （3）值传递 这就是最基本的值传递。意味着，param复制了一个传入的参数。他的哲学就是忽略忽略再忽略： 如果expr是引用，忽略引用的部分 如果忽略引用后，expr是const类型或volatile类型，忽略。 template&lt;typename T&gt; void f(T param); // param is now passed by value int x = 27; // as before const int cx = x; // as before const int&amp; rx = x; // as before f(x); // T&#39;s and param&#39;s types are both int f(cx); // T&#39;s and param&#39;s types are again both int f(rx); // T&#39;s and param&#39;s types are still both int 注意：只是忽略引用，指针还是不变。 template&lt;typename T&gt; void f(T param); // param is still passed by value const char* const ptr =&quot;Fun with pointers&quot;; // ptr is const pointer to const object f(ptr); //T is const char* const （4）退化 数组类型和指针类型是完全不一样的(虽然他们在使用时可以混用)。由于C语言老祖宗的继承关系，C++依然保留了这些特性，导致很多人误以为数组和指针参数是一样的。在传递过程中，数组会退化为它第一个元素的指针。 template&lt;typename T&gt; void f(T param); const char name[] = &quot;J. P. Briggs&quot;; // name&#39;s type is const char[13] const char * ptrToName = name; // array decays to pointer f(name); // name is array, but T deduced as const char* 这种退化导致有用的信息(数组长度)丢失。然而声明引用，可以使得模板推断保留成数组的形式： template&lt;typename T&gt; void f(T&amp; param); f(name); //deduce to const char[13] 在这个例子中T被推导为const char[13]，param则被推导为const char(&amp;)[13]。如果改为T&amp;&amp;，则T和param都被推为const char(&amp;)[13] 讲完数组，再来讲讲函数。在C++中不止是数组会退化为指针，函数类型也会退化为一个函数指针，我们对于数组的全部讨论都可以应用到函数来： void someFunc(int, double); // someFunc is a function; // type is void(int, double) template&lt;typename T&gt; void f1(T param); // in f1, param passed by value template&lt;typename T&gt; void f2(T&amp; param); // in f2, param passed by ref f1(someFunc); // param deduced as ptr-to-func; // type is void (*)(int, double) f2(someFunc); // param deduced as ref-to-func; // type is void (&amp;)(int, double) 3. 多模板参数多模板参数的形式是简单的，但细节需要考究。 template&lt;typename T1, typename T2&gt; T1 max (T1 a, T2 b) { return b &lt; a ? a : b; } auto m = ::max(1, 3.14); // 返回类型由第一个实参决定 上面的例子如果改为单模板参数则无法成功匹配。 而如果改为多模板参数，则调用过程发生了隐式转化，返回类型由第一个参数决定。如果我们把1和3.14调换位置，则返回的是double类型而不是int。 我们可以通过指定返回参数模板来解决这个问题。这段代码我们用尖括号指定模板类型，对应的位置就是RT，这样我们就能顺利返回我们想要的类型了。 template&lt;typename RT, typename T1, typename T2&gt; RT max (T1 a, T2 b); { return b &lt; a ? a : b; } ::max&lt;double&gt;(1, 3.14); // 返回类型为double, T1和T2被推断 在现代CPP体系中，我们可以自动推导返回类型。下面这段代码展示了11和14的一些区别。当我们调用::max(5, 1.2)的时候，5被隐式转化为double类型，返回的结果也是double类型。 template&lt;typename T1, typename T2&gt; // FOR c++14 auto max (T1 a, T2 b) { return b &lt; a ? a : b; } //FOR c++11 template&lt;typename T1, typename T2&gt; auto max (T1 a, T2 b) -&gt; decltype(b &lt; a ? a : b) { return b &lt; a ? a : b; } 但是，有时候这有可能会导致返回引用类型，因为paramtype可能就写为引用类型，我们需要调用decayed去除引用符号（需要头文件） template&lt;typename T1, typename T2&gt; auto max(T1 a, T2 b) -&gt; typename std::decay&lt;decltype(true ? a : b)&gt;::type { return b &lt; a ? a : b; } 现代CPP中引入了Common Type这一概念，相当于最大兼容。 common_type&lt;int, float&gt;::type // float，因为int可以转换成float common_type&lt;int, float, double&gt;::type // double，因为int, float都可以转换成double 利用这个特性，我们能够进一步改造模板。（注意一下14那个有_t，11那个没有） // for C++14 std::common_type_t&lt;T1,T2&gt; max(T1 a,T2 b) { return a&gt;b?a:b; } // for C++11 std::common_type&lt;T1,T2&gt;::type max(T1 a,T2 b) { return a&gt;b?a:b; } 4. 函数模板的重载具有相同名称的非函数模板可以和函数模板共存，利用这个特性我们能实现模板函数的重载。 int max (int a, int b) { return b &lt; a ? a : b; } template&lt;typename T&gt; //共存 T max (T a, T b) { return b &lt; a ? a : b; } int main() { ::max(1, 42); // 调用非模板的函数 ::max(1.0, 3.14); // 通过推断调用max&lt;double&gt; ::max(&#39;a&#39;, &#39;b&#39;); // 通过推断调用max&lt;char&gt; ::max&lt;&gt;(1, 42); // 通过推断调用max&lt;int&gt; ::max&lt;double&gt;(1, 42); // 调用max&lt;double&gt;，不推断 } 上面的代码展示了编译器的特性：选择最优匹配的函数。 重载模板的原则是需要保证只有一个合理匹配，否则会造成歧义，导致无法通过编译。下面的代码中，由于double可以被隐式转化为int，所以会导致歧义。 template&lt;typename T1, typename T2&gt; auto max (T1 a, T2 b){return b &lt; a ? a : b;} template&lt;typename RT, typename T1, typename T2&gt; RT max (T1 a, T2 b){return b &lt; a ? a : b;} auto a = ::max(1, 3.14); // 调用第一个模板 auto b = ::max&lt;long double&gt;(3.14, 1); // 调用第二个模板 auto c = ::max&lt;int&gt;(1, 3.14); // 错误：两个模板都匹配","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"CPP多线程总结4-并发数据结构设计实例","slug":"CPP多线程总结4-并发数据结构设计实例","date":"2019-12-28T07:40:49.000Z","updated":"2019-12-30T21:21:37.000Z","comments":true,"path":"2019/12/28/CPP多线程总结4-并发数据结构设计实例/","link":"","permalink":"jiangren.work/2019/12/28/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%934-%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/","excerpt":"着重介绍基于锁的结构设计，包括queue，map和list。同时稍微讲了一些原子操作的内容。由于原子操作内容过于复杂，我就只涉及了一些皮毛。","text":"着重介绍基于锁的结构设计，包括queue，map和list。同时稍微讲了一些原子操作的内容。由于原子操作内容过于复杂，我就只涉及了一些皮毛。 设计并发数据结构意味着，多个线程可以并发的访问这个数据结构，线程可对这个数据结构做相同或不同的操作，并且每一个线程都能在自己域中看到该数据结构。多线程环境下，无数据丢失和损毁，所有的数据需要维持原样，且无条件竞争，这样的数据结构称之为线程安全。 在第二篇中，我们介绍了互斥量，但是本质上：在互斥量的保护下，同一时间内只有一个线程可以获取互斥锁。互斥量为了保护数据，显式的阻止了线程对数据结构的并发访问。这中行为称之为串行化(serialization)：线程轮流访问被保护的数据。这是对数据进行串行的访问，而非并发。当然我们可以减少保护区域，减少序列化操作，就能提升并发访问的能力。 1. 基于锁的并发数据结构设计前面在第二篇介绍了基于锁的线程安全栈和第三篇基于锁和条件变量的线程安全队列，接下来我们再看一些精妙的设计实例。 1.1 基于细粒度锁和条件变量的线程安全队列（1）单线程版本 我们首先来实现一个单线程版本的队列： template&lt;typename T&gt; class queue { private: struct node { T data; std::unique_ptr&lt;node&gt; next; node(T data_):data(std::move(data_)) {} }; std::unique_ptr&lt;node&gt; head; node* tail; public: queue() {} queue(const queue&amp; other) = delete; queue&amp; operator=(const queue&amp; other) = delete; std::shared_ptr&lt;T&gt; try_pop() { if (!head) return std::shared_ptr&lt;T&gt;(); std::shared_ptr&lt;T&gt; res{ make_shared&lt;T&gt;(move(head-&gt;data)) }; const std::unique_ptr&lt;node&gt; old_head = move(head); head = move(old_head-&gt;next); return res; } void push(T new_value) { std::unique_ptr&lt;node&gt; p(new node(std::move(new_value)) );//** if (!tail) head = std::move(p); else tail-&gt;next = move(p); tail = p.get(); } }; 注意几个点： 使用了std::unique_ptr来管理节点，因为其能保证节点(其引用数据的值)在删除时候，不需要使用delete操作显式删除。 使用std::shared_ptr来返回被弹出值，这样可以保证结果能够被多次调用 要注意考虑head为空的时候的push情况 注意星号处创建node指针的办法 p.get()能提取被unique_ptr包裹的指针，这样他就是一个正常的指针了。 （2）通过分离数据实现并发 单线程版本移植到并发版本时有一个很大的问题，push和pop既访问head又访问tail，当我们的队列只有一个元素时head==tail，如果对两个对象上锁就是上的同一把锁。这是我们就需要请出在leetcode刷题中非常非常常见的虚拟节点了。 template&lt;typename T&gt; class queue { private: struct node //1 { shared_ptr&lt;T&gt; data; unique_ptr&lt;node&gt; next; }; unique_ptr&lt;node&gt; head; node* tail; public: queue() :head(new node), tail(head.get()) {} //2 queue(const queue&amp; other) = delete; queue&amp; operator=(const queue&amp; other) = delete; shared_ptr&lt;T&gt; try_pop() { if (head.get() == tail) //3 return shared_ptr&lt;T&gt;(); const shared_ptr&lt;T&gt; res(head-&gt;data); unique_ptr&lt;node&gt; old_head(move(head)); head = move(old_head-&gt;next); return res; } void push(T value) //4 { shared_ptr&lt;T&gt; packed_data(make_shared&lt;T&gt;(move(value))); unique_ptr&lt;node&gt; tmp_node(new node); node* new_tail = tmp_node.get(); tail-&gt;data = packed_data; tail-&gt;next = move(tmp_node); tail = new_tail; } }; 先来谈谈它和（1）有什么区别： 结构不一样了，对暴露的data进行了进一步封装，取消了构造函数，因为我们不需要初始化一个节点了。 默认构造函数不一样了，默认创建一个head和tail，第一个默认构造没有初始化任何东西，所以我们在push和pop时要判断是否为空，现在修改结构以后我们不判断了，所以必须要在这里初始化。 承接上条，由于我们现在默认构造时都会为head和tail赋予意义，所以需要以这样的方式判断。 push的方法很不同，data的结构变了，不再是T，所以要先包装data，把它送到tail指向的地方。然后让tail往后移动一个位置，同时新node指向新tail。 由于分离了head和tail现在它变成了线程安全的队列，并且现在的push()只能访问tail，而不能访问head。现在的问题是我们在哪里加锁，而且我们需要上锁的事件尽可能的少。 对push的上锁是简单的，如前面所说现在只能访问tail把他用到的地方锁上即可。而try_pop就很麻烦了。 template&lt;typename T&gt; class threadsafe_queue { private: struct node { std::shared_ptr&lt;T&gt; data; std::unique_ptr&lt;node&gt; next; }; std::mutex head_mutex; std::unique_ptr&lt;node&gt; head; std::mutex tail_mutex; node* tail; node* get_tail() { std::lock_guard&lt;std::mutex&gt; tail_lock(tail_mutex); return tail; } std::unique_ptr&lt;node&gt; pop_head() { std::lock_guard&lt;std::mutex&gt; head_lock(head_mutex); if (head.get() == get_tail()) { return nullptr; } std::unique_ptr&lt;node&gt; old_head = std::move(head); head = std::move(old_head-&gt;next); return old_head; } public: threadsafe_queue() : head(new node), tail(head.get()) {} threadsafe_queue(const threadsafe_queue&amp; other) = delete; threadsafe_queue&amp; operator=(const threadsafe_queue&amp; other) = delete; std::shared_ptr&lt;T&gt; try_pop() { std::unique_ptr&lt;node&gt; old_head = pop_head(); return old_head ? old_head-&gt;data : std::shared_ptr&lt;T&gt;(); } void push(T new_value) { std::shared_ptr&lt;T&gt; new_data( std::make_shared&lt;T&gt;(std::move(new_value))); std::unique_ptr&lt;node&gt; p(new node); node* const new_tail = p.get(); std::lock_guard&lt;std::mutex&gt; tail_lock(tail_mutex); tail-&gt;data = new_data; tail-&gt;next = std::move(p); tail = new_tail; } }; 由于guard_lock的局限性，所以我们不得不将try_pop封装成几个函数来实现细粒度锁。需要用到哪个锁，就把这段代码封装为函数。比如，最开始需要比较head和tail就把tail封装起来，相较于直接将两个同时锁住，tail受影响的时间就会小得多。 下面这段代码是个反例，这显然不是线程安全的。 std::unique_ptr&lt;node&gt; pop_head() // 这是个有缺陷的实现 { node* const old_tail=get_tail(); // 1 在head_mutex范围外获取旧尾节点的值 std::lock_guard&lt;std::mutex&gt; head_lock(head_mutex); if(head.get()==old_tail) // 2 { return nullptr; } std::unique_ptr&lt;node&gt; old_head=std::move(head); head=std::move(old_head-&gt;next); // 3 return old_head; } 1.2 基于锁的线程安全查询表本例的目的是构建一个线程安全的哈希表，这里哈希表是通过”桶”实现的，或者也叫链地址法。 图中所示的链表就可以具象的理解为一个一个的桶，这些桶合在一起构成了一个桶组。因此我们设计这个哈希表应该围绕桶组构成。想要顺利使用桶，我们需要定义桶，定义桶组，定义搜索桶位置的函数。 他的源码有点错误，2那个位置函数签名中的const应该去除。 template&lt;typename Key, typename Value,typename Hash=hash&lt;Key&gt;&gt; class threadsafe_lookup_table { private: class bucket_type { private: typedef std::pair&lt;Key, Value&gt; bucket_value; typedef std::list&lt;bucket_value&gt; bucket_data; using bucket_iterator = typename bucket_data::iterator; bucket_data thisbucket; mutable std::shared_mutex mutex; bucket_iterator a; bucket_iterator find_entry_for(Key const&amp; key) // 2 { auto m = std::find_if(thisbucket.begin(), thisbucket.end(), [&amp;](bucket_value const&amp; item) {return item.first == key; }); bucket_iterator b; return m; } public: Value value_for(Key const&amp; key, Value const&amp; default_value) { std::shared_lock&lt;std::shared_mutex&gt; lock(mutex); auto found_entry = find_entry_for(key); return (found_entry == thisbucket.end()) ? default_value : found_entry-&gt;second; } void add_or_update_mapping(Key const&amp; key, Value const&amp; value) { std::unique_lock&lt;std::shared_mutex&gt; lock(mutex); auto found_entry = find_entry_for(key); if (found_entry == thisbucket.end()) thisbucket.push_back(bucket_value(key, value)); else found_entry-&gt;second = value; } void remove_mapping(Key const&amp; key) { std::unique_lock&lt;std::shared_mutex&gt; lock(mutex); auto found_entry = find_entry_for(key); if (found_entry != thisbucket.end()) thisbucket.erase(found_entry); } }; vector&lt;unique_ptr&lt;bucket_type&gt;&gt; buckets; Hash hasher; bucket_type&amp; get_bucket_entry(Key const&amp; key)const { auto bucket_index = hasher(key) % buckets.size(); return *buckets[bucket_index]; } public: typedef Key key_type; typedef Value mapped_type; typedef Hash hash_type; threadsafe_lookup_table( unsigned num_buckets = 19, Hash const&amp; hasher_ = Hash()) : buckets(num_buckets), hasher(hasher_) { for (unsigned i = 0; i &lt; num_buckets; ++i) { buckets[i].reset(new bucket_type); } } threadsafe_lookup_table(threadsafe_lookup_table const&amp; other) = delete; threadsafe_lookup_table&amp; operator=(threadsafe_lookup_table const&amp; other)=delete; Value value_for(Key const&amp; key, Value const&amp; default_value = Value())const { return get_bucket_entry(key).value_for(key, default_value); } void add_or_update_mapping(Key const&amp; key, Value const&amp; value) { get_bucket_entry(key).add_or_update_mapping(key, value); } void remove_mapping(Key const&amp; key) { get_bucket_entry(key).remove_mapping(key); } }; 1.3 支持迭代器的线程安全链表代码易懂，有几点很值得学习: node成员的创建方式，分为可共享和不可共享 新节点的new创建方式 new_node是指针指向地址，所以需要用箭头，而head是一个实例，可以用点操作符。 函数模板 template&lt;typename T&gt; class threadsafe_list { private: struct node { std::mutex m; std::shared_ptr&lt;T&gt; data;//1 std::unique_ptr&lt;node&gt; next; node() :next() {} node(T const&amp; value) :data(make_shared&lt;T&gt;(value)) {} }; node head; public: threadsafe_list() {} threadsafe_list(threadsafe_list const&amp; other) = delete; threadsafe_list&amp; operator=(threadsafe_list const&amp; other) = delete; void push_front(T const&amp; value) { std::unique_ptr&lt;node&gt; new_node(new node(value));//2 std::lock_guard&lt;mutex&gt; lk(head.m); // head为虚拟节点，无具体值 new_node-&gt;next = move(head.next);//3 head.next = move(new_node); } template&lt;typename Function&gt;//4 void for_each(Function f) { auto current = &amp;head; std::unique_lock&lt;mutex&gt; lk(head.m); while (current-&gt;next.get() != nullptr) { auto next = current-&gt;next.get(); std::unique_lock&lt;mutex&gt; next_lk(next-&gt;m); lk.unlock(); f(*next-&gt;data);//5 current = next; lk = move(next_lk);//6 } } template&lt;typename Function&gt; shared_ptr&lt;T&gt; find_first_if(Function f) { auto current = &amp;head; unique_lock&lt;mutex&gt; lk(head.m); while (current-&gt;next.get() != nullptr) { unique_lock&lt;mutex&gt; next_lk(next-&gt;m); lk.unlock(); if (fun(*next-&gt;data)) return next-&gt;data; current = next; lk = std::move(next_lk); } } template&lt;typename Function&gt; void remove_if(Function f) { node* current = &amp;head; std::unique_lock&lt;std::mutex&gt; lk(head.m); while (node* const next = current-&gt;next.get()) { std::unique_lock&lt;std::mutex&gt; next_lk(next-&gt;m); if (f(*next-&gt;data)) { std::unique_ptr&lt;node&gt; old_next = std::move(current-&gt;next); current-&gt;next = std::move(next-&gt;next); next_lk.unlock(); } else { lk.unlock(); current = next; lk = std::move(next_lk); } } } }; 重点讲讲56。 首先来说6，指针和引用是个老大难的问题，这里做一下梳理： std::unique_ptr&lt;node&gt; new_node(new node(5)); //被unique_ptr封装好的具有GC机制的指针 auto m =new_node.get(); //能用的普通指针，指向node的地址 auto x = *m-&gt;data; //*m 解引用，指向node，x=5 auto y = new_node-&gt;data; //由于data被std::shared_ptr&lt;T&gt;封装，相当于做了一个指针拷贝 auto z = y.get(); //从shared_ptr&lt;T&gt;抽取的data指针，解引用*z后等于5 再来说说6，这个操作很精妙。整个操作中需要用到的是当前节点current和下一个节点next，采用滑动锁的形式，以lk为基准，向后滑动，同时创建lk_next锁住next 2. 无锁数据结构设计2.1 前言—原子操作原子操作指的是不可分割的操作，这种操作要么做了要么没做，不可能观察到做一半的这种状态。原子操作的关键就是使用一种同步操作方式，来替换使用互斥量的同步方式。 （1）std::atomic 最基本的原子整型类型就是std::atomic。可以使用非原子的bool类型进行构造，所以可以被初始化为true或false。 下面这段代码完成： 创建原子变量b 创建一个普通bool变量x，加载进入原子变量b b中的值存储为true 读取原子变量存储的值，修改为false，再存入(读-改-写) std::atomic&lt;bool&gt; b; bool x=b.load(std::memory_order_acquire); b.store(true); x=b.exchange(false, std::memory_order_acq_rel); 读改写操作是原子变量中非常常见且重要的操作，除了exchange()外还有比较\\交换操作，对应的函数时compare_exchange_weak()和compare_exchange_strong()成员函数。它比较原子变量的当前值和一个期望值，当两值相等时，存储所提供的值；当两值不等，期望值就会被更新为原子变量中的值。 compare_exchange_weak()可以伪失败（由于某些计算机本身的特性，导致当前线程不能很好完成这个操作，需要调用其他线程来替代工作，造成这种情况主要是时间不够而不是变量本身的问题），所以我们需要用一个循环来保证。b.compare_exchange_weak(expected,true)返回true时就是成功的时候。 bool expected=false; extern atomic&lt;bool&gt; b; // 设置些什么 while(!b.compare_exchange_weak(expected,true) &amp;&amp; !expected); （2）std::atomic指针运算 和atomic一样，std::atomic也有load(), store(), exchange(), compare_exchange_weak()和compare_exchage_strong()成员函数，与std::atomic的语义相同，获取与返回的类型都是`T*，而不是bool`。 std::atomic为指针运算提供新的操作。基本操作有fetch_add()和fetch_sub()提供，它们在存储地址上做原子加法和减法，为+=, -=, ++和—提供简易的封装。 vector&lt;int&gt; a{ 1, 2, 3, 4, 5 }; std::atomic&lt;int*&gt; p(&amp;a[0]); //p以int指针形式，指向1 auto m = p.fetch_add(2); //p右移两个单位，指向3，返回它的原始值（指向1的时） auto n = (p -= 1); //p左移一个单位，指向2，返回原始值（指向3时） 2.2 无锁的线程安全栈栈是先进后出，我们需要一个head一个tail，放的时候放入head，那么head就是我们需要保护的对象了。 template&lt;typename T&gt; class lock_free_stack { private: struct node { T data; node* next; node(T const&amp; data) :data(data_) {} }; std::atomic&lt;node*&gt; head; public: void push(T const&amp; data) { node* const new_node = new node(data); new_node-&gt;next = head.load(); while (!head.compare_exchange_weak(new_node-&gt;next, new_node)); } }; head是一个原子变量的node*指针，指向栈的头部。push的时候将head指针装载到新节点的next，然后再用新节点去替代head，他自己就成了head。和之前一样需要用循环的办法避免伪失败。 下面我们来完成pop的操作。我们需要确保当head为空时，程序不会报错，所以要先检查一下。注意，结构是无锁的，但并不是无等待的，因为在push()和pop()函数中都有while循环，当compare_exchange_weak()总是失败的时候，循环将会持续下去。 template&lt;typename T&gt; class lock_free_stack { private: struct node { T data; node* next; node(T const&amp; data) :data(std::make_shared&lt;T&gt;(data_)) {} }; std::atomic&lt;node*&gt; head; public: void push(T const&amp; data) { node* const new_node = new node(data); new_node-&gt;next = head.load(); while (!head.compare_exchange_weak(new_node-&gt;next, new_node)); } std::shared_ptr&lt;T&gt; pop() { node* old_head = head.load(); while (old_head &amp;&amp; !head.compare_exchange_weak (old_head, old_head-&gt;next)); return old_head ? old_head-&gt;data : shared_ptr&lt;T&gt;(); } };","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"并发","slug":"并发","permalink":"jiangren.work/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"CPP多线程总结3-同步异步并发","slug":"CPP多线程总结3-同步并发操作","date":"2019-12-27T07:35:10.000Z","updated":"2019-12-30T21:21:32.000Z","comments":true,"path":"2019/12/27/CPP多线程总结3-同步并发操作/","link":"","permalink":"jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%933-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/","excerpt":"以同步或异步的方式实现并发。","text":"以同步或异步的方式实现并发。 1. 条件等待1.1 达成等待条件C++标准库对条件变量有两套实现：std::condition_variable和std::condition_variable_any。两者都需要与一个互斥量一起才能工作(互斥量是为了同步)；前者仅限于与std::mutex一起工作，而后者可以和任何满足最低标准的互斥量一起工作。一般默认使用前者。 下面展示了等待唤醒机制的使用： std::mutex mut; std::queue&lt;data_chunk&gt; data_queue; // 1 std::condition_variable data_cond; void data_preparation_thread() { while(more_data_to_prepare()) { data_chunk const data=prepare_data(); std::lock_guard&lt;std::mutex&gt; lk(mut); data_queue.push(data); // 2 data_cond.notify_one(); // 3 } } void data_processing_thread() { while(true) { std::unique_lock&lt;std::mutex&gt; lk(mut); // 4 data_cond.wait( lk,[]{return !data_queue.empty();}); // 5 data_chunk data=data_queue.front(); data_queue.pop(); lk.unlock(); // 6 process(data); if(is_last_chunk(data)) break; } } 上面的代码使用一个队列在两个线程间传递数据。 在void data_processing_thread()中，我们要从队列中读取数据，首先4锁住互斥量；5在wait()函数中传递锁和lambda表达式，当判断结果为空时，线程休眠。 在void data_preparation_thread()中，2准备好数据后，先锁住互斥量，然后压入队列中；3通过notify_one()函数唤醒，结束后自动析构。 回到void data_processing_thread()中，由于唤醒消息的到来，这个函数重新启动，从头开始上锁、检查。 1.2 实战示例：使用等待条件构建线程安全队列我们模仿第二篇讲到的线程安全栈，构建一个线程安全的队列。所谓线程安全就是要像栈那样将top和pop合并。这里提供pop()函数的两个变种：try_pop()和wait_and_pop()。try_pop() ，尝试从队列中弹出数据，即使为空也会直接返回；wait_and_pop()，将会等待有值可检索的时候才返回。接口就可能会是下面这样： template&lt;typename T&gt; class threadsafe_queue { public: threadsafe_queue(); threadsafe_queue(const threadsafe_queue&amp;); threadsafe_queue&amp; operator=( const threadsafe_queue&amp;) = delete; // 不允许简单的赋值 void push(T new_value); bool try_pop(T&amp; value); // 1 std::shared_ptr&lt;T&gt; try_pop(); // 2 void wait_and_pop(T&amp; value); std::shared_ptr&lt;T&gt; wait_and_pop(); bool empty() const; }; 和之前一样，也需要提供两个版本的try_pop()和wait_for_pop()。第一个重载的try_pop()①在引用变量中存储着检索值，所以它可以用来返回队列中值的状态；当检索到一个变量时，他将返回true，否则将返回false。第二个重载②就不能做这样了，因为它是用来直接返回检索值的。当没有值可检索时，这个函数可以返回NULL指针。 完整版如下： template&lt;typename T&gt; class threadsafe_queue { private: mutable std::mutex mut; // 1 互斥量必须是可变的 std::queue&lt;T&gt; data_queue; std::condition_variable data_cond; public: threadsafe_queue() {} threadsafe_queue(threadsafe_queue const&amp; other) { std::lock_guard&lt;std::mutex&gt; lk(other.mut); data_queue=other.data_queue; } void push(T new_value) { std::lock_guard&lt;std::mutex&gt; lk(mut); data_queue.push(new_value); data_cond.notify_one(); } void wait_and_pop(T&amp; value) { std::unique_lock&lt;std::mutex&gt; lk(mut); data_cond.wait(lk,[this]{return !data_queue.empty();}); value=data_queue.front(); data_queue.pop(); } std::shared_ptr&lt;T&gt; wait_and_pop() { std::unique_lock&lt;std::mutex&gt; lk(mut); data_cond.wait(lk,[this]{return !data_queue.empty();}); std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(data_queue.front())); data_queue.pop(); return res; } bool try_pop(T&amp; value) { std::lock_guard&lt;std::mutex&gt; lk(mut); if(data_queue.empty()) return false; value=data_queue.front(); data_queue.pop(); return true; } std::shared_ptr&lt;T&gt; try_pop() { std::lock_guard&lt;std::mutex&gt; lk(mut); if(data_queue.empty()) return std::shared_ptr&lt;T&gt;(); std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(data_queue.front())); data_queue.pop(); return res; } bool empty() const { std::lock_guard&lt;std::mutex&gt; lk(mut); return data_queue.empty(); } }; 当新的数据准备完成，调用notify_one()将会触发一个正在执行wait()的线程，去检查条件和wait()函数的返回状态。 这里不保证线程一定会被通知到，即使只有一个等待线程收到通知，所有处理线程也有可能仍然在处理数据，而忽略了这个通知。 在定期重新初始化(periodic reinitialization)情况下，线程准备数据数据时，就会通过条件变量调用notify_all()成员函数，而非直接调用notify_one()函数。顾名思义，这就是全部线程在都去执行wait()(检查他们等待的条件是否满足)的原因。 2. 期望等待条件等待是指某个条件满足后，线程被激活，这是一个可重复利用的过程，流程是：条件不足—休眠—条件满足—激活—条件不足—休眠…. 而期望模型(future)则是对某一一次性特定事件的等待。某种程度上来说就需要知道这个事件在未来的期望结果，之后这个线程会在短周期内等待或检查，期间也会执行其他任务。 C++标准库中，有两种期望值，使用两种类型模板实现，声明在头文件中： 唯一期望值(unique futures)(std::future&lt;&gt;)和共享期望值(shared futures)(std::shared_future&lt;&gt;)。仿照了std::unique_ptr和std::shared_ptr。std::future的实例只能与一个指定事件相关联，而std::shared_future的实例就能关联多个事件 2.1 std::async有的时候我们需要一个长时间计算的结果，但却并不急着需要它，所以我们使用std::async函数模板。当不着急要任务结果时，可以使用std::async启动一个异步任务。与std::thread对象等待的方式不同，std::async会返回一个std::future对象，这个对象持有最终计算出来的结果。当需要这个值时，只需要调用这个对象的get()成员函数，会阻塞线程直到期望值状态为就绪为止；之后，返回计算结果。 下面举一个简单的例子： void main() { auto maxnum = 10000; vector&lt;int&gt; hello; auto fun = [maxnum = maxnum , &amp;hello]() { for (int i = 0; i &lt; maxnum; i++) hello.push_back(i); return std::accumulate(hello.begin(), hello.end(), 0); }; auto the_answer = std::async(fun); for (int i = 0; i &lt; 100; i++) { cout &lt;&lt; i &lt;&lt;&quot; &quot;; Sleep(1000); if(i==5) std::cout &lt;&lt; the_answer.get()&lt;&lt;&quot; &quot; &lt;&lt; endl; } } /* output: 0 1 2 3 4 5 49995000 6 ... */ 与std::thread 做的方式一样，std::async允许你通过添加额外的调用参数，向函数传递额外的参数。当第一个参数是一个指向成员函数的指针，第二个参数提供有这个函数成员类的具体对象(不是直接的，就是通过指针，还可以包装在std::ref中)，剩余的参数可作为成员函数的参数传入。 在函数调用之前向std::async传递一个额外参数，这个参数的类型是std::launch，还可以是std::launch::defered，表明函数调用被延迟到wait()或get()函数调用时才执行，std::launch::async 表明函数必须在其所在的独立线程上执行，并且立即执行，std::launch::deferred | std::launch::async表明实现可以选择这两种方式的一种。 2.2 std::packaged_task&lt;&gt;std::packaged_task&lt;&gt;包装任何可调用 (Callable) 目标，包括函数、 lambda 表达式、 bind 表达式或其他函数对象，使得能异步调用它，其返回值或所抛异常被存储于能通过 std::future 对象访问的共享状态中。简言之，将一个普通的可调用函数对象转换为异步执行的任务。 模板参数是一个函数签名，比如void()就是一个没有参数也没有返回值的函数，或int(std::string&amp;, double*)就是有一个非const引用的std::string和一个指向double类型的指针，并且返回类型是int。 下面给出它的使用范例： //1.包装lambda表达式 auto cmp = [](auto a, auto b) {return a &lt; b; }; packaged_task&lt;bool(int, int)&gt; task(cmp); //仿函数形式启动任务 task(2, 10); //获取共享状态中的值,直到ready才能返回结果或者异常 auto res = task.get_future(); cout &lt;&lt;boolalpha&lt;&lt; res.get() &lt;&lt; endl; //2.包装普通函数 bool cmp(int a, int b) { return a &lt; b; } std::packaged_task&lt;bool(int, int)&gt; task(cmp); task(6, 3); auto res = task.get_future(); cout &lt;&lt; boolalpha &lt;&lt; res.get() &lt;&lt; endl; //3.通过线程启动 task.reset(); res = task.get_future(); //通过线程启动任务 thread td(move(task), 2, 10); td.join(); //获取执行结果 cout &lt;&lt; &quot;task_thread :&quot; &lt;&lt; res.get() &lt;&lt; &quot;\\n&quot;; 2.3 std::promise&lt;&gt;顾名思义，就是承诺的意思。承诺和期望是好朋友，先申明一个承诺，再获得期望结果。std::packaged_task是他更高级的抽象。通过set_value将结果转化为指定值，从而实现他的承诺。 void accumulate(std::vector&lt;int&gt;::iterator first, std::vector&lt;int&gt;::iterator last, std::promise&lt;int&gt; accumulate_promise) { int sum = std::accumulate(first, last, 0); accumulate_promise.set_value(sum); // 提醒 future } // 演示用 promise&lt;int&gt; 在线程间传递结果。 std::vector&lt;int&gt; numbers = { 1, 2, 3, 4, 5, 6 }; std::promise&lt;int&gt; accumulate_promise; std::future&lt;int&gt; accumulate_future = accumulate_promise.get_future(); std::thread work_thread(accumulate, numbers.begin(), numbers.end(), std::move(accumulate_promise)); std::cout &lt;&lt; &quot;result=&quot; &lt;&lt; accumulate_future.get() &lt;&lt; &#39;\\n&#39;; work_thread.join(); 2.4 std::shared_future虽然std::future可以处理所有在线程间数据转移的同步，但他是一个独享变量，换句话说，当一个线程取得他以后，他就变成一个空壳，其他线程就无法共享这个数据。所以有了可以共享的期望std::shared_future。 std::future是只移动的，所以其所有权可以在不同的实例中互相传递，但是只有一个实例可以获得特定的同步结果，而std::shared_future实例是可拷贝的，所以多个对象可以引用同一关联期望值的结果。 每一个std::shared_future的独立对象上，成员函数调用返回的结果还是不同步的，所以为了在多个线程访问一个独立对象时避免数据竞争，必须使用锁来对访问进行保护。优先使用的办法：为了替代只有一个拷贝对象的情况，可以让每个线程都拥有自己对应的拷贝对象。这样，当每个线程都通过自己拥有的std::shared_future对象获取结果，那么多个线程访问共享同步结果就是安全的。 下面展示了他的使用过程：可以想象为两个选手的赛跑比赛，std::async作用是让两个选手上跑道准备就绪，选手准备好后就等待ready_future的信号。ready_promise.set_value();发令枪响，开始计时，两个选手开始。跑完后结果存在result1,result2中。 void main() { std::promise&lt;void&gt; ready_promise; std::shared_future&lt;void&gt; ready_future(ready_promise.get_future()); std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start; auto fun1 = [&amp;, ready_future]() -&gt; std::chrono::duration&lt;double, std::milli&gt; { auto fun1_future = ready_future; fun1_future.wait(); // 等待来自 main() 的信号 return std::chrono::high_resolution_clock::now() - start; }; auto fun2 = [&amp;, ready_future]() -&gt; std::chrono::duration&lt;double, std::milli&gt; { auto fun2_future = ready_future; fun2_future.wait(); // 等待来自 main() 的信号 return std::chrono::high_resolution_clock::now() - start; }; auto result1 = std::async(std::launch::async, fun1); auto result2 = std::async(std::launch::async, fun2); // 向线程发信使之运行 ready_promise.set_value(); // 线程已就绪，开始时钟 start = std::chrono::high_resolution_clock::now(); std::cout &lt;&lt; &quot;Thread 1 received the signal &quot; &lt;&lt; result1.get().count() &lt;&lt; &quot; ms after start\\n&quot; &lt;&lt; &quot;Thread 2 received the signal &quot; &lt;&lt; result2.get().count() &lt;&lt; &quot; ms after start\\n&quot;; } 3. 等待时间3.1 时钟对于C++标准库来说，时钟就是时间信息源。并且，时钟是一个类，提供了四种不同的信息： 当前时间 时间类型 时钟节拍 通过时钟节拍的分布，判断时钟是否稳定 当前时间可以通过调用静态成员函数now()从时钟类中获取；例如，std::chrono::system_clock::now()是将返回系统时钟的当前时间。 时钟节拍被指定为1/x(x在不同硬件上有不同的值)秒，这是由时间周期所决定——一个时钟一秒有25个节拍，因此一个周期为std::ratio&lt;1, 25&gt;，当一个时钟的时钟节拍每2.5秒一次，周期就可以表示为std::ratio&lt;5, 2&gt;。 当时钟节拍均匀分布(无论是否与周期匹配)，并且不可调整，这种时钟就称为稳定时钟。当is_steady静态数据成员为true时，表明这个时钟就是稳定的；否则，就是不稳定的。通常情况下，std::chrono::system_clock是不稳定的，因为时钟是可调的，即是这种是完全自动适应本地账户的调节。稳定闹钟对于超时的计算很重要，所以C++标准库提供一个稳定时钟std::chrono::steady_clock。 3.2 时延std::chrono::duration&lt;&gt;函数模板能够创建一段时延，比如std::chrono::duration&gt;时间为60秒，std::chrono::duration&gt;时间为1毫秒。 标准库在std::chrono命名空间内，为延时变量提供一系列预定义类型：nanoseconds[纳秒] , microseconds[微秒] , milliseconds[毫秒] , seconds[秒] , minutes[分]和hours[时]。 std::chrono::milliseconds ms(54802); 方便起见，C++14中std::chrono_literals命名空间中，有许多预定义的后缀操作符用来表示时长。下面简单的代码就是使用硬编码的方式赋予具体的时长值： using namespace std::chrono_literals; auto one_day=24h; auto half_an_hour=30min; auto max_time_between_messages=30ms; 基于时延的等待可由std::chrono::duration&lt;&gt;来完成，例如：等待期望值状态变为就绪已经35毫秒： std::future&lt;int&gt; f=std::async(some_task); if(f.wait_for(std::chrono::milliseconds(35))==std::future_status::ready) do_something_with(f.get()); 等待函数会返回一个状态值，表示是等待是超时，还是继续等待。这里可以等待期望值，所以当函数等待超时时，会返回std::future_status::timeout；当期望值状态改变，函数会返回std::future_status::ready；当与期望值相关的任务延迟了，函数会返回std::future_status::deferred。 3.3 时间点时间点可以用std::chrono::time_point&lt;&gt;类型模板来表示，实例的第一个参数用来指定所要使用的时钟，第二个函数参数用来表示时间的计量单位(特化的std::chrono::duration&lt;&gt;)，比如说std::chrono::time_point。 可以通过std::chrono::time_point&lt;&gt;实例来加/减时延，来获得一个新的时间点，所以std::chrono::hight_resolution_clock::now() + std::chrono::nanoseconds(500)将得到500纳秒后的时间。 auto start=std::chrono::high_resolution_clock::now()+std::chrono::nanoseconds(500); 我们可以通过做减法来计算时间： auto start=std::chrono::high_resolution_clock::now(); do_something(); auto stop=std::chrono::high_resolution_clock::now(); std::cout&lt;&lt;”do_something() took “ &lt;&lt;std::chrono::duration&lt;double,std::chrono::seconds&gt;(stop-start).count() &lt;&lt;” seconds”&lt;&lt;std::endl; 我们可以利用时间点做超时等待的工作，如果下面的代码换成wait_for()以时延为基础做判断的话，可能引发重复等待。 std::condition_variable cv; bool done; std::mutex m; bool wait_loop() { auto const timeout= std::chrono::steady_clock::now()+ std::chrono::milliseconds(500); std::unique_lock&lt;std::mutex&gt; lk(m); while(!done) { if(cv.wait_until(lk,timeout)==std::cv_status::timeout) break; } return done; } 4. 使用同步操作简化代码4.1 期望的函数化编程所谓的函数式编程(functional programming)是一种编程方式，这种方式中函数结果只依赖于传入函数的参数，并不依赖外部状态，就像f(x)=cosx+exf(x)=cos⁡x+ex一样，输出的结果仅仅取决于输入的参数。我们以快排为例介绍如何使用函数式并发： （1）快速排序FP模式版 下面的代码与std::sort()不同，std::sort()是无返回值的，因为参数接收的是迭代器，所以其可以对原始列表直进行修改与排序。 template&lt;typename T&gt; std::list&lt;T&gt; sequential_quiksort(std::list&lt;T&gt; input) { if (input.empty()) return input; std::list&lt;T&gt; res; res.splice(res.begin(), input, input.begin()); const T&amp; pivot = *res.begin(); auto divided_point = std::partition(input.begin(), input.end(), [pivot = pivot](auto&amp; t) {return t &lt; pivot; }); std::list&lt;T&gt; lower_part; lower_part.splice(lower_part.begin(), input, input.begin(), divided_point); auto new_lower(sequential_quiksort(std::move(lower_part))); auto new_higher(sequential_quiksort(std::move(input))); res.splice(res.begin(), new_lower); res.splice(res.end(), new_higher); return res; } 主要介绍一下里面用到的STL库函数： std::splice移动拼接 std::partition分离(predicate 谓语，这里指lambda表达式) （2）快速排序FP并发版 template&lt;typename T&gt; std::list&lt;T&gt; parallel_quick_sort(std::list&lt;T&gt; input) { if(input.empty()) { return input; } std::list&lt;T&gt; result; result.splice(result.begin(),input,input.begin()); T const&amp; pivot=*result.begin(); auto divide_point=std::partition(input.begin(),input.end(), [&amp;](T const&amp; t){return t&lt;pivot;}); std::list&lt;T&gt; lower_part; lower_part.splice(lower_part.end(),input,input.begin(), divide_point); std::future&lt;std::list&lt;T&gt; &gt; new_lower( // 1 std::async(&amp;parallel_quick_sort&lt;T&gt;,std::move(lower_part))); auto new_higher( parallel_quick_sort(std::move(input))); // 2 result.splice(result.end(),new_higher); // 3 result.splice(result.begin(),new_lower.get()); // 4 return result; } 当前线程不对小于“中间”值部分的列表进行排序，使用std::async()①在另一线程对其进行排序。大于部分列表，如同之前一样，使用递归的方式进行排序②。如果开启线程过多，运行库会自动裁剪线程。 因避开了共享可变数据，函数化编程可算作是并发编程的范型，并且也是通讯顺序进程(CSP，Communicating Sequential Processer)的范型。 4.2 持续性并发这里主要介绍std::experimental::future的特性：持续性。 与std::future类似 , std::experimental::future存储值也只能检索一次。如果期望值正处于持续使用状态，那这个期望值就不能被其他代码所访问。因此，使用fut.then()为fut期望值添加持续性后，对原始期望值fut的操作就是非法的。另外，调用fut.then()会返回一个新期望值，这个新期望值会持有持续性调用的结果。 std::experimental::future&lt;int&gt; find_the_answer; auto fut=find_the_answer(); auto fut2=fut.then(find_the_question); assert(!fut.valid()); assert(fut2.valid()); 与直接调用std::async或std::thread不同，持续性函数不需要传入参数，因为运行库已经为其定义好了参数——会传入一个就绪态持续性期望值，这个期望值保存了持续性触发后的结果。假设find_the_answer返回类型为int，find_the_question函数根据之前的例子将会传入一个std::experimental::future作为唯一参数： std::string find_the_question(std::experimental::future&lt;int&gt; the_answer); 下面举一个利用持续性的例子： 假如用户要登录你的应用，输入账号密码后，将账号送达后台获取ID，然后根据ID检查密码，通过后将信息显示出来。如果我们采用串行执行： void process_login(std::string const&amp; username, std::string const&amp; password) { try{ user_id const id = backend.authenticate_user(username, password); user_data const info_to_display = backend.request_current_info(id); update_display(info_to_display); } catch(std::exception&amp; e){ display_error(e); } } 串行可能会阻塞UI线程，如果我们采用async的方式将他们放到其他线程上，依旧会阻塞UI： std::future&lt;void&gt; process_login( std::string const&amp; username, std::string const&amp; password) { return std::async(std::launch::async,[=](){ try{ user_id consst id = backend.authenticate_user(username, password); user_data const info_to_display = backend.request_current_info(id); update_display(info_to_display); } catch(std::exception&amp; e){ display_error(e); } }); } 为了避免阻塞相应线程，需要有机制对每个完成的任务进行连接：持续性。 std::experimental::future&lt;void&gt; process_login( std::string const&amp; username, std::string const&amp; password) { return backend.async_authenticate_user(username, password).then( [](std::experimental::future&lt;user_id&gt; id){ return backend.async_request_current_info(id.get()); }).then([](std::experimental::future&lt;user_data&gt; info_to_display){ try{ update_display(info_to_display.get()); } catch(std::exception&amp; e){ display_error(e); } }); }","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"并发","slug":"并发","permalink":"jiangren.work/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"CPP多线程总结2-线程间共享数据","slug":"CPP多线程总结2-线程间共享数据","date":"2019-12-27T06:51:09.000Z","updated":"2019-12-30T21:21:28.000Z","comments":true,"path":"2019/12/27/CPP多线程总结2-线程间共享数据/","link":"","permalink":"jiangren.work/2019/12/27/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%932-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/","excerpt":"本章着重讲述如何处理线程间的共享数据，内容包括：mutex, lock, unique_lock, call_once,shared_lock。","text":"本章着重讲述如何处理线程间的共享数据，内容包括：mutex, lock, unique_lock, call_once,shared_lock。 1. 使用互斥量保护共享数据1.1 以RAII的方式使用互斥量在 C++ 中，标准库提供的互斥量是 std::mutex，它被定义在 mutex 这个头文件中。互斥量是锁的一种，它也是一种资源，必须保证资源被正确释放（正确使用互斥量的条件之一）。这就像内存需要delete一样，互斥量在lock()以后必须unlock()解除。 实际上并不推荐这么做，C++标准库为互斥量提供了一个RAII语法的模板类std::lock_guard，在构造时就能提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁互斥量能被正确解锁。 RAII要求，资源的有效期与持有资源的对象的生命期严格绑定，即由对象的构造函数完成资源的分配（获取），同时由析构函数完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现资源泄露问题。 std::list&lt;int&gt; some_list; // 1 std::mutex some_mutex; // 2 void add_to_list(int new_value) { std::lock_guard&lt;std::mutex&gt; guard(some_mutex); // 3 some_list.push_back(new_value); } bool list_contains(int value_to_find) { std::lock_guard&lt;std::mutex&gt; guard(some_mutex); // 4 return std::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end(); } 有一个全局变量①，这个全局变量被一个全局的互斥量保护②。add_to_list()③和list_contains()④函数中使用std::lock_guard，使得这两个函数中对数据的访问是互斥的：list_contains()不可能看到正在被add_to_list()修改的列表 简单理解：被声明guard的地方在析构前都是被保护的。 在C++17中新添加了一个特性，称之为模板类参数推导，这样类似std::locak_guard这样简单的模板类型的模板参数列表可以省略。③和④的代码可以简化成： std::lock_guard guard(some_mutex); 1.2 限制被保护数据的使用范围这一节讨论正确使用互斥锁的一个重要前提：必须限制被保护数据的使用范围。简单来说，就是不要将被保护数据的指针或引用通过返回值、函数参数的方式，传到无法控制的范围内。 举一个例子： class some_data { int a; std::string b; public: void do_something(); }; class data_wrapper { private: some_data data; std::mutex m; public: template&lt;typename Function&gt; void process_data(Function func) { std::lock_guard&lt;std::mutex&gt; l(m); func(data); // 1 传递“保护”数据给用户函数 } }; some_data* unprotected; void malicious_function(some_data&amp; protected_data) { unprotected=&amp;protected_data; } data_wrapper x; void foo() { x.process_data(malicious_function); // 2 传递一个恶意函数 unprotected-&gt;do_something(); // 3 在无保护的情况下访问保护数据 } 例子中process_data看起来没有任何问题，std::lock_guard对数据做了很好的保护，但调用用户提供的函数func①，就意味着foo能够绕过保护机制将函数malicious_function传递进去②，在没有锁定互斥量的情况下调用do_something()。 这段代码的问题在于根本没有保护，只是将所有可访问的数据结构代码标记为互斥。函数foo()中调用unprotected-&gt;do_something()的代码未能被标记为互斥。 所以，不能将被保护数据的指针或引用以函数返回值的形式，返回或传递给外部不可控的调用者。 1.3 定位接口间的条件竞争以std::stack为例，讲解接口设计缺陷导致的条件竞争。 if (! s.empty()){ // 1 int const value = s.top(); // 2 s.pop(); // 3 do_something(value); } 上面的代码是一套很常规的操作，存在两个竞争： 有可能线程A判断不为空后，放心的去执行2，但在步骤1和2之间，线程B插了进来弹出了最后一个元素，此时线程A执行步骤2就会发生异常。即使我们使用了互斥量也不能保证，这就是接口本身的问题。解决问题的最简单办法就是在if (! s.empty())之后，再加一个try/catch抛出异常，但这样empty就成了摆设。 （2）调用top()和pop()之间 上图是可能的操作顺序，很有可能两个线程都取了相同的值，这种条件竞争，然其结果依赖于do_something()的结果，但因为看起来没有任何错误，就会让这个Bug很难定位。 那么为什么STL的设计者还要这样设计接口呢？如果我们auto val = stk.pop()既完成取栈顶的工作，又执行弹出的操作，就会发生一个问题：传值的办法是通过拷贝，如果这里的val是一个vector类似的容器，它的拷贝需要时间，这时如果出现了异常抛出的情况，原来的值就被丢掉了——它既不存在于栈，也不存在于其他变量。 下面是解决的办法，也是一段非常经典的代码： #include &lt;exception&gt; #include &lt;memory&gt; #include &lt;mutex&gt; #include &lt;stack&gt; struct empty_stack: std::exception { const char* what() const throw() { return &quot;empty stack!&quot;; }; }; template&lt;typename T&gt; class threadsafe_stack { private: std::stack&lt;T&gt; data; mutable std::mutex m; public: threadsafe_stack() : data(std::stack&lt;T&gt;()){} threadsafe_stack(const threadsafe_stack&amp; other) { std::lock_guard&lt;std::mutex&gt; lock(other.m); data = other.data; // 1 在构造函数体中的执行拷贝 } threadsafe_stack&amp; operator=(const threadsafe_stack&amp;) = delete; void push(T new_value) { std::lock_guard&lt;std::mutex&gt; lock(m); data.push(new_value); } std::shared_ptr&lt;T&gt; pop() { std::lock_guard&lt;std::mutex&gt; lock(m); if(data.empty()) throw empty_stack(); // 在调用pop前，检查栈是否为空 std::shared_ptr&lt;T&gt; const res(std::make_shared&lt;T&gt;(data.top())); // 在修改堆栈前，分配出返回值 data.pop(); return res; } void pop(T&amp; value) { std::lock_guard&lt;std::mutex&gt; lock(m); if(data.empty()) throw empty_stack(); value=data.top(); data.pop(); } bool empty() const { std::lock_guard&lt;std::mutex&gt; lock(m); return data.empty(); } }; 在这段程序中，我们重载了两个pop版本，一个是原始版本（返回void），另一个是pop和top结合版本（返回值）。为了避免之前提到的数据丢失问题，我们采用返回指针的办法。 2. 避免死锁通俗来说，假如有两个线程分别有互斥量AB，两个线程都在等待对方解锁，这样两个锁AB就会形成死锁。死锁往往是由于不同线程之间不当交互所导致的。 从原理上来说，避免死锁的办法是两个互斥量总以相同的顺序上锁解锁：先锁住A，锁住B，先解锁A再解锁B。如果反过来，锁住AB，以BA的形式解锁，就会导致死锁。 void a() { mutex1.lock(); mutex2.lock(); doSomething(); mutex2.unlock(); mutex1.unlock(); } void b() { mutex2.lock(); mutex1.lock(); doSomething(); mutex1.unlock(); mutex2.unlock(); } 上面的代码中假设函数a先锁住了1，b同时锁住了2，这样a要去锁2时需要等待2解锁，b要去锁1时要等待1解锁，这样就凉了。 然而即使我们按顺序上锁，在一些交换操作中，交换了两个锁保护的两个实例，这下就又会发生死锁。因此我们研究几个有效避免死锁的办法： 2.1 std::lock函数std::lock——可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)，下面给出了一个很好的例子： class some_big_object; void swap(some_big_object&amp; lhs,some_big_object&amp; rhs); class X { private: some_big_object some_detail; std::mutex m; public: X(some_big_object const&amp; sd):some_detail(sd){} friend void swap(X&amp; lhs, X&amp; rhs) { if(&amp;lhs==&amp;rhs) //一定要引用，判断地址是否相同而不是值 return; std::lock(lhs.m,rhs.m); // 1 std::lock_guard&lt;std::mutex&gt; lock_a(lhs.m,std::adopt_lock); // 2 std::lock_guard&lt;std::mutex&gt; lock_b(rhs.m,std::adopt_lock); // 3 swap(lhs.some_detail,rhs.some_detail); } }; 着重看一下这个友元函数。首先需要判断两个对象是否相同，避免被同时上锁两次。然后，调用std::lock()①锁住两个互斥量，并且两个std:lock_guard实例已经创建好②③。提供std::adopt_lock参数除了表示std::lock_guard对象可获取锁之外，还将锁交由std::lock_guard对象管理，而不需要std::lock_guard对象再去构建新的锁。在退出时，互斥量能被正确解锁。 2.2 std::scoped_lock函数这是C++17中的新函数，一种新的RAII类型模板类型，与std::lock_guard&lt;&gt;的功能等价，这个新类型能接受不定数量的互斥量类型作为模板参数，以及相应的互斥量(数量和类型)作为构造参数。互斥量支持构造即上锁，与std::lock的用法相同，其解锁阶段是在析构中进行。（注意请确保你的编译器支持17，如果是使用visual studio，需要手动设置语言版本为17） void swap(X&amp; lhs, X&amp; rhs) { if(&amp;lhs==&amp;rhs) return; std::scoped_lock guard(lhs.m,rhs.m); // 1 swap(lhs.some_detail,rhs.some_detail); } 这里使用了C++17的另一个特性：自动推导模板参数。C++17可以通过隐式参数模板类型推导机制， 通过传递的对形象类型来构造实例1。其等价于： std::scoped_lock&lt;std::mutex,std::mutex&gt; guard(lhs.m,rhs.m); 3. std::unique_lock3.1 独占锁的基本用法std::unique_lock不是一种锁而是一种锁的超集，是在11中引入的锁工具的复合体。 std::unique_lock的构造函数，支持三种加锁模式： unique_lock( mutex_type&amp; m, std::defer_lock_t t ); //延迟加锁 unique_lock( mutex_type&amp; m, std::try_to_lock_t t ); //尝试加锁 unique_lock( mutex_type&amp; m, std::adopt_lock_t t ); //马上加锁 有丰富的操作函数： lock() //阻塞等待加锁 try_lock() // 非阻塞等待加锁 try_lock_for() //在一段时间内尝试加锁 try_lock_until() //在某个时间点之前尝试加锁 unlock() //临时解锁 std::lock_guard只有在析构时才会解锁，它自己本身没有加锁解锁的接口。而std::unique_lock可以在任意时间临时加锁解锁，在析构时也会自动解锁。下面举一个例子： 使用std::lock_guard我们需要生成两个锁来保护，当然可以用一个锁同时保护123，但这样锁的粒度太大，效率不行。 void shared_print(string msg, int id) { { std::lock_guard&lt;std::mutex&gt; guard(_mu); //do something 1 } //do something 2 { std::lock_guard&lt;std::mutex&gt; guard(_mu); // do something 3 } } 当我们改为独占锁，可以通过临时上锁解锁，实现精细化的操作。 void shared_print(string msg, int id) { std::unique_lock&lt;std::mutex&gt; guard(_mu); //do something 1 guard.unlock(); //临时解锁 //do something 2 guard.lock(); //继续上锁 // do something 3 } 我们甚至可以使用std::defer_lock设置初始化的时候不进行默认的上锁操作： void shared_print(string msg, int id) { std::unique_lock&lt;std::mutex&gt; guard(_mu, std::defer_lock); //do something 1 guard.lock(); // do something protected guard.unlock(); //临时解锁 //do something 2 guard.lock(); //继续上锁 // do something 3 } 此外，独占锁和unique_ptr一样不能复制，但可以移动！而lock_guard两个都不行： // unique_lock 可以移动，不能复制 std::unique_lock&lt;std::mutex&gt; guard1(_mu); std::unique_lock&lt;std::mutex&gt; guard2 = guard1; // error std::unique_lock&lt;std::mutex&gt; guard2 = std::move(guard1); // ok 下面的示例展示了所有权的传递应用： std::unique_lock&lt;std::mutex&gt; get_lock() { extern std::mutex some_mutex; std::unique_lock&lt;std::mutex&gt; lk(some_mutex); prepare_data(); return lk; // 1 } void process_data() { std::unique_lock&lt;std::mutex&gt; lk(get_lock()); // 2 do_something(); } 构造时，拷贝构造函数是delete，调用移动构造函数，所以不需要std::move。 4. 保护共享数据的其他方式4.1 保护共享数据的初始化过程延迟初始化(Lazy initialization)在单线程代码很常见——每一个操作都需要先对源进行检查，为了了解数据是否被初始化，然后在其使用前决定，数据是否需要初始化： std::shared_ptr&lt;some_resource&gt; resource_ptr; void foo() { if(!resource_ptr) { resource_ptr.reset(new some_resource); // 1 } resource_ptr-&gt;do_something(); } 转为多线程代码时，只有①处需要保护，这样共享数据对于并发访问就是安全的，我们尝试使用锁来进行保护时会出现一些问题：由于每次我们调用foo()都会检查是否初始化，这样每次都会创建锁，非常影响代码的正常运行。 std::shared_ptr&lt;some_resource&gt; resource_ptr; std::mutex resource_mutex; void foo() { std::unique_lock&lt;std::mutex&gt; lk(resource_mutex); // 所有线程在此序列化 if(!resource_ptr) { resource_ptr.reset(new some_resource); // 只有初始化过程需要保护 } lk.unlock(); resource_ptr-&gt;do_something(); } 于是有人针对这种情况提出了双重检查锁模式。由于条件判断1并没有与被锁保护的3同步，这样又会引入新条件的竞争：线程A进入了步骤3，由于C++在new一个对象时，首先会把指针指向分配的那块空间，然后在初始化该空间。此时线程B兴奋得知，resource_ptr不为空了，赶紧执行4，然而事实却是：指针只是指向了某个地方，指向的对象并没有完全初始化完成！ void undefined_behaviour_with_double_checked_locking() { if(!resource_ptr) // 1 { std::lock_guard&lt;std::mutex&gt; lk(resource_mutex); if(!resource_ptr) // 2 { resource_ptr.reset(new some_resource); // 3 } } resource_ptr-&gt;do_something(); // 4 } 为了避免这些情况，C++标准委员会建议我们使用std::call_once函数。这个函数能保证我们在多线程中，某个函数只会被调用一次。 std::once_flag flag1; void simple_do_once() { std::call_once(flag1, []() { std::cout &lt;&lt; &quot;Simple example: called once\\n&quot;; }); } int main() { std::thread st1(simple_do_once); std::thread st2(simple_do_once); st1.join(); st2.join(); } 下面展示了使用std::call_once作为类成员的延迟初始化(线程安全) class X { private: string connection_handle; std::once_flag connection_init_flag; void open_connection() { connection_handle = &quot;4396&quot;; } public: void send_data() { for (int i = 0; i &lt; 10; i++) { std::call_once(connection_init_flag, &amp;X::open_connection, this); cout &lt;&lt; &quot;Connectiong handle is &quot; &lt;&lt; connection_handle &lt;&lt; &quot; send data: &quot; &lt;&lt;i&lt;&lt; endl; } } void receive_data() { for (int i = 0; i &lt; 10; i++) { std::call_once(connection_init_flag, &amp;X::open_connection, this); cout &lt;&lt; &quot;Connectiong handle is &quot; &lt;&lt; connection_handle &lt;&lt; &quot; recieve data: &quot; &lt;&lt; i &lt;&lt; endl; } } }; 4.2 保护不常更新的数据结构有的数据比如DNS，我们很少去改改动他，平常更多的是去读取访问，但偶尔也会对他进行修改。因此我们可以使用读写锁std::shared_lock去管理。所谓「读写锁」，就是同时可以被多个读者拥有，但是只能被一个写者拥有的锁。而所谓「多个读者、单个写者」，并非指程序中只有一个写者（线程），而是说不能有多个写者同时去写。 std::shared_lock往往和shared_mutex搭配使用，下面给一个例子： class ThreadSafeCounter { public: ThreadSafeCounter() = default; // 多个线程/读者能同时读计数器的值。 unsigned int get() const { std::shared_lock&lt;std::shared_mutex&gt; lock(mutex_); return value_; } // 只有一个线程/写者能增加/写线程的值。 void increment() { std::unique_lock&lt;std::shared_mutex&gt; lock(mutex_); value_++; } // 只有一个线程/写者能重置/写线程的值。 void reset() { std::unique_lock&lt;std::shared_mutex&gt; lock(mutex_); value_ = 0; } private: mutable std::shared_mutex mutex_; unsigned int value_ = 0; };","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"并发","slug":"并发","permalink":"jiangren.work/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"利用腾讯云创建mysql数据库服务器","slug":"利用腾讯云创建mysql数据库服务器","date":"2019-12-23T04:46:00.000Z","updated":"2019-12-30T21:51:49.000Z","comments":true,"path":"2019/12/23/利用腾讯云创建mysql数据库服务器/","link":"","permalink":"jiangren.work/2019/12/23/%E5%88%A9%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%88%9B%E5%BB%BAmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"如何购买并搭建云服务器数据库。","text":"如何购买并搭建云服务器数据库。 1. MySQL安装与配置安装https://zhuanlan.zhihu.com/p/37152572，ZIP版本需要自己配置环境，MSI版本可以一键安装。 启动方式： （1）默认启动 启动默认是以localhost为用户名 （2）CMD启动 如果想要登录指定的服务器，需要在CMD中启动。 首先需要将mysql添加到系统环境变量 然后在CMD中，按照如下形式填写即可登录。 mysql -h [云数据库IP] -P[云数据库端口号] -uroot -p[云数据库密码] 当看到mysql&gt;时表示登录成功！ 2. 购买并配置腾讯云数据库 购买以后设置数据库密码，然后在管理中打开外网连接 然后点击数据库管理，创建一个账号，设置账号密码。在主机处输入%，表示允许所有IP访问。 此时，用CMD登录即可，注意这里的密码输入账户密码，数据库密码是在腾讯云控制台的管理密码，不要混淆。","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"教程","slug":"教程","permalink":"jiangren.work/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"MySQL总结7-表的创建与修改","slug":"MySQL总结7-表的创建与修改","date":"2019-11-30T05:20:27.000Z","updated":"2019-12-30T21:42:57.000Z","comments":true,"path":"2019/11/30/MySQL总结7-表的创建与修改/","link":"","permalink":"jiangren.work/2019/11/30/MySQL%E6%80%BB%E7%BB%937-%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BF%AE%E6%94%B9/","excerpt":"如何改、删、增数据表。","text":"如何改、删、增数据表。 1. 操作表1.1 创建表一般来说创建表的方法有两种： 使用交互式工具创建，比如Navicat 直接用MySQL语句操作 在创建时我们必须明确以下信息： 新表的名字，在关键词CREATE TABLE之后给出 表列的名字和定义，用逗号分隔 比如： mysql&gt; CREATE TABLE food -&gt; ( -&gt; food_id int NOT NULL AUTO_INCREMENT, -&gt; food_name char(50) NOT NULL, -&gt; PRIMARY KEY(food_id) -&gt; ) -&gt; ENGINE=InnoDB; Query OK, 0 rows affected (0.32 sec) 上面这个例子中我们可知，创建时需要注意： 表名紧跟在CREATE TABLE关键字后 之后需要用括号将信息括起来 每一行代表表中的一列，由名字-数据类型-属性决定 需要指定主键 结尾需要制定引擎 AUTO_INCREMENT的作用是：当执行INSERT操作时，根据上一个ID自动增量。每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（比如称为主键）。 可以指定默认值，比如 quantity int NOT NULL DEFAULT 1, 常见的引擎有： InnoDB，可靠的事务处理引擎,不支持全文本搜索 MEMORY，功能等同于MyISAM，但由于数据存储在内存（不是磁盘） 中，速度很快（特别适合于临时表） MyISAM是一个性能极高的引擎，它支持全文本搜索， 但不支持事务处理。 2. 更新删除表添加一个列 ALTER TABLE vendors ADD vend_phone CHAR(20); 删除列 ALTER TABLE vendors DROP COLUMN vend_phone; 删除表 DROP TABLE customers2; 重命名表 RENAME TABLE customers TO customers; 2. 操作数据2.1 插入数据把数据插入表中的最简单的方法是使用基本的INSERT语法，要求指定表名和被插入到新行中的值。举个例子： INSERT INTO customers VALUES (NULL, &#39;Pep E. LaPew&#39;, &#39;100 Main Street&#39;, &#39;Coyote Inc.&#39;, ); 上面的SQL 语句高度依赖于表中列的定义次序，容易出错，所以我们最好用比较安全的办法。 INSERT INTO customers (cust_id, cust_name, cust_address, cust_city, ) VALUES (NULL, &#39;Pep E. LaPew&#39;, &#39;100 Main Street&#39;, ); 也可以插入多行： INSERT INTO customers (cust_id, cust_name, cust_address, ) VALUES (NULL, &#39;Pep E. LaPew&#39;, ),VALUES (10002, &#39;Mouse house&#39;,); 2.2 更新和删除数据假设客户10005有了新的电子邮件，因此记录需要更新，语句如下： UPDATE customers SET cust_email = &#39;jack@gmail.com&#39; WHERE cust_id = 10005; 删除 DELETE FROM customers WHERE cust_id = 10006;","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"jiangren.work/tags/MySQL/"}]},{"title":"MySQL总结6-联结","slug":"MySQL总结6-联结","date":"2019-11-29T05:57:41.000Z","updated":"2019-12-30T21:44:24.000Z","comments":true,"path":"2019/11/29/MySQL总结6-联结/","link":"","permalink":"jiangren.work/2019/11/29/MySQL%E6%80%BB%E7%BB%936-%E8%81%94%E7%BB%93/","excerpt":"联结查询。","text":"联结查询。 1. 联结的基本用法1.1 关系表举个例子，我们建立两个表分别对应供应商vendors，和商品信息products。在供应商表中，以供应商的ID作为主键，商品表中以商品ID作为主键。 显然这两者是有联系的，所以我们把vendors表的主键叫做外键，最后形成关系表。 如果数据存储在多个表中，需要依靠联结来实现用单条SELECT语句检索出数据。联结可以从多个表返回一组输出。 1.2 创建联结前面其实已经有过介绍，这里强化一下。利用WHERE vendors.vend_id=products.vend_id即可构建联结关系。此外，FROM子句也和前面不一样，它选择了两个表。 mysql&gt; SELECT vend_name, prod_name, prod_price -&gt; FROM vendors,products -&gt; WHERE vendors.vend_id = products.vend_id -&gt; LIMIT 3; +-------------+--------------+------------+ | vend_name | prod_name | prod_price | +-------------+--------------+------------+ | Anvils R Us | .5 ton anvil | 5.99 | | Anvils R Us | 1 ton anvil | 9.99 | | Anvils R Us | 2 ton anvil | 14.99 | +-------------+--------------+------------+ 3 rows in set (0.22 sec) 这种联结称为等值联结（equijoin），它基于两个表之间的相等测试，这种联结也称为内部联结。 如果要联结多个表需要用AND将联结关系组合起来。 mysql&gt; SELECT vend_name, prod_name, prod_price, quantity -&gt; FROM orderitems,products, vendors -&gt; WHERE products.vend_id = vendors.vend_id -&gt; AND orderitems.prod_id = products.prod_id -&gt; AND order_num = 20005; +-------------+----------------+------------+----------+ | vend_name | prod_name | prod_price | quantity | +-------------+----------------+------------+----------+ | Anvils R Us | .5 ton anvil | 5.99 | 10 | | Anvils R Us | 1 ton anvil | 9.99 | 3 | | ACME | TNT (5 sticks) | 10.00 | 5 | | ACME | Bird seed | 10.00 | 1 | +-------------+----------------+------------+----------+ 4 rows in set (0.21 sec) 2. 联结的高级用法2.1 使用别名前面介绍了别名用作被检索的表列，这里别名用于联结表的简称。 mysql&gt; SELECT cust_name, cust_contact -&gt; FROM customers AS c, orders AS o, orderitems AS oi -&gt; WHERE c.cust_id = o.cust_id -&gt; AND oi.order_num = o.order_num; +----------------+--------------+ | cust_name | cust_contact | +----------------+--------------+ | Coyote Inc. | Y Lee | | Wascals | Jim Jones | | Yosemite Place | Y Sam | | E Fudd | E Fudd | +----------------+--------------+ 11 rows in set (0.22 sec) 2.2 不同类型的联结（1）自联结 举个例子，假如你发现某物品（其ID为DTNTR）存在问题，因此想知道负责生产的供应商的其他物品是否有问题。因此查询逻辑是： 找到生产ID为DTNTR的物品的供应商 找出这个供应商生产的其他物品。 前面我们提到了WHERE中的子查询可以解决这个办法 mysql&gt; SELECT prod_id,prod_name -&gt; FROM products -&gt; WHERE vend_id = ( -&gt; SELECT vend_id FROM products -&gt; WHERE prod_id = &#39;DTNTR&#39;); +---------+----------------+ | prod_id | prod_name | +---------+----------------+ | DTNTR | Detonator | | FB | Bird seed | | FC | Carrots | | SAFE | Safe | | SLING | Sling | | TNT1 | TNT (1 stick) | | TNT2 | TNT (5 sticks) | +---------+----------------+ 7 rows in set (0.23 sec) 现在使用联结进行相同的查询： -&gt; FROM products AS p1, products AS p2 -&gt; WHERE p1.vend_id = p2.vend_id -&gt; AND p2.prod_id = &#39;DTNTR&#39;; +---------+----------------+ | prod_id | prod_name | +---------+----------------+ | DTNTR | Detonator | | FB | Bird seed | | FC | Carrots | | SAFE | Safe | | SLING | Sling | | TNT1 | TNT (1 stick) | | TNT2 | TNT (5 sticks) | +---------+----------------+ 7 rows in set (0.23 sec) Products表用了两次，这是允许的，这也是为什么被称作自联结的原因。但这个使用具有二义性，为MySQL不知道你引用的是products表中的哪个实例。 这段代码的逻辑是： WHERE（通过匹配p1中 的vend_id和p2中的vend_id）首先联结两个表 按第二个表中的 prod_id找到所需要的vend_id，返回所需的数据。 （2）自联结 实现联结的必要条件是：至少有一个列出现在不止一个表中。在标准联结中，会返回所有数据，甚至相同的列会出现很多次，自然联结就是要排除多次出现。 这一 般是通过对表使用通配符（SELECT *），你只能选择那些唯一的列，然后对其他需要明确的列写出来。 mysql&gt; SELECT c.*,o.order_num,o.order_date,oi.prod_id,oi.item_price -&gt; FROM customers AS c, orders AS o, orderitems AS oi -&gt; WHERE c.cust_id = o.cust_id -&gt; AND oi.order_num = o.order_num -&gt; AND prod_id = &#39;FB&#39;; 上面这段程序的逻辑是： 在orderitem中查到prod_id=&#39;FB&#39;，以此为依据知道了order_num 以order_num为依据在orders中查到了cust_id 在customer中找到这个cust_id。 将customer的所有信息连同上面提到的order_item等信息拼在一起，输出。由于cust_id10001下了两个订单，所以有两行。 （3）外部联结 假设我们需要对每个客户下了多少订单进行计数，包括那些至今还没有下单的客户。由于没有下单所以order表中没有记录，缺乏关联性，所以需要外部联结。与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。 mysql&gt; SELECT c.cust_id,o.order_num -&gt; FROM customers AS c LEFT OUTER JOIN orders AS o -&gt; ON c.cust_id=o.cust_id; +---------+-----------+ | cust_id | order_num | +---------+-----------+ | 10001 | 20005 | | 10001 | 20009 | | 10002 | NULL | | 10003 | 20006 | | 10004 | 20007 | | 10005 | 20008 | +---------+-----------+ 6 rows in set (1.82 sec) 这条SELECT语句使用了关键字OUTER JOIN来指定联结的类型（而不是在WHERE子句中指定）。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT 指出的是OUTER JOIN左边的表）。 如果使用RIGHT，则保证所有order_num都会出现。 mysql&gt; SELECT c.cust_id,o.order_num -&gt; FROM customers AS c RIGHT OUTER JOIN orders AS o -&gt; ON c.cust_id=o.cust_id; +---------+-----------+ | cust_id | order_num | +---------+-----------+ | 10001 | 20005 | | 10001 | 20009 | | 10003 | 20006 | | 10004 | 20007 | | 10005 | 20008 | +---------+-----------+ 5 rows in set (0.67 sec)","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"jiangren.work/tags/MySQL/"}]},{"title":"MySQL总结5-函数与计算","slug":"MySQL总结5-函数与计算","date":"2019-11-29T03:01:12.000Z","updated":"2019-12-30T21:41:32.000Z","comments":true,"path":"2019/11/29/MySQL总结5-函数与计算/","link":"","permalink":"jiangren.work/2019/11/29/MySQL%E6%80%BB%E7%BB%935-%E5%87%BD%E6%95%B0%E4%B8%8E%E8%AE%A1%E7%AE%97/","excerpt":"讲解计算字段和函数的使用。","text":"讲解计算字段和函数的使用。 1. 创建计算字段1.1 计算字段存储在数据库表中的数据一般不是应用程序所需要的格式。比如 小区、户型和楼层存储在不同列中，而打印程序需要把它们作为一个恰当格式的字段检索出来。 列数据是大小写混合的，程序需要将它们按大写打印。 需要对某列的数据进行平均数计算。 实质上，字段（field）基本上与列（column）的意思相同，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上 1.2 拼接字段举个例子：在Vendor表中，包含了制造商的名字和国家，但分属于不同的列，我们想把这两个信息拼接起来。所谓拼接(concatenate)将值联结到一起构成单个值。 MySQL使用 Concat()函数来拼接两个列，而其他DBMS使用+或||来实现，所以转换时要小心。 mysql&gt; SELECT Concat(vend_name,&#39;(&#39;,vend_country,&#39;)&#39;) -&gt; FROM vendors; +----------------------------------------+ | Concat(vend_name,&#39;(&#39;,vend_country,&#39;)&#39;) | +----------------------------------------+ | Anvils R Us(USA) | | LT Supplies(USA) | | ACME(USA) | | Furball Inc.(USA) | | Jet Set(England) | | Jouets Et Ours(France) | +----------------------------------------+ 6 rows in set (0.24 sec) 可以用RTrim()去掉右边的空格，LTrim()去掉左边的空格，Trim()去掉两边的空格。 别名（alias）是一个字段或值的替换名，别名用AS关键字赋予。通过别名，客户机能够方便的引用它。 mysql&gt; SELECT Concat(vend_name,&#39;(&#39;,vend_country,&#39;)&#39;) -&gt; AS vend_title -&gt; FROM vendors; +------------------------+ | vend_title | +------------------------+ | Anvils R Us(USA) | | LT Supplies(USA) | | ACME(USA) | | Furball Inc.(USA) | | Jet Set(England) | | Jouets Et Ours(France) | +------------------------+ 6 rows in set (0.54 sec) 1.3 算数计算举个例子假设有一列表示数量，有一列表示单价，现在我要生成一列计算总价 mysql&gt; SELECT prod_id,quantity,item_price, -&gt; quantity*item_price AS expanded_price -&gt; FROM orderitems -&gt; WHERE order_num=20005; +---------+----------+------------+----------------+ | prod_id | quantity | item_price | expanded_price | +---------+----------+------------+----------------+ | ANV01 | 10 | 5.99 | 59.90 | | ANV02 | 3 | 9.99 | 29.97 | | TNT2 | 5 | 10.00 | 50.00 | | FB | 1 | 10.00 | 10.00 | +---------+----------+------------+----------------+ 4 rows in set (0.24 sec) 输出中显示的expanded_price列为一个计算字段，此计算为 quantity*item_price。客户机应用现在可以使用这个新计算 列，就像使用其他列一样。 2. 基本的数据处理函数由于不同DBMS的函数不通用，所以在使用时必须做好注释，表明使用的目的。 2.1 文本处理函数 比如，全部将其转化为大写： mysql&gt; SELECT vend_name,Upper(vend_name) -&gt; FROM vendors; +----------------+------------------+ | vend_name | Upper(vend_name) | +----------------+------------------+ | Anvils R Us | ANVILS R US | | LT Supplies | LT SUPPLIES | | ACME | ACME | | Furball Inc. | FURBALL INC. | | Jet Set | JET SET | | Jouets Et Ours | JOUETS ET OURS | +----------------+------------------+ 6 rows in set (0.26 sec) 其中，Soundx()是发音相似匹配，用于校正错误。 2.2 日期和时间处理函数日期和时间采用相应的数据类型和特殊的格式存储，以便能快速和 有效地排序或过滤，并且节省物理存储空间。 需要注意日期必须为格式yyyy-mm-dd。 假设我们希望检索一个创建于2005-09-01的订单，但是在order_Date中存储的是2005-09-01 11:30:05，这样匹配就变得麻烦了，所以我们需要将年月日单独提取出来。 mysql&gt; SELECT cust_id,order_num -&gt; FROM orders -&gt; WHERE Date(order_date)=&#39;2005-09-01&#39;; +---------+-----------+ | cust_id | order_num | +---------+-----------+ | 10001 | 20005 | +---------+-----------+ 1 row in set (0.26 sec) 另一个例子：我们需要9月里所有的订单信息。 mysql&gt; SELECT cust_id,order_num,order_date -&gt; FROM orders -&gt; WHERE Year(order_date)=2005 AND Month(order_date)=9; +---------+-----------+---------------------+ | cust_id | order_num | order_date | +---------+-----------+---------------------+ | 10001 | 20005 | 2005-09-01 00:00:00 | | 10003 | 20006 | 2005-09-12 00:00:00 | | 10004 | 20007 | 2005-09-30 00:00:00 | +---------+-----------+---------------------+ 3 rows in set (0.24 sec) 2.3 数值处理函数数一般主要用于代数、三角或几何运算 3. 数据汇总函数3.1 聚集函数我们经常需要汇总数据而不用把它们实际检索出来，为此MySQL提供了专门的函数。常见的有以下几种： 确定表中行数（或者满足特定情况的行数） 计算表中行组的和 找出某列的最值平均值。 （1）AVG函数 AVG()可用来返回所有列的平均值，也可以用来返回特定列或行的平均值。 mysql&gt; SELECT AVG(prod_price) AS avg_price -&gt; FROM products; +-----------+ | avg_price | +-----------+ | 16.133571 | +-----------+ 1 row in set (0.24 sec) 当然也可以指定条件： mysql&gt; SELECT AVG(prod_price) AS avg_price -&gt; FROM products; +-----------+ | avg_price | +-----------+ | 16.133571 | +-----------+ 1 row in set (0.24 sec) （2）COUNT函数 COUNT()函数进行计数。可利用COUNT()确定表中行的数目或符合特 定条件的行的数目。 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空 值（NULL）还是非空值。 使用COUNT(column)对特定列中具有值的行进行计数，忽略 NULL值 下面的例子返回customers表中客户的总数： mysql&gt; SELECT COUNT(*) AS num_customers -&gt; FROM customers; +---------------+ | num_customers | +---------------+ | 5 | +---------------+ 1 row in set (0.24 sec) 下面的例子只对具有电子邮件地址的客户计数： mysql&gt; SELECT COUNT(cust_email) AS num_customers -&gt; FROM customers; +---------------+ | num_customers | +---------------+ | 3 | +---------------+ 1 row in set (0.24 sec) （3）MAX和MIN函数 MAX()返回指定列中的最大值。MAX()要求指定列名，如下所示： mysql&gt; SELECT MAX(prod_price) AS max_price -&gt; FROM products; +-----------+ | max_price | +-----------+ | 55.00 | +-----------+ 1 row in set (0.24 sec) （4）SUM函数 SUM()用来返回指定列值的和（总计）。 下面举一个例子，orderitems表包含订单中实际的物品，每个物品 有相应的数量（quantity）。可如下检索所订购物品的总数： mysql&gt; SELECT SUM(quantity) AS items_ordered -&gt; FROM orderitems -&gt; WHERE order_num=20005; +---------------+ | items_ordered | +---------------+ | 19 | +---------------+ 1 row in set (0.24 sec) SUM()也可以用来合计计算值。 mysql&gt; SELECT SUM(quantity*item_price) AS items_ordered -&gt; FROM orderitems -&gt; WHERE order_num =20005; +---------------+ | items_ordered | +---------------+ | 149.87 | +---------------+ 1 row in set (0.24 sec) 3.2 组合聚集实际上SELECT 语句可根据需要包含多个聚集函数。请看下面的例子： mysql&gt; SELECT COUNT(*) AS num_items, -&gt; MAX(prod_price) AS price_max, -&gt; MIN(prod_price) AS price_min -&gt; FROM products; +-----------+-----------+-----------+ | num_items | price_max | price_min | +-----------+-----------+-----------+ | 14 | 55.00 | 2.50 | +-----------+-----------+-----------+ 1 row in set (0.24 sec)","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"jiangren.work/tags/MySQL/"}]},{"title":"MySQL总结4-正则表达式","slug":"MySQL总结4-正则表达式","date":"2019-11-29T02:08:16.000Z","updated":"2019-12-30T21:40:29.000Z","comments":true,"path":"2019/11/29/MySQL总结4-正则表达式/","link":"","permalink":"jiangren.work/2019/11/29/MySQL%E6%80%BB%E7%BB%934-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"随着过滤难度的增加，通过WHERE就很难完成任务了，我们需要正则表达式来进行匹配。正则表达式是用来匹配文本的特殊的字符集合。","text":"随着过滤难度的增加，通过WHERE就很难完成任务了，我们需要正则表达式来进行匹配。正则表达式是用来匹配文本的特殊的字符集合。 1. 基本字符匹配检索列prod_name包含文本1000的所有行 mysql&gt; SELECT prod_price,prod_name,vend_id FROM products -&gt; WHERE prod_name REGEXP &#39;1000&#39;; +------------+--------------+---------+ | prod_price | prod_name | vend_id | +------------+--------------+---------+ | 35.00 | JetPack 1000 | 1005 | +------------+--------------+---------+ 1 row in set (0.30 sec) 这条语句非常像LIKE，不同之处在于REGEXP告诉MySQL：后面的东西作为正则表达式理解。 下面这个例子说明了正则表达式优于LIKE的地方 mysql&gt; SELECT prod_price,prod_name,vend_id FROM products -&gt; WHERE prod_name REGEXP &#39;.000&#39;; +------------+--------------+---------+ | prod_price | prod_name | vend_id | +------------+--------------+---------+ | 35.00 | JetPack 1000 | 1005 | | 55.00 | JetPack 2000 | 1005 | +------------+--------------+---------+ 2 rows in set (0.22 sec) 这里使用了正则表达式.000。点号是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符，因此，1000和2000都匹配且返回。 2. OR匹配如果要搜索两个串之一，使用 | 进行逻辑安排。 mysql&gt; SELECT prod_price,prod_name,vend_id FROM products -&gt; WHERE prod_name REGEXP &#39;1000|2000&#39;; +------------+--------------+---------+ | prod_price | prod_name | vend_id | +------------+--------------+---------+ | 35.00 | JetPack 1000 | 1005 | | 55.00 | JetPack 2000 | 1005 | +------------+--------------+---------+ 2 rows in set (0.23 sec) 3. 匹配其中几个字符如果想要匹配某几个特定的字符，则使用[ ]括起来 mysql&gt; SELECT prod_price,prod_name,vend_id FROM products -&gt; WHERE prod_name REGEXP &#39;[123] Ton&#39;; +------------+-------------+---------+ | prod_price | prod_name | vend_id | +------------+-------------+---------+ | 9.99 | 1 ton anvil | 1001 | | 14.99 | 2 ton anvil | 1001 | +------------+-------------+---------+ 2 rows in set (0.23 sec) 注意：正则默认是不区分大小写的。如果要区分，可使用BINARY关键字，如WHERE prod_name REGEXP BINARY &#39;Jet&#39; [ ]可以理解为一种简写的OR语言，[123]等价于1|2|3，但要注意 mysql&gt; SELECT prod_price,prod_name,vend_id FROM products -&gt; WHERE prod_name REGEXP &#39;1|2|3 Ton&#39;; +------------+---------------+---------+ | prod_price | prod_name | vend_id | +------------+---------------+---------+ | 9.99 | 1 ton anvil | 1001 | | 14.99 | 2 ton anvil | 1001 | | 35.00 | JetPack 1000 | 1005 | | 55.00 | JetPack 2000 | 1005 | | 2.50 | TNT (1 stick) | 1003 | +------------+---------------+---------+ 5 rows in set (0.22 sec) 上面没有输出预期结果的原因是没有用括号括起来。 mysql&gt; SELECT prod_price,prod_name,vend_id FROM products -&gt; WHERE prod_name REGEXP &#39;[1|2|3] Ton&#39;; +------------+-------------+---------+ | prod_price | prod_name | vend_id | +------------+-------------+---------+ | 9.99 | 1 ton anvil | 1001 | | 14.99 | 2 ton anvil | 1001 | +------------+-------------+---------+ 2 rows in set (0.23 sec) 4. 范围匹配集合可用来定义要匹配的一个或多个字符，例如匹配数字0到9。可以从[0123456789]简化为[0-9] mysql&gt; SELECT prod_price,prod_name,vend_id FROM products -&gt; WHERE prod_name REGEXP &#39;[1-5] Ton&#39;; +------------+--------------+---------+ | prod_price | prod_name | vend_id | +------------+--------------+---------+ | 5.99 | .5 ton anvil | 1001 | | 9.99 | 1 ton anvil | 1001 | | 14.99 | 2 ton anvil | 1001 | +------------+--------------+---------+ 3 rows in set (0.23 sec) 5. 特殊字符匹配有些字符有特殊含义，比如.代表匹配一个任意字符，如果想要匹配真正的点号，就需要转义。 mysql&gt; SELECT prod_price,prod_name,vend_id FROM products -&gt; WHERE prod_name REGEXP &#39;\\\\.&#39;; +------------+--------------+---------+ | prod_price | prod_name | vend_id | +------------+--------------+---------+ | 5.99 | .5 ton anvil | 1001 | +------------+--------------+---------+ 1 row in set (0.22 sec) 要注意斜杠是反斜杠，在Enter上面。 6. 匹配预定义字符集可以使用预定义的字符集，也称为字符类 （character class）。以下例子匹配了所有带有空格的数据，省略了一部分节省空间。 mysql&gt; SELECT prod_price,prod_name,vend_id FROM products -&gt; WHERE prod_name REGEXP &#39;[:blank:]&#39;; +------------+----------------+---------+ | prod_price | prod_name | vend_id | +------------+----------------+---------+ | 5.99 | .5 ton anvil | 1001 | | 9.99 | 1 ton anvil | 1001 | | .... | ....... | .... | | 2.50 | TNT (1 stick) | 1003 | | 10.00 | TNT (5 sticks) | 1003 | +------------+----------------+---------+ 13 rows in set (0.23 sec) 7. 匹配多个实例有时需要 对匹配的数目进行更强的控制，所以需要重复元字符。 第一个实例展示了?的用法。sticks?匹配stick 和sticks（s后的?使s可选，因为?匹配它前面的任何字符的0次或1次出现） mysql&gt; SELECT prod_price,prod_name,vend_id FROM products -&gt; WHERE prod_name REGEXP &#39;[0-9] sticks?&#39;; +------------+----------------+---------+ | prod_price | prod_name | vend_id | +------------+----------------+---------+ | 2.50 | TNT (1 stick) | 1003 | | 10.00 | TNT (5 sticks) | 1003 | +------------+----------------+---------+ 2 rows in set (0.23 sec) 第二个实例展示了{}的用法。[:digit:]匹配任意数字{4}确切地要求它前面的字符（任意数字）出现4次。注意： 一定要用[ ]括起来，否则会出现语义错误。 { }不能填0 mysql&gt; SELECT prod_price,prod_name,vend_id FROM products -&gt; WHERE prod_name REGEXP &#39;[[:digit:]]{4}&#39;; +------------+--------------+---------+ | prod_price | prod_name | vend_id | +------------+--------------+---------+ | 35.00 | JetPack 1000 | 1005 | | 55.00 | JetPack 2000 | 1005 | +------------+--------------+---------+ 2 rows in set (0.23 sec) 8. 定位符目前为止的所有例子都是匹配一个串中任意位置的文本。为了匹配特定位置的文本，需要使用定位符。 假设要找到一个以.开头的产品，则 mysql&gt; SELECT prod_price,prod_name,vend_id FROM products -&gt; WHERE prod_name REGEXP &#39;^[\\\\.]&#39;; +------------+--------------+---------+ | prod_price | prod_name | vend_id | +------------+--------------+---------+ | 5.99 | .5 ton anvil | 1001 | +------------+--------------+---------+ 1 row in set (0.23 sec) 此外^还有否定的用法，在集合中[ ]使用^，表示否定该集合。","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"jiangren.work/tags/MySQL/"}]},{"title":"MySQL总结3-数据过滤","slug":"MySQL总结3-数据过滤","date":"2019-11-28T07:00:46.000Z","updated":"2019-12-30T21:40:01.000Z","comments":true,"path":"2019/11/28/MySQL总结3-数据过滤/","link":"","permalink":"jiangren.work/2019/11/28/MySQL%E6%80%BB%E7%BB%933-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/","excerpt":"总结MySQL中的数据过滤方法：WHERE的基本过滤，WHERE的组合过滤，通配符过滤，子查询，组合查询。","text":"总结MySQL中的数据过滤方法：WHERE的基本过滤，WHERE的组合过滤，通配符过滤，子查询，组合查询。 1. WHERE的初级过滤只检索所需数据需要指定搜索条件（search criteria），搜索条件也称为过滤条件（filter condition）。 mysql&gt; SELECT prod_name,prod_price -&gt; FROM products -&gt; WHERE prod_price=2.50; +---------------+------------+ | prod_name | prod_price | +---------------+------------+ | Carrots | 2.50 | | TNT (1 stick) | 2.50 | +---------------+------------+ 2 rows in set (0.88 sec) 除了上面提到的相等操作，还有WHERE通过其他操作符还能实现许多功能。 1.1 检查单个值上面举了一个利用相等条件检查单个值的情况，下面再看一个利用不等条件的例子。 mysql&gt; SELECT prod_name,prod_price -&gt; FROM products -&gt; WHERE prod_price &gt; 50; +--------------+------------+ | prod_name | prod_price | +--------------+------------+ | JetPack 2000 | 55.00 | +--------------+------------+ 1 row in set (0.25 sec) 1.2 不匹配检查列出不是由供应商1003制造的产品。 mysql&gt; SELECT vend_id, prod_name -&gt; FROM products -&gt; WHERE vend_id &lt;&gt; 1003; +---------+--------------+ | vend_id | prod_name | +---------+--------------+ | 1001 | .5 ton anvil | | 1001 | 1 ton anvil | | 1001 | 2 ton anvil | | 1002 | Fuses | | 1005 | JetPack 1000 | | 1005 | JetPack 2000 | | 1002 | Oil can | +---------+--------------+ 7 rows in set (0.24 sec) 既可以使用&lt;&gt;操作符，也可以使用!=操作符。 1.3 范围值检查为了检查某个范围的值，可使用BETWEEN操作符。下面展示，BETWEEN操作符检索价格在5美元和10美元之间的商品。 mysql&gt; SELECT prod_name,prod_price -&gt; FROM products -&gt; WHERE prod_price BETWEEN 5 and 10; +----------------+------------+ | prod_name | prod_price | +----------------+------------+ | .5 ton anvil | 5.99 | | 1 ton anvil | 9.99 | | Bird seed | 10.00 | | Oil can | 8.99 | | TNT (5 sticks) | 10.00 | +----------------+------------+ 5 rows in set (0.75 sec) 在使用BETWEEN时需要跟在WHERE后面，必须指定两个值 ——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。 1.4 空值检查SELECT语句有一个特殊的WHERE子句，可用来检查具有NULL值的列。 这个WHERE子句就是IS NULL子句。 mysql&gt; SELECT prod_name -&gt; From products -&gt; WHERE prod_price IS NULL; Empty set (0.24 sec) 注意，不能使用相等条件来检查NULL，必须使用特殊语句。 2. WHERE的高级过滤2.1 组合WHERE语句使用AND操作符给WHERE子句附加条件。 mysql&gt; SELECT prod_id,prod_price,vend_id -&gt; FROM products -&gt; WHERE vend_id=1003 AND prod_price&lt;=10; +---------+------------+---------+ | prod_id | prod_price | vend_id | +---------+------------+---------+ | FB | 10.00 | 1003 | | FC | 2.50 | 1003 | | SLING | 4.49 | 1003 | | TNT1 | 2.50 | 1003 | | TNT2 | 10.00 | 1003 | +---------+------------+---------+ 5 rows in set (0.24 sec) OR操作符与AND操作符不同，它指示MySQL检索匹配任一条件的行。 mysql&gt; SELECT prod_id,prod_price,vend_id -&gt; FROM products -&gt; WHERE prod_price&lt;5 OR vend_id=1001; +---------+------------+---------+ | prod_id | prod_price | vend_id | +---------+------------+---------+ | ANV01 | 5.99 | 1001 | | ANV02 | 9.99 | 1001 | | ANV03 | 14.99 | 1001 | | FC | 2.50 | 1003 | | FU1 | 3.42 | 1002 | | SLING | 4.49 | 1003 | | TNT1 | 2.50 | 1003 | +---------+------------+---------+ 7 rows in set (0.25 sec) 同时使用AND和OR时要注意：SQL在处理OR操作符前，优先处理AND操 作符。此问题的解决方法是使用圆括号明确地分组相应的操作符。 mysql&gt; SELECT prod_id,prod_price,vend_id -&gt; FROM products -&gt; WHERE (vend_id=1003 OR vend_id=1002)AND prod_price&lt;5; +---------+------------+---------+ | prod_id | prod_price | vend_id | +---------+------------+---------+ | FC | 2.50 | 1003 | | FU1 | 3.42 | 1002 | | SLING | 4.49 | 1003 | | TNT1 | 2.50 | 1003 | +---------+------------+---------+ 4 rows in set (0.24 sec) 2.2 IN操作符圆括号在WHERE子句中还有另外一种用法。IN操作符用来指定条件。 mysql&gt; SELECT prod_price,prod_name,vend_id -&gt; From products -&gt; WHERE vend_id IN(1002,1005); +------------+--------------+---------+ | prod_price | prod_name | vend_id | +------------+--------------+---------+ | 3.42 | Fuses | 1002 | | 35.00 | JetPack 1000 | 1005 | | 55.00 | JetPack 2000 | 1005 | | 8.99 | Oil can | 1002 | +------------+--------------+---------+ 4 rows in set (0.24 sec) 这并不表示范围，特别表示1002和1005这两个对象。相较于AND和OR更清晰直观。 2.3 NOT操作符WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所 跟的任何条件。 mysql&gt; SELECT prod_price,prod_name,vend_id -&gt; From products -&gt; WHERE vend_id NOT IN(1002,1005); +------------+----------------+---------+ | prod_price | prod_name | vend_id | +------------+----------------+---------+ | 5.99 | .5 ton anvil | 1001 | | 9.99 | 1 ton anvil | 1001 | | 14.99 | 2 ton anvil | 1001 | | 13.00 | Detonator | 1003 | | 10.00 | Bird seed | 1003 | | 2.50 | Carrots | 1003 | | 50.00 | Safe | 1003 | | 4.49 | Sling | 1003 | | 2.50 | TNT (1 stick) | 1003 | | 10.00 | TNT (5 sticks) | 1003 | +------------+----------------+---------+ 10 rows in set (0.24 sec) 3. 通配符过滤前面提到：用SELECT搜索所有数据的时候，用到的*就是一个通配符除了这个符号还有两种比较常见的。 3.1 百分号%%表示任何字符出现任意次数。例如，为了找出所有以词jet起头的产品，可使用以下SELECT 语句： mysql&gt; SELECT prod_price,prod_name,vend_id -&gt; From products -&gt; WHERE prod_name LIKE &#39;jet%&#39;; +------------+--------------+---------+ | prod_price | prod_name | vend_id | +------------+--------------+---------+ | 35.00 | JetPack 1000 | 1005 | | 55.00 | JetPack 2000 | 1005 | +------------+--------------+---------+ 2 rows in set (0.54 sec) 此例子使用了搜索模式&#39;jet%&#39;。在执行这条子句时，将检索任意以jet起头的词。%告诉MySQL接受jet之后的任意字符，不 管它有多少字符。 注意：按照MySQL的配置方式，搜索是区分大小写的。 通配符可在搜索模式中任意位置使用，并且可以使用多个通配符。 mysql&gt; SELECT prod_price,prod_name,vend_id -&gt; From products -&gt; WHERE prod_name LIKE &#39;%anvil%&#39;; +------------+--------------+---------+ | prod_price | prod_name | vend_id | +------------+--------------+---------+ | 5.99 | .5 ton anvil | 1001 | | 9.99 | 1 ton anvil | 1001 | | 14.99 | 2 ton anvil | 1001 | +------------+--------------+---------+ 3 rows in set (0.25 sec) 3.2 下划线 _下划线只匹配单个字符而不是多个字符。 如下所示.5 ton anvi的产品没有被匹配。 mysql&gt; SELECT prod_price,prod_name,vend_id -&gt; From products -&gt; WHERE prod_name LIKE &#39;_ ton anvil&#39;; +------------+-------------+---------+ | prod_price | prod_name | vend_id | +------------+-------------+---------+ | 9.99 | 1 ton anvil | 1001 | | 14.99 | 2 ton anvil | 1001 | +------------+-------------+---------+ 2 rows in set (0.24 sec) 如果输入__ ton anvil则只返回.5 ton anvil那个产品。 4. 分组过滤4.1 数据分组分组是在SELECT语句的GROUP BY子句中建立的。下面的例子中我们利用COUNT统计数据，分组。 mysql&gt; SELECT vend_id, COUNT(*) AS num_probs -&gt; FROM products -&gt; GROUP BY vend_id; +---------+-----------+ | vend_id | num_probs | +---------+-----------+ | 1001 | 3 | | 1002 | 2 | | 1003 | 7 | | 1005 | 2 | +---------+-----------+ 4 rows in set (0.55 sec) GROUP BY子句有一些独特的地方 GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套， 为数据分组提供更细致的控制。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 4.1 过滤分组为WHERE过滤指定的是行而不是分组，如果要对分组进行过滤，需要使用HAVING子句。 mysql&gt; SELECT cust_id, COUNT(*) AS orders -&gt; FROM orders -&gt; GROUP BY cust_id -&gt; HAVING COUNT(*)&gt;=2; +---------+--------+ | cust_id | orders | +---------+--------+ | 10001 | 2 | +---------+--------+ 1 row in set (0.24 sec) HAVING也可以和WHERE共用： mysql&gt; SELECT vend_id,COUNT(*) AS num_prods -&gt; FROM products -&gt; WHERE prod_price&gt;=10 -&gt; GROUP BY vend_id -&gt; HAVING COUNT(*)&gt;=2; +---------+-----------+ | vend_id | num_prods | +---------+-----------+ | 1003 | 4 | | 1005 | 2 | +---------+-----------+ 2 rows in set (0.24 sec) 4.3 SELECT子句顺序目前已经介绍了WHERE, GROUP BY, HAVING, ORDER BY, LIMIT等子句，这些字句都可以共用，但顺序需要注意。 子句 作用 SELECT 选择一些列或表达式 FROM 要检索的表 WHERE 行级过滤 GROUP BY 分组说明 HAVING 组级过滤 ORDER BY 排序 LIMIT 输出的行数 5. 子查询所谓子查询就是在WHERE中再嵌套WHERE，用IN连接 mysql&gt; SELECT cust_id FROM orders -&gt; WHERE order_num IN -&gt; (SELECT order_num FROM orderitems -&gt; WHERE prod_id = &#39;TNT2&#39;); +---------+ | cust_id | +---------+ | 10001 | | 10004 | +---------+ 2 rows in set (0.56 sec) 当然也可以使用计算字段来进行过滤查询。下面这个例子中查询了两个表：customers和orders，将orders表中查询到的各个客户的订单数量，汇总。 mysql&gt; SELECT cust_name, cust_state, -&gt; (SELECT COUNT(*) FROM orders -&gt; WHERE orders.cust_id = customers.cust_id) -&gt; AS orders -&gt; FROM customers ORDER BY cust_name; +----------------+------------+--------+ | cust_name | cust_state | orders | +----------------+------------+--------+ | Coyote Inc. | MI | 2 | | E Fudd | IL | 1 | | Mouse House | OH | 0 | | Wascals | IN | 1 | | Yosemite Place | AZ | 1 | +----------------+------------+--------+ 5 rows in set (0.25 sec) 6. 组合查询前面提到WHERE可以使用OR组合查询条件，这里再提供另一种查询方法UNION mysql&gt; SELECT vend_id, prod_id, prod_price -&gt; FROM products -&gt; WHERE prod_price&lt;=5 -&gt; UNION -&gt; SELECT vend_id, prod_id, prod_price -&gt; FROM products -&gt; WHERE vend_id IN(1001,1002); +---------+---------+------------+ | vend_id | prod_id | prod_price | +---------+---------+------------+ | 1003 | FC | 2.50 | | 1002 | FU1 | 3.42 | | 1003 | SLING | 4.49 | | 1003 | TNT1 | 2.50 | | 1001 | ANV01 | 5.99 | | 1001 | ANV02 | 9.99 | | 1001 | ANV03 | 14.99 | | 1002 | OL1 | 8.99 | +---------+---------+------------+ 8 rows in set (0.24 sec) 他等价于WHERE和OR的组合： mysql&gt; SELECT vend_id, prod_id, prod_price -&gt; FROM products -&gt; WHERE prod_price&lt;=5 OR vend_id IN(1001,1002); +---------+---------+------------+ | vend_id | prod_id | prod_price | +---------+---------+------------+ | 1001 | ANV01 | 5.99 | | 1001 | ANV02 | 9.99 | | 1001 | ANV03 | 14.99 | | 1003 | FC | 2.50 | | 1002 | FU1 | 3.42 | | 1002 | OL1 | 8.99 | | 1003 | SLING | 4.49 | | 1003 | TNT1 | 2.50 | +---------+---------+------------+ 8 rows in set (0.24 sec)","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"jiangren.work/tags/MySQL/"}]},{"title":"MySQL总结2-检索与排序","slug":"MySQL总结2-检索与排序","date":"2019-11-28T06:07:56.000Z","updated":"2019-12-30T21:34:44.000Z","comments":true,"path":"2019/11/28/MySQL总结2-检索与排序/","link":"","permalink":"jiangren.work/2019/11/28/MySQL%E6%80%BB%E7%BB%932-%E6%A3%80%E7%B4%A2%E4%B8%8E%E6%8E%92%E5%BA%8F/","excerpt":"最简单的检索数据和排序。","text":"最简单的检索数据和排序。 1. 检索数据检索数据主要依靠SELECT语句执行，使用时必须给出两条必要信息——想选择什么、从什么地方选。 1.1 检索单个列展示一个示例，利用SELECT语句从products表中检索一个名为 prod_name的列。大小写都可以。 mysql&gt; SELECT prod_name FROM products; +----------------+ | prod_name | +----------------+ | .5 ton anvil | | 1 ton anvil | | 2 ton anvil | | ... | +----------------+ 14 rows in set (0.24 sec) 1.2 检索多个列和之前一样，使用SELECT语句从表products 中选择数据。在这个例子中，指定了2个列名，列名之间用逗号分隔。 mysql&gt; SELECT prod_id,prod_name FROM products; +---------+----------------+ | prod_id | prod_name | +---------+----------------+ | ANV01 | .5 ton anvil | | ANV02 | 1 ton anvil | | ANV03 | 2 ton anvil | | DTNTR | Detonator | | .. | ......... | +---------+----------------+ 14 rows in set (1.24 sec) 1.3 检索所有列SELECT语句可以通过通配符 * 来检索所有列。 1.4 检索不同的行如上所示，检索列时会列出所有结果，数量太多，我们就需要指定行。解决办法是使用DISTINCT关键字，顾名思义，此关键字指示MySQL 只返回不同的值。 mysql&gt; SELECT DISTINCT vend_id FROM products; +---------+ | vend_id | +---------+ | 1001 | | 1002 | | 1003 | | 1005 | +---------+ 4 rows in set (1.19 sec) 当利用DISTINCT检索不同列时，只有不同列都相同的结果才会被过滤。 mysql&gt; SELECT DISTINCT vend_id, prod_price FROM products; +---------+------------+ | vend_id | prod_price | +---------+------------+ | 1001 | 5.99 | | 1001 | 9.99 | | 1001 | 14.99 | | 1003 | 13.00 | | 1003 | 10.00 | | 1003 | 2.50 | | 1002 | 3.42 | +---------+------------+ 12 rows in set (0.24 sec) 1.5 限制结果为 了返回第一行或前几行，可使用LIMIT子句。 mysql&gt; SELECT prod_name FROM products -&gt; LIMIT 3; +--------------+ | prod_name | +--------------+ | .5 ton anvil | | 1 ton anvil | | 2 ton anvil | +--------------+ 3 rows in set (1.09 sec) 为得出下一个5行，可指定检索的开始行和行数。 mysql&gt; SELECT prod_name FROM products -&gt; LIMIT 5,2; +-----------+ | prod_name | +-----------+ | Carrots | | Fuses | +-----------+ 2 rows in set (0.24 sec) 注意：第一行是0，所以输入1,1得到的结果是第二行而不是第一行。 1.6 使用完全限定的表名上面的例子都是通过表名和列名引用某列，我们也可以通过完全限定的名字来引用： mysql&gt; SELECT products.prod_name -&gt; FROM products; mysql&gt; SELECT products.prod_name -&gt; FROM test.products; 2. 排序检索数据2.1 排序数据我们之前利用SELECT得到的结果都没有特定的顺序，当然这并不意味着他们是随机出现的。实际上，如果不排序，数据一般将以它在底层表中出现的顺序显示，是最初添加的时候的顺序。 为了明确地排序用SELECT语句检索出的数据，可使用ORDER BY子句。 ORDER BY子句取一个或多个列的名字，据此对输出进行排序。 mysql&gt; SELECT prod_name,prod_id,vend_id FROM products -&gt; ORDER BY vend_id; +----------------+---------+---------+ | prod_name | prod_id | vend_id | +----------------+---------+---------+ | .5 ton anvil | ANV01 | 1001 | | 1 ton anvil | ANV02 | 1001 | | 2 ton anvil | ANV03 | 1001 | | Fuses | FU1 | 1002 | | Oil can | OL1 | 1002 | | Detonator | DTNTR | 1003 | | Bird seed | FB | 1003 | | JetPack 2000 | JP2000 | 1005 | +----------------+---------+---------+ 14 rows in set (0.24 sec) 2.2 按多个列排序我们有时候需要对多个列排序，必须显示雇员清单时，我们需要先按姓排序，再按名排序。 mysql&gt; SELECT prod_id,prod_price,vend_id FROM products -&gt; ORDER BY prod_price, vend_id; +---------+------------+---------+ | prod_id | prod_price | vend_id | +---------+------------+---------+ | FC | 2.50 | 1003 | | TNT1 | 2.50 | 1003 | | FU1 | 3.42 | 1002 | | SLING | 4.49 | 1003 | | ANV01 | 5.99 | 1001 | | OL1 | 8.99 | 1002 | | ANV02 | 9.99 | 1001 | | FB | 10.00 | 1003 | | TNT2 | 10.00 | 1003 | | DTNTR | 13.00 | 1003 | +---------+------------+---------+ 14 rows in set (0.24 sec) 2.3 指定排序方向数据的排序不仅局限于升序，从A-Z，还可以降序，使用DESC关键词。 mysql&gt; SELECT prod_id,prod_price,vend_id FROM products -&gt; ORDER BY prod_price DESC; +---------+------------+---------+ | prod_id | prod_price | vend_id | +---------+------------+---------+ | JP2000 | 55.00 | 1005 | | OL1 | 8.99 | 1002 | | ANV01 | 5.99 | 1001 | | SLING | 4.49 | 1003 | | FU1 | 3.42 | 1002 | | FC | 2.50 | 1003 | | TNT1 | 2.50 | 1003 | +---------+------------+---------+ 14 rows in set (0.24 sec) 对多个列降序排序，需要注意DESC的位置。DESC关键字只应用到直接位于其前面的列名。下面的例子中，只有price是降序排名，id还是升序。 mysql&gt; SELECT prod_id,prod_price,vend_id FROM products -&gt; ORDER BY prod_price DESC, vend_id; +---------+------------+---------+ | prod_id | prod_price | vend_id | +---------+------------+---------+ | JP2000 | 55.00 | 1005 | | SLING | 4.49 | 1003 | | FU1 | 3.42 | 1002 | | FC | 2.50 | 1003 | | TNT1 | 2.50 | 1003 | +---------+------------+---------+ 14 rows in set (0.88 sec)","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"jiangren.work/tags/MySQL/"}]},{"title":"MySQL总结1-MySQL简介","slug":"MySQL总结1-MySQL简介","date":"2019-11-28T02:07:18.000Z","updated":"2019-12-30T21:33:45.000Z","comments":true,"path":"2019/11/28/MySQL总结1-MySQL简介/","link":"","permalink":"jiangren.work/2019/11/28/MySQL%E6%80%BB%E7%BB%931-MySQL%E7%AE%80%E4%BB%8B/","excerpt":"MySQL入门的一些基本概念。","text":"MySQL入门的一些基本概念。 1. 什么是数据库和SQL数据库是一个以某种有组织的方式存储的数据集合，它通常用来作为保存有组织的数据的容器。 组织容器数据的方式主要通过表来实现。 表是某种特定类型数据的结构化清单。关键点在于，存储在表中的数据是同一种类型的数据。数据库中的每个表都有一个名字，用来标识自己，此名字是唯一的。 表中包含列和行，每一列都存储着相同数据类型的数据。例如，存储时指定该列存储整数，则该列相应的数据都应该是整数。行，也称为数据库记录，它实质上记录了一套完整的数据。 前面提到的名字唯一性来源于主键。主键的值能唯一区分表中的每一行，比如上面的Emp_Id。表中的任意列都可以作为主键，条件是： 任意两行具有不同的主键值 每行都必须具有一个主键值，不允许出现NULL值 当然主键并不是限制于唯一的一列，可以多个列形成联合主键，此时条件就变为了：所有列值的组合必须唯一。下图所示，通过社区名称、楼层和户型联合确定某一住户。 社区名称 楼层 户型 天鑫小区 23 2 龙湾小区 16 3 龙湾小区 16 1 主键最好保证不变性，也就是说我们不应该更新主键值，也不要采用可能变更的值作为主键（比如某个供应商的名字，他们合并或收购时可能改名）。 SQL (Structured Query Language) 是一种专门用来与数据库通信的语言。SQL不是某一种特定数据库供应商的专用语言，几乎所有DBMS都支持SQL，但每家的SQL有些许差异。 2. 什么是MySQL前面介绍的SQL只是一种语言，而实现的载体是数据库软件——DBMS（数据库管理系统）。而MySQL就是一种数据库软件。 DBMS通常分为两类：基于共享文件系统的DBMS和基于客户端-服务器的DBMS，我们通常使用后者。MySQL、Oracle以及Microsoft SQL Server等数据库是基于客户端—服务器的数据库。客户端-服务器模式下，需要软件分别运行在客户端和服务器下。 如何使用数据库？ 首先查看当前数据库有哪些。 show DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | | test | +--------------------+ 然后选择一个 use test; Database changed 查看数据库内的表： show tables; +----------------+ | Tables_in_test | +----------------+ | customers | | orderitems | | orders | | productnotes | | products | | vendors | +----------------+ 6 rows in set (0.24 sec)","categories":[{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","permalink":"jiangren.work/tags/MySQL/"}]},{"title":"CPP多线程总结1-线程管理","slug":"CPP多线程总结1-线程管理","date":"2019-11-26T06:25:02.000Z","updated":"2019-12-30T21:21:16.000Z","comments":true,"path":"2019/11/26/CPP多线程总结1-线程管理/","link":"","permalink":"jiangren.work/2019/11/26/CPP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%931-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"包含了线程创建的基本操作和注意事项，如何向线程传递参数，以及线程管理的高级操作：转移所有权和动态数量。","text":"包含了线程创建的基本操作和注意事项，如何向线程传递参数，以及线程管理的高级操作：转移所有权和动态数量。 1. 创建与启动线程1.1 线程与进程线程与进程的区别，这个问题真的是老生常谈了，在开始之前最好还是复习一遍： 对于操作系统来说，一个任务就是一个进程(Process)，比如打开浏览器，使用word。而一个进程可能不只干一件事（比如word既要打字又要检查拼写），这种进程内的多个子任务就是线程（Thread）。 具体来说： 进程是操作系统分配资源的单位，而线程是进程的一个实体，是CPU调度和分派的基本单位。 线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 多进程与多线程：现代操作系统一般都是多进程的，他可以同时运行多个任务，一般来说一个CPU核对应一个进程，如果开启的进程比较多就需要使用时间片轮转进程调度算法。它的思想简单介绍如下：在操作系统的管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，这样用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。 引入线程的好处： 在进程内创建、终止线程比创建、终止进程要快； 同一进程内的线程间切换比进程间的切换要快。 总结： 一个程序至少有一个进程,一个进程至少有一个线程。 线程的划分尺度小于进程，使得多线程程序的并发性高（多个计算同时执行）。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 虽然线程拥有单独的程序运行入口，出口，但不能独立执行。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 1.2 启动线程在C++11的标准库中，将创建线程和创建实例两个动作统一起来，对于人们来说来说，线程就变成了如内存、文件一样的资源，由 C++ 提供统一的接口进行管理。同时，我们也已知晓，创建线程需指定线程函数。那么，根据线程函数的不同，在 C++ 中使用 std::thread 直接创建线程，大致有三种不同的方式。 1）使用函数指针创建 void do_some_work(); std::thread wk_thread{do_some_work}; 这就是最基本的方式，当然也可以显示的传入&amp;do_some_work当做构造参数，或者利用auto进行构造： void thread_function() { for (int i = 0; i &lt; 100; i++) std::cout &lt;&lt; &quot;thread function excuting&quot; &lt;&lt; std::endl; } auto fun1 = thread_function; std::thread wk_thread(fun1); （2）可调用类型创建 class DisplayThread { public: void operator ()() { for (int i = 0; i &lt; 100; i++) std::cout &lt;&lt; &quot;Display Thread Excecuting&quot; &lt;&lt; std::endl; } }; std::thread wk_thread{DisplayThread{}}; 若是在创建线程的时候，传入的是临时构造的实例，需要注意 C++ 的语法解析规则。这种情况下，推荐使用 C++ 的列表初始化。 std::thread wk_thread(ThreadTask()); // 1 std::thread wk_thread{ThreadTask{}}; // 2 1可能会被理解为一个函数声明：参数是函数指针ThreadTask，返回类型是thread。所以这种情况下最好用花括号初始化。 （3）Lambda表达式 auto a = 1, b = 5; auto dosomething = [a=a,b=b]() {cout &lt;&lt; a+b &lt;&lt; endl; }; std::thread wk_thread(dosomething); 1.3 线程控制正如申请了内存，必须主动释放一样，对线程的管理也讲究有始有终。当线程启动之后，我们可以在 std::thread 实例销毁之前，显式地说明我们希望如何处理实例对应线程的结束状态。如果上述实例销毁之时，程序员尚未显式说明如何处理对应线程的结束状态，那么在上述实例的析构函数中，会调用 std::terminate() 函数，终止整个程序。 在主线程中，我们可以选择「挂起 (join)」或者「分离 (detach)」产生的子线程。具体来说，就是对 std::thread 实例调用 join() 或者 detach() 成员函数。 void do_something(); std::thread join_me{do_something}; std::thread detach_me{do_something}; if (join_me.joinable()) { // 1 join_me.join(); } if (detach_me.joinable()) { // 1 detach_me.detach(); } 如果选择挂起子线程，则主线程会被阻塞，直到子线程退出为止。如果选择分离子线程，则主线程对子线程的控制权丢失，将控制权转交给C++库。这会导致几个问题： 主线程结束之后，子线程可能仍在运行（因而可以作为守护线程） 主线程结束伴随着资源销毁，需要保证子线程没有引用这些资源。 struct func { size_t&amp; i_ = 0; func(int&amp; i): i_(i) {} // 1 void operator()() { for (size_t j{0}; j!= 1000000; ++j) { do_something(i); // 2 } } }; void bad_reference() { size_t working{42}; func wk_func{working}; std::thread wk_thread{wk_func}; wk_thread.detach(); // 3 return; // 4 } 在这里，我们定义了一个可调用的类。在循环内，我们不断尝试对外部传来的引用 (1) 进行一些操作 (2)。然而，在分离子线程之后 (3)，子线程所依赖的外部引用，随着函数的退出而销毁 (4)。这样，子线程后续使用该引用 (2) 的行为就是未定义的了，这是非常危险的。 事实上这段程序根本不会通过编译，因为根据C++11的新特性：向thread传引用必须使用std::ref(params)或者使用移动语义std::move(params)，前者相当于复制了一个资源进入线程。 对于可能发生资源泄漏的情况，下面介绍两种应对策略：异常抛出和RAII。 （1）RAII策略（Resource Acquisition Is Initialization） 将资源封装在一个 handle 或者 guard 当中，从而防止资源泄漏。同时，前文也提到，线程也是一种资源。因此，我们可以考虑构造一个 ThreadGuard 来处理这种异常安全的问题。 class ThreadGuard { private: std::thread&amp; t_; public: explicit ThreadGuard(std::thread&amp; t) :t_(t) {} ~ThreadGuard() { if (this-&gt;t_.joinable()) this-&gt;t_.join(); } ThreadGuard(const ThreadGuard&amp;) = delete; ThreadGuard&amp; operator=(const ThreadGuard&amp;) = delete; }; void main() { std::thread mythread{ myfun }; ThreadGuard g{ mythread }; } 如果不添加线程守护，则主程序结束后，线程资源并没有得到释放，会引起内存出错。加了以后，会一直等待子线程跑完，主线程才会彻底结束。 （2）try-catch策略 通过异常抛出的办法保护子线程的正常工作： struct func; // 定义在清单2.1中 void f() { int some_local_state=0; func my_func(some_local_state); std::thread t(my_func); try { do_something_in_current_thread(); } catch(...) { t.join(); // 1 throw; } t.join(); // 2 } try/catch块确保访问本地状态的线程退出后，函数才结束。当函数正常退出时，会执行到②处；当函数执行过程中抛出异常，程序会执行到①处。try/catch块能轻易的捕获轻量级错误。 2. 向线程传递参数2.1 确保预先转换格式void demo(int, const std::string&amp;); void bad_buffer(const int param) { char buffer[2014]; // 1 sprintf(buffer, &quot;%i&quot;, param); std::thread wk_t(demo, 42, buffer); // 2 wk_t.detach(); return; // 3 } 传入thread的是一个int，一个char*，而char*需要隐式转化为const string&amp;，如果在转化的过程中发生了函数退出(3)，则会产生一个未定义行为，这是非常危险的。 因此，关于线程函数传参的铁律是：必须在参数传递给线程构造之前，就转换好格式。 2.2 确保引用和右值的可行性对于引用类型，如前面提到的必须使用std::ref()进行转化转化为std::reference_wrapper类型。 首先介绍一下ref和std::reference_wrapper。简单来说就是让按值传参的模板可以接受一个引用作为参数。如下代码所示，由于模板是按值传递，T会被推导为int类型，所以引用无效。所以为了使得引用生效，我们必须转化为std::reference_wrapper template&lt;typename T&gt; void functest(T a){ ++a; } int a=1; int&amp; b=a; functest(a); functest(ref(a)); ref()返回一个reference_wrapper对象，事实上，ref()就是用reference wrapper来包裹对象的一个简化写法。 下面展示了ref()的一个用例，stl容器提供的是value语义而不是reference语义，所以容器不支持元素为引用，而用reference_wrapper可以实现。所以vector和list能实现同步更新（不支持添加，删除操作！） std::list&lt;int&gt; l1(2,1); std::vector&lt;std::reference_wrapper&lt;int&gt;&gt; v(l1.begin(), l1.end()); for (auto&amp; x : l1) x = x * 2; 讲完引用，下面来讲下移动语义。由于thread支持普适引用T&amp;&amp;，所以move操作可以放心执行。 std::thread wk_t(demo, 42, std::move(params)); 2.3 非静态成员函数作为线程函数类的非静态成员函数也是函数，因而也可以作为线程函数使用。不过，相比一般的函数（包括静态成员函数），将其作为线程函数使用时，有两个特殊之处。 必须显式地使用函数指针，作为 std::thread 构造函数的第一个参数（换句话说，必须使用引用的形式）； 非静态成员函数的第一个参数，实际上是类实例的指针，在创建线程时，需要显式地填入这个参数。 class Foo { public: void bar(void); }; void demo() { Foo baz; std::thread temp_t{&amp;Foo::bar, &amp;baz}; temp_t.join(); return; } 此外，必须说明的是，脱离了实例的非静态成员函数是没有意义的。因此，在将非静态成员函数作为线程函数时，必须保证对应的实例可用。 3. 转移线程所有权线程这种资源可转移但不可复制 void some_function(); void some_other_function(); std::thread t1(some_function); // 1 std::thread t2=std::move(t1); // 2 t1=std::thread(some_other_function); // 3 std::thread t3; // 4 t3=std::move(t2); // 5 t1=std::move(t3); // 6 赋值操作将使程序崩溃 上述代码中，我们先创建了一个线程t1，然后将结果移动到t2，现在t1这个变量依然存在，只是不包含任何内容。 操作3-6则尝试将一个线程赋给一个非空线程，将some_function线程的所有权转移⑥给t1。不过，t1已经有了一个关联的线程(执行some_other_function的线程)，所以这里系统直接调用std::terminate()终止程序继续运行。这样做（不抛出异常，std::terminate()是noexcept函数，是为了保证与std::thread的析构函数的行为一致。 std::thread支持移动，就意味着线程的所有权可以在函数外进行转移，或者作为参数传递进入函数中。 void f(std::thread t); void g() { void some_function(); f(std::thread(some_function)); std::thread t(some_function); f(std::move(t)); } 移动操作也可能引出一些问题：当某个对象转移了线程的所有权后，它就不能对线程进行加入或分离。为了确保线程程序退出前完成，下面的代码里定义了scoped_thread类。它的思路和我们之前写的ThreadGuard比较相似。 class scoped_thread { std::thread t; public: explicit scoped_thread(std::thread t_): // 1 t(std::move(t_)) { if(!t.joinable()) // 2 throw std::logic_error(“No thread”); } ~scoped_thread() { t.join(); // 3 } scoped_thread(scoped_thread const&amp;)=delete; scoped_thread&amp; operator=(scoped_thread const&amp;)=delete; }; struct func; // 定义在清单2.1中 void f() { int some_local_state; scoped_thread t(std::thread(func(some_local_state))); // 4 do_something_in_current_thread(); } // 5 与ThreadGuard相似，不过新线程直接传递到scoped_thread中④，而非创建一个独立变量。当主线程到达f()函数末尾时⑤，scoped_thread对象就会销毁，然后加入③到的构造函数①创建的线程对象中去。在清单2.3中的thread_guard类，需要在析构中检查线程是否”可加入”。这里把检查放在了构造函数中②，并且当线程不可加入时，抛出异常。 4. 运时决定线程数量对于那些支持移动操作的容器，我们可以将线程放入这些容器中，产生量产线程。 void do_work(unsigned id); void f() { std::vector&lt;std::thread&gt; threads; for (unsigned i = 0; i &lt; 20; ++i) { threads.emplace_back(do_work,i); // 产生线程 } for (auto&amp; entry : threads) // 对每个线程调用 join() entry.join(); } 下面给出一个很棒的实战demo，我们仔细来分析一下： template&lt;typename Iterator,typename T&gt; struct accumulate_block { void operator()(Iterator first,Iterator last,T&amp; result) { result=std::accumulate(first,last,result); } }; template&lt;typename Iterator,typename T&gt; T parallel_accumulate(Iterator first,Iterator last,T init) { unsigned long const length=std::distance(first,last); if(!length) // 1 return init; unsigned long const min_per_thread=25; unsigned long const max_threads= (length+min_per_thread-1)/min_per_thread; // 2 unsigned long const hardware_threads= std::thread::hardware_concurrency(); unsigned long const num_threads= // 3 std::min(hardware_threads != 0 ? hardware_threads : 2, max_threads); unsigned long const block_size=length/num_threads; // 4 std::vector&lt;T&gt; results(num_threads); std::vector&lt;std::thread&gt; threads(num_threads-1); // 5 Iterator block_start=first; for(unsigned long i=0; i &lt; (num_threads-1); ++i) { Iterator block_end=block_start; std::advance(block_end,block_size); // 6 threads[i]=std::thread( // 7 accumulate_block&lt;Iterator,T&gt;(), block_start,block_end,std::ref(results[i])); block_start=block_end; // #8 } accumulate_block&lt;Iterator,T&gt;()( block_start,last,results[num_threads-1]); // 9 std::for_each(threads.begin(),threads.end(), std::mem_fn(&amp;std::thread::join)); //10 return std::accumulate(results.begin(),results.end(),init); // 11 } std::accumulate函数的作用是：累加容器中begin到end的所有数，再加上init。下面我们按标号一一解释： 此处避免输入迭代器起始位置都相同，浪费计算 min_per_thread表示每个线程的最小计算数，如果输入长度较小的情况下，避免产生过多线程。 std::thread::hardware_concurrency()返回当前计算机核心数，如果没有顺利取得，就返回0，此时我们默认设为2核。 每个线程分到的计算任务量大小 创建线程容器 block_end迭代器指向当前块的末尾 启动一个新线程为当前块累加结果 当迭代器指向当前块的末尾时，启动下一个块 启动所有线程后，线程会处理最终块的结果。由于不一定分配均匀，所以需要一个来收尾。 将所有线程挂起，mem_fn表示每个容器的元素都执行这个函数。 返回所有结果的累加和。","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"并发","slug":"并发","permalink":"jiangren.work/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"EffectiveModernCPP笔记7-Lambda表达式","slug":"EffectiveModernCPP笔记7-Lambda表达式","date":"2019-10-28T05:27:58.000Z","updated":"2019-12-30T21:06:31.000Z","comments":true,"path":"2019/10/28/EffectiveModernCPP笔记7-Lambda表达式/","link":"","permalink":"jiangren.work/2019/10/28/EffectiveModernCPP%E7%AC%94%E8%AE%B07-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"介绍Lambda表达式中的一些细节：避免隐式捕获、最好通过初始化（移动）进行捕获、如何处理右值。","text":"介绍Lambda表达式中的一些细节：避免隐式捕获、最好通过初始化（移动）进行捕获、如何处理右值。 首先先澄清一些术语： lambda表达式就是一个表达式，如下面代码花括号部分 std::find_if(container.begin(), container.end(), { return 0 &lt; val &amp;&amp; val &lt; 10; }); closure闭包是通过lambda表达式创建的对象，闭包持有被捕获的拷贝和引用。lambda通常用于一次使用的场景。但closure通常是可复制的，因此一个lambda表达式可能会对应着多个closure。 auto c1 = [x](int y) { return x * y &gt; 55; }; auto c2 = c1; closure class闭包类是一个闭包的实现。编译器会为每个lambda表达式生成一个唯一的closure class，lambda表达式中的代码会成为这个类的成员函数的可执行代码。 Item 31:Avoid default capture modes.先介绍一些基础知识。Lambda表达式的完整声明格式如下： [capture list] (params list) mutable exception-&gt; return type { function body } 各项含义如下： capture list：捕获外部变量列表 params list：形参列表 mutable指示符：用来说用是否可以修改捕获的变量 exception：异常设定 return type：返回类型 function body：函数体 明确几个捕获类型： 值捕获 int a = 123; auto f = [a] { cout &lt;&lt; a &lt;&lt; endl; }; 引用捕获 int a = 123; auto f = [&amp;a] { cout &lt;&lt; a &lt;&lt; endl; }; 隐式捕获 隐式捕获有两种方式，分别是[=]和[&amp;]。[=]表示以值捕获的方式捕获外部变量，[&amp;]表示以引用捕获的方式捕获外部变量。可以让编译器根据函数体中的代码来推断需要捕获哪些变量。 那么为什么要避免使用隐式捕获呢？ 如果一个由lambda创建的闭包的生命期超过了局部变量或者形参的生命期，那么闭包的引用将会空悬。 void addDivisorFilter() { auto calc1 = computeSomeValue1(); auto calc2 = computeSomeValue2(); auto divisor = computeDivisor(calc1, calc2); filters.emplace_back( [&amp;](int value) { return value % divisor == 0; } // 危险！对divisor的引用会空悬 ); } 这代码有个定时炸弹。lambda引用了局部变量divisor， 但是局部变量的生命期在addDivisorFilter返回时终止，也就是在filters.emplace_back返回之后。由于filters容器不属于这个局部，我们采用的是引用的形式，当本体作为局部变量被销毁后，就会变为未定义行为。 即使我们加上显示引用捕获divisor，会存在着同样的问题： filters.emplace( [&amp;divisor](int value) // 危险！对divisor的引用依然会空悬 { return value % divisor == 0; } ); 虽然依然存在问题，但我们可以从中看到lambda的活性依赖于divisor的生命期，显示地写出能够提醒我们要确保divisor的生命期至少和lambda闭包一样长。即使是我们知道一个closure只在当前作用域范围内使用（不同于上面的filters），不会传播出去，使用隐式捕获依然可能出现一些问题。 template &lt;typename C&gt; void workWithContainer(const C&amp; container) { auto calc1 = computeSomeValue1(); auto calc2 = computeSomeValue2(); auto divisor = computeDivisor(calc1, calc2); using ContElemT = typename C::value_type; using std::begin; using std::end; if (std::all_of( begin(container), end(container), [&amp;](const ContElemT&amp; value) { return value % divisor == 0; })) { ... ) else { ... } } //c++14 auto can be used in params type if (std::all_of( begin(container), end(container), [&amp;](const auto&amp; value) { return value % divisor == 0; })) 这段代码本身没什么问题，但你没办法保证不会有人把这段代码拷贝到其它地方，没注意这里有个默认的引用捕获，结果出现孤悬引用。 为了解决这个问题，人们提出了几种可能的解决方案： （1）默认的值捕获 可行，但不能捕获指针 filters.emplace_back([=](int value) { return value % divisor == 0; } （2）拷贝一份成员变量，再捕获 可行 class Widget { public: ... void addFilter() const; private: int divisor; void Widget::addFilter() const { auto divisorCopy = divisor; filters.emplace_back([divisorCopy] (int value) { return value % divisorCopy == 0; }); } }; （3）初始化捕获作用于14 void Widget::addFilter() const { filters.emplace_back( [divisor = divisor] (int value) { return value % divisor == 0; } ); } Item 32:Use init capture to move objects into closures.有时候我们想把一个对象移动到closure中，比如一个只能移动的对象（std::unique_ptr或std::future），或是移动的代价远小于复制的对象（比如大多数的STL容器），这个时候默认的引用捕获和值捕获都无法做到。C++14提供了一种方式，叫“初始化捕获”，能满足这一需求。C++11无法直接实现，但后面会介绍一种间接实现的方式。 class Widget; ... auto pw = std::make_unique&lt;Widget&gt;(); ... // confiture *pw auto func = [pw = std::move(pw)] { return pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived(); }; pw = std::move(pw)中，=左边的是数据成员的名字，它的作用域就是这个closure；右边是它的初始化式，它的作用域就是closure所在的作用域。 举个更简单的例子： auto testNumber = 10; auto divisor = 3; auto pw = make_unique&lt;int&gt;(divisor); auto fun = [pw = std::move(pw)](auto&amp; divided){ return divided / *pw; }; cout &lt;&lt; fun(testNumber) &lt;&lt; endl; // result is 3 C++11实现 先介绍一下std::bind，上代码。 #include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; using namespace std::placeholders; int main() { auto fun = [](int *array, int n, int num){ for (int i = 0; i &lt; n; i++) { if (array[i] &gt; num) cout &lt;&lt; array[i] &lt;&lt; ends; } cout &lt;&lt; endl; }; int array[] = { 1, 3, 5, 7, 9 }; //_1，_2 是占位符 auto fun1 = bind(fun, _1, _2, 5); //等价于调用fun(array, sizeof(array) / sizeof(*array), 5); fun1(array, sizeof(array) / sizeof(*array)); cin.get(); return 0; } fun1函数由闭包转化而来，bind就是用于这种捆绑转化，它通过占位符汲取了闭包的第一、二个参数，然后将第三个参数置为5。这样就形成了： void fun(int* array,int n) { for (int i = 0; i &lt; n; i++) { if (array[i] &gt; 5) cout &lt;&lt; array[i] &lt;&lt; ends; } cout &lt;&lt; endl; }; 在C++11中我们可以用bind+lambda实现14中的移动捕获 std::vector&lt;double&gt; data; ... auto func = std::bind( [](const std::vector&lt;double&gt;&amp; data) {...}, std::move(data) ); 默认情况下closure class的operator()会被认为是const，因此我们在lambda中无法修改捕获的对象。这时我们可以给lambda添加上mutable标识符，令它可以修改捕获的对象： auto func = std::bind( [](std::vector&lt;double&gt;&amp; data) mutable {...}, std::move(data) ); Item 33:Use decltype on auto&amp;&amp; parameters to std::forward them.C++14的一项引入注目的新功能就是泛型lambda，即lambda的参数可以用auto来修饰。 它的实现很直接：closure class的operator()是个模板函数。给定下面的lambda：··· auto f = [](auto x) {return normalize(x);}; // closure class class SomeClosureClass { public: template &lt;typename T&gt; auto operator()(T x) const { return normalize(x); } ... }; 上面的例子中，如果normalize处理左值参数和右值参数的方式上有区别，那么我们写的还不算对，应该用上完美转发。 auto f = [](auto&amp;&amp; x) { return normalize(std::forward&lt;???&gt;(x)); }; 但问题是std::forward的实例化类型是什么。通常的完美转发我们能有一个模板参数T，但在泛型lambda中我们只有auto。closure class的模板函数中有这个T，但我们没办法用上它。用decltype可以解决这个问题！ 我们在Item3学到过：通过decltype保证返回变量的本来类型这一特性，保证不丢失CV限制符，和引用等。 auto f = [](auto&amp;&amp; x) { return normalize(std::forward&lt;decltype(x)&gt;(x)); }; 甚至还支持变量个数可变的泛型lambda： auto f = [](auto&amp;&amp;... xs) { return normalize(std::forward&lt;decltype(xs)&gt;(xs)...); };","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"EffectiveModernCPP笔记6-右值引用与移动语义","slug":"EffectiveModernCPP笔记6-右值引用与移动语义","date":"2019-10-27T04:43:58.000Z","updated":"2019-12-30T21:05:56.000Z","comments":true,"path":"2019/10/27/EffectiveModernCPP笔记6-右值引用与移动语义/","link":"","permalink":"jiangren.work/2019/10/27/EffectiveModernCPP%E7%AC%94%E8%AE%B06-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/","excerpt":"本章围绕move和forward这两个函数展开，详细介绍了右值引用，普适引用，移动语义，完美转发等概念。","text":"本章围绕move和forward这两个函数展开，详细介绍了右值引用，普适引用，移动语义，完美转发等概念。 Item 23:Understand std::move and std::forward.std::move和std::forward仅仅是进行转换的函数。std::move无条件地将它的参数转换为右值，而std::forward只在某些条件满足时进行这种转换。 （1）move的特性 下面一个接近标准库实现的std::move实现的例子： template &lt;typename T&gt; // version C++11 typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; param) { using ReturnType = typename remove_reference&lt;T&gt;::type&amp;&amp;; return static_cast&lt;ReturnType&gt;(param); } tmeplate &lt;typename T&gt; // version C++14 decltype(auto) move(T&amp;&amp; param) { using ReturnType = remove_reference_t&lt;T&gt;&amp;&amp;; return static_cast&lt;ReturnType&gt;(param); } 其中remove_reference_t用于移除类型的引用，返回原始类型。比如std::remove_reference::type就等同于int。在上面的代码中，我们先移除了对象的引用，然后加上&amp;&amp;，转化为右值。 所以我们看到，std::move只做了转换，并没有进行实际的移动，在一个对象上应用std::move就告知了编译器这个对象可以被移动，这就是它叫这个名字的原因：易于标记出可能被移动的对象。 因此，这就出现了一个问题：我们只转化了引用，对const并没有进行任何操作。下面看一个例子： class Annotation { public: explicit Annotation(const std::string text) : value(std::move(text)) {...} ... private: std::string value; }; 会收到IDE送来的警告，告诉我们最好不要对const类型进行移动构造。 我们来看看std::string的复制构造函数和移动构造函数： class string { public: ... string(const string&amp; rhs); string(string&amp;&amp; rhs); ... }; 假设输入const string&amp;&amp;，显然没办法传给string(string&amp;&amp; rhs)，但能传给string(const string&amp; rhs)。因此value的构造使用了复制构造函数，即使它的参数是右值引用。 因此，我们可以总结： 不要把希望移动的变量声明为const。 std::move不意味着移动任何东西，甚至不保证它转换的对象可移动。它只保证它的转换结果一定是右值。 （2）forward的特性 std::forward与std::move很类似，只是std::move是无条件的转换，而std::forward是有条件的转换。下面举个例子： void process(const Widget&amp; lval); void process(Widget&amp;&amp; rval); template &lt;typename T&gt; void logAndProcess(T&amp;&amp; param) { auto now = std::chrono::system_clock::now(); makeLogEntry(&quot;Calling &#39;process&#39;&quot;, now); process(std::forward&lt;T&gt;(param)); } 我们希望在param类型为左值引用时调用process(const Widget&amp; lval)，在param为右值引用时调用process(Widget&amp;&amp; rval)。但param是函数参数，它本身永远是左值。因此我们需要一种方法在条件满足时将其转换为右值——logAndProcess的实参为右值。这就是std::forward要做的，有条件的转换，即当且仅当它的参数是通过右值初始化时进行转换。 两者最大的区别是std::move是无条件的转换，而std::forward只在参数为右值引用时将其转换为右值。 Item 24:Distinguish universal references from rvalue references.在Item1中我们就介绍了普适引用(universal reference)这个东西，那时候我们基本上把它和右值引用是画等号，在这一节中，我们对他们两进行详细的区别。 T&amp;&amp;有两个含义，第一个就是右值引用，它的主要作用是标记一个可以移动的对象；第二个含义则既可能是右值引用也可能是左值引用，我们可以将其绑定在任何对象上，称其为“普适引用”。 普适引用有两个场景： 函数模板 template &lt;typename T&gt; void f(T&amp;&amp; param); auto声明 auto&amp;&amp; var2 = var1; 它们的共同点就是需要类型推断。如果不需要类型推断，例如Widget&amp;&amp; var1 = Widget();，这就不是普适引用，就只是一个右值引用。 普适引用的初始化式决定了它是右值引用还是左值引用：如果初始化式是右值，普适引用就是右值引用；如果初始化式是左值，普适引用就是左值引用： template &lt;typename T&gt; void f(T&amp;&amp; param); // universal reference Widget w; f(w); // lvalue passed to f: Widget&amp; f(std::move(w)); // rvalue passed to f: Widget&amp;&amp; 光有类型推断还不足够，普适引用要求引用的声明格式必须是T&amp;&amp;，而不是std::vector&amp;&amp;或const T&amp;&amp;这样的声明。 当然你在模板中看到了一个函数参数为T&amp;&amp;，也不代表它是普适引用，因为这里可能根本不需要类型推断。下面这个例子中，push_back的参数x不是普适引用，因为编译器会先实例化vector，之后你就发现push_back根本没有涉及到类型推断。 template &lt;class T, class Allocator = allocator&lt;T&gt;&gt; class vector { public: void push_back(T&amp;&amp; x); ... }; 与之相反，emplace_back应用了类型推断： template &lt;class T, class Allocator = allocator&lt;T&gt;&gt; class vector { public: template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args); ... }; Item 25:Use std::move on rvalue references, std::forward on universal references.前面我们已经讨论过，右值引用总是可以无条件转换为右值因此用std::move，但普适引用不一定是右值，因此要用std::forward做有条件的右值转换。 由于move没有办法应对const，所以有的人会说，我们重载两个函数来灵活应对，当传入const时，我们使用复制，否则就使用移动构造。 class Widget { public: void setName(const std::string&amp; newName) { name = newName; } void setName(std::string&amp;&amp; newName) { name = std::move(newName); } }; 想得很美好，代码也能运行，但实际情况是如果我有$n$个参数，则需要重载$2^n$个版本。 所以我们可以用std::forward（对于普适引用）去移动它们。 template &lt;typename T&gt; void setSignText(T&amp;&amp; text) { sign.setText(text); // use text, but don&#39;t modify it auto now = std::chrono::system_clock::now(); signHistory.add(now, std::forward&lt;T&gt;(text)); // conditionally cast text to rvalue } 如果有一个按值返回的函数，其返回的对象是右值引用或普适引用，那么也可以用std::move或std::forward来获得更好的性能： Matrix operator+(Matrix&amp;&amp; lhs, const Matrix&amp; rhs) { lhs += rhs; return std::move(lhs); } //或者是 template &lt;typename T&gt; Fraction reduceAndCopy(T&amp;&amp; frac) { frac.reduce(); return std::forward&lt;T&gt;(frac); } 如果Matrix和frac不支持移动，用std::move和std::forward也不会有副作用。等到他们支持移动了，上面的代码马上就能享受到性能的提升。 如果返回的对象是个local对象，有些人可能会想到用std::move来避免复制（注意和上面返回的区别）： Widget makeWidget() { Widget w; ... return std::move(w); } 但这样并不对，有个概念叫RVO，即“返回值优化”，即编译器会在返回一个local对象时，如果函数的返回类型就是值类型，那么编译器可以直接将这个local对象构造在接收函数返回值的对象上，省掉中间的复制过程。换句话说，在RVO的帮助下，直接返回这个local对象要比返回它的右值还要节省。 Item 26:Avoid overloading on universal references.注意：根据C++的重载决议规则，普适引用版本总会被优先匹配。 假设我对普适引用进行重载： vector&lt;string&gt; names; /*part1*/ template &lt;typename T&gt; void logAndAdd(T&amp;&amp; name) { names.emplace(std::forward&lt;T&gt;(name)); } /*part2*/ //获取ID后，利用函数nameFromIdx得到string再构造 std::string nameFromIdx(int idx) { return to_string(idx) + &quot;_myname&quot;; }; void logAndAdd(int idx) { names.emplace(nameFromIdx(idx)); } //调用 short nameId=10086; logAndAdd(nameId); //error 对上面的代码我们可以分为以下几种情况： part1和part2存在，输入int。换完美运行重载函数， part1和part2存在。输入short，优先运行普适引用版本，报错。 part1删除，保留part2，输入short。编译器隐式转换，扩大范围，转换为int，完美运行。 因此，我们知道普适引用版本在重载决议中的顺序都非常靠前，它们几乎能完美匹配所有类型，重载版本很可能无法顺利工作（除非类型完全匹配，不包含任何隐式转换） 在类的构造函数这里，情况变得更糟了： class Person { public: template &lt;typename T&gt; explicit Person(T&amp;&amp; n) : name(std::forward&lt;T&gt;(n)) {} explicit Person(int idx) : name(nameFromIdx(idx)) {} ... private: std::string name; }; 根据item17，某个类有模板构造函数不会阻止编译器为它生成复制和移动构造函数，因此Person中的构造函数实际上有4个： template &lt;typename T&gt; explicit Person(T&amp;&amp; n) : name(std::forward&lt;T&gt;(n)) {} explicit Person(int idx) : name(nameFromIdx(idx)) {} Person(const Person&amp; rhs); Person(Person&amp;&amp; rhs); 当我们调用如下代码时，我们以为调用了复制构造函数，实际上却是匹配到了普适引用的版本，这相当违反直觉！ Person p1(&quot;Baolan&quot;); Person p2(p1);//error const Person p3(&quot;Clearlove&quot;); Person p4(p3);//work 因为生成的默认拷贝构造函数需要const，此时编译器判断输入的Baolan不是完美匹配，所以他选择了普适引用的版本，除非我们像Clearlove那样构造cosnt Person这样才能顺利通过编译。 Item 27:Familiarize yourself with alternatives to overloading on universal references.如何解决上一章的问题呢？一种思路是放弃重载普适引用，原书中介绍了三种方式：完全放弃重载构建两个不同名函数，通过值传递，通过C98的老办法const T&amp;构造。这里先不做介绍，接下来介绍两种能够重载普适引用的办法，这两种办法非常trick，运用了很多现代CPP编程的特性，非常值得学习。 （1）使用标签分发(Tag dispatch) 重载决议是在所有参数上发生的，那么如果我们人为的增加一个Tag参数，用Tag参数来匹配，就能避免普适引用带来的问题。 首先是原始版本： std::multiset&lt;std::string&gt; names; template &lt;typename T&gt; void logAndAdd(T&amp;&amp; name) { auto now = std::chrono::system_clock::now(); log(now, &quot;logAndAdd&quot;); names.emplace(std::forward&lt;T&gt;(name)); } template &lt;typename T&gt; void logAndAdd(T&amp;&amp; name) { logAndAddImpl(std::forward&lt;T&gt;(name), std::is_integral&lt;T&gt;()); } 这里的问题在于，当实参是左值时，T会被推导为左值引用，即如果实参类型是int，那么T就是int&amp;，std::is_integral()就会返回false。这里我们需要把T可能的引用性去掉： template &lt;typename T&gt; void logAndAdd(T&amp;&amp; name) { logAndAddImpl( std::forward&lt;T&gt;(name), std::is_integral&lt;typename std::remove_reference&lt;T&gt;::type&gt;() ); } 然后logAndAddImpl提供两个特化版本。为什么用std::true_type/std::false_type而不用true/false？前者是编译期值，后者是运行时值。 template &lt;typename T&gt; void logAndAddImpl(T&amp;&amp; name, std::false_type) { auto now = std::chrono::system_clock::now(); log(now, &quot;logAndAdd&quot;); names.emplace(std::forward&lt;T&gt;(name)); } std::string nameFromIdx(int idx); template &lt;typename T&gt; void logAndAddImpl(T&amp;&amp; name, std::true_type) { logAndAdd(nameFromIdx(idx)); } 我们并没有给logAndAddImpl的第二个参数起名字，说明它就是一个Tag。这种方法常用于模板元编程。 （2）限制模板使用普适引用 Tag dispatch的思路是利用一个不重载的函数作为入口，他会安排一个tag参数，再分发给重载函数。但这种办法并不能解决类的构造函数问题，编译器依然会自己生成复制和移动构造函数。 我们可以利用C++的SFINAE特性(Substitution Failure Is Not An Error)，使用std::enable_if，只有里面的条件为真是，这个参数才有效，否则我们就忽略它。 class Person { public: template &lt;typename T, typename = typename std::enable_if&lt;condition&gt;::type&gt; explicit Person(T&amp;&amp; n); }; 我们引入了一个强大的工具，现在需要考虑怎么运用它。我们之前的问题是：我重载了普适引用，但由于const，引用符等问题导致我的重载函数和传入的参数不能完美匹配，从而让编译器选择了普适引用，现在我想让编译器明白：有没有CV符号不重要，只要长得差不多，你就赶紧给我调用重载版本！！！ 因此，我们可以把condition设为：忽略CV符号和引用，T和person是不是同一种类型。标准库中对应的工具是std::decay，它会把对象身上的引用和cv特性都去掉。它在处理数组和函数类型时会把它们转为指针类型。 引用和cv特性都去掉。它在处理数组和函数类型时会把它们转为指针类型。 class Person { public: template &lt; typename T, typename = typename std::enable_if&lt; !std::is_same&lt; Person, typename std::decay&lt;T&gt;::type &gt;::value&gt; &gt;::type &gt; explicit Person(T&amp;&amp; n); ... }; 对于Person的构造函数，上面的版本已经能解决了：在传入的参数类型为Person时调用我们希望的复制和移动构造函数，而在其它时候调用完美转发函数。 最后一个问题是派生类， class SpecialPerson: public Persion { public: SpecialPerson(const SpecialPerson&amp; rhs) // copy ctor: calls Person forwarding ctor! : Person(rhs) {...} SpecialPerson(SpecialPerson&amp;&amp; rhs) // move ctor: calls Person forwarding ctor! : Person(std::move(rhs)) {...} }; 看起来这并没有解决， 因为std::is_same::value是false，我们需要的是std::is_base_of，其作用是判断是否为基类，我们就可以改为： class Person { public: template &lt; typename T, typename = typename std::enable_if&lt; !std::is_base_of&lt; Person, typename std::decay&lt;T&gt;::type &gt;::value&gt; &gt;::type &gt; explicit Person(T&amp;&amp; n); ... }; //C++14中代码可以省一点： class Person { public: template &lt; typename T, typename = std::enable_if_t&lt; !std::is_base_of&lt;Person, std::decay_t&lt;T&gt;&gt;::value&gt; &gt; &gt; explicit Person(T&amp;&amp; n); ... }; 还没有结束，最后一个问题：如何区分整数类型和非整数类型。直接看最终版本，这个版本就代表了：如果参数T不是派生出来的也不是整数，那么就采用普适引用版本。 class Person { public: template &lt; typename T, typename = std::enable_if_t&lt; !std::is_base_of&lt;Person, std::decay_t&lt;T&gt;&gt;::value&gt; &amp;&amp; !std::is_integral&lt;std::remove_reference_t&lt;T&gt;&gt;::value &gt; &gt; explicit Person(T&amp;&amp; n) : name(std::forward&lt;T&gt;(n)) {...} explicit Person(int idx) : name(nameFromIdx(idx)) {...} ... private: std::string name; }; Item 28:Understand reference collapsing.一般来说，引用的引用在C++中是非法的，你不能： int&amp; &amp;m; 但在类型推断中，有一套单独的规则：引用折叠。可以看出这套规则中只要不是4个&amp;，统统折叠为左值。 T&amp; &amp; =&gt; T&amp; T&amp; &amp;&amp; =&gt; T&amp; T&amp;&amp; &amp; =&gt; T&amp; T&amp;&amp; &amp;&amp; =&gt; T&amp;&amp; 引用折叠就是std::forward依赖的关键特性。一个简化的std::forward实现： template &lt;typename T&gt; T&amp;&amp; forward(typename remove_reference&lt;T&gt;::type&amp; param) { return static_cast&lt;T&amp;&amp;&gt;(param); } 假设我传入了一个widget&amp;，则 remove_reference::type去除引用，将T变为widget&amp;，此时 Widget&amp;&amp; forward(Widget&amp; param) { return static_cast&lt;Widget&amp; &amp;&amp;&gt;(param); } 利用引用折叠widget&amp; &amp;&amp; = widget&amp;，返回。 若传入的是右值，则在折叠阶段，返回widget&amp;&amp; Widget&amp;&amp; forward(Widget&amp; param) { return static_cast&lt;Widget&amp;&amp;&gt;(param); } Item 30:Familiarize yourself with perfect forwarding failure cases.假设有一个非完美转发的函数f，和它对应的完美转发版本fwd，我们会遇到几个问题： template &lt;typename T&gt; void fwd(T&amp;&amp; param) { f(std::forward&lt;T&gt;(param)); } //我们希望以下两个函数有相同行为 f(expression); fwd(expression); （1）花括号初始化 void f(const std::vector&lt;int&gt;&amp; v); f({1, 2, 3}); // fine, &quot;{1, 2, 3}&quot; implicitly converted to std::vector&lt;int&gt; fwd({1, 2, 3}); // error! doesn&#39;t compile 原因在于，编译器知道f的形参类型，所以它知道可以把实参类型隐式转换为形参类型。但编译器不知道fwd的形参类型，因此需要通过实参进行类型推断。这里完美转发会在发生以下情况时失败： 无法推断出fwd的某个参数类型。 推断出错误类型。这里的“错误”可以是推断出的类型无法实例化fwd，也可以是fwd的行为与f不同。后者的一个可能原因是f是重载函数的名字，推断的类型不对会导致调用错误的重载版本。 在fwd({1, 2, 3})这个例子中，问题在于它是一个“未推断上下文”，标准规定禁止推断作为函数参数的花括号初始化式，除非形参类型是std::initializer_list。 解决方案很简单，这里我们应用了Item2中提到的一个auto特性：会优先推断接收的表达式为std::initializer_list。 auto il = {1, 2, 3}; fwd(il); （2）使用0或NULL 例子见Item8，结论就是不要用0或NULL作为空指针，用nullptr。 （3）只有声明的static const或constexpr的整数成员 通常来说我们不需要给类的声明为static const或constexpr的整数成员一个定义，因为编译器会把这些成员直接替换为对应的整数值： class Widget { public: static constexpr std::size_t MinVals = 28; ... }; // no def for MinVals ... std::vector&lt;int&gt; widgetData; widgetData.reserve(Widget::MinVals); 如果没有任何地方取MinVals的地址，编译器就没有必要给它安排一块内存，可以直接替换为整数字面值。否则我们就要给MinVals一个定义，不然程序会在链接阶段出错。 void f(std::size_t val); f(Widget::MinVals); // fine, treated as 28 fwd(Widget::MinVals); // error! shouldn&#39;t link 问题在于fwd的参数类型是非const引用，这相当于取了MinVals的地址，因此我们需要给它一个定义，注意这里就不用给初始值了，否则编译器会报错的。 constexpr std::size_t Widget::MinVals; // in Widget&#39;s .cpp file （4）重载的函数名字和模板名字 假设f的参数是一个函数： void f(int (*pf)(int)); void f(int pf(int)); //这样也可以 以及我们有两个重载函数： int processVal(int value); int processVal(int value, int priority); 当我们把processVal传入时： f(processVal); // fine fwd(processVal); // error! which processVal? 因为fwd的参数没有类型，processVal这个名字本身也没能给出一个确定的类型。 模板函数也有这样的问题： template &lt;typename T&gt; T workOnVal(T param) {...} fwd(workOnVal); // error! which workOnVal instantiation? 解决方案就是确定下来重载函数名字或模板函数名字对应的函数类型： using ProcessFuncType = int (*)(int); ProcessFuncType processValPtr = processVal; fwd(processValPtr); fwd(static_cast&lt;ProcessFuncType&gt;(workOnVal)); （5）位域 struct IPv4Header { std::uint32_t version:4, IHL:4, DSCP:6, ECN:2, totalLength:16; ... }; void f(std::size_t sz); IPv4Header h; ... f(h.totalLength); // fine fwd(h.totalLength); // error! 问题在于fwd的参数是非const引用，而C++标准禁止创建位域的非const引用。实际上，位域的const引用就是引用一个临时的复制整数。解决方案很简单：把位域的值复制出来，再传入fwd： auto length = static_cast&lt;std::uint16_t&gt;(h.totalLength); fwd(length);","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"EffectiveModernCPP笔记5-智能指针","slug":"EffectiveModernCPP笔记5-智能指针","date":"2019-10-26T03:34:53.000Z","updated":"2019-12-30T21:10:11.000Z","comments":true,"path":"2019/10/26/EffectiveModernCPP笔记5-智能指针/","link":"","permalink":"jiangren.work/2019/10/26/EffectiveModernCPP%E7%AC%94%E8%AE%B05-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","excerpt":"描述了三大智能指针：unique_ptr, shared_ptr, weak_ptr，介绍了为什么更倾向于用make构造而不是new，如何构建Pimpl来减轻编译负担。","text":"描述了三大智能指针：unique_ptr, shared_ptr, weak_ptr，介绍了为什么更倾向于用make构造而不是new，如何构建Pimpl来减轻编译负担。 Item 18:Use unique_ptr for exclusive-ownership resource management.先解释一下，exclusive ownership是独占所有权的意思，顾名思义这一章的主要目的是介绍如何利用unique_ptr管理独占所有权的资源。 std::unique_ptr体现了显式所有权的语义：非空的std::unique_ptr总是拥有它指向的对象，换句话说我们只能通过移动转移所有权，而不允许复制。 它的主要应用是在工厂模式。假设有一个基类和三个派生类，通过一个工厂函数来返回某个派生类的std::unique_ptr，这样调用方就不需要费心什么时候销毁返回的对象了：std::unique_ptr会负责这件事。 工厂函数使用了C++多态的特性，将存在继承关系的类，通过一个工厂类创建对应的子类（派生类）对象。比如父类是Shoes，子类有Nike，LiNing，Adidas，假设有一个工厂函数，把生产鞋子的需求输入其中，他就能调用shoes父类下面的子类进行构造。 我们做一个完整的例子，投资类下面有三个子类：股票、债券、期货，再带一个工厂函数： #pragma once #include &lt;assert.h&gt; #include &lt;memory&gt; #include &lt;iostream&gt; #include &lt;functional&gt; //类定义 class Investment { public: virtual ~Investment() { std::cout &lt;&lt; &quot;investment destoryed\\n&quot;; } }; void makeLogEntry(Investment* pInv) { std::cout &lt;&lt; &quot;deleting investment on &quot; &lt;&lt; pInv &lt;&lt; &quot;\\n&quot;; } class Stock : public Investment { public: Stock() { std::cout &lt;&lt; &quot;make an invesetment on stock\\n&quot;; } virtual ~Stock() { std::cout &lt;&lt; &quot;a stock investment destoryed,&quot;; } }; class Bond : public Investment { public: Bond() { std::cout &lt;&lt; &quot;make an investmentt on bond\\n&quot;; } virtual ~Bond() { std::cout &lt;&lt; &quot;a bond investment destroyed,&quot;; } }; class RealEstate : public Investment { public: RealEstate() { std::cout &lt;&lt; &quot;make an investmentt on RealEstate\\n&quot;; } virtual ~RealEstate() { std::cout &lt;&lt; &quot;a RealEstatend investment destroyed,&quot;; } }; void deleteAndLog(Investment* pInv) { makeLogEntry(pInv); delete pInv; } template&lt;typename T, typename... Ts&gt; static auto makeInvestment(Ts&amp;&amp;... params) { auto delInvmt = [](Investment* pInv) { makeLogEntry(pInv); delete pInv; }; typedef std::unique_ptr&lt;Investment, decltype(delInvmt)&gt; InvestmentPtr; std::cout &lt;&lt; sizeof(InvestmentPtr) &lt;&lt; &quot;\\n&quot;; InvestmentPtr pInv(nullptr, delInvmt); pInv.reset(new T(std::forward&lt;Ts&gt;(params)...));//不能直接将裸指针赋值给一个unique_ptr，要使用reset return pInv; } unique_ptr默认的销毁方式是通过对unique_ptr中的裸指针进行delete操作，但是也可以在声明的时候指定销毁函数，在上面的代码中，通过lambda表达式置顶了一个打印日志函数，要在销毁指针的时候会打印日志。 auto delLog = [](int* pInv) { cout &lt;&lt; &quot;See you !&quot; &lt;&lt; endl; delete pInv; }; std::unique_ptr&lt;int, decltype(delLog)&gt; pInt(nullptr, delLog); pInt.reset(new int(1)); std::cout &lt;&lt; *pInt &lt;&lt; &quot;\\n&quot;; 客户端的调用方法如下，这样会产生一个unique_ptr指针指向stock，只要这个程序不结束，那么他就不会调用销毁函数，反之当程序终止时调用函数销毁对象。 auto pInvestment = makeInvestment&lt;Stock&gt;(); 我们还可以通过move的方式转移所有权，但不能调用拷贝构造，参见delete那一章。 auto pInvestment = makeInvestment&lt;Bond&gt;(); auto pInvestment2 = std::move(pInvestment); 总结一下： delInvmt是自定义的销毁器，在std::unique_ptr析构时，自定义的销毁器会来完成释放资源必需的操作。这里用lambda表达式来实现delInvmt，不仅更方便，性能还更好。 自定义的销毁器的类型必须与std::unique_ptr的第二个模板参数相同，因此我们要用decltype(delInvmt)来声明std::unique_ptr。 makeInvestment的基本策略是创建一个空的std::unique_ptr，再令它指向合适的类型，再返回。其中我们把delInvmt作为第二个构造参数传给std::unique_ptr，从而将销毁器与pInv关联起来。 无法将裸指针隐式转换为std::unique_ptr，需要用reset来修改std::unique_ptr持有的裸指针。 我们在创建具体的对象时，使用了std::forward将makeInvestment的所有参数完美转发给对应的构造函数。 注意delInvmt的参数是Investment*，而它的实际类型可能是派生类，因此需要基类Investment有一个虚的析构函数。 Item 19:Use shared_ptr for shared-ownership resource management.很多语言都有GC(garbage collection)机制，但这种机制带来的是资源释放的不确定性，而原始的C语言有两种内存：栈上的内存（函数的局部变量等等，由操作系统释放），动态内存（依靠new，malloc等方式用户自己分配的内存，需要手动释放）。如果我们在程序中忘了释放这些动态内存，而程序又是会持续运行的服务进程，会导致内存占用越来越高，轻者致残影响系统性能，重者致命导致进程崩溃。下面举个例子： 下面这一段程序按照规范合理释放内存，他的内存使用情况如下 for (int i = 0; i &lt; 10000; i++) { int* p = (int*)malloc(sizeof(int)); *p = i; cout &lt;&lt; *p &lt;&lt; endl; free(p); } 然而如果我去掉了free(p)这一句，就会导致如下的情况，问题一目了然！有可能你的程序从70MB跑了一年跑到200MB了。 以上介绍了不及时释放内存导致泄露的结果，下面就正式介绍C++是如何在保证手工管理内存的确定性和自动GC机制的便利性中做平衡的。现代CPP给出的方案是shared_ptr！ 从c++11开始引入的shared_ptr，用来表示指针对指向对象的“共享所有权”；一个对象可以被多个shared_ptr指向和访问，这些shared_ptr类型的指针共同享有该对象的所有权，当最后一个指向该对象的shared_ptr生命周期结束的时候，对象被销毁。 下面介绍他的机制和特点： （1）基于引用计数实现 他的机制和JVM的机制一样，基于引用计数实现，shared_ptr的构造将引用计数加1，销毁的时候引用计数减1，而赋值则将源指针引用计数加1，目标指针引用计数减1，例如P1=P2，P1指向对象的引用计数减1，P2指向对象的引用计数加1。当引用计数减1之后为0的时候，shared_ptr将会销毁指向的对象。shared_ptr的构造函数函数会增加引用计数，但是移动构造除外，因为移动构造并没有增加指向对象的引用计数，所以不需要改变引用计数；需要注意： std::shared_ptr占用的内存空间是原生指针的两倍 被指向对象的内存空间必须是动态分配的 增加或者减少指针引用对象的操作必须是原子操作类型的，多线程操作时要谨慎使用std::shared_ptr （2）销毁器不是指针类型的一部分 与unique_ptr类似，shared_ptr同样也支持自定义销毁方法（默认是直接调用delete），与unique_ptr不同的是，销毁方式是unique_ptr类型的一部分，而shared_ptr的销毁方式却不是。 auto loggingDel = [](Widget *pw) { makeLogEntry(pw); delete pw; }; std::unique_ptr&lt;Widget, decltype(loggingDel)&gt; upw(new Widget, loggingDel); std::shared_ptr&lt;Widget&gt; spw(new Widget, loggingDel); 不把销毁方式作为shared_ptr类型的一部分可以带来更大的灵活性，因为这里不同的shared_ptr指针对象可能需要不同的销毁方式： auto customDeleter1 = [](Widget *pw) { … }; // custom deleters, auto customDeleter2 = [](Widget *pw) { … }; // each with adifferent type std::shared_ptr&lt;Widget&gt; pw1(new Widget, customDeleter1); std::shared_ptr&lt;Widget&gt; pw2(new Widget, customDeleter2); //由于有相同的结构，所以可以写成 std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt;vpw{pw1, pw2}; （3）包含一个控制块 与unique_ptr不同的是，自定义销毁方式并不会改变shared_ptr的size，shared_ptr的size始终是两倍的裸指针size，其内存布局是如下图所示： 使用std::make_shared的时候总是分配控制块 shared_ptr由unique_ptr或裸指针构建时分配控制块 shared_ptr由其他shared_ptr或weak_ptr构建时不分配新的控制块，而是沿用既有智能指针的控制块 这就会带来一个问题，当我们用一个裸指针构建多个shared_ptr时，会分配多个控制块，同一个对象确有多个引用计数（控制块），这就很容易导致一个对象被销毁多次，下面的代码描述了这种情况： auto pw = new Widget; // pw 是原生指针 //… std::shared_ptr&lt;Widget&gt; spw1(pw, loggingDel); // create control block for *pw std::shared_ptr&lt;Widget&gt; spw2(pw, loggingDel); // create 2nd control block 如何避免这个问题呢？尽可能避免使用裸指针来构建shared_ptr，使用make_shared。 关于shared_ptr性能的讨论 shared_ptr的控制块是动态生成的，尽管占用的空间并不大，但是控制块的实际实现比想象的要复杂，实现控制块使用到了继承和虚函数，同时引用计数的增减是原子操作也增加了性能上的代价，这些都导致了shared_ptr并不是管理所有动态资源的最好方案，使用shared_ptr解引用获取对象时会比直接使用裸指针的代价更高； 然而，尽管shared_ptr有在性能上付出了一定的代价，其带来的收益是非常显著的，shared_ptr解决了动态分配资源的生命周期自动管理，大多数时候，在“共享所有权”的语义下，使用shared_ptr管理动态资源都是值得推荐的；而没有“共享所有权”语义的其他情况下，例如“独占所有权”，则可以使用unique_ptr来代替； 另一个shared_ptr不能做的事情是管理数组，不能使用std::shared_ptr这样的类型，然而，c++ 11之后标准库已经引入了std::array，shared_ptr管理一个std::array类型的对象是可行的。 Item 20:Use weak_ptr for shared_ptr-like pointers that can dangle.虽然有了std::shared_ptr，但我们却并不知道指向的资源到底有没有被销毁，我们希望有一种智能指针能够追踪他什么时候空悬(dangle，即对象不存在)，解决方案就是采用std::weak_ptr。 先，这个指针并不是单独存在的，他需要搭配shared_ptr一起使用。std::weak_ptr通常是由std::shared_ptr中创建而来。它们指向的地方与初始化它们的std::shared_ptr指向的地方相同，但它们不会影响指向对象的引用计数： auto spw = std::make_shared&lt;Widget&gt;(); // spw是std::shared_ptr&lt;Widget&gt; // 引用计数为1 ... std::weak_ptr&lt;Widget&gt; wpw(spw); // wpw指向spw指向的Widget，引用计数仍然为1 ... spw = nullptr; // 引用计数变成0，Widget被销毁，wpw现在变成空悬指针 如上所示，当weak_ptr变为空悬指针时，我们可以去检查它if (wpw.expired()) 不过一般状况是：当你去检查std::weak_ptr是否过期，如果没有过期（即不是空悬），就要取得它指向的对象。 因为std::weak_ptr没有解引用操作，所以没有办法写出解引用的代码。就算有这个操作，单独的检查操作和解引用操作会引出一个竞争条件：在调用检查操作和解引用操作之间，另一个线程重赋值或销毁最后一个指向对象的std::shared_ptr，因此导致对象被销毁，这样解引用就产生了未定义行为。 因此需要原子操作来检查shared_ptr是否过期，通常情况我们使用std::weak_ptr::lock，如果不为空则返回对应的shared_ptr否则返回nullptr （1）应用一：cache缓存 下面是一个使用weak_ptr和哈希表容器构建缓存的示例，由于loadWidget的操作可能是大开销函数，所以我们最好设计一个缓存，保存我们加载过的对象。 std::shared_ptr&lt;const Widget&gt; fastLoadWidget(WidgetID id) { static std::unordered_map&lt;WidgetID, std::weak_ptr&lt;const Widget&gt;&gt; cache; auto objPtr = cache[id].lock(); // objPtr是指向缓存对象的shared_ptr(否则为空) if (!objPtr) { // 如果不在缓存中 objPtr = loadWidget(id); // 大开销函数加载它 cache[id] = objPtr; // 缓存它 } return objPtr; } 在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。 该变量在全局数据区分配内存； 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化； 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0； 其作用域为局部作用域 （2）应用二：观察者模式 这个设计模式的主要组成是subject（主题，即状态可能改变的对象）和observer（观察者，即出现状态改变时被通知的对象）。 B是主题，AC为观察者，AC对B有共同使用权，他们都有指向B的shared_ptr用于接收B的改变。现在的问题是如果B要及时知道A是否被销毁，问号处应该使用什么指针？有三种选择： 原生指针。若A被销毁，则B指向A的指针会空悬，B没有能力发现，B去解指针的引用时会发生未定义行为！ shared_ptr。A指向B且B指向A，形成循环。他们两抱团取暖，互相引用计数，形成闭环，即使其他数据不再指向AB，他们依然不会被销毁。从另一个角度来说，AB已经泄露：程序不能使用它们，资源无法回收。 weak_ptr。很好的解决了问题！尽管A和B在互指，B的指针也不会影响A对象的引用计数。如果A被销毁了，B的指针能知道它已经过期了。 Item 21:Prefer std::make_unique and std::make_shared to direct use of new为什么用make比用new好？直接上结论： （1）不用重复类型 auto upw1(std::make_unique&lt;Widget&gt;()); std::unique_ptr&lt;Widget&gt; upw2(new Widget); 上述代码通过make，我们只用写一遍widget，如果连续重复类型，有可能会导致dump （2）异常安全 假设我们有这样的两个函数 void processWidget(std::shared_ptr&lt;Widget&gt; spw, int priority); int computePriority(); processWidget(std::shared_ptr&lt;Widget&gt;(new Widget), computePriority()); // potential resource leak! 在processWidget的参数求值过程中，我们只能确定下面几点： new Widget一定会执行，即一定会有一个Widget对象在堆上被创建。 std::shared_ptr的构造函数一定会执行。 computePriority一定会执行。 new Widget的结果是std::shared_ptr构造函数的参数，因此前者一定早于后者执行。除此之外，编译器不保证其它操作的顺序，即有可能执行顺序为： new Widget 执行computePriority 构造std::shared_ptr 如果第2步抛异常，第1步创建的对象还没有被std::shared_ptr管理，就会发生内存泄漏。如果这里我们用std::make_shared，就能保证new Widget和std::shared_ptr是一起完成的，中间不会有其它操作插进来，即不会有不受智能指针保护的裸指针出现： processWidget(std::make_shared&lt;Widget&gt;(), computePriority()); // no potential resource leak （3）更高效 std:shared_ptr&lt;Widget&gt; spw(new Widget); 这行代码中，我们以为只有一次内存分配，实际发生了两次，第二次是在分配std::shared_ptr控制块。如果用std::make_shared，它会把Widget对象和控制块合并为一次内存分配。 但他也存在一些问题： 无法传入自定义的销毁器。 make函数初始化时使用了括号初始化，而不是花括号初始化，比如std::make_unique&gt;(10, 20)创建了一个有着20个值为10的元素的vector，而不是创建了{10, 20}这么两个元素的vector 对象和控制块分配在一块内存上，减少了内存分配的次数，但也导致对象和控制块占用的内存也要一次回收掉。即，如果还有std::weak_ptr存在，控制块就要在，对象占用的内存也没办法回收。如果对象比较大，且std::weak_ptr在对象析构后还可能长期存在，那么这种开销是不可忽视的。 如果我们因为前面这三个缺点而不能使用std::make_shared，那么我们要保证，智能指针的构造一定要单独一个语句。回到之前processWidget的例子中，假设我们有个自定义的销毁器void cusDel(Widget* ptr);，因此不能使用std::make_shared，那么我们要这么写来保证异常安全性： std::shared_ptr&lt;Widget&gt; spw(new Widget, cusDel); processWidget(spw, computePriority()); 当然我们还可以加上移动语义，让它更高效： std::shared_ptr&lt;Widget&gt; spw(new Widget, cusDel); processWidget(std::move(spw), computePriority()); Item 22:When using the Pimpl Idiom, define special member functions in the implementation file.什么是Pimpl？ Pimpl(Pointer to implementation)特别用于减轻编译负担，这是一个C++编程的小技巧，通过它你能将一个类的数据成员打包放进一个具体的实现类或者结构体中，这些数据成员的访问能将通过指针间接访问。举个例子 class Widget() //定义在头文件`widget.h` { public: Widget(); ... private: std::string name; std::vector&lt;double&gt; data; Gadget g1, g2, g3; //Gadget是用户自定义的类型 } 当我们改变Gadget类的时候，整个程序都需要重新编译，所以我们希望改变这种现状。现在我们使用智能指针实现一个Pimpl来解决这个问题： class Widget //在&quot;Widget.h&quot;中 { public: Widget(); ... private: struct Impl; //声明一个 实现结构体 std::unique_ptr&lt;Impl&gt; pImpl; //使用智能指针而不是原始指针 } 实现文件写为： #include &quot;widget.h&quot; //以下代码均在实现文件 widget.cpp里 #include &quot;gadget.h&quot; #include &lt;string&gt; #include &lt;vector&gt; struct Widget::Impl //跟之前一样 { std::string name; std::vector&lt;double&gt; data; Gadget g1,g2,g3; } Widget::Widget(): pImpl(std::make_unique&lt;Imple&gt;()){} 以上代码不会编译通过，因为我们没有给Widget实现自定义的析构函数，因此编译器为Widget准备了一个。这个析构函数会被放到Widget的定义体内，默认是内联的，因此会有一份实现在用户文件中。~Widget中只做一件事：析构pImpl，即析构一个std::unique_ptr。注意，我们隐藏了Impl的实现，在析构std::unique_ptr时编译器发现Impl还是个不完整类型，此时对它调用delete是危险的，因此编译器用static_cast禁止了这种行为。 解决方案就是我们自己实现一个析构函数， // widget.h class Widget { public: Widget(); ~Widget(); ... private: struct Impl std::unique_ptr&lt;Impl&gt; pImpl; }; // widget.cpp ... Widget::Widget(): pImpl(std::make_unique&lt;Impl&gt;()){} Widget::~Widget(){} = default; //参见item17 根据Item17，自定义的析构函数会阻止编译器生成移动构造函数和移动赋值函数，因此如果你想要Widget有移动的能力，就要自己实现（注意不要在这些特殊成员函数的声明后面加= default，这样会重复上面析构函数的问题：会被内联，因此在用户代码中有一份实现，遇到不完整类型）： class Widget { public: Widget(); ~Widget(); //Widget(Widget&amp;&amp; rhs) = default; // right idea, wrong code! //Widget&amp; operator=(Widget&amp;&amp; rhs) = default; Widget(Widget&amp;&amp; rhs) ; Widget&amp; operator=(Widget&amp;&amp; rhs) ; ... }; 接下来就是复制构造函数和复制赋值函数了。我们用std::unique_ptr是为了更好的实现Pimpl方法，这也导致了Widget无法自动生成复制函数（std::unique_ptr不支持），但这并不意味着Widget就不能支持复制了，我们还可以自己定义两个复制函数： // widget.h class Widget { public: ... Widget(const Widget&amp; rhs); Widget&amp; operator=(const Widget&amp; rhs); ... }; // widget.cpp Widget::Widget(const Widget&amp; rhs) : pImpl(nullptr) { if (rhs.pImpl) { pImpl = std::make_unique&lt;Impl&gt;(*rhs.pImpl); } } Widget&amp; Widget::operator=(const Widget&amp; rhs) { if (!rhs.pImpl) { pImpl.reset(); } else if (!pImpl) { pImpl = std::make_unique&lt;Impl&gt;(*rhs.pImpl); } else { *pImpl = *rhs.pImpl; } } 如果你把pImpl的类型改为std::shared_ptr，你会发现上面所有这些注意事项，都不见了。你不需要手动实现析构函数、移动函数、构造函数，程序编译仍然是好的。所以这么多东西仅仅针对unique_ptr。这种差异来自于std::unique_ptr和std::shared_ptr对自定义销毁器的支持方式不同。 对std::unique_ptr而言，销毁器的类型是unique_ptr的一部分，这让编译器有可能生成更小的运行时数据结构和更快的运行代码。 这种更高效率的后果之一就是unique_ptr指向的类型，在编译器的生成特殊成员函数被调用时(如析构函数，移动操作)时，必须已经是一个完成类型。 而对std::shared_ptr而言，销毁器的类型不是该智能指针的一部分，这让它会生成更大的运行时数据结构和稍微慢点的代码，但是当编译器生成的特殊成员函数被使用的时候，指向的对象不必是一个完成类型。 对于pImpl惯用法而言，在std::unique_ptr和std::shared_ptr的特性之间，没有一个比较好的折中。 因为对于类Widget以及Widget::Impl而言，他们是独享占有权关系，这让std::unique_ptr使用起来很合适。","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"EffectiveModernCPP笔记4-现代CPP特性下","slug":"EffectiveModernCPP笔记3-现代CPP特性下","date":"2019-10-26T01:51:27.000Z","updated":"2019-12-30T21:16:40.000Z","comments":true,"path":"2019/10/26/EffectiveModernCPP笔记3-现代CPP特性下/","link":"","permalink":"jiangren.work/2019/10/26/EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8B/","excerpt":"介绍六个特性：overriding，const_iterator，noexcept，constexpr，const线程安全，类的特殊成员函数。","text":"介绍六个特性：overriding，const_iterator，noexcept，constexpr，const线程安全，类的特殊成员函数。 Item 12:Declare overriding functions override.在派生和继承中，常常涉及虚函数的使用。 C++多态(polymorphism)是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。 然而虚函数能够重写的条件很苛刻，他需要满足很多条件，我们编程时很容易搞错。他需要满足以下要求： 基类函数必须是virtual 基类和派生类函数名必须完全一样 基类和派生类函数参数必须完全一样 基类和派生类函数常量性(constness)必须完全一样 基类和派生类函数的返回值和异常说明(exception specifications)必须兼容 基类和派生类函数的引用限定符（reference qualifiers）必须完全一样。 下面的代码展示了这些错误： class Base { public: virtual void mf1() const; virtual void mf2(int x); virtual void mf3() &amp;; void mf4() const; }; class Derived: public Base { public: virtual void mf1(); virtual void mf2(unsigned int x); virtual void mf3() &amp;&amp;; void mf4() const; }; 最可气的是，编译器根本不会报错，最多只是给个warning，但编译时根本不会重写，所以我们需要将它显式声明为override。 class Base { public: virtual void mf1() const; virtual void mf2(int x); virtual void mf3() &amp;; virtual void mf4() const; }; class Derived: public Base { public: virtual void mf1() const override; virtual void mf2(int x) override; virtual void mf3() &amp; override; void mf4() const override; // 可以添加virtual，但不是必要 }; 比起让编译器通过warnings告诉你重写实际不会重写，不如给你的派生类成员函数全都加上override。 Item 13:Prefer const_iterators to iterators.在STL中const_iterator等价于常量指针，他们指向不能被修改的值。C98中支持得不是很好，而在11中：const_iterator即容易获取又容易使用。容器的成员函数cbegin和cend产出const_iterator std::vector&lt;int&gt; values{1,2,3,4}; auto ci = std::find(values.cbegin(), values.cend(), 3); *ci = 10; //error 这其中，ci就直接被划定为const_iterator，所以就不能做修改 Item 14:Declare functions noexcept if they won’t emit exceptions.在C++中人们认为异常信息最有用的在于：一个函数是否会抛出异常，这是一个二元性判断，即会和不会。就其本身而言，函数是否为noexcept和成员函数是否const一样重要。这个可以影响到调用代码的异常安全性和效率。原因如下： 1）避免运行时栈展开 C++98和11有不同的不抛出异常声明方式： int f(int x) throw(); // C++98风格 int f(int x) noexcept; // C++11风格 他们最大的不同在于：在C++98的异常说明中，调用栈会展开至f的调用者，一些不合适的动作比如程序终止也会发生。C++11异常说明的运行时行为明显不同：调用栈只是可能在程序终止前展开。一个必然一个可能，这两者会对代码生成产生巨大的影响。在一个noexcept函数中，当异常传播到函数外，优化器不需要保证运行时栈的可展开状态，也不需要保证noexcept函数中的对象按照构造的反序析构。而throw()标注的异常声明缺少这样的优化灵活性，它和没加一样。 RetType function(params) noexcept; // 极尽所能优化 RetType function(params) throw(); // 较少优化 RetType function(params); // 较少优化 （2）保证移动语义能充分发挥作用 当新元素添加到std::vector，std::vector可能没地方放它，这时候，std::vector会分配一片的新的大块内存用于存放，然后将元素从已经存在的内存移动到新内存。在C++98中，移动是通过复制老内存区的每一个元素到新内存区完成的，然后老内存区的每个元素发生析构。这种方法使得push_back可以提供很强的异常安全保证：如果在复制元素期间抛出异常，std::vector状态保持不变，因为老内存元素析构必须建立在它们已经成功复制到新内存的前提下。 在C++11中，一个很自然的优化就是将上述复制操作替换为移动操作。但是很不幸，破坏了push_back的异常安全。如果异常在移动中抛出，那么push_back操作就不能完成。但是原始的std::vector已经被修改。 因此容器们演化出了一种策略：如果可以就移动，如果必要则复制，比如说std::vector::push_back，std::vector::reverse，std:;deque::insert等等。而判断可不可以移动的关键就在于，移动中是否可能产生异常！如何判断？检查是否声明noexcept 那么哪些函数可以写为noexcept呢？ 具体来说，移动操作和swap可以写为不抛出异常，有助于程序优化。宽泛点来说，我们需要讨论宽泛契约(wild contracts)和严格契约(narrow contracts)函数 有宽泛契约的函数没有前置条件。这种函数不管程序状态如何都能调用，它对调用者传来的实参不设约束。反之，没有宽泛契约的函数就有严格契约。对于这些函数，如果违反前置条件，结果将会是未定义的。 假如现在有一个函数，我想在里面加一个前置条件冲突检查s.size()&lt;32，那么我就不能声明为noexcept，我需要在里面写一个异常抛出函数，抛出&quot;precondition was violated&quot;异常。 void f(const std::string&amp; s) noexcept; Item 15:Use constexpr whenever possible.const是一个古老的关键词，他从C++诞生之日就存在，在漫长的岁月中它承担了很多很多功能，在11中，人们觉得const干太多活，让它太难顶了，于是搞了一个constexpr来帮他分担一些工作，并且使得一些功能更加明确。 总的来说constexpr就是指编译期可知，潜台词是：告诉编译器我可以是编译期间可知的，尽情的优化我吧。而const专门用来声明不变量，潜台词是：告诉程序员没人动得了我，放心的把我传出去；或者放心的把变量交给我，我啥也不动就瞅瞅。 （1）关于常量 这一部分比较简单，往往用于C++要求出现整数常量表达式（ integral constant expression ）的上下文。这类上下文包括数组大小，整数模板参数（包括std::array对象的长度），枚举量，对齐修饰符（alignas(val)），等等。 int sz; // 非constexpr变量 … constexpr auto arraySize1 = sz; // 错误! sz的值在编译期不可知 std::array&lt;int, sz&gt; data1; // 错误!一样的问题 constexpr auto arraySize2 = 10; // 没问题，10是编译期可知常量 std::array&lt;int, arraySize2&gt; data2; // 没问题, arraySize2是constexpr 注意const不提供constexpr所能保证之事，因为const对象不需要在编译期初始化它的值。简而言之，所有constexpr对象都是const，但不是所有const对象都是constexpr。 int sz; // 和之前一样 const auto arraySize = sz; // 没问题，arraySize是sz的常量复制 std::array&lt;int, arraySize&gt; data; // 错误，arraySize值在编译期不可知 （2）关于函数 如果实参是编译期常量，它们将产出编译期值；如果是运行时值，它们就将产出运行时值。 如果传给constexpr函数的实参是在编译期可知的，结果就将在编译期计算完成。如果不可知，函数就不理你。 换句话说，当一个constexpr函数被一个或者多个编译期不可知值调用时，它就像普通函数一样，运行时计算它的结果。这意味着你不需要两个函数，一个用于编译期计算，一个用于运行时计算。 例子1：假如我来测量电位，把他们的结果评估为高、中、低三种情况，现在我测量了n组样本，那么得到的组合就是3^n。我们需要一个方法在编译期计算3^n。C++标准库提供了std::pow，这里还有两个问题。 第一，std::pow是为浮点类型设计的 我们需要整型结果。 第二，std::pow不是constexpr。因此我们需要自己来写： constexpr int pow(int base, int exp) noexcept // C++11 return (exp == 0 ? 1 : base * pow(base, exp - 1)); constexpr int pow(int base, int exp) noexcept // C++14 { auto result = 1; for (int i = 0; i &lt; exp; ++i) result *= base; return result; } 因为11的要求是constexpr函数的代码不超过一行语句，所以需要采用三目运算符加递归的方式，非常麻烦，所幸14中得到了解决。 例子2：构建一个点类 在C++11中，除了void外的所有内置类型可以是constexpr： class Point { public: constexpr Point(double xVal = 0, double yVal = 0) noexcept : x(xVal), y(yVal){} constexpr double xValue() const noexcept { return x; } constexpr double yValue() const noexcept { return y; } void setX(double newX) noexcept { x = newX; } void setY(double newY) noexcept { y = newY; } private: double x, y; }; Point的构造函数被声明为constexpr，因为如果传入的参数在编译期可知，Point的数据成员也能在编译器可知。因此Point就能被初始化为constexpr： constexpr Point p1(9.4, 27.7); // 没问题，构造函数会在编译期“运行” constexpr Point p2(28.8, 5.3); // 也没问题 类似的，xValue和yValu的getter函数也能是constexpr，这使得我们可以写一个constexpr函数里面调用Point的getter并初始化constexpr的对象： constexpr Point midpoint(const Point&amp; p1, const Point&amp; p2) noexcept { return { (p1.xValue() + p2.xValue()) / 2, (p1.yValue() + p2.yValue()) / 2 }; } constexpr auto mid = midpoint(p1, p2); 这就很给力了，因为： mid对象通过调用构造函数，getter和成员函数就能在只读内存中创建！ 你可以在模板或者需要枚举量的表达式里面使用像mid.xValue()*10的表达式！ 以前相对严格的某一行代码只能用于编译期，某一行代码只能用于运行时的界限变得模糊，一些运行时的普通计算能并入编译时。越多这样的代码并入，你的程序就越快。（当然，编译会花费更长时间） 在14中，放开了对void的限制，现在你可以： class Point { public: ... constexpr void setX(double newX) noexcept { x = newX; } constexpr void setY(double newY) noexcept { y = newY; } ... }; 也能写这样的函数： constexpr Point reflection(const Point&amp; p) noexcept { Point result; result.setX(-p.xValue()); result.setY(-p.yValue()); return result; } 我们在客户端就能写： constexpr Point p1(9.4, 27.7); constexpr Point p2(28.8, 5.3); constexpr auto mid = midpoint(p1, p2); constexpr auto reflectedMid = reflection(mid); Item 16:Make const member functions thread safe本文解决以下问题： 是什么导致const成员函数变成了非线程安全 如何避免非线程安全问题 什么导致const成员函数变成了非线程安全？ 首先const的成员函数的线程是绝对安全的，因为它不允许对类的成员变量进行修改操作，只能读取。让它变得不安全的是mutable关键词 mutable 只能用来修饰类的数据成员；而被 mutable 修饰的数据成员，可以在 const 成员函数中修改。 下面这段代码展示了mutable的作用和为什么线程不安全。roots本身是一个const成员函数，每次返回rootVals，而这个值只有在第一次的时候才需要计算，此后只需要直接返回即可，所以这就有了一个rootsAreValid来表明这个值是否是已经计算。 此时如果有两个线程同时执行roots，第一个线程发现rootsAreValid是false，开始计算rootVals，在计算的过程中，第二个线程开始执行，发现rootsAreValid也是false，也开始计算rootvals，这就会出错。 class Polynomial { public: using RootsType = std::vector&lt;double&gt;; RootsType roots() const { if (!rootsAreValid) { .... rootsAreValid = true } return rootVals; } private: mutable bool rootsAreValid { false }; mutable RootsType rootVals{}; }; 如何避免这个问题？ （1）使用互斥锁 class Polynomial { public: using RootsType = std::vector&lt;double&gt;; RootsType roots() const { std::lock_guard&lt;std::mutex&gt; g(m); // lock mutex if (!rootsAreVaild) { // 如果缓存无效 rootsAreVaild = true; } return rootsVals; } // unlock mutex private: mutable std::mutex m; mutable bool rootsAreVaild { false }; mutable RootsType rootsVals {}; }; 上面的代码中引入了一个mutable的mutex，因为加锁和解锁本身是会对mutex本身有改动，所以是mutable，但这就带来两个问题： 开销变大了，后面每次都要加锁获取rootVals，但是其实只有第一次是可读可写的，非线程安全的，后面就变成只读的了是线程安全的 mutex本身其实是一个只具备移动语义的类，这导致Polynomial类相应也变成了只具备移动语义的类了，限制了Polynomial类的使用范围。 （2）使用原子变量 class Point { // 2D point public: double distanceFromOrigin() const noexcept { ++callCount; // 原子的递增 return std::sqrt((x * x) + (y * y)); } private: mutable std::atomic&lt;unsigned&gt; callCount{ 0 }; double x, y; }; 使用atomic确保修饰的counter，保证其他线程视这个操作为不可分割的。与std::mutex一样，std::atomic是move-only类型，所以在Point中调用Count的意思就是Point也是move-only的。因为对std::atomic变量的操作通常比互斥量的获取和释放的消耗更小，所以可能更倾向与依赖std::atomic。但他也有一个很大的问题： 下面的代码的问题是： 一个线程调用Widget::magicValue，将cacheValid视为false，执行这两个昂贵的计算，并将它们的和分配给cachedValue。 此时，第二个线程调用Widget::magicValue，也将cacheValid视为false，因此执行刚才完成的第一个线程相同的计算。 class Widget { public: int magicValue() const { if (cacheVaild) return cachedValue; else { auto val1 = expensiveComputation1(); auto val2 = expensiveComputation2(); cachedValue = val1 + val2; // 第一步 cacheVaild = true; // 第二步 return cachedVaild; } } private: mutable std::atomic&lt;bool&gt; cacheVaild{ false }; mutable std::atomic&lt;int&gt; cachedValue; }; 所以原子操作只适合于单变量的情况，如果是多变量或多内存位置应使用互斥锁。 Item 17:Understand special member function generation在C++术语中，特殊成员函数是指C++自己生成的函数。C++98有四个：默认构造函数函数，析构函数，拷贝构造函数，拷贝赋值运算符。这些函数仅在需要的时候才生成。 class没有任何的constructor，但它内含member object，而后者有默认的构造函数。 class没有任何的constructor，但是它派生自一个带有默认构造函数的基类。 带有虚函数的类 继承自带有虚函数的基类 只有在满足上述情况下，编译期才会帮我们生成默认的构造函数，帮我们调用成员变量的构造函数进行初始化，或者是创建虚函数表，调用基类的构造函数，初始化基类等工作。下面的代码就不会产生默认构造函数。 class simple { private: int data; }; 除此以外，11还产生了两个新的特殊成员函数：移动构造函数，移动赋值操作符，其声明方式如下： class Widget { public: ..... Widget(Widget&amp;&amp; rhs); Widget&amp; operator=(widget&amp;&amp; rhs); }; 移动构造函数的生成规则类似于拷贝构造函数，仅仅当编译器需要的时候才会生成，要求其每一个非static的成员都具有移动语义。下面给出一个例子，Private类型不具有移动语义： class test { public: test() { p = new char(&#39;a&#39;); } test(const test&amp; other) { std::cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; std::endl; } private: char* p = nullptr; }; int main() { test t; test c(std::move(t)); return 0; } 分析：当执行test t时，调用默认构造函数，将p赋值为a。执行test c(std::move(t));时，由于成员不具有移动语义，所以并不能移动构造，只能调用拷贝构造函数，输出&quot;copy construct&quot;，同时p也没有赋值，依然是nullptr。 因此当我们将成员变量改为公有类型，去掉拷贝构造函数，就能使这个类具有移动语义特性时，它就能正确执行： class test { public: test() { str = &quot;test&quot;; } std::string str; }; int main() { test t; test c(std::move(t)); return 0; } 如果给上面的代码加一个拷贝构造函数： test(const test&amp; other) { std::cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; std::endl; } 结果会调用拷贝构造函数，而不是使用移动构造。所以我们可以总结得到，造成不能移动构造的罪魁祸首是test(const test&amp; other)和char* p = nullptr; 那么为什么会这样呢？6个特殊函数的关系如何呢？ 默认构造函数，在用户没有声明自定义的构造函数的时候并且编译期需要的时候生成 默认析构函数，销毁对象时，没有自定义的析构函数就会生成 拷贝构造函数和拷贝赋值操作符，用户自定义了移动操作会导致不生成默认的拷贝构造函数，其他和上面写的C98的四条原则一样 移动构造函数和移动赋值操作符，仅仅在没有用户自定义的拷贝操作，移动操作和析构操作的时候才会生成 那么如何在自定义能有效使用默认移动构造函数呢？使用default class test { public: test() { str = &quot;test&quot;; } test(const test&amp; other) { std::cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; std::endl; } test(test&amp;&amp;) = default; //显示的声明默认的移动构造函数 test&amp; operator=(test&amp;&amp;) = default; std::string str; };","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"EffectiveModernCPP笔记4-现代CPP特性下","slug":"EffectiveModernCPP笔记4-现代CPP特性下","date":"2019-10-26T01:51:27.000Z","updated":"2020-03-26T05:11:26.000Z","comments":true,"path":"2019/10/26/EffectiveModernCPP笔记4-现代CPP特性下/","link":"","permalink":"jiangren.work/2019/10/26/EffectiveModernCPP%E7%AC%94%E8%AE%B04-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8B/","excerpt":"介绍六个特性：overriding，const_iterator，noexcept，constexpr，const线程安全，类的特殊成员函数。","text":"介绍六个特性：overriding，const_iterator，noexcept，constexpr，const线程安全，类的特殊成员函数。 Item 12:Declare overriding functions override.在派生和继承中，常常涉及虚函数的使用。 C++多态(polymorphism)是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。 然而虚函数能够重写的条件很苛刻，他需要满足很多条件，我们编程时很容易搞错。他需要满足以下要求： 基类函数必须是virtual 基类和派生类函数名必须完全一样 基类和派生类函数参数必须完全一样 基类和派生类函数常量性(constness)必须完全一样 基类和派生类函数的返回值和异常说明(exception specifications)必须兼容 基类和派生类函数的引用限定符（reference qualifiers）必须完全一样。 下面的代码展示了这些错误： class Base { public: virtual void mf1() const; virtual void mf2(int x); virtual void mf3() &amp;; void mf4() const; }; class Derived: public Base { public: virtual void mf1(); virtual void mf2(unsigned int x); virtual void mf3() &amp;&amp;; void mf4() const; }; 最可气的是，编译器根本不会报错，最多只是给个warning，但编译时根本不会重写，所以我们需要将它显式声明为override。 class Base { public: virtual void mf1() const; virtual void mf2(int x); virtual void mf3() &amp;; virtual void mf4() const; }; class Derived: public Base { public: virtual void mf1() const override; virtual void mf2(int x) override; virtual void mf3() &amp; override; void mf4() const override; // 可以添加virtual，但不是必要 }; 比起让编译器通过warnings告诉你重写实际不会重写，不如给你的派生类成员函数全都加上override。 Item 13:Prefer const_iterators to iterators.在STL中const_iterator等价于常量指针，他们指向不能被修改的值。C98中支持得不是很好，而在11中：const_iterator即容易获取又容易使用。容器的成员函数cbegin和cend产出const_iterator std::vector&lt;int&gt; values{1,2,3,4}; auto ci = std::find(values.cbegin(), values.cend(), 3); *ci = 10; //error 这其中，ci就直接被划定为const_iterator，所以就不能做修改 Item 14:Declare functions noexcept if they won’t emit exceptions.在C++中人们认为异常信息最有用的在于：一个函数是否会抛出异常，这是一个二元性判断，即会和不会。就其本身而言，函数是否为noexcept和成员函数是否const一样重要。这个可以影响到调用代码的异常安全性和效率。原因如下： 1）避免运行时栈展开 C++98和11有不同的不抛出异常声明方式： int f(int x) throw(); // C++98风格 int f(int x) noexcept; // C++11风格 他们最大的不同在于：在C++98的异常说明中，调用栈会展开至f的调用者，一些不合适的动作比如程序终止也会发生。C++11异常说明的运行时行为明显不同：调用栈只是可能在程序终止前展开。一个必然一个可能，这两者会对代码生成产生巨大的影响。在一个noexcept函数中，当异常传播到函数外，优化器不需要保证运行时栈的可展开状态，也不需要保证noexcept函数中的对象按照构造的反序析构。而throw()标注的异常声明缺少这样的优化灵活性，它和没加一样。 RetType function(params) noexcept; // 极尽所能优化 RetType function(params) throw(); // 较少优化 RetType function(params); // 较少优化 （2）保证移动语义能充分发挥作用 当新元素添加到std::vector，std::vector可能没地方放它，这时候，std::vector会分配一片的新的大块内存用于存放，然后将元素从已经存在的内存移动到新内存。在C++98中，移动是通过复制老内存区的每一个元素到新内存区完成的，然后老内存区的每个元素发生析构。这种方法使得push_back可以提供很强的异常安全保证：如果在复制元素期间抛出异常，std::vector状态保持不变，因为老内存元素析构必须建立在它们已经成功复制到新内存的前提下。 在C++11中，一个很自然的优化就是将上述复制操作替换为移动操作。但是很不幸，破坏了push_back的异常安全。如果异常在移动中抛出，那么push_back操作就不能完成。但是原始的std::vector已经被修改。 因此容器们演化出了一种策略：如果可以就移动，如果必要则复制，比如说std::vector::push_back，std::vector::reverse，std:;deque::insert等等。而判断可不可以移动的关键就在于，移动中是否可能产生异常！如何判断？检查是否声明noexcept 那么哪些函数可以写为noexcept呢？ 具体来说，移动操作和swap可以写为不抛出异常，有助于程序优化。宽泛点来说，我们需要讨论宽泛契约(wild contracts)和严格契约(narrow contracts)函数 有宽泛契约的函数没有前置条件。这种函数不管程序状态如何都能调用，它对调用者传来的实参不设约束。反之，没有宽泛契约的函数就有严格契约。对于这些函数，如果违反前置条件，结果将会是未定义的。 假如现在有一个函数，我想在里面加一个前置条件冲突检查s.size()&lt;32，那么我就不能声明为noexcept，我需要在里面写一个异常抛出函数，抛出&quot;precondition was violated&quot;异常。 void f(const std::string&amp; s) noexcept; Item 15:Use constexpr whenever possible.const是一个古老的关键词，他从C++诞生之日就存在，在漫长的岁月中它承担了很多很多功能，在11中，人们觉得const干太多活，让它太难顶了，于是搞了一个constexpr来帮他分担一些工作，并且使得一些功能更加明确。 总的来说constexpr就是指编译期可知，潜台词是：告诉编译器我可以是编译期间可知的，尽情的优化我吧。而const专门用来声明不变量，潜台词是：告诉程序员没人动得了我，放心的把我传出去；或者放心的把变量交给我，我啥也不动就瞅瞅。 （1）关于常量 这一部分比较简单，往往用于C++要求出现整数常量表达式（ integral constant expression ）的上下文。这类上下文包括数组大小，整数模板参数（包括std::array对象的长度），枚举量，对齐修饰符（alignas(val)），等等。 int sz; // 非constexpr变量 … constexpr auto arraySize1 = sz; // 错误! sz的值在编译期不可知 std::array&lt;int, sz&gt; data1; // 错误!一样的问题 constexpr auto arraySize2 = 10; // 没问题，10是编译期可知常量 std::array&lt;int, arraySize2&gt; data2; // 没问题, arraySize2是constexpr 注意const不提供constexpr所能保证之事，因为const对象不需要在编译期初始化它的值。简而言之，所有constexpr对象都是const，但不是所有const对象都是constexpr。 int sz; // 和之前一样 const auto arraySize = sz; // 没问题，arraySize是sz的常量复制 std::array&lt;int, arraySize&gt; data; // 错误，arraySize值在编译期不可知 （2）关于函数 如果实参是编译期常量，它们将产出编译期值；如果是运行时值，它们就将产出运行时值。 如果传给constexpr函数的实参是在编译期可知的，结果就将在编译期计算完成。如果不可知，函数就不理你。 换句话说，当一个constexpr函数被一个或者多个编译期不可知值调用时，它就像普通函数一样，运行时计算它的结果。这意味着你不需要两个函数，一个用于编译期计算，一个用于运行时计算。 例子1：假如我来测量电位，把他们的结果评估为高、中、低三种情况，现在我测量了n组样本，那么得到的组合就是3^n。我们需要一个方法在编译期计算3^n。C++标准库提供了std::pow，这里还有两个问题。 第一，std::pow是为浮点类型设计的 我们需要整型结果。 第二，std::pow不是constexpr。因此我们需要自己来写： constexpr int pow(int base, int exp) noexcept // C++11 return (exp == 0 ? 1 : base * pow(base, exp - 1)); constexpr int pow(int base, int exp) noexcept // C++14 { auto result = 1; for (int i = 0; i &lt; exp; ++i) result *= base; return result; } 因为11的要求是constexpr函数的代码不超过一行语句，所以需要采用三目运算符加递归的方式，非常麻烦，所幸14中得到了解决。 例子2：构建一个点类 在C++11中，除了void外的所有内置类型可以是constexpr： class Point { public: constexpr Point(double xVal = 0, double yVal = 0) noexcept : x(xVal), y(yVal){} constexpr double xValue() const noexcept { return x; } constexpr double yValue() const noexcept { return y; } void setX(double newX) noexcept { x = newX; } void setY(double newY) noexcept { y = newY; } private: double x, y; }; Point的构造函数被声明为constexpr，因为如果传入的参数在编译期可知，Point的数据成员也能在编译器可知。因此Point就能被初始化为constexpr： constexpr Point p1(9.4, 27.7); // 没问题，构造函数会在编译期“运行” constexpr Point p2(28.8, 5.3); // 也没问题 类似的，xValue和yValu的getter函数也能是constexpr，这使得我们可以写一个constexpr函数里面调用Point的getter并初始化constexpr的对象： constexpr Point midpoint(const Point&amp; p1, const Point&amp; p2) noexcept { return { (p1.xValue() + p2.xValue()) / 2, (p1.yValue() + p2.yValue()) / 2 }; } constexpr auto mid = midpoint(p1, p2); 这就很给力了，因为： mid对象通过调用构造函数，getter和成员函数就能在只读内存中创建！ 你可以在模板或者需要枚举量的表达式里面使用像mid.xValue()*10的表达式！ 以前相对严格的某一行代码只能用于编译期，某一行代码只能用于运行时的界限变得模糊，一些运行时的普通计算能并入编译时。越多这样的代码并入，你的程序就越快。（当然，编译会花费更长时间） 在14中，放开了对void的限制，现在你可以： class Point { public: ... constexpr void setX(double newX) noexcept { x = newX; } constexpr void setY(double newY) noexcept { y = newY; } ... }; 也能写这样的函数： constexpr Point reflection(const Point&amp; p) noexcept { Point result; result.setX(-p.xValue()); result.setY(-p.yValue()); return result; } 我们在客户端就能写： constexpr Point p1(9.4, 27.7); constexpr Point p2(28.8, 5.3); constexpr auto mid = midpoint(p1, p2); constexpr auto reflectedMid = reflection(mid); Item 16:Make const member functions thread safe本文解决以下问题： 是什么导致const成员函数变成了非线程安全 如何避免非线程安全问题 什么导致const成员函数变成了非线程安全？ 首先const的成员函数的线程是绝对安全的，因为它不允许对类的成员变量进行修改操作，只能读取。让它变得不安全的是mutable关键词 mutable 只能用来修饰类的数据成员；而被 mutable 修饰的数据成员，可以在 const 成员函数中修改。 下面这段代码展示了mutable的作用和为什么线程不安全。roots本身是一个const成员函数，每次返回rootVals，而这个值只有在第一次的时候才需要计算，此后只需要直接返回即可，所以这就有了一个rootsAreValid来表明这个值是否是已经计算。 此时如果有两个线程同时执行roots，第一个线程发现rootsAreValid是false，开始计算rootVals，在计算的过程中，第二个线程开始执行，发现rootsAreValid也是false，也开始计算rootvals，这就会出错。 class Polynomial { public: using RootsType = std::vector&lt;double&gt;; RootsType roots() const { if (!rootsAreValid) { .... rootsAreValid = true } return rootVals; } private: mutable bool rootsAreValid { false }; mutable RootsType rootVals{}; }; 如何避免这个问题？ （1）使用互斥锁 class Polynomial { public: using RootsType = std::vector&lt;double&gt;; RootsType roots() const { std::lock_guard&lt;std::mutex&gt; g(m); // lock mutex if (!rootsAreVaild) { // 如果缓存无效 rootsAreVaild = true; } return rootsVals; } // unlock mutex private: mutable std::mutex m; mutable bool rootsAreVaild { false }; mutable RootsType rootsVals {}; }; 上面的代码中引入了一个mutable的mutex，因为加锁和解锁本身是会对mutex本身有改动，所以是mutable，但这就带来两个问题： 开销变大了，后面每次都要加锁获取rootVals，但是其实只有第一次是可读可写的，非线程安全的，后面就变成只读的了是线程安全的 mutex本身其实是一个只具备移动语义的类，这导致Polynomial类相应也变成了只具备移动语义的类了，限制了Polynomial类的使用范围。 （2）使用原子变量 class Point { // 2D point public: double distanceFromOrigin() const noexcept { ++callCount; // 原子的递增 return std::sqrt((x * x) + (y * y)); } private: mutable std::atomic&lt;unsigned&gt; callCount{ 0 }; double x, y; }; 使用atomic确保修饰的counter，保证其他线程视这个操作为不可分割的。与std::mutex一样，std::atomic是move-only类型，所以在Point中调用Count的意思就是Point也是move-only的。因为对std::atomic变量的操作通常比互斥量的获取和释放的消耗更小，所以可能更倾向与依赖std::atomic。但他也有一个很大的问题： 下面的代码的问题是： 一个线程调用Widget::magicValue，将cacheValid视为false，执行这两个昂贵的计算，并将它们的和分配给cachedValue。 此时，第二个线程调用Widget::magicValue，也将cacheValid视为false，因此执行刚才完成的第一个线程相同的计算。 class Widget { public: int magicValue() const { if (cacheVaild) return cachedValue; else { auto val1 = expensiveComputation1(); auto val2 = expensiveComputation2(); cachedValue = val1 + val2; // 第一步 cacheVaild = true; // 第二步 return cachedVaild; } } private: mutable std::atomic&lt;bool&gt; cacheVaild{ false }; mutable std::atomic&lt;int&gt; cachedValue; }; 所以原子操作只适合于单变量的情况，如果是多变量或多内存位置应使用互斥锁。 Item 17:Understand special member function generation在C++术语中，特殊成员函数是指C++自己生成的函数。C++98有四个：默认构造函数函数，析构函数，拷贝构造函数，拷贝赋值运算符。这些函数仅在需要的时候才生成。 class没有任何的constructor，但它内含member object，而后者有默认的构造函数。 class没有任何的constructor，但是它派生自一个带有默认构造函数的基类。 带有虚函数的类 继承自带有虚函数的基类 只有在满足上述情况下，编译期才会帮我们生成默认的构造函数，帮我们调用成员变量的构造函数进行初始化，或者是创建虚函数表，调用基类的构造函数，初始化基类等工作。下面的代码就不会产生默认构造函数。 class simple { private: int data; }; 除此以外，11还产生了两个新的特殊成员函数：移动构造函数，移动赋值操作符，其声明方式如下： class Widget { public: ..... Widget(Widget&amp;&amp; rhs); Widget&amp; operator=(widget&amp;&amp; rhs); }; 移动构造函数的生成规则类似于拷贝构造函数，仅仅当编译器需要的时候才会生成，要求其每一个非static的成员都具有移动语义。下面给出一个例子，Private类型不具有移动语义： class test { public: test() { p = new char(&#39;a&#39;); } test(const test&amp; other) { std::cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; std::endl; } private: char* p = nullptr; }; int main() { test t; test c(std::move(t)); return 0; } 分析：当执行test t时，调用默认构造函数，将p赋值为a。执行test c(std::move(t));时，由于成员不具有移动语义，所以并不能移动构造，只能调用拷贝构造函数，输出&quot;copy construct&quot;，同时p也没有赋值，依然是nullptr。 因此当我们将成员变量改为公有类型，去掉拷贝构造函数，就能使这个类具有移动语义特性时，它就能正确执行： class test { public: test() { str = &quot;test&quot;; } std::string str; }; int main() { test t; test c(std::move(t)); return 0; } 如果给上面的代码加一个拷贝构造函数： test(const test&amp; other) { std::cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; std::endl; } 结果会调用拷贝构造函数，而不是使用移动构造。所以我们可以总结得到，造成不能移动构造的罪魁祸首是test(const test&amp; other)和char* p = nullptr; 那么为什么会这样呢？6个特殊函数的关系如何呢？ 默认构造函数，在用户没有声明自定义的构造函数的时候并且编译期需要的时候生成 默认析构函数，销毁对象时，没有自定义的析构函数就会生成 拷贝构造函数和拷贝赋值操作符，用户自定义了移动操作会导致不生成默认的拷贝构造函数，其他和上面写的C98的四条原则一样 移动构造函数和移动赋值操作符，仅仅在没有用户自定义的拷贝操作，移动操作和析构操作的时候才会生成 那么如何在自定义能有效使用默认移动构造函数呢？使用default class test { public: test() { str = &quot;test&quot;; } test(const test&amp; other) { std::cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; std::endl; } test(test&amp;&amp;) = default; //显示的声明默认的移动构造函数 test&amp; operator=(test&amp;&amp;) = default; std::string str; };","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"EffectiveModernCPP笔记3-现代CPP特性上","slug":"EffectiveModernCPP笔记3-现代CPP特性上","date":"2019-10-26T01:51:22.000Z","updated":"2019-12-30T21:03:18.000Z","comments":true,"path":"2019/10/26/EffectiveModernCPP笔记3-现代CPP特性上/","link":"","permalink":"jiangren.work/2019/10/26/EffectiveModernCPP%E7%AC%94%E8%AE%B03-%E7%8E%B0%E4%BB%A3CPP%E7%89%B9%E6%80%A7%E4%B8%8A/","excerpt":"主要介绍C++11/14里面的新东西，分为两个篇章，这一篇章介绍五个特性：初始化方式，nullptr，别名using，限定域枚举，deleted函数。","text":"主要介绍C++11/14里面的新东西，分为两个篇章，这一篇章介绍五个特性：初始化方式，nullptr，别名using，限定域枚举，deleted函数。 Item 7:Distinguish between () and {} when creating objects大体上来说，C++的初始化方式分为三种： int x(0); int y = 0; int z{0}; //等价于int c={0}; 对于int这种内置类型来说，他们的区别并没有太大的意义，而对于用户自定义的类型而言，区别赋值运算符和初始化就非常重要了。 Widget w1; //调用默认构造函数 Widget w2 = w1; //不是赋值运算符，调用拷贝构造函数 w1 = w2; //是一个赋值运算符，调用operator=函数 为了整合这些混乱的初始化方式，C++11引入了统一初始化(uniform initialization)，实现的办法是使用花括号！具体来说有四个好处： （1）类中非静态成员指定默认初始值 括号初始化也能被用于为非静态数据成员指定默认初始值。C++11允许”=”初始化也拥有这种能力： class Widget{ ... private: int x{0}; //没问题，x初始值为0 int y = 0; //同上 int z(0); //错误！ } （2）用于不可拷贝对象初始化 std::atomic(原子化操作)是不可拷贝对象，所以不能用=初始化！ std::atomic&lt;int&gt; ai1{0}; //没问题，x初始值为0 std::atomic&lt;int&gt; ai2(0); //没问题 std::atomic&lt;int&gt; ai3 = 0; //错误！ （3）避免变窄转换(narrowing conversion) double x,y,z; int sum1{x+y+z}; //错误 int sum2(x + y +z); //可以（表达式的值被截为int）,损失精度 int sum3 = x + y + z; //同上，损失精度 （4）避免语法解析歧义 尝试使用一个没有参数的构造函数构造对象，它就会变成函数声明： Widget w2(); //最令人头疼的解析！声明一个函数w2，返回Widget 由于函数声明中形参列表不能使用花括号，所以使用花括号初始化就可以消除这种歧义： Widget w3{};//调用没有参数的构造函数构造对象 但是使用花括号统一初始化一个大毛病！std::initializer_list误匹配！ class Widget { public: Widget(int i,bool b); Widget(int i,double b); Widget(std::initializer_list&lt;long double&gt; il); }; Widget(10,true); //调用的是第一个构造函数， Widget{10,true}; //按理应该是调用第一个构造函数，但是现在却调用了带初始化列表的构造函数 这是因为编译器热衷于把花括号初始化与使std::initializer_list构造函数匹配，热衷程度甚至超过了最佳匹配。比如： class Widget { public: Widget(int i, bool b); Widget(int i, double d); Widget(std::initializer_list&lt;bool&gt; il); … }; Widget w{10, 5.0}; //错误！要求变窄转换 当然出现这样的问题主要还是因为统一初始化是允许宽化转换的，所以上面的上面10和true都转换成long double了。而上面那个10和5.0转化到bool是窄式转化，这是不允许的！ 只有当没办法把括号初始化中实参的类型转化为std::initializer_list时，编译器才会回到正常的函数决议流程中。比如下面的string就是如此。 class Widget { public: Widget(int i, bool b); Widget(int i, double d); Widget(std::initializer_list&lt;std::string&gt; il); … }; Widget w1(10, true);// 使用小括号初始化，调用第一个构造函数 Widget w2{10, true};// 使用花括号初始化，调用第一个构造函数 Widget w3(10, 5.0);// 使用小括号初始化，调用第二个构造函数 Widget w4{10, 5.0};// 使用花括号初始化，调用第二个构造函数 这个毛病会造成某些时候括号和花括号不同语义。std::vector有一个非std::initializer_list构造函数允许你去指定容器的初始大小，以及使用一个值填满你的容器。但它也有一个std::initializer_list构造函数允许你使用花括号里面的值初始化容器。令人头疼！ std::vector&lt;int&gt; v1(10, 20); //使用非std::initializer_list //构造函数创建一个包含10个元素 //所有的元素的值都是20 std::vector&lt;int&gt; v2{10, 20}; //使用std::initializer_list //构造函数创建包含两个元素的std::vector //元素的值为10和20 总的来说，为了避免这些问题，那么作为库的开发者你应该把你的构造函数设计为不管用户是小括号还是使用花括号进行初始化都不会有什么影响（避免vector设计的睿智操作）；作为库的使用者必须认真的在花括号和小括号之间选择一个来创建对象。大多数开发者都使用其中一种作为默认情况，只有当他们不能使用这种的时候才会考虑另一种。 Item 8: Prefer nullptr to 0 and NULL.废话不多说，直接说好处： （1）使用nullptr*代替0和NULL可以避开那些烦人的函数重载决议 NULL最大的问题在于它没有明确的类型。 void f(int); //三个f的重载函数 void f(bool); void f(long); void f(void*); f(NULL); //可能会不通过，也可能会调用int,但不会调用void* f(NULL)的不确定性是由于NULL的实现不同造成的，在我的编译环境下(Visual Studio 2019)，NULL被划定为int型。这样的话，调用就具有二义性！ 现在做一个实验：注释掉int的重载类型，发现 这是因为缺失了int类型的重载，它会开始转化，而从int到long, bool, void\\*的转换都会被考虑。同理，调用f(0)也会出现这样的状况。 为了避免二义性，准确地定位到void\\*，推荐使用nullptr！ nullptr的类型是std::nullptr_t，这种类型的特点是可以转换为指向任何内置类型的指针，这也是为什么把它叫做通用类型的指针。 （2）和auto共用时，让代码更加明确 如果你不知道findRecord返回了什么（或者不能轻易的找出），那么你就不太清楚到底result是一个指针类型还是一个整型。 auto result = findRecord( /* arguments */ ); if (result == 0) { … } 因此，我们最好改为: auto result = findRecord( /* arguments */ ); if (result == nullptr) { … } （3）模板中有更好兼容性 假如有一些函数只能被合适的已锁互斥量调用。每个函数都有一个不同类型的指针： int f1(std::shared_ptr&lt;Widget&gt; spw); // 只能被合适的已锁互斥量调用 double f2(std::unique_ptr&lt;Widget&gt; upw); bool f3(Widget* pw); 我们用模板： template&lt;typename FuncType,typename MuxType,typename PtrType&gt; decltype(auto) lockAndCall(FuncType func, MuxType&amp; mutex, PtrType ptr) { MuxGuard g(mutex); return func(ptr); } 可以写这样的代码调用lockAndCall模板: auto result1 = lockAndCall(f1, f1m, 0); // 错误！ auto result2 = lockAndCall(f2, f2m, NULL); // 错误！ auto result3 = lockAndCall(f3, f3m, nullptr); // OK 为什么会出现错误呢？还是老毛病：0和NULL都是int型（至少在我的编译环境下是），但我们期待的参数是std::shared_ptr，所以推导的过程中就会发生错误。 Item 9:Prefer alias declarations to typedefsC++常常为复杂的类型做一个重定义，方式有两种：typedef和using使用别名。前者是98的东西，后者是11提供的新东西。 typedef std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt; UPtrMapSS; using UPtrMapSS = std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;; 具体来说使用using别名有这么几个好处： // FP是一个指向函数的指针的同义词，它指向的函数带有int和const std::string&amp;形参，不返回任何东西 typedef void (*FP)(int, const std::string&amp;); // typedef //同上 using FP = void (*)(int, const std::string&amp;); // 别名声明 （2）方便使用模板 typedef没有办法在模板声明的作用域中做类型重定义，必须放在一个自定义类型作用域内，而using没有这个限制。 template&lt;typename T&gt; struct MyAllocList { typedef std::list&lt;T, MyAlloc&lt;T&gt;&gt; type; }; MyAllocList&lt;Widget&gt;::type lw; 而using没有这个限制。 template&lt;typename T&gt; using MyAllocList = std::list&lt;T,MyAlloc&lt;T&gt;&gt;; MyAllocList&lt;Widget&gt; lw; 对于嵌套类型来说，typedef需要使用typename template&lt;typename T&gt; struct MyAllocList { typedef std::list&lt;T, MyAlloc&lt;T&gt;&gt; type; }; template&lt;typename T&gt; class Widget { private: typename MyAllocList&lt;T&gt;::type list; … }; 由于MyAllocList::type使用了一个类型，它依赖于模板参数T，因此它是一个依赖类型，依赖类型就必须在前面加上typename。 相反，使用using就不会有问题。对你来说，MyAllocList（使用了模板别名声明的版本）可能看起来和MyAllocList::type（使用typedef的版本）一样都应该依赖模板参数T，但编译器和你想的不同。 当编译器处理MyAllocList（使用模板别名声明的版本），它们知道MyAllocList是一个类型名，它一定是一个类型名。因此MyAllocList就是一个非依赖类型，就不要求必须使用typename。 Item 10:Prefer scoped enums to unscoped enums.首先介绍一下枚举： 打开一个文件可能有三种状态：input, output和append. 典型做法是，对应定义3个常数，即：const int input = 1;const int output = 2;const int append = 3;然后，调用以下函数：bool open_file(string file_name, int open_mode); 问题是可能用户手贱输了一个4进去，超出范围，这就很麻烦了，而且纯数字也不好记忆和分辩。通过枚举可以解决这个问题。 enum open_modes {input = 1, output, append}; open_file(&quot;Phenix_and_the_Crane&quot;, append); C++的枚举分为两种：有限定域的枚举和无限定域枚举，前者是11的新特性，后者是98的特性。推荐使用有限定域的枚举，理由如下： （1）防止污染命名空间 通常来说我们在花括号中定义的名称其作用域就在花括号中，但是C++98的枚举类型的声明却不遵从这个规则。 enum Color {black,white,red}; auto white = false; //编译出错white已经声明了 在11中，我们通过使用enum class关键词就可以声明限定域枚举，避免泄露枚举名： enum class Color { black, white, red }; // black, white, red // 限制在Color域内 auto white = false; // 没问题，同样域内没有这个名字 Color c = white; // 错误，这个域中没有white Color c = Color::white; // 没问题 auto c = Color::white; // 也没问题（也符合条款5的建议） （2）避免隐式转化 void primeFactors(std::size_t x) { return; } enum Color { black, white, red }; // 未限域枚举 Color c = red; if (c &lt; 3.5) { //int和double比较，玩蛇？ primeFactors(c); // int强转编程size_t，终极玩蛇？ } 虽然这些操作在玩蛇，但编译器依然将他们通过，这可能会造成不好的结果，所以我们倾向于使用限域枚举，上面的玩蛇操作都不会通过编译！如果真的很想进行转化，使用强转符号。 if (static_cast&lt;double&gt;(c) &lt; 14.5) { // 奇怪的代码，但是有效 auto factors =primeFactors(static_cast&lt;std::size_t&gt;(c)); // 能通过编译 } （3）支持前项声明 先解释一下前项声明： 前向声明（Forward Declaration）是指声明标识符(表示编程的实体，如数据类型、变量、函数)时还没有给出完整的定义。下面就是一个函数前向声明的例子。 void printThisInteger(int); ... void printThisInteger(int x) { printf(&quot;%d\\n&quot;, x); } 使用未限定域枚举前向声明会发生错误: enum Color; // 错误！ enum class Color; // 没问题 原因是unscoped枚举类型的实际类型并不是enum，它有一个底层存储类型。而这个底层存储类型是编译器在编译的时候决策的，根据你的取值范围来定义你的底层存储类型。 enum Color { black, white, red }; //编译器选择char型，因为只有三个值 enum Status { good = 0, //编译器选择int或long，因为范围比较大 failed = 1, incomplete = 100, corrupt = 200, indeterminate = 0xFFFFFFFF }; 可以看到，由于类型未定，所以不能前置声明，这就带来一个问题：编译依赖过强！换句话说，整个枚举类作用于整个系统，我新添加一个成员，就会导致全部重新编译。 enum class Status; // forward declaration void continueProcessing(Status s); // use of fwd-declared enum 即使Status的定义发生改变，包含这些声明的头文件也不会重新编译，如果它只是添加一个枚举名。continueProcessing也不会受影响，因为他不涉及新添加的枚举。 enum class Color; int foo(Color c); //修改成员后，上面的部分都不用管 enum class Color {red,black}; int foo(Color red) { return 1; } void main() { Color r = Color::red; cout &lt;&lt; foo(r) &lt;&lt; endl; } 但是，使用限定域枚举有的时候反而会加大工作量！ 比如在社交网站中，假设我们有一个tuple保存了用户的名字，email地址，声望点： using UserInfo = // 类型别名，参见Item 9 std::tuple&lt;std::string, // 名字 std::string, // email地址 std::size_t&gt; ; // 声望 UserInfo uInfo; // tuple对象 auto val = std::get&lt;1&gt;(uInfo); // 获取第一个字段 这里先说明一下tuple： std::tuple是类似pair的模板。每个pair的成员类型都不相同，但每个pair都恰好有两个成员。不同std::tuple类型的成员类型也不相同，但一个std::tuple可以有任意数量的成员。 要访问一个tuple的成员，就要使用一个名为get的标准库函数模板。get尖括号中的值必须是一个整型常量表达式。与往常一样，我们从0开始计数，意味着get&lt;0&gt;是第一个成员。 虽然注释说明了tuple各个字段对应的意思，但还是要记住第一个字段代表用户的email地址，这让人很不爽。我们可以使用非限定域枚举将名字和字段编号关联起来解决这个问题。 之所以它能正常工作是因为UserInfoFields中的枚举名隐式转换成std::size_t了,其中std::size_t是std::get模板实参所需的。 对应的限域枚举版本就很啰嗦了： enum class UserInfoFields { uiName, uiEmail, uiReputation }; UserInfo uInfo; // as before … auto val = std::get&lt;static_cast&lt;std::size_t&gt;(UserInfoFields::uiEmail)&gt; (uInfo); Item 11:Prefer deleted functions to private undefined ones.我们都知道，如果你写的代码不想别人使用，你可以将它声明为private，但在C++11以后，建议使用delete而不是private。delete的用法有三类： （1）在类中防止某些函数调用 比如说，我们要防止拷贝istream和ostream。因为要进行哪些操作是模棱两可的。比如一个istream对象，代表一个输入值的流，流中有一些已经被读取，有一些可能马上要被读取。解决这个问题最好的方法是不定义这个操作。直接禁止拷贝流。 在98中是这样写的： template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt; class basic_ios : public ios_base { public: … private: basic_ios(const basic_ios&amp; ); // not defined basic_ios&amp; operator=(const basic_ios&amp;); // not defined }; 在11中可以改为： template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt; class basic_ios : public ios_base { public: … basic_ios(const basic_ios&amp; ) = delete; basic_ios&amp; operator=(const basic_ios&amp;) = delete; … }; deleted函数不能以任何方式被调用，即使你在成员函数或者友元函数里面调用deleted函数也不能通过编译。 需要注意的是：deleted函数被声明为public而不是private。这也是有原因的。当客户端代码试图调用成员函数，C++会在检查deleted状态前检查它的访问性。当客户端代码调用一个私有的deleted函数，一些编译器只会给出该函数是private的错误。 （2）作用于非成员函数禁止调用 bool isLucky(int number); C++有沉重的C包袱，使得含糊的、能被视作数值的任何类型都能隐式转换为int，但是有一些调用可能是没有意义的： 如果我们想幸运数必须是整数，就应该禁止通过这些编译： bool isLucky(int number); // 原始版本 bool isLucky(char) = delete; // 拒绝char bool isLucky(bool) = delete; // 拒绝bool bool isLucky(double) = delete; // 拒绝float和double （3）禁止一些模板实例化 在指针的世界里有两种特殊情况。一是void*指针，因为没办法对它们进行解引用，或者加加减减等。另一种指针是char*，因为它们通常代表C风格的字符串，而不是正常意义下指向单个字符的指针。这两种情况要特殊处理，在processPointer模板里面，我们假设正确的函数应该拒绝这些类型。 template&lt;&gt; void processPointer&lt;void&gt;(void*) = delete; template&lt;&gt; void processPointer&lt;char&gt;(char*) = delete;","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"EffectiveModernCPP笔记2-auto的使用","slug":"EffectiveModernCPP笔记2-auto的使用","date":"2019-10-26T01:36:38.000Z","updated":"2019-12-30T21:01:14.000Z","comments":true,"path":"2019/10/26/EffectiveModernCPP笔记2-auto的使用/","link":"","permalink":"jiangren.work/2019/10/26/EffectiveModernCPP%E7%AC%94%E8%AE%B02-auto%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"变量声明的注意事项。","text":"变量声明的注意事项。 Item 5:Prefer auto to explicit type declarations这一条条款全篇都在强调：为什么我们更青睐使用auto而不是显示类型声明。总得来说，好处有四个： （1）避免潜在未初始化变量的出现 在C++中有可能因为定义了变量却没有初始化导致错误的结果。而且编译器也不报错。 int x1; //不报错，但潜在的未初始化的变量 auto x2; //错误！必须要初始化 auto x3=0; //没问题，x已经定义了 （2）省略冗长的声明类型 std::map&lt;int,int&gt;::iterator it=mymap.begin(); //复杂 auto it=mymap.begin(); //简单 （3）直接保存闭包 所谓闭包通俗点说就是指lambda表达式、重载运算符、bind表达式。 自从C++11后，我们可以用auto来存储lambda表达式： auto derefUPLess = [](const std::unique_ptr&lt;Widget&gt; &amp;p1,const std::unique_ptr&lt;Widget&gt; &amp;p2) { return *p1&lt;*p2; };//专用于Widget类型的比较函数 在C++14，lambda表达式也可以使用auto： auto derefUPLess = [](const auto&amp; p1,const auto&amp; p2) { return *p1&lt;*p2; }; 上述例子中，我们使用auto来保存这个闭包(lambda表达式)。如果不使用auto就必须使用std::function！ std::function是一个C++11标准模板库中的一个模板，它泛化了函数指针的概念。与函数指针只能指向函数不同，std::function可以指向任何可调用对象，也就是那些像函数一样能进行调用的东西。当你声明函数指针时你必须指定函数类型（即函数签名），同样当你创建std::function对象时你也需要提供函数签名 bool(const std::unique_ptr&lt;Widget&gt; &amp;p1, const std::unique_ptr&lt;Widget&gt; &amp;p2); 就需要使用std::function这么写： std::function&lt;bool(const std::unique_ptr&lt;Widget&gt; &amp;p1, const std::unique_ptr&lt;Widget&gt; &amp;p2)&gt; func; 如果不用auto，上面那么大一坨东西十分繁琐！ （4）避免类型不匹配 这里举两个常见的错误，他们都可以被auto很友好的规避。 错误1：误以为std::vector::size_type就是unsigned。 std::vector&lt;int&gt; v; unsigned sz = v.size(); 在Windows 32-bit上std::vector::size_type和unsigned int都是一样的类型，但是在Windows 64-bit上std::vector::size_type是64位，unsigned int是32位。这意味着这段代码在Windows 32-bit上正常工作，但是当把应用程序移植到Windows 64-bit上时就可能会出现一些问题。 错误2：std::unordered_map的key是一个常量 std::unordered_map&lt;std::string,int&gt; m; ... for(const std::pair&lt;std::string,int&gt;&amp; p : m) { ... } 由于是常量，所以上面的调用应该改为std::pair Item 6:Use the explicitly typed initializer idiom when auto deduces undesired types.auto推断也存在一些问题。 现在有一个函数feature，传入一个vector数组，比较每个元素正负，然后返回vector std::vector&lt;bool&gt; features(vector&lt;int&gt; nums) { vector&lt;bool&gt; res; for (auto x : nums) res.push_back(x &gt; 0 ? true:false); return res; } 现在我想返回数组容器的第5个元素的正负情况，我这么来调用： auto negative4 = features(nums)[4]; 当把鼠标移到negative4上查看类型时，结果…. vector的operator[]的返回值并不是bool类型却变为了std::vector::reference，这样的话，后面的调用一定会出现奇奇怪怪的问题，这是怎么回事呢？ 因为bool占用一个字节，标准库为了节省内存，改用bit来表示 因为operator[]需要返回一个内部元素的引用，但是没办法对一个bit进行引用 为了让返回的类型统一，无论是bool类型，还是其它类型 此标准库为了实现上述三个目标就封装了一个内部的类型vector::reference，是一个proxy类(代理类)。其实这个问题指针对于bool类型，如果是实数类型，不会受到任何影响！ 解决的办法是调用显式类型初始器！通过强制转化达成目的。 auto negative4 = static_cast&lt;bool&gt;(features(nums)[4]);","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"EffectiveModernCPP笔记1-类型推断","slug":"EffectiveModernCPP笔记1-类型推断","date":"2019-10-24T05:06:44.000Z","updated":"2019-12-30T21:00:29.000Z","comments":true,"path":"2019/10/24/EffectiveModernCPP笔记1-类型推断/","link":"","permalink":"jiangren.work/2019/10/24/EffectiveModernCPP%E7%AC%94%E8%AE%B01-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/","excerpt":"主要关于类型推断的一些条款。","text":"主要关于类型推断的一些条款。 Item 1:Understand template type deduction在模板的使用过程中，我们需要区分两个类型T和Paramtype。T是基本类型，paramtype是包含CV修饰后的结果。 template&lt;typename T&gt; void f(const T&amp; param); int expr = 0; f(expr); 解释一下param type是param最后的类型 下面就围绕T, expr, param type展开讨论： （1）Case 1:ParamType is a Reference or Pointer, but not a Universal Reference 当param type是引用或者指针类型时，它的推断遵从两个原则： 忽略expr中param type包含的部分得到T 将T与param type配对的到param template&lt;typename T&gt; void f(T&amp; param); // param is a reference int x = 27; // x is an int const int cx = x; // cx is a const int const int&amp; rx = x; // rx is a reference to x as a const int f(x); // T is int, param&#39;s type is int&amp; f(cx); // T is const int, // param&#39;s type is const int&amp; f(rx); // T is const int, // param&#39;s type is const int&amp; ////////////////////////////// template&lt;typename T&gt; void f(const T&amp; param); // param is now a ref-to-const int x = 27; // as before const int cx = x; // as before const int&amp; rx = x; // as before f(x); // T is int, param&#39;s type is const int&amp; f(cx); // T is int, param&#39;s type is const int&amp; f(rx); // T is int, param&#39;s type is const int&amp; //////////////////////////////////// //指针也适用这个原则 template&lt;typename T&gt; void f(T* param); // param is now a pointer int x = 27; // as before const int *px = &amp;x; // px is a ptr to x as a const int f(&amp;x); // T is int, param&#39;s type is int* f(px); // T is const int, // param&#39;s type is const int* （2）Case 2: ParamType is a Universal Reference 当考虑全局引用(universal reference, T&amp;&amp;)的时候，情况会变得有些不一样。他遵循两个原则： 如果expr是左值，T和param都被推为左值引用(不管有没有统统加上引用符) 如果是右值，T不变，param加上&amp;&amp;。 template&lt;typename T&gt; void f(T&amp;&amp; param); // param is now a universal reference int x = 27; // as before const int cx = x; // as before const int&amp; rx = x; // as before f(x); // x is lvalue, so T is int&amp;, // param&#39;s type is also int&amp; f(cx); // cx is lvalue, so T is const int&amp;, // param&#39;s type is also const int&amp; f(rx); // rx is lvalue, so T is const int&amp;, // param&#39;s type is also const int&amp; f(27); // 27 is rvalue, so T is int, // param&#39;s type is therefore int&amp;&amp; （3）case3: ParamType is Neither a Pointer nor a Reference 这就是最基本的值传递。意味着，param复制了一个传入的参数。 template&lt;typename T&gt; void f(T param); // param is now passed by value 如果expr是引用，忽略引用的部分 如果忽略引用后，expr是const类型或volatile类型，忽略。 int x = 27; // as before const int cx = x; // as before const int&amp; rx = x; // as before f(x); // T&#39;s and param&#39;s types are both int f(cx); // T&#39;s and param&#39;s types are again both int f(rx); // T&#39;s and param&#39;s types are still both int 注意：只是忽略引用，指针还是不变。 template&lt;typename T&gt; void f(T param); // param is still passed by value const char* const ptr =&quot;Fun with pointers&quot;; // ptr is const pointer to const object f(ptr); // pass arg of type const char * const const int theAnswer = 42; auto x = theAnswer; auto y = &amp;theAnswer; // const int* 取引用相当于转成了指针 首先要澄清一个误区：数组类型和指针类型是完全不一样的(虽然他们在使用时可以混用)。由于C语言老祖宗的继承关系，C++依然保留了这些特性，导致很多人误以为数组和指针参数是一样的。 在传递过程中，数组会退化为它第一个元素的指针。注意，这里是退化。 template&lt;typename T&gt; void f(T param); // template with by-value parameter const char name[] = &quot;J. P. Briggs&quot;; // name&#39;s type is const char[13] f(name); // name is array, but T deduced as const char* 这种退化导致有用的信息(数组长度)丢失。然而声明引用，可以使得模板推断保留成数组的形式： template&lt;typename T&gt; void f(T&amp; param); f(name); //deduce to const char[13] 根据原则：忽略paramtype包含的部分T，T加上包含的部分得到param。在这个例子中T被推导为const char[13]，param则被推导为const char(&amp;)[13]。 如果改为T&amp;&amp;，根据原则：统统推导为左值引用。则T和param都被推为const char(&amp;)[13] 利用这一特性，我们在对模板函数声明为一个指向数组的引用使得我们可以在模板函数中推导出数组的大小： template&lt;typename T, std::size_t N&gt; constexpr std::size_t arraySize(T (&amp;)[N]) noexcept { return N; } 关键词constexpr能够让结果在编译时有效，从而实现以下的效果： int keyVals[] = { 1, 3, 7, 9, 11, 22, 35 }; // keyVals has 7 elements int mappedVals[arraySize(keyVals)]; 讲完数组，再来讲讲函数。在C++中不止是数组会退化为指针，函数类型也会退化为一个函数指针，我们对于数组的全部讨论都可以应用到函数来： void someFunc(int, double); // someFunc is a function; // type is void(int, double) template&lt;typename T&gt; void f1(T param); // in f1, param passed by value template&lt;typename T&gt; void f2(T&amp; param); // in f2, param passed by ref f1(someFunc); // param deduced as ptr-to-func; // type is void (*)(int, double) f2(someFunc); // param deduced as ref-to-func; // type is void (&amp;)(int, double) Item 2:Understand auto type deduction.auto推断和模板推断具有清晰的映射关系，也分为3+1种情况： （1） 参数类型为指针或引用，但不是universal reference int x=7; auto&amp; rx = x; //rx is int &amp; int&amp; z = x; const auto&amp; rx = z; // rx is const int&amp; （2）参数类型为universal reference auto x = 7; const int cx = 7; auto &amp;&amp;uref1 = x; // uref1的类型为int &amp; auto &amp;&amp;uref2 = cx; // uref2的类型为const int &amp; auto &amp;&amp;uref3 = 27; // uref3的类型为int &amp;&amp; （3）参数类型为pass-by-value auto x = 7; // x is int const int&amp; y=10; auto rx = y; // rx is int Tips: 我们在使用for-auto语句时，以下两种情况完全不同，一个可以改变原有的值一个不能。原因就是auto&amp;把x推断为 int&amp; for(auto x:nums) for(auto&amp; x:nums) （4） 数组和函数 const char name[] = [...] // name&#39;s type is const char[13] &quot;R. N. Briggs&quot;; auto arr1 = name; // arr1&#39;s type is const char* auto&amp; arr2 = name; // arr2&#39;s type is const char (&amp;)[13] void someFunc(int, double); // someFunc is a function; // type is void(int, double) auto func1 = someFunc; // func1&#39;s type is // void (*)(int, double) auto&amp; func2 = someFunc; // func2&#39;s type is // void (&amp;)(int, double) 下面来说说auto和模板推断不一样的地方： 在C++中auto初始化有四种方式： auto x1 = 27; auto x2(27); auto x3 = { 27 }; auto x4{ 27 }; 前两个会被推导为int类型，后两个则是std::initial izer_list。这是因为当auto遇到花括号时会做自动转化，因此，以下情况是不允许的： auto x5 = { 1, 2, 3.0 }; // error! 与模板推断不同的地方如下： auto x = { 11, 23, 9 }; // x&#39;s type is std::initializer_list&lt;int&gt; template&lt;typename T&gt; f({ 11, 23, 9 }); // error! can&#39;t deduce type for T 如果我们改一下： template&lt;typename T&gt; void f(std::initializer_list&lt;T&gt; initList); f({ 11, 23, 9 }); // T deduced as int, and initList&#39;s type is std::initializer_list&lt;int&gt; 值得注意的是C++14允许auto用于函数返回值并会被推导（参见Item3），而且C++14的lambda函数也允许在形参中使用auto。在表面上使用的是auto但是实际上是模板类型推导的那一套规则在工作，所以说下面这样的代码不会通过编译： auto createInitList() { return {1,2,3}; //错误！ } Item 3:Understand Decltype.decltype不像是auto和模板推断那样有着很多奇奇怪怪的限制。它，简单直观，是什么类型就一定返回什么类型。举一些例子： const int i = 0; // decltype(i) is const int bool f(const Widget&amp; w); // decltype(w) is const Widget&amp; // decltype(f) is bool(const Widget&amp;) Widget w; // decltype(w) is Widget if (f(w)) … // decltype(f(w)) is bool vector&lt;int&gt; v; // decltype(v) is vector&lt;int&gt; if (v[0] == 0) // decltype(v[0]) is int&amp; 在C++11中decltype结合auto还可以完成函数返回值的类型推导。 template&lt;typename Container,typename Index&gt; auto AccessContainer(Container&amp; c,Index i) -&gt; decltype(c[i]) { return c[i]; } 到了C++14的时候就可以省略掉后面的-&gt; decltype(c[i])了，变成下面的样子。 template&lt;typename Container,typename Index&gt; auto AccessContainer(Container&amp; c,Index i) { return c[i]; } 更高级的可以改为如下形式。它的作用原理是：auto声明表示“我要进行推断了”，而decltype则表示“auto你听我说，必须按照我decltype的方法推断（原封不动）” template&lt;typename Container,typename Index&gt; decltype(auto) AccessContainer(Container&amp; c,Index i) { return c[i]; } 通过decltype保证返回变量的本来类型这一特性，保证不丢失CV限制符，和引用等，因此在C++14中可以通过decltype和auto来声明变量，保证变量的类型和赋值的类型一模一样。 const int&amp; cw = 10; auto autoia = cw; //推导出的类型是int，引用和CV限制符都会忽略 decltype(auto) deautoia = cw; //const int&amp; 保证和cw的类型一模一样 上面的方案通过decltype和auto让返回值的类型变的完美，但是如果用户传入一个const的容器，将会导致编译出错。因为AccessContainer的参数类型是非常量引用，为了让他可以接收常量和非常量。 template&lt;typename Container,typename Index&gt; decltype(auto) AccessContainer(const Container&amp; c,Index i) { return c[i]; } 这带来的另外一个问题就是，c[i]，返回的是常量引用，无法修改。好在C++11中引入了右值引用，它可以接收左值，右值还有带const的。 template&lt;typename Container,typename Index&gt; decltype(auto) AccessContainer(Container&amp;&amp; c,Index i) { return c[i]; } 由于传入后，会把c的原本的形式给整没，也就是说：如果用户传入的是一个右值，通过移动语义传递给了AccessContainer的参数c，c变成了一个左值，如果在AccessContainer中需要把c再次传递给其他的函数的话就不能再次利用右值的移动语义了，带来了不必要的拷贝开销。那么就需要用到完美转发。 template&lt;typename Container,typename Index&gt; decltype(auto) AccessContainer(Container&amp;&amp; c,Index i) { return std::forward&lt;Container&gt;(c)[i]; } Item 4:Know how to view deduced types.这一节主要针对实际问题做讨论，做一下简化，只讨论可能用得到的。 查看类型推导最简单的方法就是在IDE里面，把鼠标移到变量上查看。大部分情况下是很好用的，但不能适用于很复杂的情况。 如果要在运行时推断，有两种方法： （1）typeid的应用。简单明了，但忽略了CV限定符和引用 #include &lt;typeinfo&gt; const int&amp; m = 10; std::cout &lt;&lt; typeid(decltype(m)).name() &lt;&lt; std::endl; //输出int （2）boost库函数。能准确提取结果，但需要额外安装boost库。windows安装方法 void f(const T&amp; param) { using std::cout; using boost::typeindex::type_id_with_cvr; cout &lt;&lt; &quot;param = &quot; &lt;&lt; type_id_with_cvr&lt;T&gt;().pretty_name() &lt;&lt; &#39;\\n&#39;; cout &lt;&lt; &quot;param = &quot; &lt;&lt; type_id_with_cvr&lt;decltype(param)&gt;().pretty_name() &lt;&lt; &#39;\\n&#39;; } const int&amp; m = 10; f(m); //output: param = int param = int const &amp; __ptr64","categories":[{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"鱼眼镜头模型","slug":"鱼眼镜头模型","date":"2019-09-13T07:31:27.000Z","updated":"2019-12-30T21:48:38.000Z","comments":true,"path":"2019/09/13/鱼眼镜头模型/","link":"","permalink":"jiangren.work/2019/09/13/%E9%B1%BC%E7%9C%BC%E9%95%9C%E5%A4%B4%E6%A8%A1%E5%9E%8B/","excerpt":"详细讲解鱼眼镜头的成像原理。","text":"详细讲解鱼眼镜头的成像原理。 1. 鱼眼镜头原理常见的相机模型是小孔模型，但小孔模型的视场比较小，即使采用超广角镜头视场也大概只有150°，很难做到全覆盖。因此人们利用鱼眼的特性发明了鱼眼镜头，能够达到接近180°的视场。 如图所示，小孔模型对于180°视场，只能将一部分投影到平面上，剩余的一小部分被截去了。 在自然界中，鱼眼能够通过水的折射，将光线压缩到一个锥形内 在这个锥形内部有一部分来自水面上方，有一部分来自水面下方，水面上方的所有景物都被压缩到了一个圈内，这就是斯涅耳窗口 如果这样拍一张照片，就可以在一个合理的照片大小范围内，记录整个水面上的半球空间内的景象。有效的视角范围接近 180°，远远超过普通超广角镜头记录的范围。鱼眼镜头与这个场景类似，也是把很大角度范围内的光线进行「压缩」和「扭曲」，压进一个相对较小的空间内，从而可以被相机所记录下来。 2. 鱼眼镜头模型鱼眼镜头由一系列复杂的透镜组成，前两个透镜负责大力折射光线，后面的镜头负责成像。 鱼眼相机成像时遵循的模型可以近似为单位球面投影模型。可以将鱼眼相机的成像过程分解成两步： 三维空间点线性地投影到一个球面上，它是一个虚拟的单位球面，它的球心与相机坐标系的原点重合 单位球面上的点投影到图像平面上，这个过程是非线性的 从球面投影到CCD平面的模型有很多种 等距投影 $r_d = f \\theta$ 等立体角投影 $r_d = 2fsin(\\frac{\\theta}{2})$ 正交投影 $r_d = fsin( \\theta)$ 体视投影 $r_d = 2ftan(\\frac{\\theta}{2})$ 3. Opencv中的鱼眼相机模型由于投影方式多种多样，我们可以对其采用近似方法将其统一。观察可以发现，$\\sin,\\tan$的泰勒展开都是奇次项形式，取前5项可得即： r_d =f\\theta _d \\\\\\theta_d= k_0\\theta + k_1 \\theta^3 + k_2 \\theta^5 + k_3 \\theta^7 + k_4 \\theta^9从空间点到鱼眼图像上的点的变换过程可用式子表示为： \\left[ \\begin{array}{c} X_c \\\\ Y_c \\\\ Z_c \\end{array} \\right]=RX+t\\\\ x_c = \\frac{X_c}{Z_c},\\ y_c=\\frac{Y_c}{Z_c}\\\\ r^2 = x^2_c + y^2_c\\\\ \\theta = arctan(r)\\\\ \\theta _d = k_0\\theta + k_1 \\theta^3 + k_2 \\theta^5 + k_3 \\theta^7 + k_4 \\theta^9\\\\ x_d=\\frac{\\theta_d}{r}x_c, \\ y_d=\\frac{\\theta_d}{r}y_c\\\\ u=f_xx_d+c_x, \\ v=f_yy_d+c_y","categories":[{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}]},{"title":"Leetcode题目总结11-其他","slug":"Leetcode题目总结11-其他","date":"2019-09-07T09:33:36.000Z","updated":"2020-03-28T01:41:50.000Z","comments":true,"path":"2019/09/07/Leetcode题目总结11-其他/","link":"","permalink":"jiangren.work/2019/09/07/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%9311-%E5%85%B6%E4%BB%96/","excerpt":"有些题目不好分类就放到其他里面了。主要包含了树的构造和遍历、二维数组的一些内容。","text":"有些题目不好分类就放到其他里面了。主要包含了树的构造和遍历、二维数组的一些内容。 1. 树的构造和遍历144 二叉树的前序遍历非递归： vector&lt;int&gt; preorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; stk; vector&lt;int&gt; data; while (root||!stk.empty()) { if (root) { data.push_back(root-&gt;val); stk.push(root); root = root-&gt;left; } else { root = stk.top(); //中序就把push_back写在这里 stk.pop(); root = root-&gt;right; } } return data; } 递归： 注意递归前要先判断是否存在。 vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; data; if(!root) return data; recursive(data,root); return data; } void recursive(vector&lt;int&gt;&amp; data,TreeNode* root) { data.push_back(root-&gt;val); if(root-&gt;left) recursive(data,root-&gt;left); if(root-&gt;right) recursive(data,root-&gt;right); } 094 二叉树的中序遍历vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; data; stack&lt;TreeNode*&gt; stk; if(!root) return data; while(root||!stk.empty()) { if(root) { stk.push(root); root=root-&gt;left; } else { root=stk.top(); data.push_back(root-&gt;val); stk.pop(); root=root-&gt;right; } } return data; } 145 二叉树的后序遍历因为前面两道题前序和中序分别占据了if-else的其中一个，所以后序没得用了。换种思路：前序遍历是：中-左-右，而后序是左-右-中，它是中-右-左的逆过程， 在前序遍历中我们将data.push_back()塞到了if(root)中，在这里我们只需要将容器栈放到这里即可。 vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; data; if(!root) return data; stack&lt;TreeNode*&gt; stk; while(root||!stk.empty()){ if(root){ data.push_back(root-&gt;val); stk.push(root); root=root-&gt;right; }else{ root=stk.top(); stk.pop(); root=root-&gt;left; } } reverse(data.begin(),data.end()); return data; } 105 从前序与中序遍历构造二叉树前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 3 / \\ 9 20 / \\ 15 7 解答： 前序的第一个一定是root，假设位置为prei，找到其在中序的位置midi。此时中序左边是左子树所有的部分，右边是右子树所有的部分。那么左子节点就是prei+1，右子节点计算方法是：跳过所有左子树，下一个就是右子节点，prei+(midi-inorder_start)+1 TreeNode* generate(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int inorder_start, int inorder_end, int pre_root_index) { if (inorder_start == inorder_end) return new TreeNode(preorder[pre_root_index]); if (inorder_start &gt; inorder_end) return NULL; //叶子节点 int value = preorder[pre_root_index]; TreeNode* root = new TreeNode(value); int i = 0; for (; i &lt; inorder.size(); i++) { if (inorder[i] == value) break; } root-&gt;left = generate(preorder, inorder, inorder_start, i - 1, pre_root_index + 1); root-&gt;right = generate(preorder, inorder, i + 1, inorder_end, pre_root_index + (i- inorder_start+1)); return root; } 106 从中序与后序遍历构造二叉树中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 3 / \\ 9 20 / \\ 15 7 解答： TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { return fun(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1); } TreeNode* fun(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pre_start, int pre_end, int in_start, int in_end) { if (pre_start &gt; pre_end) { return NULL; } int pre_first_result = preorder[pre_start]; int root_position = in_start; for (; root_position &lt; in_end; root_position++) { if (inorder[root_position] == pre_first_result) { break; } } TreeNode* node = new TreeNode(pre_first_result); int left_length = root_position - in_start; int right_length = in_end - root_position; node-&gt;left = fun(preorder, inorder, pre_start + 1, pre_start + left_length, in_start, root_position - 1); node-&gt;right = fun(preorder, inorder, pre_end - right_length + 1, pre_end, root_position + 1, in_end); return node; } 2. 二维数组036 有效的数独判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 解答： bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { vector&lt;set&lt;int&gt;&gt; rows(9); vector&lt;set&lt;int&gt;&gt; cols(9); vector&lt;set&lt;int&gt;&gt; cell(9); for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++) { if(board[i][j]==&#39;.&#39;) continue; int val = board[i][j]-&#39;0&#39;; if(!rows[i].count(val)) rows[i].insert(val); else return false; if(!cols[j].count(val)) cols[j].insert(val); else return false; int index = cell_index(i,j); if(!cell[index].count(val)) cell[index].insert(val); else return false; } return true; } int cell_index(int i,int j) { return i/3+3*(j/3); } 048 旋转图像给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 解答： 先沿副对角线交换，再沿中间水平线交换 void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if (matrix.size() == 0) return; int n = matrix.size(); //沿副对角线交换 for(int i=0;i&lt;n;i++) for (int j = 0; j &lt; n-i; j++) { int tmp = matrix[i][j]; //n-1-j表示间隔距离，调换一下ij的间隔距离即可达到副对角线 matrix[i][j] = matrix[n - 1 - j][n - 1 - i]; matrix[n - 1 - j][n - 1 - i]=tmp; } for(int i=0;i&lt;n/2;i++) for (int j = 0; j &lt; n; j++) { int tmp = matrix[i][j]; matrix[i][j] = matrix[n - 1 - i][j]; matrix[n - 1 - i][j] = tmp; } } 054 旋转矩阵题目： 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例： 输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,3,6,9,8,7,4,5] 解答： vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { vector&lt;int&gt; res; if (matrix.size() == 0) return res; int len1 = matrix.size(); int len2 = matrix[0].size(); int right = matrix[0].size() - 1; int left = 0; int up = 1; int down = matrix.size() - 1; int row = 0, col = 0, k = 0; int dir[4][4] = { {1,0,-1,0} ,{0,1,0,-1} };//列行 for (int i = 0; i &lt; len1 * len2; i++) { res.push_back(matrix[row][col]); row += dir[1][k % 4]; col += dir[0][k%4]; switch (k % 4) { case 0: if (col &gt; right) { col = right; row++; right--; k++;//转向 } break; case 1: if (row &gt; down) { row = down; col--; down--; k++; } break; case 2: if (col &lt; left) { col = left; row--; left++; k++; } break; case 3: if (row &lt; up) { row = up; col++; up++; k++; } break; } } return res; } 059 旋转矩阵 II题目： 给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例： 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] 解答： vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n){ vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); if (n== 0) return res; int len1 = n; int len2 = n; int right = n - 1; int left = 0; int up = 1; int down = n - 1; int row = 0, col = 0, k = 0; int dir[4][4] = { {1,0,-1,0} ,{0,1,0,-1} };//列行 for (int i = 0; i &lt; len1 * len2; i++) { res[row][col] = i + 1; row += dir[1][k % 4]; col += dir[0][k % 4]; switch (k % 4) { case 0: if (col &gt; right) { col = right; row++; right--; k++;//转向 } break; case 1: if (row &gt; down) { row = down; col--; down--; k++; } break; case 2: if (col &lt; left) { col = left; row--; left++; k++; } break; case 3: if (row &lt; up) { row = up; col++; up++; k++; } break; } } return res; } 073 矩阵置零题目： 给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 输入: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] 输出: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] 解答： 为了能使空间为$O(1)$，我们就不能令设参数来记录哪些行列应该为0，解决办法是用边界来记录。 void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { bool row = false, col = false; int m = matrix.size(), n = matrix[0].size(); for (int i = 0; i &lt; m; ++i) { if (matrix[i][0] == 0) col = true; } for (int i = 0; i &lt; n; ++i) { if (matrix[0][i] == 0) row = true; } for (int i = 1; i &lt; m; ++i) for (int j = 1; j &lt; n; ++j) { if (matrix[i][j] == 0) matrix[i][0] = 0, matrix[0][j] = 0; } for (int i = 1; i &lt; m; ++i) for (int j = 1; j &lt; n; ++j) { if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0; } if (col) { for (int i = 0; i &lt; m; ++i) matrix[i][0] = 0; } if (row) { for (int i = 0; i &lt; n; ++i) matrix[0][i] = 0; } } 3. 其他56 合并区间给出一个区间的集合，请合并所有重叠的区间。 输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 解答： vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { vector&lt;vector&lt;int&gt;&gt; res; if(intervals.size()==0||intervals[0].size()==0) return res; auto lambda = [](vector&lt;int&gt;&amp; vec1,vector&lt;int&gt;&amp; vec2) { return vec1[0] &lt; vec2[0]; }; sort(intervals.begin(), intervals.end(), lambda); res.push_back(intervals[0]); for(int i=1;i&lt;intervals.size();++i){ if(res.back()[1]&gt;=intervals[i][0]){ res.back()[1]=max(res.back()[1],intervals[i][1]); }else{ res.push_back(intervals[i]); } } return res; } 59 螺旋矩阵II给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] 解答： vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { if(n==0) return {{}}; vector&lt;vector&lt;int&gt; &gt; res(n,vector&lt;int&gt;(n,0)); int down=0,up=n-1,left=0,right=n-1; int itm=1; while(left&lt;=right &amp;&amp; down&lt;=up){ for(int i=left;i&lt;=right;i++) res[down][i]=itm++; for(int i=down+1;i&lt;=up;i++) res[i][right]=itm++; for(int i=right-1;i&gt;=left;i--) res[up][i]=itm++; for(int i=up-1;i&gt;=down+1;i--) res[i][left]=itm++; down++; up--; left++; right--; } return res; }","categories":[{"name":"算法","slug":"算法","permalink":"jiangren.work/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"jiangren.work/tags/Leetcode/"},{"name":"数据结构","slug":"数据结构","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Leetcode题目总结10-链表","slug":"Leetcode题目总结10-链表","date":"2019-09-06T04:24:31.000Z","updated":"2020-03-28T02:11:25.000Z","comments":true,"path":"2019/09/06/Leetcode题目总结10-链表/","link":"","permalink":"jiangren.work/2019/09/06/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%9310-%E9%93%BE%E8%A1%A8/","excerpt":"链表真的太重要了，本文的行文结构按照链表类题目的两大解法分类：虚拟节点、快慢指针。","text":"链表真的太重要了，本文的行文结构按照链表类题目的两大解法分类：虚拟节点、快慢指针。 1. 虚拟节点虚拟节点有两个作用： 保护head，便于返回 用于节点交换的引导 002 两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 解答： 需要运用加法进位的技术，具体参考数学那一篇中讲解。也需要用到虚拟节点的办法。注意虚拟节点的next ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { if(l1==nullptr||l2==nullptr) return nullptr; ListNode* index=new ListNode(0); ListNode* pre=index; int carry=0; while(l1!=nullptr||l2!=nullptr){ int sum=carry; carry=0; if(l1!=nullptr){ sum+=l1-&gt;val; l1=l1-&gt;next; } if(l2!=nullptr){ sum+=l2-&gt;val; l2=l2-&gt;next; } if(sum&gt;=10){ carry=sum/10; sum=sum%10; } ListNode* node=new ListNode(sum); index-&gt;next=node; index=index-&gt;next; } if(carry!=0){ ListNode* node=new ListNode(carry); index-&gt;next=node; } return pre-&gt;next; } 021 合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解答： ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* pre=new ListNode(0); ListNode* cur=pre; while(l1&amp;&amp;l2) { if(l1-&gt;val&lt;l2-&gt;val) { cur-&gt;next=l1; cur=cur-&gt;next; l1=l1-&gt;next; } else { cur-&gt;next=l2; cur=cur-&gt;next; l2=l2-&gt;next; } } if(l1!=nullptr) cur-&gt;next=l1; if(l2!=nullptr) cur-&gt;next=l2; return pre-&gt;next; } 024 两两交换链表中的节点给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 解答： 注意，不能返回head，否则会变为1-4-3，应该先预设一个dummy来准备返回。 必须first&amp;&amp;first-&gt;next，针对上线的单数的情况。 ListNode* swapPairs(ListNode* head) { ListNode* pre=new ListNode(0); pre-&gt;next=head; ListNode* first = head; ListNode* dummy = pre; while(first&amp;&amp;first-&gt;next) { ListNode* last = first-&gt;next; first-&gt;next=last-&gt;next; last-&gt;next=first; pre-&gt;next=last; pre=first; first=first-&gt;next; } return dummy-&gt;next; } 083 删除排序链表中的重复元素给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3 输出: 1-&gt;2-&gt;3 解答： ListNode* deleteDuplicates(ListNode* head) { ListNode* pre=new ListNode(0); pre-&gt;next=head; ListNode* cur=head; while(cur) { ListNode* last=cur-&gt;next; while(last!=nullptr&amp;&amp;cur-&gt;val==last-&gt;val) { last=last-&gt;next; } cur-&gt;next=last; cur=cur-&gt;next; } return pre-&gt;next; } 082 删除排序链表中的重复元素 II给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 输出: 1-&gt;2-&gt;5 解答： 时刻要牢记three&amp;&amp;two-&gt;next-&gt;val==three-&gt;val，用之前要先判断是否为null！ ListNode* deleteDuplicates(ListNode* head) { ListNode* pre=new ListNode(0); pre-&gt;next=head; ListNode* one=pre; while(one-&gt;next&amp;&amp;one-&gt;next-&gt;next) { ListNode* two = one-&gt;next; ListNode* three = one-&gt;next-&gt;next; while(three&amp;&amp;two-&gt;val==three-&gt;val) { three=three-&gt;next; } if(three&amp;&amp;two-&gt;next-&gt;val==three-&gt;val)//没有重复 one=one-&gt;next; else one-&gt;next=three; } return pre-&gt;next; } 86 分隔链表给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 解答： ListNode* partition(ListNode* head, int x) { ListNode dummyHead1 = new ListNode(0); ListNode dummyHead2 = new ListNode(0); ListNode node1 = dummyHead1; ListNode node2 = dummyHead2; while(head){ if(head-&gt;val&lt;x){ node1-&gt;next=head; node1=node1-&gt;next; head=head-&gt;next; }else{ node2-&gt;next=head; node2=node2-&gt;next; head=head-&gt;next; } } node2-&gt;next=NULL; //防止自环 node1-&gt;next=dummyHead2.next; return dummyHead1.next; } 206 反转链表反转一个单链表。 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 解答： ListNode* reverseList(ListNode* head) { if(!head) return nullptr; ListNode* pre=new ListNode(0); pre-&gt;next=head; ListNode* cur=head; while(cur-&gt;next) { ListNode* last = cur-&gt;next; cur-&gt;next=last-&gt;next; last-&gt;next=pre-&gt;next; pre-&gt;next=last; } return pre-&gt;next; } 092 反转链表 II反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。说明: 1 ≤ m ≤ n ≤ 链表长度。 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 解答： pre一定要随动，所以需要一个dummy来返回 ListNode* reverseBetween(ListNode* head, int m, int n) { if(!head) return nullptr; ListNode* pre=new ListNode(0); pre-&gt;next=head; ListNode* dummy=pre; ListNode* cur=head; int flag=n-m; while(m!=1) { cur=cur-&gt;next; pre=pre-&gt;next; m--; } while(cur-&gt;next&amp;&amp;flag!=0) { ListNode* last = cur-&gt;next; cur-&gt;next=last-&gt;next; last-&gt;next=pre-&gt;next; pre-&gt;next=last; flag--; } return dummy-&gt;next; } 143 重排链表给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 解答： 将原来的链表全部塞入双端队列，然后从前后分别放出。 注意： while里面要双重判断 最后要处理一下屁股 void reorderList(ListNode* head) { //双端队列 if (head == NULL) return; deque&lt;ListNode*&gt; de; ListNode* pre = new ListNode(0); pre-&gt;next = head; ListNode* dummy = pre; while (dummy-&gt;next != NULL) { de.push_back(dummy-&gt;next); dummy = dummy-&gt;next; } while (1) { if (de.empty()) break; pre-&gt;next = de.front(); de.pop_front(); pre = pre-&gt;next; //再后，这里判断一下是不是空了 if (de.empty()) break; pre-&gt;next = de.back(); de.pop_back(); pre = pre-&gt;next; } //把屁股处理一下 pre-&gt;next = NULL; } 203 移除链表元素除链表中等于给定值 val 的所有节点。 输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6 输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 解答： ListNode* removeElements(ListNode* head, int val) { ListNode* pre = new ListNode(0); pre-&gt;next = head; ListNode* dummy = pre; while (pre-&gt;next != NULL) { if (pre-&gt;next-&gt;val == val) pre-&gt;next = pre-&gt;next-&gt;next; else pre = pre-&gt;next; } return dummy-&gt;next; } 2. 快慢指针019 删除链表的倒数第N个节点给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 解答： ListNode* removeNthFromEnd(ListNode* head, int n) { if (!head) return NULL; ListNode* pre=new ListNode(0); pre-&gt;next=head; ListNode* fast=pre; ListNode* slow=pre; for(int i=0;i&lt;n;i++) fast=fast-&gt;next; while(fast-&gt;next) { slow=slow-&gt;next; fast=fast-&gt;next; } //注意！！！ slow-&gt;next=slow-&gt;next-&gt;next; return pre-&gt;next; } 061 旋转链表给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 解释: 向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL 向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 解答： ListNode* rotateRight(ListNode* head, int k) { ListNode* pre = new ListNode(0); if (!head) return NULL; pre-&gt;next = head; ListNode* fast = pre; ListNode* slow = pre; int len = 0; while (fast-&gt;next != NULL) { fast = fast-&gt;next; len++; } int jump = len - (k % len); while (jump &gt; 0) { jump--; slow = slow-&gt;next; } // 输入: pre-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 // slow fast // 输出: pre-&gt;4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL*/ fast-&gt;next = pre-&gt;next; pre-&gt;next = slow-&gt;next; slow-&gt;next = NULL; return pre-&gt;next; } 109 有序链表转化为二叉搜索树给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 解答： public TreeNode sortedListToBST(ListNode head) { if(head == null) return null; else if(head.next == null) return new TreeNode(head.val); ListNode pre = head; ListNode p = pre.next; ListNode q = p.next; //找到链表的中点p while(q!=null &amp;&amp; q.next!=null){ pre = pre.next; p = pre.next; q = q.next.next; } //将中点左边的链表分开 pre.next = null; TreeNode root = new TreeNode(p.val); root.left = sortedListToBST(head); root.right = sortedListToBST(p.next); return root; } 141 环形链表给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 输入：head = [3,2,0,-4], pos = 1 输出：true 解答： bool hasCycle(ListNode* head) { ListNode* fast=head; ListNode* slow=head; while (fast != NULL &amp;&amp; fast-&gt;next != NULL) { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) return true; } return false; } 142 环形链表 II给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 输入：head = [3,2,0,-4], pos = 1 输出：tail connects to node index 1 解释：链表中有一个环，其尾部连接到第二个节点。 解答： ListNode *detectCycle(ListNode *head) { set&lt;ListNode*&gt; s; ListNode* index=head; while(index) { if(!s.count(index)) { s.insert(index); index=index-&gt;next; } else return index; } return nullptr; } 148 排序链表在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0 输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解答： 归并排序 //[ivan_allen]https://leetcode-cn.com/problems/sort-list/comments/ ListNode* sortList(ListNode* head) { ListNode* p = head; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; int len = 0; while (p) { len++; p = p-&gt;next; } for (int size = 1; size &lt; len; size = size &lt;&lt; 1) { ListNode* cur = dummy-&gt;next; ListNode* tail = dummy; while (cur) { auto left = cur; auto right = cut(left, size); cur = cut(right, size);//移动到下一个地方 tail-&gt;next = merge(left, right); while (tail-&gt;next) tail = tail-&gt;next; } } return dummy-&gt;next; } ListNode* cut(ListNode* head, int n) { ListNode* first = head; //--n！！！ while (--n &amp;&amp; first) { first = first-&gt;next; } if (!first) return nullptr; //second为第二链表开头，first为第一 ListNode* second = first-&gt;next; first-&gt;next = nullptr; return second; } ListNode* merge(ListNode* l1, ListNode* l2) { ListNode* pre = new ListNode(0); ListNode* dummy = pre; while (l1 &amp;&amp; l2) { int val1 = l1-&gt;val; int val2 = l2-&gt;val; if (val1 &gt; val2) { pre-&gt;next = l2; pre = l2; l2 = l2-&gt;next; } else { pre-&gt;next = l1; pre = l1; l1 = l1-&gt;next; } } if (l1) pre-&gt;next = l1; else pre-&gt;next = l2; return dummy-&gt;next; } 234 回文链表请判断一个链表是否为回文链表。 输入: 1-&gt;2-&gt;2-&gt;1 输出: true 解答： bool isPalindrome(ListNode* head) { ListNode* pre=new ListNode(0); pre-&gt;next=head; ListNode* fast=pre; ListNode* slow=pre; stack&lt;ListNode*&gt; stk; while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL) { slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; stk.push(slow); } //bool isEven=false; if(fast==NULL) stk.pop(); while(slow-&gt;next) { ListNode* cur=stk.top(); stk.pop(); if(cur-&gt;val!=slow-&gt;next-&gt;val) return false; slow=slow-&gt;next; } return true; } 3. 其他类型160 相交链表编写一个程序，找到两个单链表相交的起始节点。 题解： 一定要保证每个引导指针都能跑到NULL节点，即使两个不相干的链表也能将NULL视为相交节点！ ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) { ListNode* index1 = headA; ListNode* index2 = headB; if (index1 == NULL || index2 == NULL) return NULL; //如果长度相同没有交点，第一轮后同时为NULL，退出 //如果长度不同没有交点，第二轮后两者移动相同距离 //同时为NULL，退出 while (index1 != index2) { //必须写index1而不是index1-&gt;next，不然没法出NULL index1 = (index1 == NULL) ? headB : index1-&gt;next; index2 = (index2 == NULL) ? headA : index2-&gt;next; } return index1; } 237 删除链表中的节点请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 解答： node=node-&gt;next不行，要改为指针传递或引用传递。 void deleteNode(ListNode* node) { *node=*node-&gt;next; }","categories":[{"name":"算法","slug":"算法","permalink":"jiangren.work/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"jiangren.work/tags/Leetcode/"},{"name":"数据结构","slug":"数据结构","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Leetcode题目总结7-容器的应用","slug":"Leetcode题目总结7-容器的应用","date":"2019-09-05T03:23:21.000Z","updated":"2020-03-27T14:00:24.000Z","comments":true,"path":"2019/09/05/Leetcode题目总结7-容器的应用/","link":"","permalink":"jiangren.work/2019/09/05/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%937-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"1. 关联容器妙用STL中的容器能大大加快解题速度。","text":"1. 关联容器妙用STL中的容器能大大加快解题速度。 1. 关联容器关联容器指set和map，这两种容器都是有序的，依靠内部的红黑树维护。 001 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 解答： 注意： 不能排序，因为要返回下标序列，排序会打乱 这里需要用map记录而不是set，因为需要记录下标 对比一下167题输入的是有序数组，015三数之和要求返回的是数字组合而不是下标。 vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { map&lt;int,int&gt; m; vector&lt;int&gt; res{-1,-1}; if(nums.size()==0) return res; for(int i=0;i&lt;nums.size();i++) { int another = target - nums[i]; if(m.find(another)!=m.end()) { res[0]=m[another]; res[1]=i; } else m[nums[i]]=i; } return res; } 012 整数转罗马数字罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 输入: 1994 输出: &quot;MCMXCIV&quot; 解释: M = 1000, CM = 900, XC = 90, IV = 4. 解答： 遍历从M到I的所有罗马数字，遇到合适的就填进res中，同时num减少。 string intToRoman(int num) { vector&lt;pair&lt;int, string&gt;&gt; vec; vec.push_back(make_pair(1000, &quot;M&quot;)); vec.push_back(make_pair(900, &quot;CM&quot;)); vec.push_back(make_pair(500, &quot;D&quot;)); vec.push_back(make_pair(400, &quot;CD&quot;)); vec.push_back(make_pair(100, &quot;C&quot;)); vec.push_back(make_pair(90, &quot;XC&quot;)); vec.push_back(make_pair(50, &quot;L&quot;)); vec.push_back(make_pair(40, &quot;XL&quot;)); vec.push_back(make_pair(10, &quot;X&quot;)); vec.push_back(make_pair(9, &quot;IX&quot;)); vec.push_back(make_pair(5, &quot;V&quot;)); vec.push_back(make_pair(4, &quot;IV&quot;)); vec.push_back(make_pair(1, &quot;I&quot;)); //vec的顺序是从大到小 string res=&quot;&quot;; for(int i=0;i&lt;vec.size();i++) { //先尝试最大的 while(num&gt;=vec[i].first) { num-=vec[i].first; res+=vec[i].second; } } return res; } 013 罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 输入: &quot;LVIII&quot; 输出: 58 解释: L = 50, V= 5, III = 3. 解答： 转化规则：前一个数小于后一个数，则前一个数为负记入总数，反之为正记入总数。 int romanToInt(string s) { map&lt;char,int&gt; mymap; mymap.insert(make_pair(&#39;M&#39;,1000)); mymap.insert(make_pair(&#39;D&#39;, 500)); mymap.insert(make_pair(&#39;C&#39;, 100)); mymap.insert(make_pair(&#39;L&#39;, 50)); mymap.insert(make_pair(&#39;X&#39;, 10)); mymap.insert(make_pair(&#39;V&#39;, 5)); mymap.insert(make_pair(&#39;I&#39;, 1)); int res=0; if(s.size()==0) return 0; for(int i=0;i&lt;s.size()-1;i++) { if(mymap[s[i]]&lt;mymap[s[i+1]]) res-=mymap[s[i]]; else res+=mymap[s[i]]; } res+=mymap[s.back()]; return res; } 017 电话号码的字母组合给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 输入：&quot;23&quot; 输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 解答： 需要关注临时容器，依靠push的作用增添新元素。 vector&lt;string&gt; letterCombinations(string digits) { map&lt;char, string&gt; mp; mp[&#39;2&#39;] = { &quot;abc&quot; }; mp[&#39;3&#39;] = { &quot;def&quot; }; mp[&#39;4&#39;] = { &quot;ghi&quot; }; mp[&#39;5&#39;] = { &quot;jkl&quot; }; mp[&#39;6&#39;] = { &quot;mno&quot; }; mp[&#39;7&#39;] = { &quot;pqrs&quot; }; mp[&#39;8&#39;] = { &quot;tuv&quot; }; mp[&#39;9&#39;] = { &quot;wxyz&quot; }; vector&lt;string&gt; res; if (digits.size() == 0) return res; else res.push_back(&quot;&quot;); //一定要做这一步不然循环都进不去 for(auto digit:digits) { string letter = mp[digit]; //需要做一个临时容器，否则会污染 vector&lt;string&gt; tmp; for(auto oldstring:res) for(auto newletter:letter) tmp.push_back(oldstring+newletter); res=tmp; } return res; } 049 字母异位词分组给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;], 输出: [ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;] ] 解答： 如何判定是否异位相似：对每个字符串排序，将结果插入map中，最后再取出来。 vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { vector&lt;vector&lt;string&gt;&gt; res; map&lt;string,vector&lt;string&gt;&gt; m; if(strs.size()==0) return res; for(auto str:strs) { string tmp = str; sort(tmp.begin(),tmp.end()); m[tmp].push_back(str); } for(auto x:m) res.push_back(x.second); return res; } 138 复制带随机指针的链表给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 解答： 克隆每个节点需要干三件事：val, next, random，由于random的缘故我们需要一个map&lt;Node*,Node*&gt;来记录原来的节点和克隆节点的对应关系。 注意 必须m[NULL]=NULL 复制时，必须由origin_index在前开路 添加随机时，两者同行 添加随机时需要重置 Node* copyRandomList(Node* head) { //用map记录 if (!head) return NULL; Node* clone = new Node(head-&gt;val, NULL, NULL); Node* clone_index = clone; Node* origin_index = head; map&lt;Node*, Node*&gt; mp; mp[head] = clone; mp[NULL] = NULL; //!非常重要 //先不复制随机 while(origin_index-&gt;next){ Node* newNode=new Node(origin_index-&gt;next-&gt;val,NULL,NULL); clone_index-&gt;next=newNode; mp[origin_index-&gt;next]=newNode; clone_index=clone_index-&gt;next; origin_index=origin_index-&gt;next; } //添加随机 clone_index = clone; //重置 origin_index = head; while (clone_index) { clone_index-&gt;random = mp[origin_index-&gt;random]; clone_index = clone_index-&gt;next; origin_index = origin_index-&gt;next; } return clone; } 146 LRU缓存机制设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 解答： 数据结构的核心：List存数据，map记录某个数据在list中的位置，我们每次get和put都需要维护这两个数据结构。 无论是get还是put都需要先判断mp中是否已经存在！ 记住：优先考虑如何更新map，然后再是删除list操作 class LRUCache { private: //list参数：key，val list&lt;pair&lt;int, int&gt;&gt; l; //map参数：key，iterator(这个key在list中的顺序) map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; m; int cap; public: LRUCache(int capacity) { cap = capacity; } int get(int key) { //it返回的不是顺序，而是map的pair //it指向map中发现key的位置(一个pair,包含key和iterator) //it-&gt;second指向list的iterator //it-&gt;second-&gt;second指向val auto it = m.find(key); if (it == m.end()) return -1; //不能放到erase之后！！！！ int val = it-&gt;second-&gt;second; //更新list l.push_front(make_pair(key, val)); //更新map必须在l之后！！！！！ m[key] = l.begin(); l.erase(it-&gt;second); return it-&gt;second-&gt;second; } void put(int key, int value) { auto it = m.find(key); if (it != m.end()) //l的erase参数是iterator l.erase(it-&gt;second); l.push_front(make_pair(key, value)); m[key] = l.begin(); if (l.size() &gt; cap) { int key = l.back().first; //m的erase参数是key //擦去的时候map擦key，list擦iterator m.erase(key); l.pop_back(); } } }; 205 同构字符串给定两个字符串 s和 t，判断它们是否是同构的。如果s中的字符可以被替换得到 t ，那么这两个字符串是同构的。 输入: s = &quot;paper&quot;, t = &quot;title&quot; 输出: true 输入: s = &quot;foo&quot;, t = &quot;bar&quot; 输出: false 解答： 抽象为ABAC类型 bool isIsomorphic(string s, string t) { return abstract(s)==abstract(t); } string abstract(string str) { string tmp=str; int flag=0; map&lt;char,char&gt; m; for(int i=0;i&lt;str.size();i++) { if(m.find(str[i])==m.end()) { tmp[i]=&#39;a&#39;+flag; m[str[i]]=tmp[i]; flag++; } else tmp[i]=m[str[i]]; } return tmp; } 208 实现Trie(前缀树)实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 Trie trie = new Trie(); trie.insert(&quot;apple&quot;); trie.search(&quot;apple&quot;); // 返回 true trie.search(&quot;app&quot;); // 返回 false trie.startsWith(&quot;app&quot;); // 返回 true 解答： 注意打上leaf不表示这一脉真的结束了，而是表示从头到这个节点，在字典里有对应，方便search操作。 class Trie { public: struct TrieNode { map&lt;char,TrieNode*&gt; child; bool isLeaf; TrieNode():isLeaf(false){}; }; TrieNode* root; /** Initialize your data structure here. */ Trie() { root=new TrieNode(); } /** Inserts a word into the trie. */ void insert(string word) { TrieNode* cur = root; for(auto c:word) { auto it=cur-&gt;child.find(c); if(it==cur-&gt;child.end()) cur-&gt;child.insert(make_pair(c,new TrieNode())); cur=cur-&gt;child[c]; } cur-&gt;isLeaf=true; } /** Returns if the word is in the trie. */ bool search(string word) { TrieNode* cur = root; for(auto c:word) { auto it=cur-&gt;child.find(c); if(it==cur-&gt;child.end()) return false; cur=cur-&gt;child[c]; } return cur-&gt;isLeaf; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { TrieNode* cur = root; for(auto c:prefix) { auto it=cur-&gt;child.find(c); if(it==cur-&gt;child.end()) return false; cur=cur-&gt;child[c]; } return true; } }; 217 存在重复元素给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 输入: [1,2,3,1] 输出: true 解答： SET去重 bool containsDuplicate(vector&lt;int&gt;&amp; nums) { set&lt;int&gt; s; for(auto num:nums) s.insert(num); return s.size()!=nums.size(); } 219 存在重复元素 II给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且i和j的差的绝对值最大为k。 输入: nums = [1,2,3,1], k = 3 输出: true 解答： bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) { if(nums.size()==0||k==0) return false; map&lt;int,int&gt; m; for(int i=0;i&lt;nums.size();i++) { auto it = m.find(nums[i]); if(it==m.end()) m[nums[i]]=i; else { if(i-m[nums[i]]&lt;=k) return true; else m[nums[i]]=i; } } return false; } 220 存在重复元素 III给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i]和nums [j]的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 k。 输入: nums = [1,2,3,1], k = 3, t = 0 输出: true 解答： 这道题也可以按219的模板来做，但速度就很感人了。可以维护一个窗口，大小不超过k，滑动窗口比较nums的值是否满足要求。采用set来存储窗口的值。 bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) { set&lt;long long&gt; s; for (int i = 0, j = 0; i &lt; nums.size(); i++) { if (i - j &gt; k) { s.erase(nums[j]); j++; } auto it = s.lower_bound((long long)nums[i] - t);//有可能nums[i] - t是个负数 if (it != s.end() &amp;&amp; abs(nums[i] - *it) &lt;= t)//必须要double check return true; s.insert(nums[i]); } return false; } 3. 容器适配器指stack，queue的运用 020 有效的括号给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 输入: &quot;{[]}&quot; 输出: true 输入: &quot;([)]&quot; 输出: false 解答： switch一定要跟break，不然会顺序执行。 switch(1) { case 1 : cout &lt;&lt; &#39;1&#39;; // 打印 &quot;1&quot;, case 2 : cout &lt;&lt; &#39;2&#39;; // 然后打印 &quot;2&quot; } 最后要判断栈是否为空，防止输入[，返回true这种情况 bool isValid(string s) { if(s.size()==0) return true; stack&lt;char&gt; stk; for(auto c:s) { switch(c) { case &#39;(&#39;: stk.push(&#39;(&#39;); break; case &#39;[&#39;:stk.push(&#39;[&#39;); break; case &#39;{&#39;:stk.push(&#39;{&#39;); break; case &#39;)&#39;: if(stk.empty()||stk.top()!=&#39;(&#39;) return false; else stk.pop(); break; case &#39;]&#39;: if(stk.empty()||stk.top()!=&#39;[&#39;) return false; else stk.pop(); break; case &#39;}&#39;: if(stk.empty()||stk.top()!=&#39;{&#39;) return false; else stk.pop(); break; } } return stk.empty(); } 21 括号生成给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot; ] 解答： class Solution { public: vector&lt;string&gt; res; vector&lt;string&gt; generateParenthesis(int n) { gen(&quot;&quot;, 0, 0, n); return res; } void gen(string str,int numLeft,int numRight,int n){ //剪枝条件 if(numRight&gt;numLeft) return; //右括号数目大于左括号，凉凉 if(numRight&gt;n||numLeft&gt;n) return; //某一种括号太多，凉凉 //收集条件 if(numLeft== n &amp;&amp; numRight == n) {res.push_back(str); return;} gen(str+&#39;(&#39;,numLeft+1,numRight,n); gen(str+&#39;)&#39;,numLeft,numRight+1,n); return; } }; 150 逆波兰表达式求值根据逆波兰表示法，求表达式的值。有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] 输出: 6 解释: (4 + (13 / 5)) = 6 输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] 输出: 9 解释: ((2 + 1) * 3) = 9 解答： 从前往后遍历数组，遇到数字则压入栈中，遇到符号，则把栈顶的两个数字拿出来运算，把结果再压入栈中，直到遍历完整个数组，栈顶数字即为最终答案。 int evalRPN(vector&lt;string&gt;&amp; tokens) { stack&lt;int&gt; s; for (int i = 0; i &lt; tokens.size(); i++) { string c = tokens[i]; if (c == &quot;+&quot; || c == &quot;-&quot; || c == &quot;*&quot; || c == &quot;/&quot;) { //栈存取顺序！ int val2 = s.top(); s.pop(); int val1 = s.top(); s.pop(); if (c == &quot;+&quot;) { val1 += val2; s.push(val1); } if (c == &quot;-&quot;) { val1 -= val2; s.push(val1); } if (c == &quot;*&quot;) { val1 *= val2; s.push(val1); } if (c == &quot;/&quot;) { val1 = val1 / val2; s.push(val1); } } else s.push(stoi(tokens[i])); } return s.top(); } 155 最小栈设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 解答： 维护两个栈：一个存最小，一个存数据。注意一定要小于等于，为了pop的一致性。 class MinStack { public: stack&lt;int&gt; data; stack&lt;int&gt; min; /** initialize your data structure here. */ MinStack() { } void push(int x) { data.push(x); if(min.empty()||x&lt;=getMin()) min.push(x); } void pop() { if(data.top()==min.top()) min.pop(); data.pop(); } int top() { return data.top(); } int getMin() { return min.top(); } }; 225 用队列实现栈解答: 可以用双端队列，但比较慢，而且没什么意思。 class jr225_MyStack { //双队列交替存储 public: /** Initialize your data structure here. */ MyStack() { } queue&lt;int&gt; q1; queue&lt;int&gt; q2; /** Push element x onto stack. */ void push(int x) { if (q1.empty() &amp;&amp; q2.empty()) q1.push(x); else if (q2.empty()) { q2.push(x); while (!q1.empty()) { q2.push(q1.front()); q1.pop(); } } else//q1.empty { q1.push(x); while (!q2.empty()) { q1.push(q2.front()); q2.pop(); } } } /** Removes the element on top of the stack and returns that element. */ int pop() { int val; if (!q1.empty()) { val= q1.front(); q1.pop(); } else if (!q2.empty()) { val = q2.front(); q2.pop(); } return val; } /** Get the top element. */ int top() { if (!q1.empty()) return q1.front(); else if (!q2.empty()) return q2.front(); else return 0; } /** Returns whether the stack is empty. */ bool empty() { return q2.empty() &amp;&amp; q1.empty(); } }; 232 用栈实现队列解答: class MyQueue { public: /** Initialize your data structure here. */ stack&lt;int&gt; s1, s2; MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { while (!s2.empty()) { s1.push(s2.top()); s2.pop(); } s2.push(x); while (!s1.empty()) { s2.push(s1.top()); s1.pop(); } } /** Removes the element from in front of queue and returns that element. */ int pop() { int a = s2.top(); s2.pop(); return a; } /** Get the front element. */ int peek() { return s2.top(); } /** Returns whether the queue is empty. */ bool empty() { return s2.empty(); } };","categories":[{"name":"算法","slug":"算法","permalink":"jiangren.work/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"jiangren.work/tags/Leetcode/"},{"name":"数据结构","slug":"数据结构","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Leetcode题目总结6-BFS和DFS","slug":"Leetcode题目总结6-BFS和DFS","date":"2019-09-04T12:15:58.000Z","updated":"2020-03-28T04:37:32.000Z","comments":true,"path":"2019/09/04/Leetcode题目总结6-BFS和DFS/","link":"","permalink":"jiangren.work/2019/09/04/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%936-BFS%E5%92%8CDFS/","excerpt":"BFS和DFS是一对孪生兄弟，几乎所有DFS可以完成的地方BFS都可以完成。本章主要以BFS的介绍为主，DFS为辅。","text":"BFS和DFS是一对孪生兄弟，几乎所有DFS可以完成的地方BFS都可以完成。本章主要以BFS的介绍为主，DFS为辅。 1. 算法介绍简单的说，BFS是从根节点开始，沿着树（图）的宽度遍历树（图）的节点。如果所有节点均被访问，则算法中止。BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。 解题步骤一般是： 首先将根节点放入队列中。 从队列中取出第一个节点，并检验它是否为目标。如果找到目标，则结束搜寻并回传结果。否则将它所有尚未检验过的直接子节点加入队列中。 若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。 重复步骤2。 DFS递归和栈都能用，BFS统统使用队列。 2. 树的BFS树BFS基本就是纯粹的模板，模板有两个while，第一个是大while，第二个是小while。假设如下的二叉树，最开始队列存储root，1 while次数 队列存储结果 1 [2,3] 2 [4,5,6,7] 存储的顺序是正序还是反序，主要根据left和right的先后顺序。模板见102题。 102 二叉树的层次遍历给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点） 3 / \\ 9 20 / \\ 15 7 RES=[[3],[9,20],[15,7]] 解答： 中序遍历用的是stack 注意要先判断是否为空，剩下的内容基本都是套路模板。注意while(!q.empty())是取非，不要马虎写错了。 vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { queue&lt;TreeNode*&gt; q; vector&lt;vector&lt;int&gt;&gt; res; if(root==NULL) return res; q.push(root); while(!q.empty()) { auto size = q.size(); vector&lt;int&gt; tmp; while(size--) { TreeNode* node = q.front(); q.pop(); tmp.push_back(node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } res.push_back(tmp); } return res; } 103 二叉树的锯齿形层次遍历给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 3 / \\ 9 20 / \\ 15 7 [[3],[20,9],[15,7]] 解答： 很巧妙的翻转。 vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); int flag=0; while(!q.empty()) { vector&lt;int&gt; tmp; auto size=q.size(); while(size--) { TreeNode* node=q.front(); tmp.push_back(node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); q.pop(); } if(flag%2==1) reverse(tmp.begin(),tmp.end()); flag++; res.push_back(tmp); } return res; } 107 二叉树的层次遍历 II给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 3 / \\ 9 20 / \\ 15 7 [[15,7],[9,20],[3]] 解答： vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) { //和102一样，最后反转即可 vector&lt;vector&lt;int&gt;&gt; res; if (root == NULL) return res; queue&lt;TreeNode*&gt; myq; myq.push(root); while (!myq.empty()) { vector&lt;int&gt; tmp; auto size = myq.size(); while (size--) { TreeNode* node=myq.front(); myq.pop(); tmp.push_back(node-&gt;val); if (node-&gt;left) myq.push(node-&gt;left); if (node-&gt;right) myq.push(node-&gt;right); } res.push_back(tmp); } reverse(res.begin(), res.end()); return res; } 104 二叉树的最大深度给定一个二叉树，找出其最大深度。 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 解答： int maxDepth(TreeNode* root) { if(root == NULL) return 0; return max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+1; } int maxDepth(TreeNode* root) { if(root == NULL) return 0; int num = 0; queue&lt;TreeNode *&gt; que; que.push(root); while(!que.empty()){ int n = que.size(); for(int i = 0;i &lt; n;++i){ TreeNode *cur = que.front(); if(cur-&gt;left != NULL) que.push(cur-&gt;left); if(cur-&gt;right != NULL) que.push(cur-&gt;right); que.pop(); } num++; } return num; } 110 平衡二叉树判断一个二叉树是否平衡，即一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 解答： bool isBalanced(TreeNode* root) { return dfs(root)==-1?false:true; } int dfs(TreeNode* root){ if(root==NULL) return 0; int left=dfs(root-&gt;left); int right=dfs(root-&gt;right); if(abs(left-right)&gt;1) return -1; return max(left,right)+1; } 111 二叉树的最小深度解答： int minDepth(TreeNode* root) { if(root == NULL) return 0; int num = 0; queue&lt;TreeNode *&gt; que; que.push(root); while(!que.empty()){ int n = que.size(); for(int i = 0;i &lt; n;++i){ TreeNode *cur = que.front(); if(cur-&gt;left != NULL) que.push(cur-&gt;left); if(cur-&gt;right != NULL) que.push(cur-&gt;right); que.pop(); } num++; if(pow(2,num-1)!=n) return num-1; } return num; } 116 填充每个节点的下一个右侧节点指针 解答： Node* connect(Node* root) { if (!root) return NULL; queue&lt;Node*&gt; q; q.push(root); //每一个while循环都是一层 //size就是这一层的节点数量 //i&lt;size-1时，代表要右指 //每一层干三件事：1.弹出旧的 2.判断右指 3.添加新的 while (!q.empty()) { auto size = q.size(); for (int i = 0; i &lt; size; ++i) { Node* t = q.front(); q.pop(); if (i &lt; size - 1) { t-&gt;next = q.front(); } if (t-&gt;left) q.push(t-&gt;left); if (t-&gt;right) q.push(t-&gt;right); } } return root; } 199 二叉树的右视图给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 输入: [1,2,3,null,5,null,4] 输出: [1, 3, 4] 解释: 1 &lt;--- / \\ 2 3 &lt;--- \\ \\ 5 4 &lt;--- 解答： vector&lt;int&gt; rightSideView(TreeNode* root) { vector&lt;int&gt; res; if (!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) { int size = q.size(); res.push_back(q.front()-&gt;val); //BFS新技术size法 while (size--) { TreeNode* tmp = q.front(); q.pop(); if (tmp-&gt;right) q.push(tmp-&gt;right); if (tmp-&gt;left) q.push(tmp-&gt;left); } } return res; } 226 翻转二叉树 4 / \\ 2 7 / \\ / \\ 1 3 6 9 4 / \\ 7 2 / \\ / \\ 9 6 3 1 解答： TreeNode* invertTree(TreeNode* root) { if(root==NULL) return NULL; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) { auto size = q.size(); while(size--) { TreeNode* node = q.front(); q.pop(); swap(node-&gt;left,node-&gt;right); if (node-&gt;left) q.push(node-&gt;left); if (node-&gt;right) q.push(node-&gt;right); } } return root; } 2. 图的BFS 133 克隆图给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。 解答： 需要通过map来进行映射，记录是否已经拷贝。 记住：nei是原节点，m[nei]是复制节点，凡是m[xx]都是复制节点 Node* cloneGraph(Node* node) { if (!node) return NULL; map&lt;Node*, Node*&gt; m; queue&lt;Node*&gt; q; q.push(node); //注意下vector&lt;Node*&gt;{}写法 Node* clone = new Node(node-&gt;val, vector&lt;Node*&gt;{}); m[node] = clone; while (!q.empty()) { Node* t = q.front(); q.pop(); for (Node* nei : t-&gt;neighbors) { //nei是原节点，m[nei]是复制节点，凡是 //m[xx]都是复制节点 if (!m.count(nei)) { m[nei] = new Node(nei-&gt;val,vector&lt;Node*&gt;{}); q.push(nei); } m[t]-&gt;neighbors.push_back(m[nei]); } } return clone; } 207 课程表现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 输入: 2, [[1,0],[0,1]] 输出: false 解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0； 并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 解答： 本质就是有向图是否存在环的问题。 bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { //有向图的标准设置：map&lt;int, set&lt;int&gt;&gt;存领域，vector&lt;int&gt;存入度 map&lt;int, set&lt;int&gt;&gt; adjacent; vector&lt;int&gt; indegree(numCourses); for (auto&amp; edge : prerequisites) //建图 { int from = edge[0]; int to = edge[1]; adjacent[from].insert(to); indegree[to]++; } int count = 0; queue&lt;int&gt; Inq; for (int i = 0; i &lt; numCourses; i++) if (!indegree[i]) Inq.push(i); while (!Inq.empty()) { auto v = Inq.front(); Inq.pop(); count++; auto adjs = adjacent[v]; //因为把v删了，所以入度也要改变 for (auto&amp; adj : adjs) { indegree[adj]--; if (!indegree[adj]) Inq.push(adj); } } //reverse(indegree.begin(), indegree.end());; return count == numCourses; } 210 课程表 II和上面一样，不过要记录下可能的课程顺序（一种即可） 输入: 4, [[1,0],[2,0],[3,1],[3,2]] 输出: [0,1,2,3] or [0,2,1,3] 解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。 解答： vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { vector&lt;int&gt; res; map&lt;int, set&lt;int&gt;&gt; adjacent; vector&lt;int&gt; indegree(numCourses); for (auto&amp; edge : prerequisites) { int from = edge[0]; int to = edge[1]; adjacent[from].insert(to); indegree[to]++; } int count = 0; queue&lt;int&gt; Inq; for (int i = 0; i &lt; numCourses; i++) if (!indegree[i]) Inq.push(i); while (!Inq.empty()) { auto v = Inq.front(); Inq.pop(); count++; //添加 res.push_back(v); auto adjs = adjacent[v]; //因为把v删了，所以入度也要改变 for (auto&amp; adj : adjs) { indegree[adj]--; if (!indegree[adj]) Inq.push(adj); } } //修改 if (numCourses != count) return vector&lt;int&gt;{}; else { reverse(res.begin(), res.end()); return res; } } 3. 其他结构的BFS和DFS079 单词搜索给定一个二维网格和一个单词，找出该单词是否存在于网格中。 board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] 给定 word = &quot;ABCCED&quot;, 返回 true 给定 word = &quot;SEE&quot;, 返回 true 解答： bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { if (board.empty() || word.empty()){ return false; } int row = board.size(), col = board[0].size(); vector&lt;vector&lt;int&gt;&gt; f(row, vector&lt;int&gt;(col, 0)); for (int i = 0; i &lt; row; ++i){ for (int j = 0; j &lt; col; ++j){ if (dfs(board, word, 0, i,j, f)){ return true; } } } return false; } bool dfs (vector&lt;vector&lt;char&gt;&gt;&amp; board, string&amp; word, int size, int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; f){ if (size == word.size()){ return true; }//outofbound if (x &lt; 0 || x &gt;= board.size() || y &lt; 0 || y &gt; board[0].size() || board[x][y] != word[size]){ return false; } if (f[x][y] == 0) { f[x][y] = 1; if (dfs(board, word, size+1, x+1, y, f) || dfs(board, word, size+1, x-1, y, f) || dfs(board, word, size+1, x, y+1, f) || dfs(board, word, size+1, x, y-1, f)){ return true; } f[x][y] = 0; } return false; } 101 对称二叉树给定一个二叉树，检查它是否是镜像对称的。 bool isSymmetric(TreeNode* root) { return isMirror(root,root); } bool isMirror(TreeNode* p,TreeNode* q){ if(!p&amp;&amp;!q) return true; if(!p||!q) return false; if(p-&gt;val==q-&gt;val) return isMirror(p-&gt;left,q-&gt;right)&amp;&amp;isMirror(p-&gt;right,q-&gt;left); return false; } 108 将有序数组转化为二叉树将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 解答： 注意区间的开闭，root-&gt;left=dfs(nums,l,mid);以及root-&gt;right=dfs(nums,mid+1,r); TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) { int len = nums.size(); return dfs(nums,0,len); } TreeNode* dfs(vector&lt;int&gt;&amp; nums,int l,int r){ if(l==r) return NULL; int mid=(l+r)/2; TreeNode* root=new TreeNode(nums[mid]); root-&gt;left=dfs(nums,l,mid); root-&gt;right=dfs(nums,mid+1,r); return root; } 127 单词接龙给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母 转换过程中的中间单词必须是字典中的单词。 输入: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;] 输出: 5 解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。 解答： 实质上就是统计BFS的层数 int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { if (wordList.size() == 0) return 0; //假如当前为dot， //则下一个为log或dog，q就是存log和cog的 queue&lt;string&gt; q; //字典，存单词 map&lt;string, int&gt; dic; //初始化字典，1表示有这个单词 for (int i = 0; i &lt; wordList.size(); i++) dic[wordList[i]] = 1; q.push(beginWord); int layer=1; dic.erase(beginWord); //及时擦去，避免自环 while ((!q.empty()) &amp;&amp; dic.size()) { //取一个出来 auto size=q.size(); layer++; while(size--) { string now = q.front(); q.pop(); for (int i = 0; i &lt; now.size(); i++) { string tmp = now; for (char c = &#39;a&#39;; c &lt;= &#39;z&#39;; c++) { if (tmp[i] == c) continue; else tmp[i] = c; if (dic.find(tmp) != dic.end()) { if (tmp == endWord)return layer; q.push(tmp); dic.erase(tmp); //擦掉tmp不是now } } } } } return 0; } 200 岛屿数量给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 11000 11000 00100 00011 输出: 3 解答： 绝对不能用size法，因为grid是变化的。 //总体思路是把某个点1相连通的区域变为0， //这样有多少个点就有多少个连通 //BFS用队列，DFS使用递归 int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { if (grid.size() == 0 || grid[0].size() == 0) return 0; const int M = grid.size(), N = grid[0].size(); int res = 0; for (int i = 0; i &lt; M; ++i) { for (int j = 0; j &lt; N; ++j) { if (grid[i][j] == &#39;1&#39;) { ++res; dfs(grid, i, j); } } } return res; } // gird[x][y] = 1, delete it and its around. void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int x, int y) { const int M = grid.size(), N = grid[0].size(); queue&lt;pair&lt;int, int&gt;&gt; q; q.push({ x, y }); while (!q.empty()) { auto head = q.front(); q.pop(); int x = head.first; int y = head.second; if (grid[x][y] != &#39;1&#39;) continue; grid[x][y] = &#39;0&#39;; for (auto d : dirs) { int i = x + d.first; int j = y + d.second; if (i &lt; 0 || i &gt;= M || j &lt; 0 || j &gt;= N || grid[i][j] != &#39;1&#39;) { continue; } q.push({ i, j }); } } }","categories":[{"name":"算法","slug":"算法","permalink":"jiangren.work/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"jiangren.work/tags/Leetcode/"},{"name":"数据结构","slug":"数据结构","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Leetcode题目总结8-数学","slug":"Leetcode题目总结8-数学","date":"2019-09-04T12:15:58.000Z","updated":"2020-02-29T10:27:30.000Z","comments":true,"path":"2019/09/04/Leetcode题目总结8-数学/","link":"","permalink":"jiangren.work/2019/09/04/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%938-%E6%95%B0%E5%AD%A6/","excerpt":"介绍Leetcode中的一些数学题，按反转、进位、进制等问题分类。","text":"介绍Leetcode中的一些数学题，按反转、进位、进制等问题分类。 1. 数字反转007 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 输入: -123 输出: -321 输入: 120 输出: 21 解答： 可以转化为字符串来做，也可以按照数学题中常见的数字分割来做。注意检查溢出。不能写x!=0，这样负数就无效了。 int reverse(int x) { long sum=0; while(x) { sum=sum*10+x%10; x=x/10; } if(sum&gt;INT_MAX||sum&lt;INT_MIN) return 0; else return sum; } 009 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 输入: 121 输出: true 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 解答： bool isPalindrome(int x) { if(x&lt;0) return false; long sum=0; int origin=x; while(x) { sum=sum*10+x%10; x=x/10; } return (sum==origin)?true:false; } 2. 进位问题043 字符串相乘给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 输入: num1 = &quot;2&quot;, num2 = &quot;3&quot; 输出: &quot;6&quot; 输入: num1 = &quot;123&quot;, num2 = &quot;456&quot; 输出: &quot;56088&quot; 解答： 注意index = num1.size() + num2.size() - 2;因为是数组下标。进位最后不要忘了carry还要加上去。 /* * 1 2 3 * * 3 2 1 * ---------- * 1 2 3 * 2 4 6 * 3 6 9 * -------------- * 3 8 14 8 9 * 乘法的计算是错位相加最后的位数=n+(m-1),原数有3位，乘以一个三位数相当于向左添加了2位 * */ string multiply(string num1, string num2) { if (num1 == &quot;0&quot; || num2 == &quot;0&quot;) return &quot;0&quot;; vector&lt;int&gt; res(222, 0); int index = num1.size() + num2.size() - 2; for (int i = num1.size() - 1; i &gt;= 0; i--) { for (int j = num2.size() - 1; j &gt;= 0; j--) { int mul = (num1[i] - &#39;0&#39;) * (num2[j] - &#39;0&#39;); int t = index - i - j; //index:0-4 res[t] = res[t] + mul; } } //处理完成3 8 14 8 9 //反过来装 9 8 14 8 3 string str = &quot;&quot;; int carry = 0; //注意这里是等于！！ for (int i = 0; i &lt;= index; i++) { res[i] += carry; carry = 0; if (res[i] &gt;= 10) { carry = res[i] / 10; res[i] = res[i] % 10; } str.append(to_string(res[i]));//数字转string } if (carry != 0) str.append(to_string(carry)); reverse(str.begin(), str.end()); return str; } 066 加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 解答： 分三种情况讨论即可。 vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) { int len = digits.size(); int lastdigit = digits[len-1]; if(lastdigit!=9) {digits[len-1]+=1; return digits;} int flag=0; for(auto x:digits) if(x==9) flag++; if(flag==len) { vector&lt;int&gt; res(len+1,0); res[0]=1; return res; } int carry = 0; digits[len-1]+=1; for(int i=len-1;i&gt;=0;i--) { digits[i]+=carry; carry=0; if(digits[i]&gt;=10) { carry = digits[i]/10; digits[i]=digits[i]%10; } } return digits; } 067 二进制求和给定两个二进制字符串，返回他们的和（用二进制表示）。输入为非空字符串且只包含数字 1 和 0。 输入: a = &quot;1010&quot;, b = &quot;1011&quot; 输出: &quot;10101&quot; 解答： 注意判空。 string addBinary(string a, string b) { string res; int carry=0; while(!a.empty()||!b.empty()) { int sum=0; sum+=carry; carry=0; if(!a.empty()) { sum+=a.back()-&#39;0&#39;; a.pop_back(); } if(!b.empty()) { sum+=b.back()-&#39;0&#39;; b.pop_back(); } carry=sum/2; res.append(to_string(sum%2)); } if(carry!=0) res.append(to_string(carry)); reverse(res.begin(),res.end()); return res; } 3. 进制168 Excel表列名称1 -&gt; A 2 -&gt; B 3 -&gt; C ... 26 -&gt; Z 27 -&gt; AA 28 -&gt; AB ... 解答： string convertToTitle(int n) { if (n &lt;= 0) return &quot;&quot;; string res; while (n &gt; 0) { //假设26，取余后变为1了，结果不正确 //不能(n%26)-1+&#39;A&#39; n--; res=char((n % 26) + &#39;A&#39;)+res; n = n / 26; } return res; } 171 Excel表列序号A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ... 解答： int titleToNumber(string s) { int sum=0; for(auto c:s) { int val = c-&#39;A&#39;+1; sum=sum*26+val; } return sum; } 4. 其他029 两数相除给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。返回被除数 dividend 除以除数 divisor 得到的商。 输入: dividend = 10, divisor = 3 输出: 3 输入: dividend = 7, divisor = -3 输出: -2 解答： int divide(int dividend, int divisor) { long ans = 0, up = std::fabs(dividend), down = std::fabs(divisor); while(up &gt;= down){ long count = 1, base = down; while(up &gt; (base &lt;&lt; 1)){ count &lt;&lt;= 1; base &lt;&lt;= 1; } ans += count; up -= base; } ans = ((dividend &lt; 0)^(divisor &lt; 0)) ? -ans : ans; return (ans &gt; INT_MAX || ans &lt; INT_MIN) ? INT_MAX : ans; } 050 Pow(x,n)实现 pow(x, n) ，即计算 x 的 n 次幂函数。 输入: 2.00000, -2 输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 解答： 如果直接线性循环，太慢通不过。需要用快速幂算法，复杂度O(lgn) double myPow(double x, int n) { //排除特殊情况 if (n == 0) return 1; //一定要转化为long型，防止表示-n时溢出 long long tmpn=n; if (n &lt; 0) { x = 1 / x; tmpn=-(long long)n;; } return mymypow(x, tmpn); } double mymypow(double x, long long n) { //递归出口 if (n == 1) return x; //递归主体 long long tmp = n / 2; double res = mymypow(x, tmp); //返回情况 if (n % 2 == 0) return res * res; else return res * res * x; } 172 阶乘后的零给定一个整数 n，返回 n! 结果尾数中零的数量。 输入: 5 输出: 1 解释: 5! = 120, 尾数中有 1 个零. 解答： 首先题目的意思是末尾有几个0， 比如$6! = [1 2 3 4 5 6]$其中只有25末尾才有0，所以就可以抛去其他数据专门看2和5 以及其倍数，毕竟 4 * 25末尾也是0 比如$10!= [2456810]$其中 $4$能拆成$22$ ,$10$能拆成$25$ 所以$10！ = [2（22）5（23）（222）（2*5）]$一个2和一个5配对 就产生一个0 所以10！末尾2个0 转头一想 2肯定比5多 所以只数5的个数就行了 假若N=31 31里能凑10的5为$[5, 25, 35, 45, 25, 65]$， 其中 25还能拆为 5*2 int trailingZeroes(int n) { int count = 0; while(n/5!=0){ count+=n/5; n/=5; } 204 计数质数统计所有小于非负整数 n 的质数的数量。 输入: 10 输出: 4 解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 解答： 如果x是质数，则nx全部都不是质数 int countPrimes(int n) { if (n &lt; 2) return 0; int count = 0; vector&lt;bool&gt; judge(n, true); for (int i = 2; i &lt; n; i++) { if (judge[i])//如果是质数 { for (int j = i * 2; j &lt; n; j = j + i) { judge[j] = false; } count++; } } return count; }","categories":[{"name":"算法","slug":"算法","permalink":"jiangren.work/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"jiangren.work/tags/Leetcode/"}]},{"title":"Leetcode题目总结5-位运算","slug":"Leetcode题目总结5-位运算","date":"2019-09-03T11:22:41.000Z","updated":"2019-12-30T20:38:36.000Z","comments":true,"path":"2019/09/03/Leetcode题目总结5-位运算/","link":"","permalink":"jiangren.work/2019/09/03/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%935-%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"位运算最基本的用法就是移位取值的使用。","text":"位运算最基本的用法就是移位取值的使用。 1. 常见的位运算技巧(1) 判断奇偶 奇数最后一位为1，偶数为0 if(num&amp;1){} //奇数 else {} //偶数 (2) 交换两数 if(a!=b) a^=b,b^=a,a^=b; (3) 变换符号 二进制取反+1就可以将正变负，负变正。 return ~a+1; （4）取出某一位的数字 int val=(x &gt;&gt; i) &amp; 1 2. 移位取值这一类题目都运用到了前面提到的取出某一位数字的技巧，这种方法将位运算转化为类似字符串的操作形式，十分简便。 136 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素 输入: [4,1,2,1,2] 输出: 4 解答： 假设数组是001,001,000,000,011，多余的元素是011，最后一位操作加起来取余2，余下了1，所以，多余元素就是1。 int singleNumber(vector&lt;int&gt;&amp; nums) { int target = 0; for (int i = 0; i &lt; 32; i++) { int sum = 0; for (auto x : nums) //取出单个比特的数字 sum += (x &gt;&gt; i) &amp; 1; int residue = sum % 2; target = target | residue &lt;&lt; i; } return target; } 137 只出现一次的数字 II给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。 输入: [0,1,0,1,0,1,99] 输出: 99 解答： 方法和上面一样，不过是取余3而已。 int singleNumber(vector&lt;int&gt;&amp; nums) { int res=0; for(int i=0;i&lt;32;i++) { int sum=0; for(auto x:nums) sum+=(x&gt;&gt;i)&amp;1; int residue=sum%3; res|=residue&lt;&lt;i; } return res; } 169 多数元素给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 输入: [2,2,1,1,1,2,2] 输出: 2 解答： 和上面两题一脉相承，如果数组有7个元素，而001是众数，则第0位的1的数量一定大于等于4，0的数量小于等于3，所以只需要比较0和1的数量就可以判断。 int majorityElement(vector&lt;int&gt;&amp; nums) { int res=0; for(int i=0;i&lt;32;i++) { int zeros=0; int ones=0; for(auto x:nums) { if((x&gt;&gt;i)&amp;1) ones++; else zeros++; } if(ones&gt;zeros) res|=1&lt;&lt;i; } return res; } 190 颠倒二进制位颠倒给定的 32 位无符号整数的二进制位。 输入: 00000010100101000001111010011100 输出: 00111001011110000010100101000000 解答： 利用栈的特性。 uint32_t reverseBits(uint32_t n) { stack&lt;int&gt; st; uint32_t res=0; for(int i=0;i&lt;32;i++) { int val =(n&gt;&gt;i)&amp;1; st.push(val); } for(int i=0;i&lt;32;i++) { res|=st.top()&lt;&lt;i; st.pop(); } return res; } 191 位1的个数编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量） 输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。 解答： 极其简单，也可以一行解决return bitset&lt;32&gt;(n).count(); int hammingWeight(uint32_t n) { int res=0; for(int i=0;i&lt;32;i++) { if((n&gt;&gt;i)&amp;1) res++; } return res; }","categories":[{"name":"算法","slug":"算法","permalink":"jiangren.work/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"jiangren.work/tags/Leetcode/"}]},{"title":"Leetcode题目总结9-字符串","slug":"Leetcode题目总结9-字符串","date":"2019-09-03T11:22:41.000Z","updated":"2019-12-30T20:44:43.000Z","comments":true,"path":"2019/09/03/Leetcode题目总结9-字符串/","link":"","permalink":"jiangren.work/2019/09/03/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%939-%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"本文着重介绍字符串流stringstream的妙用。","text":"本文着重介绍字符串流stringstream的妙用。 1. 字符串流的运用字符串流stringstream配合读写符&gt;&gt;可以轻松做到精确分割。分割的办法有两种 字符数字交替分割，可以分割1.22.3这样的数，但并不实用 int num; char c; str&gt;&gt;c;str&gt;&gt;num; 另一种是以空格为标志的分割，非常好用。我们可以实现将原字符串某些部分转化为空格，以此作为分割的标志。 008 字符串转换整数(atoi)请你来实现一个 atoi 函数，使其能将字符串转换成整数。 输入: &quot;42&quot; 输出: 42 输入: &quot; -42&quot; 输出: -42 解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。 输入: &quot;4193 with words&quot; 输出: 4193 解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。 输入: &quot;-91283472332&quot; 输出: -2147483648 解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 解答： int myAtoi(string str) { stringstream s(str); long val=0; s &gt;&gt; val; if (val &gt; INT_MAX) return INT_MAX; if (val &lt; INT_MIN) return INT_MIN; return val; } 058 最后一个单词的长度给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串，返回其最后一个单词的长度。如果不存在最后一个单词，请返回 0 。 输入: &quot;Hello World&quot; 输出: 5 解答： 在stringstream中判断是否为空的办法是s.rdbuf()-&gt;in_avail()返回剩余字符串长度，如果为0就是为空。 int lengthOfLastWord(string s) { stringstream str(s); string word; while (str.rdbuf()-&gt;in_avail()) { str &gt;&gt; word; } return word.size(); } 071 简化路径以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 输入：&quot;/home/&quot; 输出：&quot;/home&quot; 解释：注意，最后一个目录名后面没有斜杠。 输入：&quot;/../&quot; 输出：&quot;/&quot; 解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。 输入：&quot;/home//foo/&quot; 输出：&quot;/home/foo&quot; 解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。 解答： 第一步需要从/中切割出想要的成分。第二部开始分析，由于//也是消灭的对象所以需要考虑part==&quot;&quot;。将/替换为空格，就可以利用流的特性进行分割读取。 注意： 在s&gt;&gt;part之前要先把垃圾清空 part == &quot;..&quot;的判断一定要分两步走，防止/../这种情况 string simplifyPath(string path) { stack&lt;string&gt; stk; auto lambda = [](auto&amp; element) { if (element == &#39;/&#39;) element = &#39; &#39;; }; for_each(path.begin(), path.end(), lambda); stringstream s(path); string part; while (s.rdbuf()-&gt;in_avail()) { part = &quot;&quot;; s &gt;&gt; part; if (part == &quot;.&quot; || part == &quot;&quot;) continue; else if (part == &quot;..&quot; ) { if(!stk.empty()) stk.pop(); } else stk.push(&quot;/&quot; + part); } string res = &quot;&quot;; while (!stk.empty()) { //注意顺序 res = stk.top() + res; stk.pop(); } if (res.size() == 0) res = &quot;/&quot;; return res; } 125 验证回文串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 输入: &quot;A man, a plan, a canal: Panama&quot; 输出: true 解答： 思路和上面一样，不过在lambda中需要先转化为小写，因为本题要求不考虑大小写。 bool isPalindrome(string s) { auto lambda = [](auto&amp; element) { if (!isalnum(element)) element = &#39; &#39;; element = tolower(element); }; for_each(s.begin(), s.end(), lambda); stringstream str(s); string ans = &quot;&quot;; while (str.rdbuf()-&gt;in_avail()) { string tmp; str &gt;&gt; tmp; ans += tmp; } string rev_ans = ans; reverse(rev_ans.begin(), rev_ans.end()); return ans == rev_ans; } 165 比较版本号比较两个版本号 version1 和 version2。如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。 输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot; 输出：0 解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。 输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot; 输出: -1 解答： 承接容器必须要int类型，如果用string来接会出现&quot;001&quot;和&quot;1&quot;不相等的情况。最后还要考虑长度问题解决version1 = &quot;7.5.3.4&quot;, version2 = &quot;7.5.3&quot;这一类长度不等的情况。 int compareVersion(string version1, string version2) { auto lambda=[](auto&amp; element){ if(!isdigit(element)) element=&#39; &#39;; }; string str1=version1; string str2 = version2; for_each(str1.begin(),str1.end(),lambda); for_each(str2.begin(),str2.end(),lambda); stringstream s1(str1); stringstream s2(str2); while(s1.rdbuf()-&gt;in_avail()||s2.rdbuf()-&gt;in_avail()) { int tmp1=0; int tmp2=0; s1&gt;&gt;tmp1; s2&gt;&gt;tmp2; if(tmp1&gt;tmp2||(tmp2==0&amp;&amp;tmp1!=0)) return 1; if(tmp1&lt;tmp2||(tmp1==0&amp;&amp;tmp2!=0)) return -1; } return 0; } 2. 其他006 Z字变换将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 解答： 如果行数为3，就分成3个子串分别收集，依靠step进行指路。 string convert(string s, int numRows) { if(s.empty()||numRows==1) return s; int step=-1; int dir=0; vector&lt;string&gt; str(numRows); for(int i=0;i&lt;s.size();i++) { str[dir]+=s[i]; if(dir==numRows-1||dir==0) step=-step; dir+=step; } string res=&quot;&quot;; for(auto x:str) res=res+x; return res; } 014 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出: &quot;fl&quot; 解答： C++中字符串的大小比较是按照字典序排序的，利用这一性质我们可以找到最大和最小，只需要比较最大最小的前缀即可。 string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if(strs.size()==0) return &quot;&quot;; string res=&quot;&quot;; auto it_max = max_element(strs.begin(),strs.end()); auto it_min = min_element(strs.begin(),strs.end()); string max=*it_max; string min=*it_min; auto size = std::min(max.size(),min.size()); int i=0; for(;i&lt;size;i++) { if(max[i]!=min[i]) break; } return max.substr(0,i); }","categories":[{"name":"算法","slug":"算法","permalink":"jiangren.work/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"jiangren.work/tags/Leetcode/"}]},{"title":"Leetcode题目总结4-回溯","slug":"Leetcode题目总结4-回溯","date":"2019-09-03T04:55:34.000Z","updated":"2020-02-26T13:15:30.000Z","comments":true,"path":"2019/09/03/Leetcode题目总结4-回溯/","link":"","permalink":"jiangren.work/2019/09/03/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%934-%E5%9B%9E%E6%BA%AF/","excerpt":"回溯法就处理两种问题：组合、排列，本质上还是套用模板。","text":"回溯法就处理两种问题：组合、排列，本质上还是套用模板。 1. 算法讲解回溯法（backtracking）本质其实是一种在深度优先搜索（DFS）的基础上，加入了剪枝函数（pruning），从而使得空间复杂度在一定程度上有所降低。回溯法适合组合数相当大的问题，也就是许多组合优化的问题适合用回溯法解决。 常见的地方有两个 backtrack函数的开头，剪掉后方便放入收集容器 for循环的开头，一般是去重 回溯函数的一般化流程是: void backtrack(原数组，结果容器，临时容器，起始位置，....) { if(...) return//剪枝条件 if(...) //结果容器收集条件 { res.push_back(tmp); return; } //回溯过程 for(int i=start;i&lt;nums.size();i++) { //这里也可能有剪枝条件，比如去除重复元素 tmp.push_back(); backtrack(位置); tmp.pop_back(); } } 2. 组合问题组合是按先后顺序依次进行，区分组合和排列的关键就是看：前面用过后面还用不用。 比如，[1,2,3]的全排列，1虽然用过，但依然可能出现在其他位置，再接着用；而[1,2,3,4,5]数组中和为8的数组集合，这里用过1（pass过）就不会再出现了。所以排列问题需要用flag标记，组合则不需要。 039 组合总和给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。 输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ [7], [2,2,3] ] 解答： 注意，要排序！最后调用backtrack进入的是i，不是start！并且不加1（candidates 中的数字可以无限制重复被选取）。注意要传引用。 vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; res; sort(candidates.begin(), candidates.end()); backtrack(res,tmp,candidates,target,0); return res; } void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res,vector&lt;int&gt;&amp; tmp, vector&lt;int&gt;&amp; candidates, int target, int start) { if(target&lt;0) return; if(target ==0) { res.push_back(tmp); return; } for(int i=start;i&lt;candidates.size();i++) { tmp.push_back(candidates[i]); backtrack(res,tmp,candidates,target-candidates[i],i); tmp.pop_back(); } } 040 组合总和II给定一个数组有重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 解答： 因为有数组有重复所以要去重，因为只能用一次所以backtrack时需要+1防止自环。 vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; res; sort(candidates.begin(),candidates.end()); backtrack(res,tmp,candidates,target,0); return res; } void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res,vector&lt;int&gt;&amp; tmp,vector&lt;int&gt;&amp; candidates, int target,int start) { if(target&lt;0) return; if(target==0) { res.push_back(tmp); return; } for(int i=start;i&lt;candidates.size();i++) { if(i&gt;start&amp;&amp;candidates[i]==candidates[i-1]) //上一个已经用过 continue; tmp.push_back(candidates[i]); backtrack(res,tmp,candidates,target-candidates[i],i+1); tmp.pop_back(); //取巧去重 //set&lt;vector&lt;int&gt;&gt; s(res.begin(),res.end()); //res.assign(s.begin(),s.end()); } } 077 组合给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 解答： 按照直觉，先构建数组。注意比较的时候tmp.size()==k而不是start==k vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { vector&lt;int&gt; vec; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; for(int i=1;i&lt;=n;i++) vec.push_back(i); backtrack(res,tmp,vec,0,k); return res; } void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res,vector&lt;int&gt;&amp; tmp, vector&lt;int&gt;&amp; vec, int start,int k) { if(tmp.size()==k) { res.push_back(tmp); return; } for(int i=start;i&lt;vec.size();i++) { tmp.push_back(vec[i]); backtrack(res,tmp,vec,i+1,k); tmp.pop_back(); } } 216 组合总和III找出所有相加之和为 n\\ 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 解答： 这道题和077一样，需要自己创造一个nums容器出来，这样会比较清晰。 vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; nums; vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) { for(int i=1;i&lt;=9;i++) nums.push_back(i); backtrack(k,n,0); return res; } void backtrack(int k,int n,int start) { if(n&lt;0) return; if(n==0&amp;&amp;k!=0) return; if(n==0&amp;&amp;k==0) { res.push_back(tmp); return; } for(int i=start;i&lt;nums.size();i++) { tmp.push_back(nums[i]); backtrack(k-1,n-nums[i],i+1); tmp.pop_back(); } } 078 子集给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 输入: nums = [1,2] 输出: [ [1], [2], [1,2], [] ] 解答： vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; backtrack(res,tmp,nums,0); return res; } void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res,vector&lt;int&gt;&amp; tmp, vector&lt;int&gt;&amp; nums, int start) { res.push_back(tmp); for(int i=start;i&lt;nums.size();i++) { tmp.push_back(nums[i]); backtrack(res,tmp,nums,i+1); tmp.pop_back(); } } 090 子集II给定一个可能包含重复元素的整数数组 nums\\，返回该数组所有可能的子集（幂集）。 输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 解答： 两个要点： 查重，注意i&gt;start不是i&gt;0 排序，不排序的话如果出现[4,4,4,1,4]这种，查重查不出来 vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; sort(nums.begin(), nums.end()); backtrack(res,tmp,nums,0); return res; } void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res,vector&lt;int&gt;&amp; tmp, vector&lt;int&gt;&amp; nums, int start) { res.push_back(tmp); for(int i=start;i&lt;nums.size();i++) { if(i&gt;start&amp;&amp;nums[i]==nums[i-1]) continue; tmp.push_back(nums[i]); backtrack(res,tmp,nums,i+1); tmp.pop_back(); } } 093 复原IP地址给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 输入: &quot;25525511135&quot; 输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 解答： 这道题特别复杂，而且也不是传统的回溯套路。这里的for代表第n个字节，有三个剪枝条件，注意第二个的办法非常巧妙。 vector&lt;string&gt; restoreIpAddresses(string s) { vector&lt;string&gt; res; string tmp = &quot;&quot;; backtrack(s, res, tmp, 0); return res; } void backtrack(string s, vector&lt;string&gt;&amp; res, string tmp, int n) { if(s.size()&gt;3*(4-n)) return ; if(n==4&amp;&amp;s.size()==0) { tmp.pop_back(); //去掉最后的&#39;.&#39; res.push_back(tmp); } for(int i=1;i&lt;=3;i++) { if(s.size()&lt;i) break; int val=stoi(s.substr(0,i)); if(i!=to_string(val).size()) break; if(val&gt;255) break; tmp+=s.substr(0,i)+&#39;.&#39;; backtrack(s.substr(i),res,tmp,n+1); tmp=tmp.substr(0,tmp.size()-i-1); } } 113 路径总和 II给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 [ [5,4,11,2], [5,8,4,5] ] 解答： 112不需要存值，直接DFS就好，要存值最好用回溯模板。容器收集判断需要放在push后面！ vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) { vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; path(res, root, sum, tmp); return res; } void path(vector&lt;vector&lt;int&gt;&gt;&amp; res, TreeNode* root, int sum, vector&lt;int&gt;&amp; tmp) { //相较于112,需要记录 //采用深度优先的办法 if (root == NULL) return; tmp.push_back(root-&gt;val); if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) { if (root-&gt;val == sum) res.push_back(tmp); } path(res, root-&gt;left, sum - root-&gt;val, tmp); path(res, root-&gt;right, sum - root-&gt;val, tmp); tmp.pop_back(); } 131 分割回文串给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。 输入: &quot;aab&quot; 输出: [ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;] ] 解答： vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; tmp; vector&lt;vector&lt;string&gt;&gt; partition(string s) { backtrack(s, 0); return res; } bool isPalindrome(string s) { string tmp = s; reverse(tmp.begin(),tmp.end()); return s==tmp; } //start是开始计算的位置 void backtrack(string s, int start) { //如果不满足回文，start不会增长，start&gt;s.size()-1意味着检验完毕 if (start &gt; s.size() - 1) { res.push_back(tmp); return; } //len是分割字符的长度 //这里必须小于等于，start=0，len=3，有效 for (int len = 1; len &lt;= s.size() - start; len++) { //substr:pos+len if (isPalindrome(s.substr(start, len))) { tmp.push_back(s.substr(start, len)); backtrack(s, start + len); tmp.pop_back(); } } } 3. 排列问题前面讲过，组合问题是按先后顺序进行，而排列则不是：前面用过的元素后面依然可能用到。所以排列问题需要用flag标记，组合则不需要。 046 全排列给定一个没有重复数字的序列，返回其所有可能的全排列。 输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 解答： 我们需要用flag来做标记，用了某个元素就打上标记，回溯完以后就撤掉这个标记，重复利用。除了标记还需要注意int i = 0而不是组合问题中int i=start; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { vector&lt;bool&gt; flag(nums.size(),false); backtrack(nums,flag); return res; } void backtrack(vector&lt;int&gt;&amp; nums,vector&lt;bool&gt;&amp; flag) { if(tmp.size()==nums.size()) { res.push_back(tmp); return; } for(int i=0;i&lt;nums.size();i++) { if(flag[i]) continue; tmp.push_back(nums[i]); flag[i]=true; backtrack(nums,flag); flag[i]=false; tmp.pop_back(); } } 047 全排列II给定一个可包含重复数字的序列，返回所有不重复的全排列。 输入: [1,1,2] 输出: [ [1,1,2], [1,2,1], [2,1,1] ] 解答： 简单的去重没什么好说的，注意一定要sort排序，避免[4,4,4,1,4]这种情况。 vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; //sort(nums.begin(), nums.end()); vector&lt;bool&gt; flag(nums.size(), false); backtrack(nums, flag, res, tmp); return res; } void backtrack(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; flag, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp) { if (tmp.size() == nums.size()) { res.push_back(tmp); return; } for (int i = 0; i &lt; nums.size(); i++) { if (flag[i]) continue; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !flag[i - 1]) continue; flag[i] = true; tmp.push_back(nums[i]); backtrack(nums, flag, res,tmp); tmp.pop_back(); flag[i] = false; } }","categories":[{"name":"算法","slug":"算法","permalink":"jiangren.work/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"jiangren.work/tags/Leetcode/"}]},{"title":"Leetcode题目总结3-动态规划","slug":"Leetcode题目总结3-动态规划","date":"2019-09-02T10:55:12.000Z","updated":"2020-03-27T16:53:42.000Z","comments":true,"path":"2019/09/02/Leetcode题目总结3-动态规划/","link":"","permalink":"jiangren.work/2019/09/02/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%933-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"本文根据处理对象的结构将动态规划分为线性一维、矩形二维、三角形这三种类型。","text":"本文根据处理对象的结构将动态规划分为线性一维、矩形二维、三角形这三种类型。 1. 算法讲解1.1 简介动态规划脱胎于暴力解法，通过优化重叠子问题形成了DP这种高效的解法。 动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。分治法也是将问题分为若干个子问题，但经分解后得到的子问题往往不是互相独立的。 要解决动态规划(dp)的问题需要考虑四个步骤： 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来 状态转移方程和转移条件：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。 初始状态的本质是递推，递推就需要明确初始条件。 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件 其实最主要的还是考虑23，转移方程转移条件和初始状态！ 以爬楼梯为例，假设每次爬楼梯只能爬1步或2步，求爬到第n阶有多少种办法？ 确定状态和状态变量：爬到第i层所需要的步数dp。 转移方程：dp[i] = dp[i - 1] + dp[i - 2]。 初始条件：dp[0] = 1;和dp[1] = 2; 边界条件：第n层结束。 int climbStairs(int n) { vector&lt;int&gt; dp(100,0); dp[0] = 1,dp[1] = 2; for (int i = 2; i &lt; n; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n - 1]; } 1.2 解法前面说到，动态规划脱胎于暴力解法，需要优化。优化的办法有两种：带备忘录的递归解法（自顶向下），动态规划解法（自底向上） 带备忘录的递归优化一个斐波那契数列的暴力解法如下，画出递归树后发现了大量重复的子问题，因此导致时间复杂度很高（呈指数上升$O(2^n)$） int fib(int N) { if (N == 1 || N == 2) return 1; return fib(N - 1) + fib(N - 2); } 因此我们想到利用一个备忘录记载用过的子问题： int fib(int N) { if (N &lt; 1) return 0; // 备忘录全初始化为 0 vector&lt;int&gt; memo(N + 1, 0); return helper(memo, N); } int helper(vector&lt;int&gt;&amp; memo, int n) { if (n == 1 || n == 2) return 1; if (memo[n] != 0) return memo[n]; // 未被计算过 memo[n] = helper(memo, n - 1) + helper(memo, n - 2); return memo[n]; } 由于递归的时候，先从左子树一路向下，因此通过备忘录就能实现剪枝： 如上图所示，直接把$2^n$的树形结构，剪成了nn的一维数组结构，大大减小了时间复杂度！ 动态规划优化有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一个专门的容器，直接在这个容器中完成所有算法，这样时间和备忘录一样，但空间更节省。这就是自底向上。 int fib(int N) { vector&lt;int&gt; dp(N + 1, 0); dp[1] = dp[2] = 1; for (int i = 3; i &lt;= N; i++) dp[i] = dp[i - 1] + dp[i - 2]; return dp[N]; } 2. 线性一维DP005 最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot; 也是一个有效答案。 解答： 这里的一维是指处理对象的维度，dp容器可以是二维的。解答思路很简单，如果abba是回文，则bb肯定是回文。 一定要写l &lt;= length，因为这里的l代表了回文的长度，如果aaaa则l==length。 这道题要维护两个重要变量，回文串起始位置start和长度len string longestPalindrome(string s) { const int length = s.size(); //最后返回字符串，返回的记录方式是：位置(start)+长度（maxlen） int maxlength = 1, start = 0; if (length == 0) return s; vector&lt;vector&lt;bool&gt;&gt; dp(length + 1, vector&lt;bool&gt;(length + 1, false)); for (int i = 0; i &lt; length; i++) //这里一定不能写length-1 { //初始化 dp[i][i] = true; if (i &lt; length - 1 &amp;&amp; s.at(i) == s.at(i + 1))//必须在这里判断 { dp[i][i + 1] = true; start = i; maxlength = 2; } } //一定要写等于 for (int l = 3; l &lt;= length; l++) for (int i = 0; i &lt;= length - l; i++) //这里也一定要加等号 { int s_start = i; int s_end = i + l - 1; if (dp[s_start + 1][s_end - 1] &amp;&amp; s.at(s_start) == s.at(s_end)) { dp[s_start][s_end] = true; maxlength = l; start = s_start; } } if (maxlength &gt;= 2) return s.substr(start, maxlength); //maxlength=1时，直接返回第一个字符（要写成串的形式） else return s.substr(0, 1); } 053 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 解答： 最重要是写出转移方程sum[i]=max(sum[i-1]+a[i],a[i]);只要a[i]不是大，当前组就还有机会靠下一个a[i+1]翻盘。 std::max_element()返回的是迭代器位置，所以还需要解引用。 int maxSubArray(vector&lt;int&gt;&amp; nums) { if(nums.size()==0) return 0; vector&lt;int&gt; sum(nums.size()); sum[0]=nums[0]; for(int i=1;i&lt;nums.size();i++) sum[i]=max(sum[i-1]+nums[i],nums[i]); return *max_element(sum.begin(), sum.end()); } 055 跳跃游戏给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。 输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 解答： 贪心算法，计算每个点能跳跃到的最大长度 bool canJump(vector&lt;int&gt;&amp; nums) { int canReach=0; for(int i=0;i&lt;nums.size();i++){ if(i&gt;canReach){ return false; } canReach=max(canReach,nums[i]+i); } return true; } 091 解码方法一条包含字母 A-Z 的消息通过以下方式进行了编码： &#39;A&#39; -&gt; 1 &#39;B&#39; -&gt; 2 ... &#39;Z&#39; -&gt; 26 输入: &quot;226&quot; 输出: 3 解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 解答： 这道题引入了转移条件： 只要前一位不为0，就可以dp[i]+=dp[i-1] 只要前两位组合在[10,26]之间，就可以dp[i]+=dp[i-2] 要注意dp[m]不是表示s的下标，而是表示长度，表示第m位！dp[0]=dp[1]=1，dp[0]表示第0位（这是虚拟状态，有利于做题而已），dp[1]表示第1位。 凡是涉及到要索引上上位，都可以考虑使用虚拟状态。 int numDecodings(string s) { if(s.empty()) return 0; if(s[0]==&#39;0&#39;) return 0; vector&lt;int&gt; dp(s.size()+1,0); dp[0]= 1; dp[1]= 1; for(int i=2;i&lt;s.size()+1;i++) { if(s[i-1]!=&#39;0&#39;) dp[i]+=dp[i-1]; if(s.substr(i-2,2)&gt;=&quot;10&quot;&amp;&amp;s.substr(i-2,2)&lt;&quot;27&quot;) dp[i]+=dp[i-2]; } return dp[s.size()]; } 096 不同的二叉搜索树给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树 解答： 这个题必须要考虑0个节点时，依然是一个二叉搜索树NULL。状态转移方程：dp[i] += dp[left] * dp[right]。dp[num]代表了num个节点能够组成多少个BST。 int numTrees(int n) { vector&lt;int&gt; dp(n+1); dp[0]=dp[1]=1; if(n==0||n==1) return 1; for(int num=2;num&lt;=n;num++)//有多少个节点 for(int left=0;left&lt;num;left++) { int right = num-left-1;//要分配一个为root dp[num]+=dp[left]*dp[right]; } return dp[n]; } 121 买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 解答： 维护两个变量minPrice[i]和maxProfit[i] int maxProfit(vector&lt;int&gt;&amp; prices) { vector&lt;int&gt; minprice(prices.size()); vector&lt;int&gt; maxprofit(prices.size()); if(prices.size()==0) return 0; minprice[0]=prices[0]; maxprofit[0]=0; for(int i=1;i&lt;prices.size();i++) { minprice[i]=min(prices[i],minprice[i-1]); int curprofit = prices[i]-minprice[i]; maxprofit[i]=max(curprofit,maxprofit[i-1]); } return maxprofit[prices.size()-1]; } 122 买卖股票的最佳时机II比上一道题目加了条件：多次买卖一支股票 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 解答： 因为同一天又能买又能卖，所以转移方程dp[i]=max(dp[i-1]+p[i]-p[i - 1],dp[i-1]) int maxProfit(vector&lt;int&gt;&amp; prices) { if(prices.size()==0) return 0; vector&lt;int&gt; maxProfit(prices.size(),0); for(int i=1;i&lt;prices.size();i++) maxProfit[i]=max(maxProfit[i-1],maxProfit[i-1]+prices[i]-prices[i-1]); return maxProfit[prices.size()-1]; } 152 乘积最大子序列给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 解答： 由于乘法的特殊性，两个转移变量，同时需要比较三个变量的最大最小。注意一下maxvec不是递增序列，需要返回一个最大值。 int maxProduct(vector&lt;int&gt;&amp; nums) { if(nums.size()==0) return 0; if(nums.size()==1) return nums[0]; vector&lt;int&gt; maxvec(nums.size()); vector&lt;int&gt; minvec(nums.size()); maxvec[0]=minvec[0]=nums[0]; for(int i=1;i&lt;nums.size();i++) { maxvec[i]=max3(maxvec[i-1]*nums[i],nums[i],minvec[i-1]*nums[i]); minvec[i]=min3(minvec[i-1]*nums[i],nums[i],maxvec[i-1]*nums[i]); } return *max_element(maxvec.begin(),maxvec.end()); } int max3(int a, int b, int c) { return max(a,max(b,c)); } int min3(int a, int b, int c) { return min(a,min(b,c)); } 198 打家劫舍如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 解答： 转移方程很简单dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);，需要注意一下初始条件。 int rob(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if(len==0) return 0; if(len==1) return nums[0]; vector&lt;int&gt; dp(len); dp[0]=nums[0]; dp[1]=max(nums[0],nums[1]); for(int i=2;i&lt;len;i++) { dp[i]=max(dp[i-2]+nums[i],dp[i-1]); } return dp[len-1]; } 213 打家劫舍II这个地方所有的房屋都围成一圈 输入: [2,3,2] 输出: 3 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 解答： 分类讨论，每次讨论时，前3个初始变量都需要考虑 int rob(vector&lt;int&gt;&amp; nums) { int n=nums.size(); if(n==0) return 0; vector&lt;int&gt; dp1(nums.size()); vector&lt;int&gt; dp2(nums.size()); if(n&lt;=3) return *max_element(nums.begin(),nums.end()); //偷第一家 dp1[0]=dp1[1]=nums[0]; dp1[2]=nums[0]+nums[2]; for(int i=3;i&lt;n-1;i++) dp1[i]=max(dp1[i-2]+nums[i],dp1[i-1]); //不偷第一家 dp2[0]=0; dp2[1]=nums[1]; dp2[2]=max(nums[1],nums[2]); for(int i=3;i&lt;n;i++) dp2[i]=max(dp2[i-2]+nums[i],dp2[i-1]); return max(*max_element(dp1.begin(),dp1.end()), *max_element(dp2.begin(),dp2.end())); } 3. 矩形二维DP062 不同的路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 解答： 转移方程dp[i][j]=dp[i-1][j]+dp[i][j-1]，注意边界的转移条件。 int uniquePaths(int m, int n) { vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n)); dp[0][0]=1; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) { if(i==0||j==0) dp[i][j]=1; else dp[i][j]=dp[i-1][j]+dp[i][j-1]; } return dp[m-1][n-1]; } 063 不同路径II现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 解答： 需要分类讨论。由于加了障碍物所以需要特别考虑边的情况，看看是否有东西堵住。需要注意：初始化要放到循环里面。 int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int m=obstacleGrid.size(); int n=obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,0)); for(int i=0;i&lt;m;i++) { for(int j=0;j&lt;n;j++) { if(obstacleGrid[i][j]==1) dp[i][j]=0; else if(i==0&amp;&amp;j==0) dp[i][j]=1; else if(i==0&amp;&amp;j!=0) dp[i][j]=dp[i][j-1]; else if(j==0&amp;&amp;i!=0) dp[i][j]=dp[i-1][j]; else dp[i][j]=dp[i-1][j]+dp[i][j-1]; } } return dp[m-1][n-1]; } 064 最小路径和给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 解答： 需要分类讨论。dp[i][j]+=dp[i][j-1];不是这样的，和前面区分好！ int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(); int n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, { vector&lt;int&gt;(n,0) }); for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) { if(i==0&amp;&amp;j==0) dp[i][j]=grid[i][j]; else if(i==0&amp;&amp;j!=0) dp[i][j]=dp[i][j-1]+grid[i][j]; else if(i!=0&amp;&amp;j==0) dp[i][j]=dp[i-1][j]+grid[i][j]; else dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i][j]; } return dp[m-1][n-1]; } 221 最大正方形在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 输入: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 输出: 4 解答： 和前面的路径题非常相似，但需要比较3个中的最小者。 int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { if (matrix.empty() || matrix[0].empty()) return 0; int M = matrix.size(); int N = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(M, vector&lt;int&gt;(N, 0)); for(int i=0;i&lt;M;i++) for(int j=0;j&lt;N;j++) { if(matrix[i][j]!=&#39;1&#39;) continue; if(i==0||j==0) dp[i][j]=1; else dp[i][j]=min(dp[i-1][j-1], min(dp[i-1][j],dp[i][j-1]))+1; } int res=0; for(auto x:dp) res=max(res,*max_element(x.begin(),x.end())); return res*res; } 4. 三角形二维DP118 杨辉三角给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 输入: 5 输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 解答： 两边要特别处理。每次需要resize一下，因为维度都不相同。 vector&lt;vector&lt;int&gt;&gt; generate(int numRows) { vector&lt;vector&lt;int&gt;&gt; dp(numRows); if(numRows==0) return dp; for(int i=0;i&lt;numRows;i++) { dp[i].resize(i+1); //对dp[i]resize而不是dp dp[i][0]=dp[i][i]=1; for(int j=1;j&lt;i;j++) //i=0被直接跳过 dp[i][j]=dp[i-1][j-1]+dp[i-1][j]; } return dp; } 119 杨辉三角II给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 输入: 3 输出: [1,3,3,1] 解答： 如果按照上一题的思路老实推的话，占用空间较大。这里选择原地修改的办法。 vector&lt;int&gt; getRow(int rowIndex) { vector&lt;int&gt; dp(rowIndex +1); if (rowIndex == 0) return dp; //i代表第几行 for (int i = 0; i &lt; rowIndex; i++) { dp.resize(i + 1); dp[0] = dp[i] = 1; //原地修改 for (int j = 1; j &lt; i; j++) dp[j] = dp[j] + dp[j - 1]; } return dp; } 120 三角形最小路径和给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 [ [2], [3,4], [6,5,7], [4,1,8,3] ] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 解答： 和前面的三角并没有什么不用，还是要注意两边，另外初始化的resize要特别注意。 int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { int rowSize = triangle.size(); if (rowSize == 0) return 0; int colSize = triangle[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(rowSize); dp[0].resize(1);//没有这一句内存会出错 dp[0][0] = triangle[0][0]; for (int i = 1; i &lt; rowSize; i++) { dp[i].resize(i + 1); dp[i][0] = dp[i - 1][0] + triangle[i][0]; dp[i][i] = dp[i - 1][i - 1] + triangle[i][i]; for (int j = 1; j &lt; i; j++) dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]; } return *min_element(dp[rowSize - 1].begin(), dp[rowSize - 1].end()); }","categories":[{"name":"算法","slug":"算法","permalink":"jiangren.work/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"jiangren.work/tags/Leetcode/"}]},{"title":"Leetcode题目总结2-双指针","slug":"Leetcode题目总结2-双指针","date":"2019-09-02T06:46:46.000Z","updated":"2020-03-31T08:56:43.000Z","comments":true,"path":"2019/09/02/Leetcode题目总结2-双指针/","link":"","permalink":"jiangren.work/2019/09/02/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%932-%E5%8F%8C%E6%8C%87%E9%92%88/","excerpt":"严格来说二分法也是双指针的一种，本文的双指针更具有一般性。","text":"严格来说二分法也是双指针的一种，本文的双指针更具有一般性。 1. 首尾双指针将两个指针分布在首尾，特别针对排序数组。 167 两数之和II-输入有序数组给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解答： 这道题在二分法那一篇中已经讲过了，现在我们改为用双指针。注意：使用双指针之前一定要确保排序。 vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int l =0,r=numbers.size()-1; if(numbers.size()==0) return vector&lt;int&gt;{-1,-1}; while(l&lt;r) { if(numbers[l]+numbers[r]==target) return vector&lt;int&gt;{l+1,r+1}; else if(numbers[l]+numbers[r]&lt;target) l++; else r--; } return vector&lt;int&gt;{-1,-1}; } 015 三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] 解答： 这道题不太一样，它需要收集所有的可能结果，并且要排除重复结果。而且要注意它本身无序，所以要排序。 最简单的办法是利用std::set的去重特性来做，不要忘了if(nums[i]+nums[l]+nums[r]==0)也要做l++和r--，否则会死循环。 vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { set&lt;vector&lt;int&gt;&gt; s; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(),nums.end()); if (nums.size() &lt; 2) return res; for(int i=0;i&lt;nums.size()-1;i++) { int l=i+1,r=nums.size()-1; while(l&lt;r) { if(nums[i]+nums[l]+nums[r]==0) { vector&lt;int&gt; tmp={nums[i],nums[l],nums[r]}; s.insert(tmp); l++;r--; } else if(nums[i]+nums[l]+nums[r]&lt;0) l++; else r--; } } for(auto x:s) res.push_back(x); return res; } 上面这种办法慢得离谱，酌情使用。常规做法是去重。要注意对i去重是用过了再去，因为可能出现[-1,-1,2]这种情况，如果按照if(nums[i] == nums[i + 1]) continue;就会导致结果不全。 注意push进入结果时，l和r也需要增加或减少，不然会超时。 对l和r去重时要注意，l++和r--用两次。 for去重时，应该要加入i&gt;0的判断，不然会溢出。 应该nums[l]==nums[l+1]而不是nums[l-1]==nums[l]这样会和i重合 vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; if (nums.size() &lt; 2) return res; for (int i = 0; i &lt; nums.size() - 2; i++) { //对i去重 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int l = i + 1, r = nums.size() - 1; int sum = 0 - nums[i]; while (l &lt; r) { if (nums[l] + nums[r] == sum) { res.push_back(vector&lt;int&gt;{nums[i], nums[l], nums[r]}); while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; l++; r--; } else if (nums[l] + nums[r] &lt; sum) { while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; l++; } else { while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; r--; } } } return res; } 016 最接近的三数之和给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为2. (-1 + 2 + 1 = 2). 解答： 相较于上一题，不用去除重复。需要加一个closest，表示最接近的数。每次循环都比较更新维护这个数。要注意closet不能设为INT_MAX，后面可能会溢出。 int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { if (nums.size() &lt; 3) return 0; sort(nums.begin(),nums.end()); int closet = accumulate(nums.begin(),nums.begin()+3,0); for(int i=0;i&lt;nums.size()-2;i++) { int l=i+1,r=nums.size()-1; while(l&lt;r) { int sum=nums[l]+nums[r]+nums[i]; if(sum==target) return sum; if(abs(sum-target)&lt;abs(closet-target)) closet=sum; else if(sum&lt;target) l++; else r--; } } return closet; } 018 四数之和给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 解答： 更015一样，多一层即可 vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt;&gt; res; if(nums.size()&lt;4) return res; sort(nums.begin(),nums.end()); for(int i=0;i&lt;nums.size()-3;i++) { if(i!=0&amp;&amp;nums[i]==nums[i-1]) continue; for(int j=i+1;j&lt;nums.size()-2;j++) { if(j!=i+1&amp;&amp;nums[j]==nums[j-1]) continue; int l=j+1,r=nums.size()-1; int sum12=nums[i]+nums[j]; while(l&lt;r) { int sum34=nums[l]+nums[r]; if(sum12+sum34==target) { vector&lt;int&gt; tmp{nums[i],nums[j],nums[l],nums[r]}; res.push_back(tmp); while(l&lt;r&amp;&amp;nums[l]==nums[l+1]) l++; while(l&lt;r&amp;&amp;nums[r]==nums[r-1]) r--; l++; r--; } else if(sum12+sum34&lt;target) { while(l&lt;r&amp;&amp;nums[l]==nums[l+1]) l++; l++; } else { while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; r--; } } } } return res; } 011 乘最多水的容器图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 解答： 面积=最短边*距离，要提高面积就有两种办法：增大最短边，保持长距离。让两边较小者往内移动，这样最有可能找到最大面积。同时，我们需要维护一个maxarea int maxArea(vector&lt;int&gt;&amp; height) { int l=0,r=height.size()-1; int maxarea = 0; while(l&lt;r) { int area = min(height[l],height[r])*(r-l); maxarea=max(maxarea,area); if(height[l]&lt;height[r]) l++; else r--; } return maxarea; } 075 颜色分类给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 解答： 典型的快排。采用了三指针，两个放首尾，index放中间。要保证index以前的都是有序的，我们构建两个标志zerotail和twohead分别表示最后一个0的下一个和第一个2的前一个，比如[0,1,1,2]，zerotail=1，twohead=2。 注意：当nums[index] == 2交换时，index不能盲目前进，因为不知道被换过来的是1还是2，需要放到下一轮进行检验。（由于我们保证了index以前都是有序的，所以和0做交换是安全的） 注意：去重时，必须要判断twohead &gt;= 0和zerotail &lt; nums.size()，不然会溢出。比如[2]，使得twohead=-1，下一次while就会导致nums[twohead]溢出。 注意：index小于等于twohead，要保证所有都检查完！ 注意：while (zerotail &lt; nums.size() &amp;&amp; nums[zerotail] == 0)顺序很重要，不然会溢出！ void sortColors(vector&lt;int&gt;&amp; nums) { int zerotail = 0, twohead = nums.size() - 1; while (zerotail &lt; nums.size() &amp;&amp; nums[zerotail] == 0) zerotail++; while (twohead &gt;= 0 &amp;&amp; nums[twohead] == 2) twohead--; int index = zerotail; while (index &lt;= twohead) { if (nums[index] == 0) std::swap(nums[zerotail++], nums[index++]); else if (nums[index] == 2) std::swap(nums[twohead--], nums[index]); else index++; } } 2. 同向双指针也可以称为滑动窗口法，使用滑动窗口时考虑三个问题：初始化窗口范围、终止条件、移动条件。 003 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 输入: &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 解答： 利用双指针l和r维护一个set，遇到不一样的就加进来，遇到一样的删尾巴。起始条件r=l=0，终止条件r==s.size() 当遇到重复时，并没有将前面的全部擦除，而是一个一个擦，这样很慢，但set没办法，它的迭代器不支持加减运算符。 int lengthOfLongestSubstring(string s) { set&lt;char&gt; cache; int l=0,r=0; int maxlen=0; while(r&lt;s.size()) { if(cache.find(s[r])==cache.end()) { cache.insert(s[r++]); maxlen=max(maxlen,r-l); } else cache.erase(s[l++]); } return maxlen; } 209 长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 输入: s = 7, nums = [2,3,1,2,4,3] 输出: 2 解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组 解答： 注意右边的边界，一定要加双判断，不然要越界。是while (sum &lt; s &amp;&amp; right &lt; len)不是if，所以可能会越界，不要搞晕了。 int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) { if (nums.empty()) return 0; int left = 0, right = 0, sum = 0, len = nums.size(); int res = INT_MAX; while (right &lt; len) { while (sum &lt; s &amp;&amp; right &lt; len) sum += nums[right++]; while (sum &gt;= s) { res = min(res, right - left); sum -= nums[left++]; } } return res == INT_MAX ? 0 : res; } 3. 其他双指针028 实现strStr()给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出: 2 解答： 这道题本质上应该用KMP算法，但一道easy级别的题目这么搞显然不合理。所以就用笨一点的分离双指针遍历好了。 两个指针，一个负责haystack搜索，找到合适的起始位置后，另一个也启动在needle和haystack一起搜索。 为空时，返回0，为了和C语言以及java中的API相对应。 int strStr(string haystack, string needle) { if (needle == &quot;&quot;) return 0; int i = 0; for (; i &lt; haystack.size(); i++) { if (haystack[i] != needle[0]) continue; int j = 0; for (; j &lt; needle.size(); j++) { if (haystack[i + j] != needle[j]) break; } if (j == needle.size()) return i; } return -1; } 088 合并两个有序数组给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 解答： 从后往前遍历，维护三个指针：i负责nums1的有效位置，j负责nums2，index负责插入位置。 最后要把剩余的j补上去。 void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int i=m-1,j=n-1; int len=nums1.size()-1; while(i&gt;=0&amp;&amp;j&gt;=0) { if(nums1[i]&gt;nums2[j]) nums1[len--]=nums1[i--]; else nums1[len--]=nums2[j--]; } while(j&gt;=0) nums1[len--]=nums2[j--]; }","categories":[{"name":"算法","slug":"算法","permalink":"jiangren.work/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"jiangren.work/tags/Leetcode/"}]},{"title":"Leetcode题目总结1-二分法","slug":"Leetcode题目总结1-二分法","date":"2019-09-01T08:42:36.000Z","updated":"2020-03-27T17:34:02.000Z","comments":true,"path":"2019/09/01/Leetcode题目总结1-二分法/","link":"","permalink":"jiangren.work/2019/09/01/Leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%931-%E4%BA%8C%E5%88%86%E6%B3%95/","excerpt":"二分法看似简单，实际上有很多问题都比较麻烦，比如：mid取整方式，区间开闭，序列是否有重复元素，会不会越界，会不会死循环······ 在网上参考了许多前辈的写法，各有优劣，但始终不是特别满意。这里主要参照知乎用户LightGHLi的写法，算是比较清楚覆盖面比较好的写法。","text":"二分法看似简单，实际上有很多问题都比较麻烦，比如：mid取整方式，区间开闭，序列是否有重复元素，会不会越界，会不会死循环······ 在网上参考了许多前辈的写法，各有优劣，但始终不是特别满意。这里主要参照知乎用户LightGHLi的写法，算是比较清楚覆盖面比较好的写法。 1. 二分法的解决思路从问题上说二分查找分三大类：无重复序列找具体值，无重复序列找上下界，有重复序列找上下界。将他们归为四类模板，皆针对不下降序列（有重复无重复都可以）。 看起来很复杂，其实记忆方法很简单： 情况 条件 求最小的i mid向下取整，l快r缓，返回r，if(nums[mid] &lt; target) l=mid+1 求最大的i mid向上取整，r快l缓，返回l，if(nums[mid] &gt; target) r=mid-1 取整方式有两种： int mid =(l+r) / 2; //向下取整 int mid=(l+r+1)/2; //向上取整 快慢方式： if (nums[mid]&lt;target) l=mid+1; //L快 else r=mid; if(nums[mid]&gt;target) r=mid-1; //R快 else l=mid; 要注意这种方式必须先判断nums是否为空，否则会越界！return的部分要写在while外面！ 后两种进化版相较于基本版有三点不同： 边界 快时取等，普通版是慢时取等if(nums[mid]&lt;key) l=mid+1; 返回条件为不等式 下面看一下实例展示： (1)求最小的i，使得a[i] = key，若不存在，则返回-1（下界） int l =0,r=nums.size()-1; while(l&lt;r) { int mid=(l+r)/2; if(nums[mid]&lt;key) l=mid+1; //慢时取等 else r=mid; } if(nums[r]==key) return r; return -1; (2)求最大的i，使得a[i] = key，若不存在，则返回-1（上界） int l=0,r=nums.size()-1; while(l&lt;r) { int mid=(l+r+1)/2; if(nums[mid]&gt;key) r=mid-1; else l=mid; } if(nums[l]==target) return l; return -1; 注意：下面这两种需要先判断边界，所谓的i只是指插入位置而已。 要快就要取等！这和前两种基本版是相反的。 (3)求最小的i，使得a[i] &gt; key，若不存在，则返回-1（上界） int l=0,r=nums.size()-1; if(key&gt;nums[r]) return r+1; if(key&lt;nums[l]) return l; while(l&lt;r) { int mid=(l+r)/2; if(nums[mid]&lt;=key) l=mid+1; //快时取等 else r=mid; } if(nums[r]&gt;key) return r; return -1; (4)求最大的i，使得a[i] &lt; key，若不存在，则返回-1（下界） int l=0,r=nums.size()-1; if(key&gt;nums[r]) return r; if(key&lt;nums[l]) return l-1; while(l&lt;r) { int mid=(l+r+1)/2; if(nums[mid]&gt;=target) r=mid-1; else l=mid; } if(nums[l]&lt;target) return l; return -1; 2. 寻找具体值033 搜索旋转排序数组假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2]，搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。 输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4 解答： 基本模板是：最小i等于key。需要特别注意if(nums[mid]&lt;target&amp;&amp;target&lt;=nums[r])只有一个等，请参考模板if(nums[mid]&lt;key) l=mid+1;这里也是没取等的，一定要注意！ 另一个地方是else //mid左边是有序的 不要写成else if，因为相等的情况也需要包含进去。 另外如果nums[l]&lt;=target这里去等了，则大if也要取等，比如： if(nums[mid]&gt;=nums[l]){ if(nums[mid]&gt;=target&amp;&amp;nums[l]&lt;=target){ r=mid; int search(vector&lt;int&gt;&amp; nums, int target) { if(nums.size()==0) return -1; int l=0,r=nums.size()-1; while(l&lt;r) { int mid=(l+r)/2; if(nums[mid]&lt;nums[r])//mid右边是有序的 { //target在mid和r之间，只有一个等 if(nums[mid]&lt;target&amp;&amp;target&lt;=nums[r]) l=mid+1; else r=mid; } else //mid左边是有序的 { //target在l和mid之间，有两个等 if(nums[l]&lt;=target&amp;&amp;target&lt;=nums[mid]) r=mid; else l=mid+1; } } if(nums[r]==target) return r; return -1; } 081 搜索旋转排序数组二假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。编写一个函数来判断给定的目标值是否存在于数组中。存在重复元素。 输入: nums = [2,5,6,0,0,1,2], target = 0 输出: true 解答： 假设nums=[4,5,6,3,3,3,3]，target=4输入，可知mid为3，r也为3，又因为我们判断if(nums[mid]&lt;nums[r])，所以认为左边是有序的，但[4,5,6,3]并不有序，所以结果错误，如果我们改为if(nums[mid]&lt;=nums[r])就能正常输出。但如果输入数组变成nums=[4,4,4,4,1,2,3]则我们的改动又会出错。 所以，为了防止上述情况的出现，我们要斩掉两边重复的数字！我们只是去掉多余的重复，所以不需要斩尽杀绝，采用if(n[i]==n[i+1]) i++;而不是if(n[i]=n[i-1]) i++; bool search(vector&lt;int&gt;&amp; nums, int target) { if(nums.empty()) return false; int l=0,r=nums.size()-1; while(l&lt;r) { while(l&lt;r&amp;&amp;nums[l]==nums[l+1]) l++; while(l&lt;r&amp;&amp;nums[r]==nums[r-1]) r--; int mid=(l+r)/2; if(nums[mid]&lt;nums[r]) { if(nums[mid]&lt;target&amp;&amp;target&lt;=nums[r]) l=mid+1; else r=mid; } else{ if(nums[l]&lt;=target&amp;&amp;target&lt;=nums[mid]) r=mid; else l=mid+1; } } if(nums[r]==target) return true; return false; } 074 搜索二维矩阵判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 输入: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 输出: true 解答： 两个二分搜索的组合，寻找一个最大的i，使得nums[i]&lt;=key；再加一个常规的二分搜索。易错点在于： 需要判断边界 col判断边界时要返回matrix.size()-1否则溢出 if(matrix[l][0]&lt;=target)和模板不一样，因为这里我们要找到nums[i]&lt;=key class Solution { public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { if(matrix.size()==0||matrix[0].size()==0) return false; int col=searchCol(matrix,target); if(col==-1) return false; int row=searchRow(matrix[col],target); if(row!=-1) return true; return false; } int searchCol(vector&lt;vector&lt;int&gt;&gt; matrix, int target){ int m=matrix.size(); if(matrix[0][0]&gt;target) return -1; if(matrix[m-1][0]&lt;target) return m-1; int l=0,r=m-1; while(l&lt;r){ int mid=(l+r+1)/2; if(matrix[mid][0]&gt;target) r=mid-1; else l=mid; } if(matrix[l][0]&lt;=target) return l; return -1; } int searchRow(vector&lt;int&gt; nums,int target){ int l=0,r=nums.size()-1; while(l&lt;r){ int mid=(l+r)/2; if(nums[mid]&lt;target) l=mid+1; else r=mid; } if(nums[r]==target) return r; else return -1; } }; 167 两数和—输入有序数组给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 解答： 要注意这道题l=i+1而不是l=i，另外返回vector&lt;int&gt;{i+1,r+1};才符合题目要求。 vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { if(numbers.empty()) return vector&lt;int&gt;{-1,-1}; if(target&lt;numbers[0]) return vector&lt;int&gt;{-1,-1}; for(int i=0;i&lt;numbers.size();i++) { int key = target-numbers[i]; int l=i+1,r=numbers.size()-1; while(l&lt;r) { int mid=(l+r)/2; if(numbers[mid]&lt;key) l=mid+1; else r=mid; } if(numbers[r]==key) return vector&lt;int&gt;{i+1,r+1}; } return vector&lt;int&gt;{-1,-1}; } 2. 返回某个位置034 在排序数组中查找元素的第一和最后一个位置给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值，返回 [-1, -1]。 输入: nums = [5,7,7,8,8,10], target = 8 输出: [3,4] 解答： 注意最后那里，不能写成if-else，否则会报错。 vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { int l = 0, r = nums.size() - 1; vector&lt;int&gt; res{ -1,-1 }; if (nums.empty()) return res; //search the min i while (l &lt; r) { int mid = (l + r) / 2; if (nums[mid] &lt; target) l = mid + 1; else r = mid; } if (nums[r] == target) res[0] = r; else return res; //search the max i (Notice: reset l and r) l = 0, r = nums.size() - 1; while (l &lt; r) { int mid = (l + r + 1) / 2; if (nums[mid] &gt; target) r = mid - 1; else l = mid; } if (nums[l] == target) res[1] = l; return res; //不能写为if-else } 035 搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。 输入: [1,3,5,6], 5 输出: 2 输入: [1,3,5,6], 2 输出: 1 解答： 翻译过来就是：找到最小的i，使得a[i] &gt;= key。这种类型需要改动最后return的判断，以及之前需要加上边界判断。 int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int l=0,r=nums.size()-1; if(nums.size()==0) return 0; if(nums[r]&lt;target) return r+1; if(nums[l]&gt;target) return l; while(l&lt;r) { int mid=(l+r)/2; if(nums[mid]&lt;=target) l=mid+1; else r=mid; } if(nums[r]&gt;=target) return r; return -1; } 069 X的平方根实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 解答： 需要变通一下：将x视为target，将mid*mid视为nums[mid]。这样就变为了：找最大的i使得的a[i]&lt;key int mySqrt(int x) { long l=0,r=50000; while(l&lt;r){ long mid=(l+r+1)/2; if(mid*mid==x) return mid; if(mid*mid&gt;x) r=mid-1; else l=mid; } return l; } 3. 未知具体值153 寻找旋转数组最小值假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。找到那个旋转点 输入: [3,4,5,1,2] 输出: 1 输入: [4,5,6,7,0,1,2] 输出: 0 解答： 基本思路就是如果nums[mid] &gt; nums[r]则最小值在右边，l往上提，反之r往下拉。由于预设的是所以l=mid+1，最后返回r（其实最后l==r，返回哪一个都一样） int findMin(vector&lt;int&gt;&amp; nums) { int l = 0, r = nums.size() - 1; while (l &lt; r) { int mid = (l + r) /2; //assume that //there is no dumplicated elements if (nums[mid] &gt; nums[r]) l = mid + 1; else r = mid ; } return nums[l]; } 162 寻找峰值峰值元素是指其值大于左右相邻值的元素。给定一个输入数组 nums，其中 nums[i] != nums[i+1]，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 输入: nums = [1,2,3,1] 输出: 2 解释: 3 是峰值元素，你的函数应该返回其索引 2。 输入: nums = [1,2,1,3,5,6,4] 输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2； 解答： int findPeakElement(vector&lt;int&gt;&amp; nums) { int l = 0, r = nums.size() - 1; while (l &lt; r) { int mid = (l + r) &gt;&gt; 1; //如果mid&lt;mid+1，峰肯定在右边 if (nums[mid] &lt; nums[mid + 1]) l = mid + 1; else r = mid; } return r; }","categories":[{"name":"算法","slug":"算法","permalink":"jiangren.work/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"jiangren.work/tags/Leetcode/"}]},{"title":"ORB_SLAM2源码解析-LoopClosing回环检测","slug":"ORB-SLAM2源码解析-LoopClosing回环检测","date":"2019-08-26T03:59:43.000Z","updated":"2019-12-30T16:49:36.000Z","comments":true,"path":"2019/08/26/ORB-SLAM2源码解析-LoopClosing回环检测/","link":"","permalink":"jiangren.work/2019/08/26/ORB-SLAM2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-LoopClosing%E5%9B%9E%E7%8E%AF%E6%A3%80%E6%B5%8B/","excerpt":"ORBSLAM三大线程之Tracking部分。","text":"ORBSLAM三大线程之Tracking部分。 1. 概述1.1 回环检测的意义在Slam14讲中提到过，回环检测可以显著减小累计误差的影响，但具体的作用机理并没有讲清楚，这里做一个补充。 由于机器移动过程中，误差会逐步累积导致其计算路径偏离实际路径（误差最明显的是尺度漂移），我们希望能将计算路径修正。 当检测出回环帧，确认路径闭环时，我们可以认为当前帧和回环帧应该是重合的。而实际情况却不相同，这中间差了一个相似变换矩阵S=[sRt01]S=[sRt01]，通过计算当前帧和回环帧的信息，我们能求出这个矩阵。再通过位姿传播原理，对之前所有的计算路径进行修正，最终再全局BA得到最优结果。 可以看到，如果不进行回环检测，画出的地图非常糟糕： 而通过回环检测，能有效提高地图效果： 1.2 总体结构回环检测的过程就是一个不断筛选择优的过程，总的来说主要的筛选条件有：词袋相似度检测，孤点检测，连续性检测，词袋特征点匹配检测，Sim3匹配检测，重投影匹配检测。 2. 检测回环DetectLoop这一步我们准确地检测出回环帧，检测的办法就是通过不断的筛选。筛选的过程可以分为两类：单帧对单帧的筛选，多帧对多帧的筛选。 前者是要筛选出和当前帧有可能回环关系的候选帧，包括二者的相似性，候选帧是否孤立等等。后者是一系列帧的比较，主要是检测连续性。 2.1 总体步骤 取出一帧 先从mlpLoopKeyFrameQueue队列中取一帧，这个队列是在LocalMapping的最后插入的关键帧。 检测与上一次回环的距离 如果距离上次闭环没多久（小于10帧），或者map中关键帧总共还没有10帧，则不进行闭环检测 计算当前帧与共视帧的Bow得分 这一步需要遍历所有共视关键帧呢，计算他们之间的Bow相似度得分，并得到最低得分minScore 找出闭环备选帧 和当前关键帧具有回环关系的关键帧,不应该低于当前关键帧的相邻关键帧的最低的相似度，且候选帧不应该孤立 连续性检测 实现多帧与多帧的闭环 2.2 找出闭环备选帧这一步为了在闭环检测中找到与该关键帧可能闭环的关键帧。筛选时有两个阈值：最大共词数，最大组得分。最大共词数用于筛选那些和当前帧长得不像的候选帧，最大组得分用于筛选长得像但孤立的候选帧。 找出和当前帧具有公共单词的所有关键帧 需要排除与当前帧链接的关键帧，把找到的候选帧放入lKFsSharingWords，同时记录当前帧与候选帧具有相同word的个数mnLoopWords 统计候选帧中的最大共词数 在上一步中所有闭环候选帧与当前帧的共次数都存在了mnLoopWords，遍历然后找到最大共词数。 挑选共次数合格的候选帧并计算得分 程序设定的条件是，共词数大于0.8最大共词数。然后调用DBoW2自带的score函数计算得分。将合格的候选帧和得分组成pair放入lScoreAndMatch 计算组得分去除孤立点 单单计算当前帧和某一关键帧的相似性是不够的，这里将与关键帧相连归为一组，计算累计得分。具体做法是： 构建组 利用pKFi-&gt;GetBestCovisibilityKeyFrames(10)得到最佳共视的10帧放入容器vpNeighs中形成一组。 计算组得分 遍历组，如果组中的帧满足上面步骤3的条件，则将它的分数累加。 记录最高得分 将所有组中的得分最高组的分数记录下来，作为阈值 组筛选 排除分数低于0.75倍最高分数的组。将筛选后的候选帧插入vpLoopCandidates 2.3 连续性检测需要实现多帧与多帧闭环，所以要做连续性检测。 如图所示，在闭环候选帧中，紫色那一帧连续被三个当前帧匹配到，所以它通过了合格性检测，可以被作为良好的候选帧。这种检测方法是将一系列当前帧和一系列闭环候选帧比较，所以是多帧对多帧闭环。 这里的”匹配”非常特殊，因为闭环候选帧不是连续的，他们的拓扑结构是这样： 彩色三角代表候选帧，蓝色圆形则为普通帧。我们将候选帧和与他有良好共视关系的普通帧圈起来，组成子候选组，后面比较连续性就是以组为单位比较。 检测时，当前帧如果和某一子候选组发生关系(和组员有良好共视关系)，那么这一子候选组连续性+1，并传递到下一个当前帧。如果当前帧没有和某子候选组发生关系，则此候选组连续性直接清零。如果能连续通过3次考验，则就算通过连续性检测。 3. Sim3计算ComputeSim3该函数计算相似变换，从mvpEnoughConsistentCandidates中找出真正的闭环帧mpMatchedKF。 这个部分要达成两个目的：第一，准确计算Sim变换矩阵，为后面的校正做铺垫；第二，进一步筛选闭环帧。 筛选分为三个阶段：阶段一利用词袋匹配的办法剔除，阶段二利用Sim3匹配剔除，阶段三利用重投影匹配剔除。 Step1 一次筛选 从闭环候选帧容器中取出一帧 之前通过连续性检测的结果都放在mvpEnoughConsistentCandidates，从这里面取出一帧。 当前帧与候选帧匹配 通过bow加速得到mpCurrentKF与pKF之间的匹配特征点，调用函数SearchByBoW，如果匹配的特征点少于20个，vbDiscarded[i]打上标记。 构造Sim3求解器 Ransac参数：迭代300次，至少20个内点才能通过。结束后重复执行1。 Step2 二次筛选 从候选帧容器取出一帧 如果vbDiscarded有标记，则放弃此帧，再取一帧。 求解Sim3 Step1.3构造的求解器存储在vpSim3Solvers[i]中，取出来，求解，迭代5次。如果得不到好的结果，打上discard标记。 Sim3弥补漏匹配 在Step1.2中进行了一次匹配，但由于尺度误差，很多特征点没有进行有效匹配，现在成功计算出了相似变换矩阵，用它进行弥补。调用函数SearchBySim3 Sim3优化 引入弥补后的匹配点，调用OptimizeSim3进行优化。如果优化得到的内点数大于20，则表示通过考验，此帧就是闭环帧。然后立马break。结束后重复执行1。 清理垃圾 如果把候选帧容器都遍历完了，依然没有任何一帧被确立为回环帧，则说明当前帧没有发生回环。清除mvpEnoughConsistentCandidates Step3 三次筛选 提取闭环帧的相连关键帧 把相连关键帧的所有MapPoint放入mvpLoopMapPoints 投影到当前帧匹配 调用SearchByProjection，统计匹配成功的点数 清理候选帧容器 如果匹配成功的点数nTotalMatches大于40，说明完成了最后的考验，返回true，清空容器mvpEnoughConsistentCandidates；若小于40，则表示闭环失败，清空容器，返回false。 4. 回环校正CorrectLoop通过前面的操作我们得到了最终的回环帧和Sim变换矩阵，现在要利用这些条件，进行全局校正。 校正之前需要先停止LocalMapping线程，停止全局BA。 4.1 主要步骤 更新连接 回环检测和Sim3计算需要消耗一定时间，这时候机器人依然在移动，依然有关键帧传输进来，因此在这一步需要重新更新一下帧与帧之间的共视关系。 Sim3优化位姿和地图点 主要是通过位姿传播原理，通过相对位姿关系，可以确定这些相连的关键帧与世界坐标系之间的Sim3变换。这一 步开始遍历相连关键帧 检查地图点冲突 检查当前帧与闭环帧的MapPoints是否存在冲突，对冲突的MapPoints进行替换或填补。有的时候可能会产生一个特征点对应两个地图点的情况，需要用Step3匹配的结果替换当前帧的结果。和下面不同的是：这里并没有做投影匹配，只是调用replace函数将重复的地图点踢掉了。 地图点融合 这一步跟上一步有点像，不同的是融合的对象是闭环时所有相连关键帧对应的地图点mvpLoopMapPoints。此处调用了Fuse函数，它通过投影作用，将mvpLoopMapPoints投影到校正后的当前帧，在阈值为4的范围内搜索。如果MapPoint能匹配关键帧的特征点，并且该点有对应的MapPoint，那么将两个MapPoint合并（选择观测数多的）。如果如果MapPoint能匹配关键帧的特征点，并且该点没有对应的MapPoint，那么为该点添加MapPoint。 更新连接 与第一步不同的是，这一步更新是因为闭环校正，第一步是因为新插入了关键帧。调用UpdateConnections后得到了新的连接关系，然后删除之前存在的一级连接关系和二级连接关系（防止冲突） 优化 EssentialGraph优化 对形成闭环后新生成的重要的关键帧的Sim3位姿进行优化。回环边不参与优化。调用OptimizeEssentialGraph优化，采用g2o方案 全局BA优化 上一步没有优化回环边，这里添加进去。新建了一个线程执行全局BA。 4.2 Sim3传播优化针对第二步Sim3优化位姿和地图点进行详细分析。 传播计算Sim3 位姿传播公式PoselPosec=SimlSimcPoselPosec=SimlSimc，我们只需要得到回环帧的位姿，当前帧的位姿，回环帧的Sim矩阵，就可以求出当前帧的Sim矩阵，把计算后的结果放在CorrectedSim3(这里只算出来，还没有校正) 修正MapPoint 利用Sim修正的结果计算地图点 校正关键帧位姿 将Sim3转换为SE3才能更新位姿 更新连接","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"}]},{"title":"ORB_SLAM2源码解析-LocalMapping建图","slug":"ORB-SLAM2源码解析-LocalMapping建图","date":"2019-08-25T08:47:25.000Z","updated":"2019-12-30T16:48:11.000Z","comments":true,"path":"2019/08/25/ORB-SLAM2源码解析-LocalMapping建图/","link":"","permalink":"jiangren.work/2019/08/25/ORB-SLAM2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-LocalMapping%E5%BB%BA%E5%9B%BE/","excerpt":"ORBSLAM三大线程之LocalMapping部分。","text":"ORBSLAM三大线程之LocalMapping部分。 1.概述1.1 图的概念Convisibility Graph 顶点：所有pose；边：pose-pose有共视关系(共视点大于15个) 换言之，将所有共视关系大于15的pose点连接起来，连接的edge的权重就是共视点的个数。图中绿色即为edge，红色为局部地图点，红色+黑色为全局地图点。 Spanning Tree 图论的概念，无向图能产生不同的生成树(spanning tree)，通过边能遍历所有节点。而所有边的权重加起来最小的生成树就是最小生成树。 这里的spanning tree是在无向图convisibility graph的基础上，以共视点最多为筛选标准形成的最小生成树。这里面同时还包含了 loop closure edges(红色) Essential Graph 包含了spanning tree以及convisibility graph中具有极佳共视关系(&gt;100)的边 1.2 总体结构 最后剔除冗余关键帧的条件有两个： 90%以上的MapPoints能被至少3个其他关键帧观测到。 他们都处在同一尺度下 2. 处理关键帧ProcessNewKeyFrame处理要达成四个目的： 计算该关键帧特征点的Bow映射关系 处理新匹配上的MapPoints 更新关键帧间的连接关系 将该关键帧插入到地图中 2.1 处理过程LocalMapping中有一个成员变量std::list mlNewKeyFrames是等待处理的关键帧列表。在tracking线程中，调用了void LocalMapping::InsertKeyFrame(KeyFrame *pKF)函数，向mlNewKeyFrames链表插入了元素。因此在处理关键帧前，要首先调用bool LocalMapping::CheckNewKeyFrames()检查等待关键帧链表是否为空。 处理时调用void LocalMapping::ProcessNewKeyFrame()，步骤如下: 从链表取出一帧 分三步：锁线程，取元素，删除顶部元素 计算关键帧特征点Bow映射关系 MapPoints和当前关键帧绑定 MapPoints分为两种情况：在tracking过程跟踪到的MapPoints；创建关键帧时创建的MapPoints。前者很可靠，直接为他们添加属性（添加观测者，平均观测方向和观测距离范围，更新最佳描述子），后者不可靠需要放到mlpRecentAddedMapPoints等待进一步检测。 更新关键帧间的连接关系 包括Covisibility图和生成树 插入关键帧到地图 2.2 更新连接关系UpdateConnections更新的目的是更新Covisibility图和生成树。步骤如下： 统计共视关系 共视关系保存在map KFcounter中，这个成员key是关键帧，value是权重（权重为其它关键帧与当前关键帧共视3d点的个数)，结构如下： 计算的方法借助了std::map mObservations，它记录了观测到该MapPoint的KF和该MapPoint在KF中的索引，是MapPoint的成员变量。 因为MapPoint是属于当前帧的，所以只需要执行KFcounter[obervation-&gt;first]++;就可以统计和当前关键帧共视的其他关键帧，以及共视点个数。 记录有良好共视关系的关键帧 搜索KFcounter中共视点个数大于阈值th(15)的关键帧，将他们放入vector &gt; vPairs容器中（将关键帧的权重写在前面，关键帧写在后面方便后面排序）。同时记录有最多共视点的关键帧，如果没有发现任何大于阈值的帧，就用最多共视点关键帧建立连接。 记录完后sort排序，按共视点个数从大到小。 更新图连接 更新与该关键帧连接的关键帧与权重mConnectedKeyFrameWeights = KFcounter;，将排序的vPairs拆开，容器mvpOrderedConnectedKeyFrames记录排序后的关键帧，容器mvOrderedWeights记录排序后的共视点个数（权重） 然后更新生成树，父节点为共视程度最高的那个关键帧mpParent = mvpOrderedConnectedKeyFrames.front();，并且父节点将本帧添加为子节点(建立双向连接关系)mpParent-&gt;AddChild(this); 3. 检查剔除地图点MapPointCulling对上一函数获取到的最新加入的局部地图点(创建关键帧时创建的MapPoints)mlpRecentAddedMapPoints进行检查，该地图点被创建后的三个关键帧里必须要经过严格的测试，这样保证其能被正确的跟踪和三角化。 删除过程调用SetBadFlag()干两件事情：删除点与帧的观测关系mObservations.clear()，删除帧与点的对应关系 for(map&lt;KeyFrame*,size_t&gt;::iterator mit=obs.begin(), mend=obs.end(); mit!=mend; mit++) { KeyFrame* pKF = mit-&gt;first; pKF-&gt;EraseMapPointMatch(mit-&gt;second);// 告诉可以观测到该MapPoint的KeyFrame，该MapPoint被删了 } for(map&lt;KeyFrame*,size_t&gt;::iterator mit=obs.begin(), mend=obs.end(); mit!=mend; mit++) { KeyFrame* pKF = mit-&gt;first; pKF-&gt;EraseMapPointMatch(mit-&gt;second);// 告诉可以观测到该MapPoint的KeyFrame，该MapPoint被删了 } Copy 删除条件如下: 已经是坏点 pMP-&gt;isBad()==true IncreaseFound / IncreaseVisible &lt; 25% 在SearchLocalMap（TrackLocalMap第二步），通过isInFrustum判断，就调用IncreaseVisible()。在TrackLocalMap中，通过优化，得到了内点和外点，如果点不是外点，说明这个点不仅能被观测，还能和特征点对应上，调用IncreaseFound()。跟踪到该MapPoint的Frame数相比可观测到该MapPoint的Frame数的比例需大于25% 小于观测阈值 从该点建立开始，到现在已经过了不小于2个关键帧，且观测数pMP-&gt;Observations()&lt;=cnThObs，其中cnThObs是针对不同类型相机设置的阈值单目为2，双目为3。 如果这个点已经过了3个关键帧而没有被剔除，则认为是质量高的点，因此没有SetBadFlag()，仅从队列中删除，放弃继续对该MapPoint的检测。 4. 创建地图点CreateNewMapPoints4.1 创建地图点一般步骤 找到共视程度最高的n帧 寻找与当前关键帧拥有最多共视点的n帧，n取值与相机有关，单目要求会高一些。 遍历共视关键帧 如果有新关键帧需要处理就处理新的 判断关键帧间距是否足够长 对于双目而言，间距需要大于双目相机本身的基线；对于单目而言，间距与场景深度中值之比小于0.01 特征匹配 通过极线约束限制匹配时的搜索范围，进行特征点匹配。所谓极线约束就是说同一个点在两幅图像上的映射，已知左图映射点PLPL，那么右图映射点PRPR 一定在相对于PLPL的极线上，这样可以减少待匹配的点数量。最后得到的匹配结果放在vector &gt; vMatchedIndices;中。 三角化生成地图点 4.2 三角化一般来说单目相机没有深度信息，需要依靠三角化获得，双目相机能自己获得深度信息。如果点太远，用相机模型获取深度就不是很合适。 如图所示，如果zz的值很大，则视差dd就会变得很小，误差的影响就非常大，所以这时候同样也需要三角化计算深度。 由相似三角形可知： z=\\frac{fb}{d}, \\ d=u_l-u_r三角化解法： 假设一个点在三维空间的坐标是$P=[X,Y,Z,1]^T$，其中$p,p’$是匹配好的特征点，他们在不同位姿相机坐标系下: sp=TP\\\\ s'p'=T'P其中$T$可以表示为： T=\\begin{bmatrix} t_1&t_2&t_3&t_4&\\\\ t_5&t_6&t_7&t_8&\\\\ t_9&t_{10}&t_{11}&t_{12}&\\\\ \\end{bmatrix} =\\begin{bmatrix} \\mathbf{t}_{0[4\\times1]}\\\\ \\mathbf{t}_{1[4\\times1]}\\\\ \\mathbf{t}_{2[4\\times1]} \\end{bmatrix}左边叉乘$p_1,p_2$($z$已被归一化为1)： \\begin{bmatrix} y\\mathbf{t}_2-\\mathbf{t}_1\\\\ \\mathbf{t}_0-x\\mathbf{t}_2\\\\ x\\mathbf{t}_1-y\\mathbf{t}_0\\\\ \\end{bmatrix}P=0将两个式子合并（第三个等式没有有效的约束）： AP=\\begin{bmatrix} y\\mathbf{t}_2-\\mathbf{t}_1\\\\ \\mathbf{t}_0-x\\mathbf{t}_2\\\\ y'\\mathbf{t}_2-\\mathbf{t}_1\\\\ \\mathbf{t}_0-x'\\mathbf{t}_2\\\\ \\end{bmatrix}P=0四个有效方程，P中含有三个未知数，这是一个超定方程，对矩阵AA奇异值分解SVD求最小二乘解。 具体步骤如下： 提取匹配特征点 从vMatchedIndices中提取 计算视差角 视差角需要计算两个：第一个是当前帧和参考帧的视差夹角，第二个是双目相机左镜头和右镜头的视差夹角。 对于帧与帧的视差角，利用匹配点反投影可以得到方向向量，利用直线夹角计算公式$\\theta=\\frac{\\vec{n_1}\\vec{n_2}}{|\\vec{n_1}||\\vec{n_1}|}$即可算得。对于左右镜头视差角利用近似的几何关系算得。$\\theta=\\arctan(\\frac{1}{2}B/Z)$ 计算3D点 单目相机采用三角化的办法，双目相机如果物点距离很远也采用三角化，距离很近直接采用深度（判断距离远近比较两个视差角） 检查3D点 检测生成的3D点是否在相机前方，检测重投影误差是否在可接受范围，检查尺度连续性 将3D点构造成MapPoint 老生常谈了，调用构造函数，然后添加属性 加入检测队列 这些MapPoints都会经过MapPointCulling函数的检验 5. 融合地图点SearchInNeighbors前面通过新加入的关键帧建立了一些地图点，然而这些地图点和以前建立的可能有重复，所以这一步需要剔除重复。 步骤: 获得最佳共视关系的邻接关键帧 找到当前帧一级相邻与二级相邻关键帧。一级邻接是指和当前帧有最佳共视关系的那些帧，数量根据单双目情况，有所不同。二级关键帧是和一级关键帧有良好共视关系的（程序中是最好的5帧） 正向融合 融合时有两个参数：帧，地图点。若存在重复，则删除；若不重复，添加属性成为正式的地图点，当然也要检查是否具有匹配关系。正向融合的帧是一二级邻接关键帧（遍历），地图点是当前关键帧产生的地图点。 反向融合 反向融合帧是当前关键帧，地图点是所有一二级关键帧对应的地图点（遍历）。 更新 更新当前帧MapPoints的最佳描述子，平均深度，平均观测主方向等属性。同时更新covisibility图，更新当前帧的MapPoints后更新与其它帧的连接关系。","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"}]},{"title":"ORB_SLAM2源码解析-Tracking追踪","slug":"ORB-SLAM2源码解析-Tracking追踪","date":"2019-08-22T01:45:25.000Z","updated":"2019-12-30T16:46:18.000Z","comments":true,"path":"2019/08/22/ORB-SLAM2源码解析-Tracking追踪/","link":"","permalink":"jiangren.work/2019/08/22/ORB-SLAM2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Tracking%E8%BF%BD%E8%B8%AA/","excerpt":"ORBSLAM三大线程之Tracking部分。","text":"ORBSLAM三大线程之Tracking部分。 1. 概述程序分为两种模式：SLAM模式和Localization模式，由变量mbOnlyTracking标记。SLAM模式中，三个线程全部都在工作，即在定位也在建图。而Localization模式中，只有Tracking线程在工作，即只定位，输出追踪结果（姿态），不会更新地图和关键帧。Localization模式主要用于已经有场景地图的情况下（在SLAM模式下完成建图后可以无缝切换到Localization模式）。Localization模式下追踪方法涉及到的关键函数是一样的，只是策略有所不同。 tracking中包含了5种状态： SYSTEM_NOT_READY 系统没有准备好的状态（启动后加载配置文件和词典时） NO_IMAGES_YET 当前无图像（图像复位、或者第一次运行时） NOT_INITIALIZED 有图像但是没有完成初始化 OK 正常时候的工作状态 LOST 系统已经跟丢了的状态（TrackLocalMap时匹配成功的MapPoint太少） tracking线程的目的有三个：获取精确的位姿，设置地图点，设置关键帧。程序中所有的内容都紧紧围绕这三个目的展开。 从流程上说，整个程序分为四大部分：初始化，初始追踪，精确追踪(TrackLocalMap)，加入关键帧。 整体流程如下图所示（深色表示后面有详细分析）： 2. 初始化2.1 双目初始化双目初始化包括了双目相机和RGBD相机（都把他们认为双目），双目初始化的目的是：设定初始位姿，获得初始关键帧，构造初始3D地图点。整个模块都是调用void Tracking::StereoInitialization()初始化。 设定初始位姿 需要先加一个判断if(mCurrentFrame.N&gt;500)整个函数只有在当前帧的特征点超过500的时候才会进行。初始位姿由Mat::eye构造，是单位变换矩阵。 构造初始关键帧 构造的时候需要用参数mCurrentFrame，mpMap，mpKeyFrameDB（关键帧数据库用于重定位和回环）。构造完成后需要将关键帧添加到mpMap地图中。 特征点构造地图点 判断是否具有正深度 反投影获得特征点三维坐标 将3D点构造成地图点 3D点是Mat类需要转化为MapPoint* 为构造的地图点MapPoint添加属性 观测到该MapPoint的关键帧；该MapPoint的最佳描述子；该MapPoint的平均观测方向和深度范围 向地图中添加MapPoint 为关键帧添加特征点和地图点的对应关系 将地图点和特征点序号添加到关键帧，并构建对应关系（哪个特征点可以观测到哪个3D点），f和e使用了同一个函数AddMapPoint但使用对象不同，e是对地图使用，f是对关键帧使用 在局部地图中添加该初始关键帧 除了使用InsertKeyFrame函数插入关键帧以外，每次添加关键帧还需做一些额外操作。 首先需要将当前帧变上一帧（上一帧=当前帧，上一关键帧ID=当前帧ID，上一关键帧=当前帧） 然后需要添加到局部关键帧集合和局部地图点集合，并设置参考关键帧（关键帧的参考关键帧就是自己） 把当前（最新的）局部MapPoints作为ReferenceMapPoints（画图用） 2.2 单目初始化单目的SLAM系统需要进行初始化，因为单帧图像数据并不能获取深度信息，也不能生成初始的地图。 早期的MonoSLAM，系统初始化利用一个已知尺寸的平面矩形实现，将相机摆放在该矩形前已知距离的地方，利用平面矩形的四个角点计算初始位姿。 单目SLAM地图初始化的目标是构建初始的三维点云。由于不能仅仅从单帧得到深度信息，因此需要从图像序列中选取两帧以上的图像，估计摄像机姿态并重建出初始的三维点云。 在ORB-SLAM中，作者并行计算基本矩阵和单应矩阵（用RANSAC方法），并评估两种方法的对称传输误差来选择合适的模型。完成之后，就会进行适当的分解，恢复出相机的位姿，并三角化生成初始地图点，最后通BA调整优化地图。如果选择的模型导致跟踪质量差，或者图像上的特征匹配较少，初始化就会迅速被系统丢弃，重新进行初始化，这保证了初始化的可靠性。 2.2.1 初始化的基本流程Track线程中的Tracking::MonocularInitialization()，这个函数完成了单目的初始化，并且初始化了地图。 构建初始器，并选择初始器的第一关键帧 如果初始器还未生成，则开始构建初始器。否则进入第二步。构建初始器：选取一帧提取到的特征点大数目于100的图像帧，构建初始器Initializer,并将当前帧图像设为初始化的第一帧，返回等待下一帧图像； 搜索第二关键帧 搜索当前帧如果特征点大于100个，就构建为初始化的第二帧，否则需要重新构造初始器(连续两帧大于100才算成功) 两帧匹配 调用匹配器matcher，如果初始化的两帧之间的匹配点太少，重新初始化 求取单应矩阵和基本矩阵 进入初始化器中的Initialize()的过程(主要在initialize.cpp中实现)，完成H矩阵和F矩阵的构建。构建的过程中会判断是构建H矩阵还是F矩阵，并根据构建的矩阵的质量判断是否初始化成果。如果矩阵的质量不好，那么就判断初始化失败，返回第二步，重新寻找初始化的第二帧。 删除无法三角化的点 无法三角化是指三角化的结果差的重投影差的离谱 位姿和坐标确定 删除那些无法进行三角化的匹配点。计算变换矩阵，将初始化的第一帧作为世界坐标系。 生成初始地图 初始化完成R,T还有三角化完成的3D点。接下来就是先删除无法进行三角化的点，然后将第一帧的位姿设为世界坐标的位姿，最后将将三角化得到的3D点包装成MapPoints，加入到新建立的地图CreateInitialMapMonocular()。 2.2.2 单目三角化点包装成地图点无论是单目还是双目，将特征点包装成地图点MapPoint都是必不可少的。区别在于双目镜头可以直接得到特征点的深度信息，因此包装的过程比较简单，所以直接放在初始化函数中StereoInitialization()，而单目的包装过程非常复杂，因此单独拿出来作为一个函数Tracking::CreateInitialMapMonocular() 首先就是用3D点构造MapPoint，之后为初始化用到的这两帧构建连接关系(双目只用到了一帧所以没有这一步)，最后需要对MapPoint的深度归一化。 3D点构造MapPoint 这一步跟双目构造大同小异 利用3D点创建一个MapPoint 为MapPoint添加属性(观测到的关键帧，最佳描述子，平均观测方向，深度范围) 向地图中添加MapPoint 更新关键帧间的连接关系 这里调用KeyFrame::UpdateConnections。在3D点和关键帧之间建立边，每个边有一个权重，边的权重是该关键帧与当前帧公共3D点的个数。 BA优化 优化的对象是当前地图mpMap，使用的是全局优化函数Optimizer::GlobalBundleAdjustemnt 深度归一化 计算归一化系数 首先计算MapPoint的平均深度，调用KeyFrame::ComputeSceneMedianDepth，然后求倒数 判断可行条件 平均深度大于0||当前帧观测到的地图点大于100，否则Reset 归一化变化矩阵 提取变换矩阵Tc2w的第三列，乘以归一化系数，将两帧之间的变换归一化到平均深度1的尺度下。 归一化地图点 把地图点的尺度也归一化到1，直接将点的世界坐标乘以归一化系数 深度归一化的步骤是：首先求得所有MapPoint的深度（相机坐标系下Z的大小）的中位数，再将所有点的深度除以中值深度。这样最后得到的点所有深度的平均深度（中值深度）就为1。 变换矩阵如下所示，只需要提取$R$的第三行，乘以点的世界坐标就可以得到点在相机坐标系下的深度，再加上平移量$t$，即可求得点的深度。 \\begin{bmatrix} a_1\\\\a_2\\\\a_3\\end{bmatrix} = \\begin{bmatrix} e_1^T e_1' & e_1^T e_2' & e_1^T e_3'\\\\e_2^T e_1'&e_2^T e_2'&e_1^T e_3'\\\\e_3^T e_1'&e_3^T e_2'&e_3^T e_3'\\end{bmatrix} \\begin{bmatrix} a_1'\\\\a_2'\\\\a_3'\\end{bmatrix} =Ra3. 追踪模型初始化完成后，对于相机获取当前图像mCurrentFrame，通过跟踪匹配上一帧mLastFrame特征点的方式，可以获取一个相机位姿的初始值；为了兼顾计算量和跟踪鲁棒性，处理了三种模型： TrackWithMotionModel 恒速模型 TrackReferenceKeyFrame 关键帧模型 Relocalization 重定位模型 这三种跟踪模型都是为了获取相机位姿一个粗略的初值，后面会通过跟踪局部地图TrackLocalMap对位姿进行BA优化。在使用三大追踪模型前我们需要更新上一帧的地图点。 3.1 TrackWithMotionModel该模型根据两帧之间的约束关系来求解估算位姿。假设物体处于匀速运动，那么可以用上一帧的位姿和速度来估计当前帧的位姿（认为这两帧之间的相对运动和之前两帧间相对运动相同）。上一帧的速度可以通过前面几帧的位姿计算得到。这个模型适用于运动速度和方向比较一致、没有大转动的情形。 如果是静止状态或者运动模型匹配效果不佳（运用恒速模型后反投影发现LastFrame的地图点和CurrentFrame的特征点匹配很少），通过增大参考帧的地图点反投影匹配范围，获取较多匹配后，计算当前位姿；而对于运动比较随意的目标，上述操作失效的。 在执行恒速模型前需要先判断一下：速度是否为空。速度为空意味着刚完成重定位，这时候只能采用关键帧模型。 3.1.1 更新地图点 UpdateLastFrame如果采用关键帧参考模型或重定位模型，参考的帧是关键帧，则其记录了足够丰富的地图点MapPoint信息，运动模型参考的上一帧可能是普通帧，包含的地图点信息非常少(mvpMapPoints包含的对应关系特别少)，这样不利于优化，所以我们需要为上一帧添加一些临时地图点用于优化（这些点之后会被删除）。这一步只针对于双目和RGBD相机（单目为什么不需要目前不清楚） 更新上一帧位姿 将上一帧的位姿设为参考关键帧的位姿(与上一帧有最多共视关系的参考帧) 获取上一帧具有正深度的特征点如果特征点的深度为负，说明根本不在视野范围内，无法重投影。 将特征点按深度从小到大排列 将距离较近的特征点包装为MapPoint 如果这个特征点已经是MapPoint了就不管，如果还不是，则需要创建并添加属性。满足两个条件时，更新结束：1.当前的点的深度已经超过了远点的阈值mThDepth(分割远近点的阈值=基线长度*比例系数/焦距)；2.已经拥有100个MapPoint 3.1.2 整体思路步骤如下： 更新地图点 根据前两帧速度计算当前位姿 v=\\frac{T_{n-2}*T_{n-1}}{t}\\\\ T_{n}=v*t*T_{n-1}​ 前两帧算速度，然后将速度乘以当前帧的前一帧计算粗略位姿。 重投影追踪 预设一个搜索半径th ，根据上一帧特征点对应的3D点投影的位置缩小特征点匹配范围，计算符合要求的特征点数目。实现方法在ORBmatcher.cpp中。如果得到跟踪点太少，则扩大搜索半径再来一次。如果还是不行则认为跟踪失败。 优化位姿 调用Optimizer::PoseOptimization优化 剔除outlier的关键点 在优化时，将区域分为outliers和inliers，我们将非常不可能的测量值（根据测量模型）称为外点（outlier）。在优化的过程中就有了对这些外点的标记，outlier不参与下次优化。具体检测方法有RANSAC和卡方分布法。 返回ture、false标志 如果成功匹配到的地图点数目（剔除外点后）数目大于等于10，则返回true，否则返回false 3.2 TrackReferenceKeyFrame假如motion model已经失效（返回false），那么首先可以尝试和最近一个关键帧去做匹配。毕竟当前帧和上一个关键帧的距离还不是很远。作者利用了bag of words（BoW）来加速匹配。首先，计算当前帧的BoW，并设定初始位姿为上一帧的位姿；其次，根据位姿和BoW词典来寻找特征匹配。 添加到地图中的帧称为关键帧(KeyFrame)，它构建在帧(Frame)的基础上，与地图(Map)关联。换句话说关键帧是对建图和定位比较重要的帧 步骤如下: 将当前帧的描述子转化为BoW向量 通过特征点的BoW加快当前帧与参考帧之间的特征点匹配 由ORBmatcher提供方法，采用SearchByBoW()专门计算，由vpMapPointMatches存储匹配关系。参考关键帧就是里当前帧最近的关键帧。如果匹配数目不够就退出，采用重定位模式。 将上一帧的位姿态作为当前帧位姿的初始值 这里需要拷贝两个东西：把上一帧的位姿mLastFrame.mTcw设置为本帧的位姿（不是上一个关键帧）。另外需要将与关键帧匹配得到的路标点vpMapPointMatches复制到mCurrentFrame.mvpMapPoints中。 优化位姿 优化3D-2D的重投影误差，依然是Optimizer.cpp内容 剔除outlier 返回true、false标志 3.3 Relocalization假如当前帧与最近邻关键帧的匹配也失败了，意味着此时当前帧已经丢失，无法确定其真实位置。此时，只有去和所有关键帧匹配，看能否找到合适的位置。 重定位的方法是利用词袋模型，在关键帧数据库中找到与当前图像帧相似的候选关键帧(与回环检测过程不同，回环检测使用参考关键帧去寻找闭环候选帧，这里使用普通帧去寻找候选）。 步骤如下: 将当前帧的描述子转化为BoW向量 初次筛选找到与当前帧相似的候选关键帧 通过KeyFrameDB.cc中的DetectRelocalizationCandidates进行候选，存储一个容器中vector，筛选的条件比较复杂 Bow二次筛选候选帧 这一步想要确定出满足进一步要求的候选关键帧并且为其创建pnp优化器。首先通过BoW进行匹配，筛选条件是单词匹配数，匹配数太小直接放弃此帧，如果合格就初始化PnPsolver。 遍历关键帧 通过Bow二次筛选，我们得到了一个小范围的候选帧。接下来对这些候选帧进行分析。后面每次操作都会判断内点数量nGood有没有超过50，超过了就直接bMatch=true，然后跳出，证明匹配成功 EPnP估算姿态 估算可以得到位姿和内点数，如果RANSAC迭代后发现效果不好，直接踢掉此帧 存入所有内点 将上一次筛选得到的关键帧的内点vbInliers存入mCurrentFrame.mvpMapPoints和sFound，这个sFound是一个set类型，表示找到地图点的集合。后续重投影搜索有用。 优化位姿 如果优化后内点太少，踢掉 删除外点更新地图 如果内点比较少，一系列骚操作 这里骚操作实在太多，结构见上图。总的来说就是不断重复：投影找额外点，然后让原本的内点加上额外点一起优化，再投影找额外点，再次共同优化。最后看结果内点有没有超过50，超过了就表示顺利匹配上了，否则说明这个候选帧不行，再选一个从a做起。值得注意的是，不管怎样，都要在最后检测nGood&gt;50 4. 局部地图匹配 TrackLocalMap4.1 总体思路上面的三个跟踪模型得到的位姿和地图点是粗略的。下面需要进一步优化地图和位姿。我们还需要通过TrackLocalMap判断我们追踪的结果怎么样，有没有跟丢。 姿态优化部分的主要思路是在当前帧和（局部）地图之间寻找尽可能多的对应关系，来优化当前帧的位姿。实际程序中，作者选取了非常多的关键帧和地图点。在跑Euroc数据集MH_01_easy时，几乎有一半以上的关键帧和地图点（后期&gt;3000个）会在这一步被选中。然而，每一帧中只有200~300个地图点可以在当前帧上找到特征匹配点。这一步保证了非关键帧姿态估计的精度和鲁棒性。 匹配的步骤如下: 更新局部关键帧和局部地图点 更新局部关键帧mvpLocalKeyFrames和局部地图点mvpLocalMapPoints 进一步筛选局部地图点 投影范围超出相机画面、观测视角和地图点平均观测方向相差60°以上、特征点的尺度和地图点的尺度不匹配。 再次优化 通过更新和抛弃，再次调用Optimizer::PoseOptimization优化得到位姿 更新当前帧的MapPoints被观测程度 通过优化我们得到了精确的位姿和当前帧对应的地图点。判断mvpMapPoints是不是外点（主要针对单目），如果不是外点，说明能被观测到，被观测统计量Found+1，匹配内点数mnMatchesInliers+1。这些参数用于判别是否跟踪成功。 判别是否跟踪成功 如果最近刚刚发生了重定位,那么至少跟踪上了50个点mnMatchesInliers我们才认为是跟踪上了。如果是正常的状态话只要跟踪的地图点大于30个我们就认为成功了。 4.2 更新局部关键帧和局部地图点首先第一步更新局部关键帧和局部地图点的目的是为了给优化提供样本。 局部地图包括：当前帧POS3，与当前帧有共视关系的关键帧POS2，与POS2有密切关系的关键帧POS1；局部关键帧对应的所有地图点X1X2。 4.2.1 更新局部关键帧在论文里作者定义局部地图关键帧的方式如下。简单来说局部关键帧包含了两个集合(set)：第一，与当前帧有共视关系(share map points)的关键帧，记作集合K1；第二，与集合K1在共视图中(covisibility graph)有良好共视关系的帧（具体见下），记作K2。 作者原文：This local map contains the set of keyframes K1, that share map points with the current frame, and a set K2 with neighbors to the keyframes K1 in the covisibility graph. K1比较好理解，凡是和当前帧有共同的MapPoint的关键帧都可以被归为这一集合。K2比较麻烦，总体来说是和K1比较密切的帧的集合。这里的密切有三种条件： 与K1有良好共视关系的子关键帧(作者选取了最佳共视的10帧) K1中元素的子关键帧 K1中元素的父关键帧 满足其中一种条件的关键帧都可以被归为K2集合。 在处理完局部关键帧后，还需要添加参考关键帧。与当前帧共视程度最高（有最多share map points）的关键帧作为参考关键帧。 4.2.2 更新局部地图点比较简单。上一步得到了所有的局部关键帧，这一步只需要把局部关键帧中对应的MapPoints全部添加到mvpLocalMapPoints中即可。注意，在添加之前需要将mvpLocalMapPoints清空才行。 4.3 进一步筛选局部地图点4.2得到了一大堆局部地图点，这些点有很多是不能用的，所以需要进一步做筛选。 遍历当前帧mvpMapPoints MapPoint一定是没有问题的，是我们可以用来做优化样本的，所以在这一步标记一下，之后不参与判断，默认放行。需要注意的是：MapPoint是地图点，在tracking三大模型中经过层层筛选得到的，一帧有很多特征点，只有少数才能被遴选为MapPoint。因此除了MapPoint，当前帧还有很多特征点和其他帧有共视关系，这就是我们需要在这一步筛选的。 将所有局部地图点投影到当前帧，判断是否在视野内 检查这个地图点在当前帧的相机坐标系下，是否有正的深度。如果是负的，就说明它在当前帧下不在相机视野中。 将MapPoint投影到当前帧, 并判断是否在图像内（即是否在图像边界中） MapPoint到相机中心的距离是否在范围内。如果里的太远或者太近这个点就不合适。 计算当前视角和平均视角夹角的余弦值, 需要小于60°才能合格 经过4个关卡的重重考验后，这些MapPoint被认为能够作为最后优化的样本。然后为他们添加一些信息：点到光心的距离；置位标记（true表示要被投影）；这个点在图像中的投影坐标；当前视角和平均视角夹角的余弦值。 为合格的地图点确立投影匹配关系 要先设立一个阈值th，如果匹配关系落在阈值内就表示匹配成功，正式成为优化样本一员。 4.4 优化这里采用的是g2o优化器优化，顶点是当前位姿和合格地图点，需要进行4次优化。 优化图如上所示，顶点有当前帧位姿和所有的合格地图点，其中地图点固定。这里采用的是EdgeSE3ProjectXYZOnlyPose和EdgeStereoSE3ProjectXYZOnlyPose类型，这是g2o中提供的模板，用于优化位姿，地图点默认固定。 优化结束后就进行信息记录和判别是否追踪成功，具体内容见4.1总体思路部分。 5. 创建新的关键帧ORB-SLAM中关键帧的加入是比较密集的，这样确保了定位的精度，同时在LocalMapping线程最后会进行关键帧的剔除，确保了关键帧的数量不会无限增加，不会对large scale的场景造成计算负担。 以下条件必须同时满足，才可以加入关键帧： 距离上一次重定位距离至少1S 当前帧跟踪至少50个点，保证精度 当前帧跟踪到LocalMap中参考帧的地图点数量少于90%，确保关键帧之间有明显的视觉变化 局部地图线程空闲 或者 距离上一次加入关键帧过去了20帧(如果需要关键帧插入过了20帧。而LocalMapping线程忙，则发送信号给线程，停止局部地图优化，使得新的关键帧可以被及时处理) 调用函数创建完成后，将关键帧传递到LocalMapping线程。 注意：这里只是判断是否需要将当前帧创建为关键帧，并没有真的加入全局地图，因为Tracking线程的主要功能是局部定位，而处理地图中的关键帧、地图点，包括如何加入、如何删除的工作是在LocalMapping线程完成的，Tracking负责localization，LocalMapping负责Mapping。 5.1 是否需要加入关键帧首先是NeedNewKeyFrame()判断是否加入关键帧： 判断是否重定位 由于插入关键帧过程中会生成MapPoint，因此用户选择重定位后地图上的点云和关键帧都不会再增加。 判断局部地图是否被闭环检测使用 如果局部地图被闭环检测使用，则不插入关键帧 获取参考关键帧跟踪到的MapPoints数量 在 UpdateLocalKeyFrames 函数中会将与当前关键帧共视程度最高的关键帧设定为当前帧的参考关键帧 查询localMapper是否繁忙 统计可以添加和跟踪到地图中的的MapPoint数量 决策是否插入关键帧（必须满足a-e所有条件） 长时间没有插入关键帧 localMapper处于空闲状态 地图点匹配数目和跟踪成功比例很小，即将撑不下去 radio=被关键帧观测到的mappoints数/总共可以添加的mappoints数(如果是近点,并且这个特征点的深度合法,就可以被添加到地图中)；这个radio比例太小，说明track is weak 与之前的参考帧重复度不高 共视的地图点不是很多 如果localMapper繁忙，等待队列等待数需要小于3 前面判断localMapper是否繁忙，用的是mpLocalMapper-&gt;AcceptKeyFrames()也就是说是否接受关键帧。这里判断的是关键帧等待队列是否阻塞严重(&gt;3) 5.2 创建关键帧之后利用CreateNewKeyFrame()创建关键帧 构造关键帧 当前关键帧设置为当前帧的参考关键帧 关键帧的参考关键帧就是他自己。 根据Tcw计算额外矩阵 普通帧为了节省计算量，只计算了TcwTcw相机坐标到世界坐标的转化（也就是相机变换矩阵或者相机姿态），而关键帧由于在很多地方有特殊用途所以还需要额外计算一些矩阵。 mRcw 旋转矩阵 mRwc 旋转矩阵的逆 mtcw 平移向量 mOw 光心在世界坐标系下的坐标 获取正深度特征点 用于重新构建MapPoint 按照深度从小到大排序 将距离比较近的点包装成MapPoints 如果当前帧中无这个地图点，或者是刚刚创立（观测者Observations&lt;1），就在全局地图中创建地图点。每次创建MapPoint都需要添加属性。如果当前已经处理了超过100个点且深度已超过阈值，就停止。 插入关键帧 执行插入关键帧的操作,其实也是在列表中等待。同时需要然后现在允许局部建图器停止，并且让当前帧成为新的关键帧。","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"}]},{"title":"单应矩阵与对极几何","slug":"单应矩阵与对极几何","date":"2019-08-19T11:26:53.000Z","updated":"2019-12-30T16:41:56.000Z","comments":true,"path":"2019/08/19/单应矩阵与对极几何/","link":"","permalink":"jiangren.work/2019/08/19/%E5%8D%95%E5%BA%94%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/","excerpt":"本文围绕F基础矩阵、E本质矩阵、H单应矩阵这三个矩阵展开。","text":"本文围绕F基础矩阵、E本质矩阵、H单应矩阵这三个矩阵展开。 1. 对极几何原理假设相机1运动到了相机2，两个相机的中心分别是$O_1,O_2$，成像得到了图像$I_1,I_2$。图像1中有一个特征点$p_1$，在图像2中对应了$p_2$（根据特征匹配的结果）。 也就是说通过两个图像的像素位置来估计相机的运动。 连线$\\vec{O_1p_1}$和连线$\\vec{O_1p_1}$在三维空间中交于点P，通过$O_1O_2P$这三个点可以形成一个平面，称之为极平面（Epipolar plane）,$O_1O_2$被称为基线(Baseline)，基线与图像平面的交点为$e_1e_2$记作极点(Epipoles)，$l_1l_2$称之为极线(Epipolar line) 假设第一个相机的P点的相机坐标系$P=[X,Y,Z]$。由于第一个相机的中心作为世界坐标系的原点，也就是说第一个相机没有旋转和平移，通过小孔相机模型可得： p_1 = KP，p_2=K(RP+t)从$p_1 = KP$可以得到$P=K^{-1}p_1$，带入第二个式子可以得到： p_2=K(RK^{-1}p_1 + t)两边同时左乘$K^{-1}$，可以得到 K^{-1}p_2=RK^{-1}p_1 + t假设$x_1=K^{-1}p_1,x_2=K^{-1}p_2$，尝试带入可得： x_2=Rx_1+t左右两边同时乘以反对称矩阵$t^{\\land}$，由于$t^{\\land}t=0$，所以： t^{\\land}x_2=t^{\\land}Rx_1两边再同时左乘$x_2^T$ x_2^Tt^{\\land}x_2=x_2^Tt^{\\land}Rx_1由于$t^\\land x_2$是向量$t$和向量$x_2$的叉积，得到的结果同时垂直于两向量，所以左边等于0，于是： x_2^Tt^{\\land}Rx_1=0替换掉$x$: p_2^TK^{-T}t^{\\land}RK^{-1}p_1=0这就是对极约束。令$F$来表示中间的基础矩阵： p_2^TFp_1 = 0 , 其中 F=K^{-T}t^{\\land}RK^{-1}由于相机内参已知，所以实际上我们可以用本质矩阵$E$来表示我们要求的对象： E = t^{\\land}R2. 单应矩阵单应(Homography)是射影几何中的概念，又称为射影变换。它把一个射影平面上的点(三维齐次矢量)映射到另一个射影平面上，并且把直线映射为直线。换句话说，单应是关于三维齐次矢量的一种线性变换，可以用一个3×3的非奇异矩阵$H$表示： x_1=Hx_2假设已经取得了两图像之间的单应，则可以通过单应矩阵H将两幅图关联起来： \\left(\\begin{array}{c}u_1\\\\v_1\\\\1\\end{array}\\right) = H\\left(\\begin{array}{c}u_2\\\\v_2\\\\1\\end{array}\\right)假设使用同一相机在不同的位姿拍摄同一平面，如下图： 上图表示场景中的平面π在两相机的成像，设平面π在第一个相机坐标系下的单位法向量为$N$，其到第一个相机中心（坐标原点）的距离为$d$，则平面$π$可以表示为： N^TX_1 = d \\\\ \\frac{1}{d}N^TX_1 = 1,\\forall X_1 \\in \\pi其中，$X_1$是三维点$P$在第一相机坐标系下的坐标，其在第二个相机坐标系下的坐标为$X_2$， 2.1 平移+旋转假设， X_2 = RX_1 + T将他们结合起来： X_2 = RX_1 + T\\frac{1}{d}N^TX_1\\\\ =(R+T\\frac{1}{d}N^T)X_1=H'X_1因此就得到了同一个平面两个不同坐标系的单应矩阵： H' = R+T\\frac{1}{d}N^T上述的单应矩阵在相机坐标系下，将它转化为像素坐标： x_1 = KX_1,x_2 = KX_2\\\\ H = K(R+T\\frac{1}{d}N^T)K^{-1}这个公式和对极几何非常像，本质上也是利用了对极几何的约束性质，基础矩阵的另一种表现形式。 \\begin{align*} X_2&=RX_1+T\\\\ \\\\ E_1 &= T^{\\land}R\\\\ E_2 &= R+T\\frac{1}{d}N^T \\end{align*}2.2 只有旋转由于没有平移，所以点在相机坐标系下的三维坐标没有变： p_1 = KP \\ ,p_2 = KRP\\\\ P=K^{-1}p_1,p_2 = KRK^{-1}p_1最后结果为： H = KRK^{-1}在相机只有旋转而没有平移的情况下，两视图的对极约束就不再适用，这时可以使用单应矩阵$H$来描述两个图像像点的对应关系。 在这种情况下，不存在参数$d$，也就是说两图像点的匹配不依赖于三维点的深度信息，无法使用三角法重构出三维点在世界坐标系中的三维坐标。 3. 基础矩阵解法3.1 八点法考虑它的尺度等价性(按比例表示即可，不需要具体数值)，因此这个约束条件可以减少一个未知数，只需要8对匹配的点对就可以求解出两视图的基础矩阵$F$，这就是八点法 假设一对匹配的像点$p_1=[u_1,v_1,1]^T,p_2=[u_2,v_2,1]^T$，带入式子： [u_1,v_1,1]\\left[\\begin{array}{ccc}f_1&f_2&f_3\\\\f_4&f_5&f_6\\\\f_7&f_8&f_9\\end{array}\\right] \\left[\\begin{array}{c}u_2\\\\v_2\\\\1\\end{array}\\right] = 0把基础矩阵F的各个元素当作一个向量处理: f = [f_1,f_2,f_3,f_4,f_5,f_6,f_7,f_8,f_9]就可以改写为： [u_1u_2,u_1v_2,u_1,v_1u_2,v_1v_2,v_1,u_2,v_2,1]\\cdot f = 0 \\left[ \\begin{array}{ccccccccc} u_1^1u_2^1&u_1^1v_2^1&u_1^1&v_1^1u_2^1&v_1^1v_2^1&v_1^1&u_2^1&v_2^1&1\\\\ u_1^2u_2^2&u_1^2v_2^2&u_1^2&v_1^2u_2^2&v_1^2v_2^2&v_1^2&u_2^2&v_2^2&1\\\\ u_1^3u_2^3&u_1^3v_2^3&u_1^3&v_1^3u_2^1&v_1^3v_2^1&v_1^3&u_2^3&v_2^3&1\\\\ \\cdots&\\cdots&\\cdots&\\cdots&\\cdots&\\cdots&\\cdots&\\cdots&\\cdots \\\\ u_1^8u_2^8&u_1^8v_2^8&u_1^8&v_1^8u_2^8&v_1^8v_2^8&v_1^8&u_2^8&v_2^8&1 \\end{array} \\right] \\left[ \\begin{array}{c} f_1\\\\f_2\\\\f_3\\\\f_4\\\\f_5\\\\f_6\\\\f_7\\\\f_8\\\\f_9 \\end{array} \\right]=0求解上面的方程组就可以得到基础矩阵各个元素了。 求得本质矩阵$E$的解以后，需要得到$R$和$t$，这个过程使用奇异值分解(SVD)： E=U\\varSigma V^{T}其中$U$和$V$都是正交矩阵，$\\Sigma$为对角矩阵。解出来的结果有四种情况： 只有第一种解中，P 在两个相机中都具有正的深度。因此，只要把任意一点代入四种解中，检测该点在两个相机下的深度，就可以确定哪个解是正确的了。 3.2 RANSAC法RANSAC做出了如下基本假设： 数据是由局内点组成，例如：数据的分布可以用一些模型参数来解释； 局外点是不能适应该模型的数据； 除此之外的数据属于噪声。 局外点产生的原因有：噪声的极值；错误的测量方法；对数据的错误假设。 一个简单的例子就是从一组观测数据中找出合适的二维直线。假设观测数据中包含局内点和局外点，其中局内点近似的被直线所通过，而局外点远离直线。 简单的最小二乘法不能找到适应于局内点的直线，原因是最小二乘法尽量去适应包括局外点在内的所有点。相反，RANSAC能得出一个仅仅利用局内点计算出模型，并且概率还足够高。但是，RANSAC并不能保证结果一定正确，为了保证算法有足够高的合理概率，我们必须小心的选择算法的参数。图示如下所示： 具体步骤如下： 有一个模型适应于假设的局内点，即所有的未知参数都能从假设的局内点计算得出； 用1中得到的模型去测试所有的其他数据，如果某个点适应于估计的模型，认为它也是局内点。 如果有足够多的点被归类于假设的局内点，那么估计的模型就足够合理； 然后，用所有假设的局内点去重新估计模型，因为它仅仅被初始的假设局内点估计过； 最后，通过估计局内点与模型的错误率来评估模型。 优缺点： 优点：能鲁棒的估计模型参数。例如，它能从包含大量局外点的数据集中估计出高精度的参数。 缺点：计算参数的迭代次数没有上限，如果设置迭代次数的上限，得到的结果可能不是最优的结果，甚至可能得到错误的结果。 将RANSAC应用于基础矩阵的求解中，我们知道： \\left(\\begin{array}{c}x_2\\\\y_2\\\\1\\end{array}\\right)=\\left(\\begin{array}{ccc}H_{11}&H_{12}&H_{13}\\\\H_{21}&H_{22}&H_{23}\\\\H_{31}&H_{32}&H_{33}\\end{array}\\right)\\left(\\begin{array}{c}x_1\\\\y_1\\\\1\\end{array}\\right)\\Leftrightarrow p_2= Hp_1RANSAC算法从匹配数据集中随机抽取四个样本并保证这四个样本之间不共线。计算出单应性矩阵，然后利用这个模型测试所有数据，并计算满足这个模型数据点的个数和投影误差（即代价函数）若此模型为最优模型，则对应的代价函数最小： \\sum_{i=1}^{n}((x_i^{}{h_{11}x_i+h_{12}y_i+h_{13} \\over h_{31}x_i+h_{32}y_i+h_{33} })^2+(y_i^{}{h_{21}x_i+h_{22}y_i+h_{23} \\over h_{31}x_i+h_{32}y_i+h_{33} })^2)结果如下：","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"数学","slug":"数学","permalink":"jiangren.work/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"SIFT特征检测","slug":"SIFT特征检测","date":"2019-08-19T02:44:35.000Z","updated":"2019-12-30T16:33:03.000Z","comments":true,"path":"2019/08/19/SIFT特征检测/","link":"","permalink":"jiangren.work/2019/08/19/SIFT%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B/","excerpt":"本文详细介绍了SIFT特征检测的原理，以及相关的预备知识。","text":"本文详细介绍了SIFT特征检测的原理，以及相关的预备知识。 1. 概述SIFT全称Scale Invariant Feature Transform，即尺度不变特征变换。相较于Harris和Fast这两种角点特征检测手段，SIFT专注于那些尺度不变的特征。 Harris算子不是尺度不变的，当图像变小时，检测结果的语义也会发生变化。 SIFT被设计出来的目的就是解决特征检测过程中经常遇到的尺度不变问题和旋转不变问题。 SIFT所查找到的关键点是一些十分突出，不会因光照，仿射变换和噪音等因素而变化的点，如角点、边缘点、暗区的亮点及亮区的暗点等。 基本的算法流程是： 尺度空间极值点检测 关键点精确定位 确定方向 确定描述子 2. 高斯金字塔与高斯差分金字塔高斯金字塔和高斯差分金字塔如下图所示： 首先我们把输入的原图扩大一倍，由该图像进行高斯模糊的得到的第0组第0层图像设定为基准图像，设它的尺度为$\\sigma_0$，称之为基准层尺度。则第0组第1层尺度为$k\\sigma_0$，第0组第2层尺度为$k^2\\sigma_0$，以此类推。 那么第0组中的图像的尺度为： \\sigma = k^r\\sigma_0 ,r=0,1,...,s-2第1组的第0层图像倒数第三张图像采样得到，若令$k=2^\\frac{1}{s}$，则其相对于输入图像来说，尺度为$2\\sigma_0$。 上述规律总结如下： 第$o$组第$r$层图像相对于输入图像的尺度为： \\sigma = 2^ok^r\\sigma_0\\\\ 其中，o = 0,1,2,...;r = 0,1,2,...,s+2该图像相对于本组中的基准图像的尺度为： \\sigma = k^r\\sigma_0而差分金字塔(DOG)就比较简单了，直接同组相邻的图像相减即可。 3. 算法流程3.1 检测极值点基本思路是在DOG金字塔中检测最大最小值点 具体检测思路是： 检测点和周围8个邻域点比较是否为极值点 检测点和尺度空间上下两层共计18个邻域点比较是否为极值点 同时满足这两个条件才可以被初步认定为特征点。 3.2 关键点精确定位我们之前找到的极值点也就是离散空间中的极值点，但是离散空间中的极值点并不是真实的连续空间中的极值点。所以需要对DoG空间进行拟合处理，以找到极值点的精确位置和尺度。 我们得到的极值点是一个三维向量，包括它所在的尺度$\\sigma$以及所在尺度图像中的位置坐标，即$X = (x,y,\\sigma)$，泰勒展开即可得到 f(\\left[\\begin{matrix}x\\\\y\\\\\\sigma\\end{matrix}\\right]) \\approx f(\\left[\\begin{matrix}x_0\\\\y_0\\\\\\sigma_0\\end{matrix}\\right]) + [\\frac{\\partial f}{\\partial x} \\frac{\\partial f}{\\partial y} \\frac{\\partial f}{\\partial \\sigma}]\\left(\\left[\\begin{matrix}x\\\\y\\\\\\sigma\\end{matrix}\\right]-\\left[\\begin{matrix}x_0\\\\y_0\\\\\\sigma_0\\end{matrix}\\right]\\right) + \\\\\\frac{1}{2}\\left(\\left[x \\quad y \\quad \\sigma\\right] - \\left[x_0 \\quad y_0 \\quad \\sigma_0\\right]\\right)\\left[\\begin{matrix}\\frac{\\partial^2 f}{\\partial x \\partial x} & \\frac{\\partial^2 f}{\\partial x \\partial y} & \\frac{\\partial^2 f}{\\partial x \\partial \\sigma} \\\\ \\frac{\\partial^2 f}{\\partial x \\partial y}&\\frac{\\partial^2 f}{\\partial y \\partial y}&\\frac{\\partial^2 f}{\\partial y \\partial \\sigma}\\\\ \\frac{\\partial^2 f}{\\partial x \\partial \\sigma}&\\frac{\\partial^2 f}{\\partial y \\partial \\sigma}&\\frac{\\partial^2 f}{\\partial \\sigma \\partial \\sigma}\\end{matrix}\\right]\\left(\\left[\\begin{matrix}x\\\\y\\\\\\sigma\\end{matrix}\\right]-\\left[\\begin{matrix}x_0\\\\y_0\\\\\\sigma_0\\end{matrix}\\right]\\right)若写成矢量形式，则为： f(X) = f(X_0）+\\frac{\\partial f^T}{\\partial X}(X- X_0)+\\frac{1}{2}(X-X_0)^T\\frac{\\partial^2 f}{\\partial X^2}(X-X_0)此处，$X_0$表示中心，$X$表示拟合后连续空间的差值坐标，设$\\hat{X} = X - X_0$表示偏移量。令导数为0则有： \\hat{X} = -\\frac{\\partial^2 f^{-1}}{\\partial X^2}\\frac{\\partial f}{\\partial X}带入原公式： f(\\hat{X}) = f(X_0) + \\frac{1}{2}\\frac{\\partial f^T}{\\partial X} \\hat{X}若上式得到的偏移量大于阈值，则把位置移动到拟合后的新位置继续进行迭代求偏移量，若迭代过一定次数后偏移量仍然大于阈值，则抛弃该点。 有些极值点的位置是在图像的边缘位置的，因为图像的边缘点很难定位，同时也容易受到噪声的干扰，我们把这些点看做是不稳定的极值点，需要进行去除。 判定办法和Harris的办法很相似，设图像某点处的黑塞矩阵为 M=\\left[ \\begin{matrix} I_x^2& I_xI_y \\\\ I_xI_y & I_y^2\\end{matrix} \\right] = \\left[ \\begin{matrix} A& C\\\\ C& B\\end{matrix} \\right]则有： detM=\\lambda_1 \\lambda_2=AB-C^2\\\\ traceM=\\lambda_1 + \\lambda_2 = A+B如果两个特征值相差特别大，就认为是边缘，排除。 3.3 方向计算选取半径为$r$的区域作为邻域，计算每个像素的梯度幅角： \\theta(x,y) = arctan\\left(\\frac{L(x,y+1)-L(x,y-1)}{L(x+1,y)-L(x-1,y)}\\right)将 $2\\pi$ 分为 $n$ 份，对应于直方图的 $n$ 个单位。比如分为6份，每个直方图代表 $60^o$： 选取其中最高的一柱代表主方向。 之后将每个特征点的方向调整至一致，这期间一般使用双线性差值的办法填补像素。 3.4 确定描述子步骤1：将$16\\times16$区域作为一个patch，校正方向 步骤2：按照3.3所述的办法计算每个像素的方向和幅度 步骤3：将其分为$4\\times4$的方框，计算每个方框的8方向直方图 最后就能得到128维描述向量（每个柱可用1-8的数字表示）","categories":[{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}]},{"title":"PNP与EPNP","slug":"PNP与EPNP","date":"2019-08-18T08:23:12.000Z","updated":"2019-12-30T16:25:03.000Z","comments":true,"path":"2019/08/18/PNP与EPNP/","link":"","permalink":"jiangren.work/2019/08/18/PNP%E4%B8%8EEPNP/","excerpt":"相机坐标系，世界坐标系，图像坐标系三者之间的转化关系在三维视觉中非常重要。本文介绍PNP和EPNP这两种办法用于关系转化的原理。","text":"相机坐标系，世界坐标系，图像坐标系三者之间的转化关系在三维视觉中非常重要。本文介绍PNP和EPNP这两种办法用于关系转化的原理。 1. PNP算法对极几何和单应矩阵都是解决2D-2D的问题，现在假设我们知道n 个 3D 空间点以及它们的投影位置时，如何估计相机所在的位姿。 PnP（Perspective-n-Point）是求解 3D 到 2D 点对运动的方法。它描述了当我们知道 n 个 3D 空间点以及它们的投影位置时，如何估计相机所在的位姿。，如果两张图像中，其中一张特征点的 3D 位置已知，那么最少只需三个点对（需要至少一个额外点验证结果）就可以估计相机运动。 特征点的 3D 位置可以由 RGB-D 相机的深度图确定。因此，在双目或 RGB-D 的视觉里程计中， 我们可以直接使用 PnP 估计相机运动。 PnP估计方法有很多种，下面介绍P3P方法。 P3P还需要使用一对验证点，以从可能的解出选出正确的那一 个（类似于对极几何情形）。记验证点对为 D−d。 我们知道的是 A,B,C 在世界坐标系中的坐标，而不是在相机坐标系中的坐标。一旦 3D 点在相机坐标系 下的坐标能够算出，我们就得到了 3D-3D 的对应点，把 PnP 问题转换为了 ICP 问题。 OA^2 + OB^2 - 2OA \\cdot OB \\cdot \\cos(a,b) = AB^2 \\\\ OB^2 + OC^2 - 2OB \\cdot OC \\cdot \\cos(b,c) = BC^2 \\\\ OA^2 + OC^2 - 2OA \\cdot OC \\cdot \\cos(a,c) = AC^2记$x=\\dfrac{OA}{OC}，y=\\dfrac{OB}{OC}$，因为ABC在相机坐标系的位置未知，所以$x,y$也未知。另外记$u=\\dfrac{BC^2}{AB^2},w=\\dfrac{AC^2}{AB^2}$，由于ABC的世界坐标是已知的，所以$u,w$可以求出。通过转化可以得到： (1-u)y^2-ux^2-\\cos(b,c)y+2uxy \\cos(a,b) +1 = 0 \\\\ (1-w)x^2-wy^2-\\cos(a,c)x+2wxy \\cos(a,b) +1 = 0由于我们知道了2D点在图像的位置，三个余弦角是已知的。该方程组是关于$x,y$的一个二元二次方程，最多可能得到四个解，因此在三个点之外还需要一组匹配点进行验证。 2. EPNP算法PnP是利用已知匹配点对以及相机内参来求解相机位姿的算法，而EPnP则是针对$n≥3$情况下相机位姿求解的$O(n)$时间的算法。它描述了当我们知道 n 个 3D 空间点以及它们的投影位置时，如何估计相机所在的位姿。 2.1 基本原理上图表示场景中的平面π在两相机的成像，设平面π在第一个相机坐标系下的单位法向量为$N$，其到第一个相机中心（坐标原点）的距离为d，则平面π可以表示为： 其中，世界坐标系中的点$p_i^w$可以表示为： p_i^w=\\sum_{j=1}^{4} \\alpha _{ij} c_j^w , \\ \\ \\ \\ with \\sum_{j=1}^{4}\\alpha _{ij}=1对于相机坐标系中的点$ p_i^c$,有： p_i^c=\\sum_{j=1}^{4} \\alpha _{ij} c_j^c , \\ \\ \\ with \\sum_{j=1}^{4}\\alpha _{ij}=1对于上面的公式来说，首先需要说明的是$ \\alpha _{ij}$确实存在，因为$c_j^w$构成的方程组是非正定的，所以一定存在解。理论上来说，控制点可以随便选择，这里选择控制点为参考点的中心，其他的点在主方向的单位长度处，从而提高算法的稳定性。 2.2 控制点在相机坐标系下的坐标首先需要求解4个控制点在世界坐标系下的坐标，按照上述说法，就是找到点云的重心和点云的三个主方向，可以参考主成分分析PCA。 根据投影方程得到世界坐标系中参考点坐标和相机坐标系中参考点的约束关系： \\forall i, w_i\\left[\\matrix{u_i \\cr v_i \\cr 1 \\cr}\\right]=A p_i^c=A\\sum_{j=1}^{4}\\alpha _{ij}c_j^c写成矩阵的形式为： \\forall i, w_i\\left[\\matrix{u_i \\cr v_i \\cr 1 \\cr}\\right]=\\left[\\matrix{f_u & 0 & u_c \\cr 0 & f_v & v_c \\cr 0 & 0 & 1 \\cr}\\right] \\sum_{j=1}^{4} \\alpha _{ij} \\left[\\matrix{x_j^c \\cr y_j^c \\cr z_j^c \\cr}\\right]将等式拆解，从第三行得到： w_i=\\sum _{j=1}^{4} \\alpha_{ij} z_j^c将$w_i$代入一二行，可以得到如下等式： \\matrix{ \\sum_{j=1}^{4} \\alpha _{ij} f_u x_j^c + \\alpha _{ij} (u_c-u_i)z_j^c =0 \\cr \\sum_{j=1}^{4} \\alpha _{ij} f_v y_j^c + \\alpha _{ij} (v_c-v_i)z_j^c =0 \\cr }因此，可以得到如下线性方程组： MX=0上面的方程中，四个控制点总共12个未知变量，$M$为$2n \\times 12 $的矩阵。因此，x为矩阵M的右奇异向量，可以通过SVD得到。 x=\\sum_{i=1}^{N} \\beta _i v_i$\\beta$是分解得到的奇异值，个数为1-4个。 说明：使用$M^TM$比使用M计算量更小，因为$M^TM$的求解是常数复杂度，而$M$求逆是$O(n^3)$的复杂度，但是计算$M^TM$的复杂度是$O(n)$的。 2.3 计算R和t通过前面的就算可以求出控制点在相机坐标系下的位置，下面就需要恢复出参考点在相机坐标系中的坐标。剩下的工作就是已知一组点云在两个坐标系中的坐标，求两个坐标系的位姿变换。 首先计算质心坐标： p_c^c={\\sum p_c^i \\over N}\\\\ \\ p_w^c={\\sum p_w^i \\over N}然后计算去质心坐标： q_c^i=p_c^i-p_c^c\\\\ q_w^i=p_w^i-p_w^c之后计算矩阵： H=\\sum_{i=1}^{N}q_c^i q_w^{iT}最后进行SVD分解计算$R$和$T$： H=U \\Sigma V^T\\\\ \\\\ R=VU^T\\\\ t=P_c^c -R P_w^c","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"jiangren.work/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Sim3变换","slug":"Sim3变换","date":"2019-08-17T11:45:13.000Z","updated":"2019-12-30T16:25:46.000Z","comments":true,"path":"2019/08/17/Sim3变换/","link":"","permalink":"jiangren.work/2019/08/17/Sim3%E5%8F%98%E6%8D%A2/","excerpt":"Sim3变化比较难，主要用于SLAM回环检测匹配时的尺度校正。","text":"Sim3变化比较难，主要用于SLAM回环检测匹配时的尺度校正。 1. 概述常见的欧式变换由6个自由度($R,T$各三个)，在SLAM问题中，可能会存在尺度的改变，因此自由度就变成了7个，见下图： Sim3(Similarity Transformation)的提出就是为了解决两个坐标系之间的相似变换问题，只要我们能得到3对匹配好的点在两个坐标系下的坐标，我们就能解出相似变换。 从几何上理解：在欧式变换中，我们只需要两对匹配的点就可以求解，因为两个点构成向量，通过比较向量在两个空间的平移量和旋转量，就可以得到欧式变换的结果。而在相似变换中，通过增加一个点，三个点构成三角形，通过法向量能计算旋转量，通过面积相似性能计算尺度变化，利用$R,s$将两个面平行，通过计算面距离得到平移量。 从代数上理解：两组三维点，能构成6个方程，解6个未知数；三组三维点，构成9个方程，超定方程解7个未知数。 在SLAM中主要用于回环检测，因为回环过程中会产生尺度的漂移，需要计算当前帧和候选帧之间的sim3变换。 2. 算法2.1 坐标系假设3个点在左右两个坐标系下的坐标分别是$r{l,1},r{l,2},r{l,3}$和$r{r,1},r{r,2},r{r,3}$，令$r{l,1}$和$r{r,1}$分别为左右两个坐标系的原点，则我们可以算出这两个坐标系的$x,y,z$轴方向的单位向量： $X$方向：$xl=r{l,2}-r_{l,1}$,则单位向量$\\hat x_l=x_l/|x_l|$ $Y$方向：$yl=(r{l,3}-r{l,1})-[(r{l,3}-r_{l,1})·\\hat x_l]\\hat x_l$ ，则单位向量$\\hat y_l=y_l/|y_l|$ 上面式子中$(r{l,3}-r{l,1})·\\hat xl$大小为$r{l,3}-r_{l,1}$在$x$轴的投影（没有方向），再乘以$\\hat x_l$得到了方向。做差后得到了与$x$轴垂直的方向。 $Z$方向：$\\hat z_l=\\hat x_l \\times \\hat y_l$ 根据所得的坐标系单位向量，可以得到左右两侧坐标系的各个方向单位向量构成的基底矩阵： M_l=|\\hat x_l \\hat y_l \\hat z_l| \\\\ M_r=|\\hat x_r \\hat y_r \\hat z_r|假设左边坐标系有一个向量 $r_l$ ,那么： $M_l^Tr_l$ 是 $r_l$ 在 $M_l$ 基底下的坐标，左乘 $M_r$ 变成右坐标系： $r_r=M_rM_l^Tr_l$变换为： $R=M_rM_l^T$ 2.2 计算平移量设有n个点，在左右坐标系中分别表示为 ${r{l,i}}$ 和 ${r{r,j}}$ ,我们的目的是找到如下的变换形式： $r_r=sR(r_l)+r_0$，其中$r_0$为平移偏移量。 实际当中，两个坐标系之间的变换不会那么容易计算出精确的变换向量，一般使用最小二乘法来求解。此时，这里的误差为： e_i=r_{r,i}-sR(r_{l,i})-r_0那么，求解的最小二乘问题变成了求解： \\sum^n_{i=1}\\|e_i\\|^2首先计算左右两个坐标系所有点的质心： r_l^-=\\frac{1}{n}\\sum^n_{i=1}r_{l,i}\\\\ r_r^-=\\frac{1}{n}\\sum^n_{i=1}r_{r,i}则每一个点距离质心的距离为： r_{l,i}'=r_{l,i}-r^-_l \\\\ r_{r,i}'=r_{r,i}-r^-_r\\\\ \\sum_{i=1}^n r_{l,i}'=0 \\\\ \\sum_{i=1}^nr_{r,i}'=0由此得出： \\begin{eqnarray} &&r_{r,i}'=sR(r_{l,i}')-r_0' \\\\ &&\\Longrightarrow r_0'=r_{r,i}'-sR(r_{l,i}')\\\\ &&\\Longrightarrow r_0'=r_{r,i}'-sR(r_{l,i}-\\overline r_l)\\\\ &&\\Longrightarrow r_0'=r_{r,i}'-sR(r_{l,i})+sR(\\overline r_l)\\\\ &&\\Longrightarrow r_0'=r_0-r_r^-+sR(\\overline r_l)\\\\ \\end{eqnarray}优化函数变为： \\begin{eqnarray} \\sum_{i=1}^n\\|e_i\\|^2&&=\\sum_{i=1}^n\\|r_{r,i}'-[sR(r_{r,i}')+r_0'\\|^2]\\\\ &&=\\sum_{i=1}^n\\|r_{r,i}'-sR(r_{l,i}')\\|^2-2r_0'\\cdot\\sum_{i=1}^n[r_{r,i}'-sR(r_{l,i}')]+n\\|r_0'\\|^2 \\end{eqnarray}最后一项明显不为负，所以当最后一项等于0时最小，由此可以计算出平移量$t$： \\begin{eqnarray} t&&=r_0=r_r^--sR(r_l^-) \\end{eqnarray}2.3 尺度计算旋转尺度不变性： $|R(r{l,i}’)|^2=|r{l,i}’|^2$ ，对误差式展开得： \\sum_{i=1}^n\\|r'_{r,i}\\|^2-2s\\sum_{i=1}^nr'_{r,i} \\cdot R(r'_{l,i})+s^2\\sum\\|r'_{l,i}\\|^2将上式写成： S_r-2sD+s^2S_l 进一步拆分成： (s\\sqrt{S_l}-D/\\sqrt{S_l})^2+(S_rS_l-D^2)/S_l上面的式子只有第一项与s有关，所以当第一项等于0时达到最小，即 $s=D/S_l$ : s=\\sum_{i=1}^nr'_{r,i} \\cdot R(r'_{l,i})/\\sum_{i=1}^n\\|r'_{l,i}\\|^2在误差模型中除一个根号s： e_i=\\frac{1}{\\sqrt{s}}r’_{r,i}-\\sqrt{s}R(r’_{i,j})我们只是求误差的最小值，除以一个系数是没关系的，这样做的好处是最后求得的s与旋转因子无关，并且便于后面求解。 最后得到： s=(\\sum_{i=1}^n\\|r'_{r,i}\\|^2/\\sum_{i=1}^n\\|r'_{i=1}\\|^2)^{1/2}因此只有在D取得最大的情况下，误差才会最小，现在就把问题变为了求D的过程。 引入四元数qq表示旋转(具体推导见三维刚体运动那一部分)： \\sum_{i=1}^n r'_{r,i} \\cdot R(r'_{l,i})= \\sum_{i=1}^n(q'r'_{l,i}q'^*) \\cdot r'_{r,i}=\\sum_{i=1}^n(q'r'_{l,i}) \\cdot (r'_{r,i}q')左边等于： q’r’_{l,i}=\\left[\\begin{matrix} 0 & -x’_{l,i} & -y’_{l,i} & -z’_{l,i}\\\\ x’_{l,i} & 0 & z’_{l,i} & -y’_{l,i} \\\\ y’_{l,i} & -z’_{l,i} & 0 & x’_{l,i} \\\\ z’_{l,i} & y’_{l,i} & -x’_{l,i} & 0 \\end{matrix}\\right]q’=R_{l,i}q’右边等于： r’_{r,i}q’=\\left[\\begin{matrix} 0 & -x’_{r,i} & -y’_{r,i} & -z’_{r,i}\\\\ x’_{r,i} & 0 & -z’_{r,i} & y’_{r,i} \\\\ y’_{r,i} & z’_{r,i} & 0 & -x’_{r,i} \\\\ z’_{r,i} & -y’_{r,i} & x’_{r,i} & 0 \\end{matrix}\\right]q’= R_{r,i}q’所以又可以表达为： \\sum_{i=1}^n(R_{l,i}q') \\cdot (R_{r,i}q')=\\sum_{i=1}^nq'^TR_{l,i}^TR_{r,i}q'=q'^TNq'为了求解$N$，先引入一个$M$矩阵： M=\\sum_{i=1}^nr'_{l,i}r'^T_{r,i}=\\left[\\begin{matrix} S_{xx} & S_{xy} & S_{xz}\\\\ S_{yx} & S_{yy} & S_{yz} \\\\ S_{zx} & S_{zy} & S_{zz} \\end{matrix}\\right]则$N$矩阵就可以表示为: N=\\left[\\begin{matrix} (S_{xx}+S_{yy}+S_{zz}) & S_{yz} -S_{zy} & S_{zx}-S_{xz} & S_{xy}-S_{yx}\\\\ S_{yz}-S_{zy} & (S_{xx}-S_{yy}-S_{zz}) & S_{xy}+S_{yx} & S_{zx}+S_{xz}\\\\ S_{zx}-S_{xz} & S_{xy}-S_{yx} & (-S_{xx}+S_{yy}-S_{zz}) & S_{yz}+S_{zy} \\\\ S_{xy} -S_{yx} & S_{zx}+S_{xz} & S_{yz}-S_{zy} &(-S_{xx}-S_{yy}+S_{zz}) \\end{matrix}\\right]引出$M$来就是为了让其中的量来表示$N$，如上式。将$N$进行特征分解，求得最大特征值对应的特征向量为四元数表示的旋转。之后平移和尺度关系也能相应求解。","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"jiangren.work/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"详解BA","slug":"详解BA","date":"2019-08-17T10:22:54.000Z","updated":"2019-12-30T17:01:42.000Z","comments":true,"path":"2019/08/17/详解BA/","link":"","permalink":"jiangren.work/2019/08/17/%E8%AF%A6%E8%A7%A3BA/","excerpt":"BA是SLAM中重要的优化手段，本文详细解释了这种方法的原理，以及采用g2o图优化的应用示例。","text":"BA是SLAM中重要的优化手段，本文详细解释了这种方法的原理，以及采用g2o图优化的应用示例。 1. 投影模型与BA优化函数BA(Bundle Adjustment)，又称光束法平差（平差就是抹平误差）。BA的本质是一个优化模型，其目的是最小化重投影误差。 所谓重投影误差就是二次投影与一次投影之间产生的误差。 第一次投影指的就是相机在拍照的时候三维空间点投影到图像上第一次投影在相机平面产生了特征点$p_1$，我们可以计算出$P$的坐标位置。 之后相机进行了运动，通过一些方法我们得到这个运动的数值，进而得到了它的位姿。由于我们现在知道相机的位姿（计算估计得来）和$P$的世界坐标，因此可以计算$P$在第二幅图下的投影，这就是所谓的第二次投影。 此时在相机平面产生了特征点$p_2$，而通过特征匹配我们能够知道特征点$p_2’$的真实位置，两者会产生误差，这就是所谓的重投影误差。换句话说，重投影误差是指的真实三维空间点在图像平面上的投影（也就是图像上的像素点）和重投影（其实是用我们的计算值得到的虚拟的像素点）的差值。 给定$N$个两张图中完成匹配的点，记作： {z_1} = \\left\\{ {z_1^1,z_1^2, \\ldots ,z_1^N} \\right\\},{z_2} = \\left\\{ {z_2^1,z_2^2, \\ldots ,z_2^N} \\right\\}已知相机的内参矩阵为$K$，求解相机的运动$R,t$，注意字符$z$的上标表示第几个点。则： z_i^j=[u,v]_i^j根据投影关系： \\begin{equation} {\\lambda _1}\\left[ \\begin{array}{l} z_1^j\\\\ 1 \\end{array} \\right] = K{P^j},\\quad {\\lambda _2}\\left[ \\begin{array}{l} z_2^j\\\\ 1 \\end{array} \\right] = K\\left( {R{P^j} + t} \\right) \\end{equation}采用最小二乘法优化： \\begin{equation} \\mathop {\\min }\\limits_{P^j,R,t} {\\left\\| {K{P^j} - {\\left[ {z_1^j,1} \\right]}^T} \\right\\|^2} + {\\left\\| {K\\left( {R{P^j} + t} \\right) - {\\left[ {z_2^j,1} \\right]}^T} \\right\\|^2} \\end{equation}简化形式，已知观测方程为$z=h(x,y)$其中$x$表示位姿，$y$表示路标。观测误差就可以表示为： e=z-h(\\xi,p)$z$表示一次投影得到的特征点位置，$h(\\xi,p)$表示二次投影的结果，$h$就是投影函数（这里用李代数表示，$p$表示三维点）。如果把所有观测结果考虑进来，给误差添加一个下标：$z_{ij}$表示位姿$\\xi_i$处观测路标$p_i$产生的数据，最后就得到了需要优化的函数： \\frac{1}{2}\\sum_{i=1}^{m}\\sum_{j=1}^{n}||e_{ij}||^2=\\frac{1}{2}\\sum_{i=1}^{m}\\sum_{j=1}^{n}||z_{ij}-h(\\xi_i,p_j)||^22. 求解BA2.1 迭代求解这不是一个线性函数，所以可以通过第六章的非线性优化的方法来求解。根据非线性优化的思想，我们应该从某个的初始值开始，不断地寻找下降方向 $\\Delta x$ 来找到目标函数的最优解，即不断地求解增量方程中的增量$\\Delta x$。 首先需要把所有自变量定义成待优化变量： x=[\\xi_1,...,\\xi_m,p_1,...,p_n]^T相应的，增量方程中的$\\Delta x$则是对整体自变量的增量。在这个意义下，当我们给自变量一个增量时，目标函数变为： \\frac{1}{2}\\|f(\\boldsymbol{x}+\\Delta \\boldsymbol{x})\\|^{2} \\approx \\frac{1}{2} \\sum_{i=1}^{m} \\sum_{i=1}^{n}\\left\\|\\boldsymbol{e}_{i j}+\\boldsymbol{F}_{i j} \\Delta \\boldsymbol{\\xi}_{i}+\\boldsymbol{E}_{i j} \\Delta \\boldsymbol{p}_{j}\\right\\|^{2}其中$F{ij}$表示整个代价函数在当前状态下对相机姿态的偏导数，$E{ij}$表示该函数对路标点位置的偏导。把相机的位姿变量和空间点变量放在一起： x_c=[\\xi_1,\\xi_2,...,\\xi_m]^T\\\\ x_p=[p_1,p_2,...,p_n]^T最后待求式子就可以被化简为： \\frac{1}{2}||f(x+\\Delta x)||^2=\\frac{1}{2}||e+F\\Delta x_c+E\\Delta x_p||^2通过GN或者LM方法，最后可以得到增量线性方程： H\\Delta x=g由于我们把变量分为了位姿和空间点两种，所以雅克比矩阵还需要被分块： J=[F\\ E]以GN为例，H矩阵表示为： H=J^TJ=\\begin{bmatrix} F^TF&F^TE\\\\ E^TF& E^TE \\end{bmatrix}因为考虑了所有的优化变量，这 个线性方程的维度将非常大，包含了所有的相机位姿和路标点。如果直接对 H 求逆来计算增量方程，由于矩阵求逆是复杂度为 O(n3) 的操作 ，这是非常消耗计算资源的。 幸运地是，这里的 H 矩阵是有一定的特殊结构的。利用这个特殊结构，我们可以加速求解过程。 2.3 稀疏性与边缘化先举个例子，如下图相机$C1$能够观测到路标$P{1,2,3,4}$而相机$C2$能观测到路标$P{3,4,5,6}$ 该场景下的BA优化函数为: \\frac{1}{2}\\sum_{i=1}^{m}\\sum_{j=1}^{n}||e_{ij}||^2=\\frac{1}{2}(||e_{11}||^2+||e_{12}||^2\\\\+||e_{13}||^2+||e_{14}||^2+||e_{23}||^2+||e_{24}||^2\\\\+||e_{25}||^2+||e_{26}||^2)此时$x=[\\xi_1,\\xi_2,p_1,…,p_6]^T$可知： J_{11}=\\frac{\\partial e_{11}}{\\partial x}=(\\frac{\\partial e_{11}}{\\xi_1},\\frac{\\partial e_{11}}{\\xi_2},\\frac{\\partial e_{11}}{p_1},\\frac{\\partial e_{11}}{p_2},\\frac{\\partial e_{11}}{p_3},\\frac{\\partial e_{11}}{p_4},\\frac{\\partial e_{11}}{p_5},\\frac{\\partial e_{11}}{p_6})由于这里描述的是$C_1$观测到$P_1$所以只有两项不为0： J_{11}=\\frac{\\partial e_{11}}{\\partial x}=(\\frac{\\partial e_{11}}{\\xi_1},0_{2\\times6},\\frac{\\partial e_{11}}{p_1},0_{2\\times3},0_{2\\times3},0_{2\\times3},0_{2\\times3},0_{2\\times3})用图案表示如下： $H$矩阵和$C,P$关系图之间，除了对角线元素以外，有明显的关联性： 现在考虑更一般的情况，假如我们有 m 个相机位姿，n 个路标点。由于通常路标数量远远会比相机多，于是有 n ≫ m。由上面推理可知，实际当中的 H 矩阵会像下图所示的那样。它的左上角块显得非常小，而右下角的对角块占据了大量地方。除此之外，非对角部分则分布着散乱的观测数据。这就是镐形矩阵（箭头矩阵）。 因此线性方程$H\\Delta x=g$又可以表示为如下形式： \\begin{bmatrix} B&E\\\\ E^T& C \\end{bmatrix} \\begin{bmatrix} \\Delta x_c\\\\ \\Delta x_p \\end{bmatrix}= \\begin{bmatrix} v\\\\ w \\end{bmatrix} 对于这个方程直接代入消元，先求$\\Delta x_c$然后求$\\Delta x_p$，得到的结果为： [B-EC^{-1}E^T]\\Delta x_c=v-EC^{-1}w\\\\ \\Delta x_p=C^{-1}(w-E^T\\Delta x_c)由于$C$是一个对角块矩阵，对角矩阵的逆矩阵非常好求（对角线上的元素不能为0）： \\left[\\begin{array}{ccccc}{a_{1}} & {} & {} & {} & {} \\\\ {} & {a_{2}} & {} & {} & {} \\\\ {} & {} & {\\ddots} & {} & {} \\\\ {} & {} & {} & {a_{n}}\\end{array}\\right]^{-1}=\\left[\\begin{array}{ccccc}{a_{1}^{-1}} & {} & {} & {} & {} \\\\ {} & {a_{2}^{-1}} & {} & {} & {} \\\\ {} & {} & {a_{2}^{-1}} & {} & {} \\\\ {} & {} & {} & {\\ddots} & {} \\\\ {} & {} & {} & {a_{n}}\\end{array}\\right]因此边缘化的主要计算量在于求解$\\Delta x_c$ 。从概率角度来看，我们称这一步为边缘化，是因为我们实际上把求 $(\\Delta x_c,\\Delta x_p)$的问题，转化成先求$\\Delta x_c$，再求 $\\Delta x_p$的过程。这一步相当于做了条件概率展开： P(x_c,x_p)=P(x_c)·P(x_p|x_c)结果是求出了关于$x_c$ 的边缘分布，故称边缘化。在上边讲的边缘化过程中，我们实际把所有的路标点都给边缘化了。 2.3 鲁棒核函数在前面的 BA 问题中，我们最小化误差项的二范数平方和，作为目标函数。当出现误匹配时，误差$e$就会很大，如果我们再使用平方，这个误差就会更大，算法将试图调整这条边所连接的节点的估计值，使它们顺应这条边的无理要求。由于这个边的误差真的很大，往往会抹平了其他正确边的影响，使优化算法专注于调整一个错误的值。 出现这种问题的原因是，当误差很大时，二范数增长得太快了。于是就有了核函数的存在。核函数保证每条边的误差不会太大以至于掩盖掉其他的边。这种核函数称之为鲁棒核函数。 最常用的鲁棒核函数有Huber核： H(e)=\\begin{equation} \\left\\{ \\begin{array}{lr} \\frac{1}{2}e^2\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\text{if}\\ |e|","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}]},{"title":"SVD解超定方程","slug":"SVD解超定方程","date":"2019-08-17T04:36:45.000Z","updated":"2019-12-30T16:39:47.000Z","comments":true,"path":"2019/08/17/SVD解超定方程/","link":"","permalink":"jiangren.work/2019/08/17/SVD%E8%A7%A3%E8%B6%85%E5%AE%9A%E6%96%B9%E7%A8%8B/","excerpt":"超定方程就是方程个数大于未知数的方程组，本文介绍了如何用最小二乘法解这样的方程。","text":"超定方程就是方程个数大于未知数的方程组，本文介绍了如何用最小二乘法解这样的方程。 1. 奇异值分解原理1.1 特征值的数学含义对角矩阵$M$作用在任何一个向量上： \\begin{bmatrix}3&0\\\\0&1 \\end{bmatrix} \\begin{bmatrix}x\\\\y \\end{bmatrix} = \\begin{bmatrix}3x\\\\y \\end{bmatrix}换言之这个变换让$x$方向拉伸了3倍，$y$方向保持不变，对角矩阵起到作用是将水平垂直网格作水平拉伸（或者反射后水平拉伸）的线性变换。 对于一个一般矩阵$M=\\begin{bmatrix}1&amp;1\\0&amp;1 \\end{bmatrix}$，我们可以找到一组网格，然后通过旋转+拉伸的方法保证变换后的网格依旧互相垂直。 特征向量的几何含义为：对于任何的一个矩阵，我们要找到一组两两正交单位向量序列，使得矩阵作用在此向量序列上后得到新的向量序列保持两两正交。特征值的几何含义为：拉伸 A=W\\Sigma W^{-1}其中$W$是这$n$个特征向量张成的$n$维矩阵，一般而言我们会把$W$的这$n$个特征向量标准化，即: ||w_i||_2=w_i^Tw_i=1此时$W$就变为了标准正交基，满足： W^TW=I,\\ W^T=W^{-1}这样我们的特征分解表达式可以写成： A=W\\Sigma W^{T}2.2 奇异值的含义特征值需要方阵，对于一个非方阵而言我们可以通过$M=AA^T$将它变为方阵，对变换后的方阵$M$求特征值的结果就是奇异值。 若$AA^T$的特征值为： \\lambda _{1} \\geq \\lambda _{2} \\geq ... \\geq \\lambda _{r} > \\lambda _{r+1} = \\cdots = \\lambda_{m} = 0则称$\\sigma {i}=\\sqrt {\\lambda {i}} \\quad (i=1, 2, …, r)$为矩阵$A$的奇异值（注意这里只有r个）。 存在$m$阶酉矩阵$U$和$n$阶酉矩阵$V$，使得： A=UDV^{T}=U \\left[ \\begin{matrix} \\Sigma & 0_{r \\times (n-r)} \\\\ 0_{(m-r) \\times r} & 0_{(m-r) \\times (n-r)} \\\\ \\end{matrix} \\right] V^{T} \\\\其中, \\quad \\Sigma = \\left[ \\begin{matrix} \\sigma_{1} & & & \\\\ & \\sigma_{2} & & \\\\ & & \\ddots & \\\\ & & & \\sigma_{r} \\\\ \\end{matrix} \\right]上式中 D的对角元叫做 A 的奇异值，U 中的列向量称为 A 的左奇异向量，V 中的列向量称为 A 的右奇异向量。 2. 奇异值分解解线性方程2.1 解非齐次线性方程组($Ax=b$)若矩阵的行数大于列数，则为超定方程，需要求最小二乘解，即使得$||Ax-b||_{2}$最小时的$x$，由2-范数具有酉不变性，有： ||Ax-b||_{2} = \\left| \\left| U \\left[ \\begin{matrix} \\Sigma & 0_{r \\times (n-r)} \\\\ 0_{(m-r) \\times r} & 0_{(m-r) \\times (n-r)} \\\\ \\end{matrix} \\right] V^{T} x-b \\right| \\right| \\\\= \\left| \\left| \\left[ \\begin{matrix} \\Sigma & 0_{r \\times (n-r)} \\\\ 0_{(m-r) \\times r} & 0_{(m-r) \\times (n-r)} \\\\ \\end{matrix} \\right] V^{T} x-U^{T}b \\right| \\right| 如果范数满足$║A║=║UAV║$对任何矩阵$A$以及酉矩阵$(U,V)$成立，则此范数为酉不变范数。2-范数是酉不变范数。 要让上述二范数最小，让里面的内容等于0即可。所以$Ax=b$的最小二乘解为$\\left[ \\begin{matrix} \\Sigma &amp; 0{r \\times (n-r)} \\ 0{(m-r) \\times r} &amp; 0_{(m-r) \\times (n-r)} \\ \\end{matrix} \\right] V^{T}x = U^{T}b$的最小二乘解。 令$y=V^{H}x，c=U^{H}b$，则原方程可亦表示为: \\left[ \\begin{matrix} \\Sigma & 0_{r \\times (n-r)} \\\\ 0_{(m-r) \\times r} & 0_{(m-r) \\times (n-r)} \\\\ \\end{matrix} \\right] y = c表达成矩阵形式如下： \\left[ \\begin{array}{cccc:c} \\sigma_{1} & & & & \\\\ & \\sigma_{2} & & & \\\\ & & \\ddots & & 0_{r \\times (n-r)} \\\\ & & & \\sigma_{r} & \\\\ \\hdashline & & 0_{(m-r) \\times r} & & 0_{(m-r) \\times (n-r)} \\end{array} \\right]_{m \\times n} \\cdot \\left[ \\begin{matrix} y_{1} \\\\ y_{2} \\\\ \\vdots \\\\ y_{r} \\\\ \\hdashline \\mathcal{Y_{(n-r) \\times 1}} \\\\ \\end{matrix} \\right]_{n \\times 1} = \\left[ \\begin{matrix} c_{1} \\\\ c_{2} \\\\ \\vdots \\\\ c_{r} \\\\ \\hdashline \\mathcal{C_{(m-r) \\times 1}} \\\\ \\end{matrix} \\right]_{m \\times 1}所以$Dy=c$的最小二乘解为： y=[\\frac{c_{1}}{\\sigma _{1}}, \\frac{c_{2}}{\\sigma _{2}}, \\cdots, \\frac{c_{r}}{\\sigma _{r}}, \\underbrace{0, \\cdots, 0}_{n-r} ]^{T}原方程组的最小二乘解为： x=V^{T}y2.2 解齐次线性方程组($Ax=0$)2.1的情况是让$||Ax-b||{2}$的值最小，但2.2由于$b=0$所以是让$||Ax||{2}$最小，由于$x=0$是方程的解，而我们一般不想要这个解，所以增加一个约束$||x||_2=1$，这样问题就变成了： min(||Ax||_{2})，||x||_{2}=1又因为： ||Ax||=||UDV^{T}x||=||DV^{T}x||令$y=V^{T}x$，则问题变为： min(||Dy||), ||y||=1展开以后得到： \\left[ \\begin{array}{cccc:c} \\sigma_{1} & & & & \\\\ & \\sigma_{2} & & & \\\\ & & \\ddots & & 0_{r \\times (n-r)} \\\\ & & & \\sigma_{r} & \\\\ \\hdashline & & 0_{(m-r) \\times r} & & 0_{(m-r) \\times (n-r)} \\end{array} \\right]_{m \\times n} \\cdot \\left[ \\begin{matrix} y_{1} \\\\ y_{2} \\\\ \\vdots \\\\ y_{r} \\\\ \\hdashline \\mathcal{Y_{(n-r) \\times 1}} \\\\ \\end{matrix} \\right]_{n \\times 1} = \\left[ \\begin{matrix} 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ \\hdashline \\mathcal{0_{(m-r) \\times 1}} \\\\ \\end{matrix} \\right]_{m \\times 1}因为对角阵$D$的对角元素（奇异值）按递减顺序排列，所以最优解为$y=[0, 0, \\cdots, 1]^{T}$（考虑到约束条件）,又因为$x=Vy$，所以最优解是最小奇异值对应的$V$的列向量(右奇异向量)，也就是$V$的最右边一列。比如下面的结果就是$[a_3,b_3,c_3]^T$ V=\\begin{bmatrix}a_1&a_2&a_3\\\\ b_1&b_2&b_3\\\\ c_1&c_2&c_3\\end{bmatrix}","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"jiangren.work/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Harris特征检测","slug":"Harris特征检测","date":"2019-08-16T02:56:55.000Z","updated":"2019-12-30T16:37:18.000Z","comments":true,"path":"2019/08/16/Harris特征检测/","link":"","permalink":"jiangren.work/2019/08/16/Harris%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B/","excerpt":"Harris是一种简单但实用的角点检测手段，本文介绍了他的基本原理，以及优劣势。","text":"Harris是一种简单但实用的角点检测手段，本文介绍了他的基本原理，以及优劣势。 1. 基本原理 当一个窗口在图像上移动，在平滑区域如图(a)，窗口在各个方向上没有变化。在边缘上如图(b)，窗口在边缘的方向上没有变化。在角点处如图(c)，窗口在各个方向上具有变化。 假设图像窗口平移$[u,v]$产生的变化为$E(u,v)$则： E(u, v)=\\sum_{x_{s}, y} w(x, y)[I(x+u, y+v)-I(x, y)]^{2}泰勒展开可得： I(x+u, y+v)=I(x, y)+I_{x} u+I_{y} v+O\\left(u^{2}, v^{2}\\right)这是单个像素的表达式，当发生微小位移时，忽略无穷小量。现在，我们考虑一个领域窗口内所有像素的移动情况，写成矩阵形式： E(u, v)=\\sum_w[u, v]\\left[\\begin{array}{cc}{I_{x}^{2}} & {I_{x} I_{y}} \\\\ {I_{x} I_{y}} & {I_{y}^{2}}\\end{array}\\right]\\left[\\begin{array}{l}{u} \\\\ {v}\\end{array}\\right]=[u, v]M\\left[\\begin{array}{l}{u} \\\\ {v}\\end{array}\\right]假设梯度坐标表示为$(I_X,I_Y)$，，这个和上面有区别。不同的纹理特征表现出来的梯度坐标分布不同： 注意：样例图片并不是纯色，里面包含了很多的椒盐点，所以梯度分布才会出现散状。 可以看出，均匀图像的灰度在 $x,y$ 方向几乎没有变化，类似一个圆；边缘图像在某一个轴方向变化剧烈，在另一个方向没有变化，近似为一个扁椭圆；角点在两个方向变化都很剧烈，近似为一个卵型。 因此判断角点的条件就变为：长轴短轴都超过某一阈值，转化为矩阵语言就是$M$有两个大特征值。 2. 计算方法由上可知，我们判断角点的依据就是特征值的大小 常规思路是进行SVD分解： M=X\\Sigma X^T = X \\left[ \\begin{matrix} \\lambda_1& 0\\\\ 0& \\lambda_2\\end{matrix} \\right] X^T但速度比较慢，难以做到视频中实时监测的需求（30帧每秒），所以我们可以采用近似的做法： M(x,y)=\\Sigma_w \\left[ \\begin{matrix} I_x^2& I_xI_y \\\\ I_xI_y & I_y^2\\end{matrix} \\right] = \\left[ \\begin{matrix} A& C\\\\ C& B\\end{matrix} \\right]采用近似的形式，$\\alpha$一般取0.04-0.06： R = detM-\\alpha (traceM)^2\\\\ detM=\\lambda_1 \\lambda_2=AB-C^2\\\\ traceM=\\lambda_1 + \\lambda_2 = A+B此时判断条件变为： 3. 性质一般来说计算的角点会呈块状分布 所以我们需要使用非极大抑制(Non-maxima suppression)处理，得到单个的角点： Harris角点对亮度和对比度的变化并不敏感 对于亮度来说，整体的上升和下降，并不影响角点的检测。对于对比度来说，按比例拉伸曲线，并不改变Harris响应的极值点出现的位置，但是，由于阈值的选择，可能会影响角点检测的数量。 Harris角点检测算子具有旋转不变性。Harris角点检测算子使用的是角点附近的区域灰度二阶矩矩阵。而二阶矩矩阵可以表示成一个椭圆，椭圆的长短轴正是二阶矩矩阵特征值平方根的倒数。当特征椭圆转动时，特征值并不发生变化，所以判断角点响应值也不发生变化，由此说明Harris角点检测算子具有旋转不变性。 Harris角点不具有尺度不变性。当图被缩小时，在检测窗口尺寸不变的前提下，在窗口内所包含图像的内容是完全不同的。左侧的图像可能被检测为边缘或曲线，而右侧的图像则可能被检测为一个角点。 随着尺度的减小，能检测到角点数量也相应降低。","categories":[{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}]},{"title":"光流法","slug":"光流法","date":"2019-08-15T05:22:52.000Z","updated":"2019-12-30T16:23:35.000Z","comments":true,"path":"2019/08/15/光流法/","link":"","permalink":"jiangren.work/2019/08/15/%E5%85%89%E6%B5%81%E6%B3%95/","excerpt":"光流法是计算机视觉中非常重要的方法，本文介绍了光流法的基本原理和提高精度的进阶办法。","text":"光流法是计算机视觉中非常重要的方法，本文介绍了光流法的基本原理和提高精度的进阶办法。 1. 光流法基本原理光流是一种描述像素随时间在图像之间运动的方法，随着时间的流逝，同一个像素会在图像中运动,我们可以追踪他的运动。 光流法应用的前提是灰度不变假设，也就是说$I(x_1,y_1,t_1)=I(x_2,y_2,t_2)$，虽然这是一个很苛刻的假设，但我们还是需要认为其在某些场景下具有合理性。 假设在$t+dt$的时刻某个像素运动到了$(x+dx,y+dy)$，我们可以得到： I(x,y,t) = I(x+dx, y+dy,t+dt)如果对上式中右侧进行一阶泰勒展开： I(x+dx,y+dy,t+dt) \\approx I(x,y,t)+\\frac{\\partial I}{\\partial x}dx + \\frac{\\partial I}{\\partial y}dy + \\frac{\\partial I}{\\partial t}dt根据灰度不变假设可以得到： \\frac{\\partial I}{\\partial x}dx + \\frac{\\partial I}{\\partial y}dy + \\frac{\\partial I}{\\partial t}dt = 0.两侧同时除以$dt$，可以得到： \\frac{\\partial I}{\\partial x}\\frac{dx}{dt} + \\frac{\\partial I}{\\partial y}\\frac{dy}{dt} = -\\frac{\\partial I}{\\partial t}其中 $\\frac{dx}{dt},\\frac{dy}{dt}$ 为像素在$x,y$轴上的运动速度，将他们记为 $u,v$。同时 $\\frac{\\partial I }{\\partial x},\\frac{\\partial I}{\\partial y}$ 记为图像在$x,y$方向上的梯度，分别记为$I_x,I_y$，把图像灰度对于时间的变化量记为 $I_t$，上面的式子可以表示为： \\begin{bmatrix} I_x&I_y \\end{bmatrix} \\begin{bmatrix} u\\\\ v \\end{bmatrix} = - I_t我们假设某个$W\\times W$的窗口内的像素具有相同的运动，则： A=\\left[\\begin{array}{c}{\\left[I_{x}, I_{y}\\right]_{1}} \\\\ {\\vdots} \\\\ {\\left[I_{x}, I_{y}\\right]_{k}}\\end{array}\\right], b=\\left[\\begin{array}{c}{I_{t 1}} \\\\ {\\vdots} \\\\ {I_{t k}}\\end{array}\\right]简化后可得： A\\left[\\begin{array}{l}{u} \\\\ {v}\\end{array}\\right]=-b这是一个超定方程(方程个数大于未知数个数)，可以使用最小二乘法求解： \\begin{bmatrix} u\\\\ v \\end{bmatrix}^* = -(A^TA)^{-1}A^Tb 超定方程组是指方程个数大于未知量个数的方程组，在方程$Ax=b$两边乘以$A^T$，所以该方程有唯一解且为原方程的最小二乘解： \\begin{equation} \\begin{split} A^TAx=A^Tb \\end{split} \\\\ x=(A^TA)^{-1}A^Tb \\end{equation} 总结一下，光流法基于三个假设： 灰度不变，所以$I(x+dx,y+dy,t+dt) =I(x,y,t)$ 小运动，所以我们可以取一阶泰勒展开 邻域内光流不变，所以我们可以取$W\\times W$的小窗口 2. 金字塔光流法光流法重要前提是小运动，也就是说图像随时间变化缓慢，这样灰度才能求偏导，最理想的条件当然是相邻帧图片间隔1个像素。为了解决运动过快导致的误差较大问题，我们可以通过减少图像中物体的位移。 缩小图像尺寸能有效减少位移，比如图像为400×400时，物体单位时间位移为[16,16]，那么当图像缩小为200×200时，位移变为[8,8]。缩小尺寸的办法可以使用金字塔分层。 高斯金字塔的概念在SIFT特征检测中已经详细说明。通过高斯金字塔能形成组（Octave）和层（Level或Interval）。 下面开始公式推导，假设$I,J$是两幅相邻运动图像。图像$I$的点$(x,y)$对应了图像$J$的点$(x+dx,y+dy)$，也就是说： I(x,y)=J(x+dx,y+dy)当然这之间肯定会存在误差，写出一片领域下的误差函数： e=\\sum_{x=u_{x}-\\omega_{x}}^{u_{x}+\\omega_{x}} \\sum_{y=u_{y}-\\omega_{y}}^{u_{y}+\\omega_{y}}\\left(I(x, y)-J\\left(x+d_{x}, y+d_{y}\\right)\\right)^{2}假设图像的尺寸每次缩放为原来的一半，共缩放了$Lm$组，第0组误差为$e(d)$，则每组的光流计算结果为为： g(L)=\\frac{g(0)}{2^L}这并不是准确的结果，还得加上残差： g(L)_{real}=g(L)+d(L)反馈到第$L-1$层： g(L-1)=2[g(L)+d(L)]对于每一层，我们都希望光流的计算基于邻域内所有点匹配误差和最小化： e(L)=\\sum_{x=u_{x}^{L}-\\omega_{x}}^{u_{x}^{L}+w_x} \\sum_{y=u_{y}^{L}-\\omega_{y}}^{u_{y}^{L}+\\omega_{y}}\\left(I^{L}(x, y)-J^{L}\\left(x+g_{x}^{L}+d_{x}^{L}, y+g_{y}^{L}+d_{y}^{L}\\right)\\right)^{2}具体算法是： 利用最小二乘法计算最顶层的最小光流 更新光流$v=2*v$，将光流方向传递到下一层，计算最小光流 持续传递，直到传递到原图像输出","categories":[{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}]},{"title":"ORB特征检测","slug":"ORB特征检测","date":"2019-08-15T05:22:52.000Z","updated":"2019-12-30T16:28:40.000Z","comments":true,"path":"2019/08/15/ORB特征检测/","link":"","permalink":"jiangren.work/2019/08/15/ORB%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B/","excerpt":"ORB特征检测是由FAST角点检测和BRIEF描述子检测组合的检测手段，在ORBSLAM中有良好运用。","text":"ORB特征检测是由FAST角点检测和BRIEF描述子检测组合的检测手段，在ORBSLAM中有良好运用。 1. 基本概念特征点指图像中选取比较有代表性的点，这些点在相机视角发生少量变化后会保持不变，所以我们会在各个图像中找到相同的点。 特征点由关键点（Key-point）和描述子（Descriptor）两部分组成。关键点是指该特征点在图像里的位置，有些特征点还具有朝向、大小等信息。描述子通常是一个 向量，描述了该关键点周围像素的信息。描述子是按照“外观相似的特征应该有相似的描述子”的原则设计的。 ORB （Oriented FAST and Rotated BRIEF）改进了 FAST 检测子不具有方向性的问题，并采用速度极快的二进制描述子 BRIEF，使整个图像特征提取的环节大大加速。借助尺度空间理论构建图像高斯金字塔，然后在每一层金字塔图像上检测角点，以实现尺度不变性。 ORB 特征亦由关键点和描述子两部分组成。它的关键点称为”Oriented FAST”，是 一种改进的 FAST 角点，它的描述子称为 BRIEF （Binary Robust Independent Elementary Features）。因此，提取 ORB 特征分为两个步骤： FAST 角点提取：找出图像中的”角点”。相较于原版的 FAST, ORB 中计算了特征点的主方向，为后续的 BRIEF 描述子增加了旋转不变特性。 BRIEF 描述子：对前一步提取出特征点的周围图像区域进行描述。 2. Fast关键点FAST 是一种角点，主要检测局部像素灰度变化明显的地方，以速度快著称。它的思想是：如果一个像素与它邻域的像素差别较大（过亮或过暗）, 那它更可能是角点。算法步骤如下： 在图像中选取像素 $p$，假设它的亮度为 $I_p$。 设置一个阈值 $T$(比如 Ip 的 20%) 以像素 $p$ 为中心, 选取半径为 3 的圆上的 16 个像素点。 假如选取的圆上，有连续的 $N$ 个点的亮度大于 $(I_p + T)$ 或小于 $(I_p −T)$，那么像素 p 可以被认为是特征点 ($N$ 通常取 12，即为 FAST-12。其它常用的 $N$ 取值为9和11， 他们分别被称为 FAST-9，FAST-11)。 在 FAST-12 算法中，为了更高效，可以添加一项预测试操作，以快速地排除绝大多数不是角点的像素。直接检测邻域圆上的第 1，5，9，13 个像素的亮度。只有当这四个像素中有三个同时亮度大于 $(I_p + T)$ 或小于 $(I_p −T)$，当前像素才有 可能是一个角点，否则应该直接排除。 FAST算子本身是不具有方向性的，因此我们需要引入距分析来完成oriented： 图像的距为： m_{p q}=\\sum_{x, y \\in B} x^{p} y^{q} I(x, y), \\quad p, q=\\{0,1\\}质心为： C=\\left(\\frac{m_{10}}{m_{00}}, \\frac{m_{01}}{m_{00}}\\right)连接图像的几何中心O和质心C可以得到方向向量$\\vec{OC}$，方向就可以被定义为： \\theta=\\arctan{(m_{01}/m_{10})}3. BRIEF描述子BRIEF 是一种二进制描述子，它的描述向量由许多个 0 和 1 组成，这里的 0 和 1 编码了关键点附近两个像素（比如说 p 和 q）的大小关系：如果 p 比 q 大，则取 1，反之就取 0。如果我们取了 128 个这样的 pq，最后就得到 128 维由 0，1 组成的向量。 pq的选点在BRIEF中采取了随机选点的比较，速度很快。 算法步骤如下： 以特征点P为中心，取一个S×S大小的Patch邻域； 在这个邻域内随机取N对点(x,y)，比较N对像素点的灰度值的大小,如果x的灰度大于y，则写为1，反之为0 重复步骤2得到N个（一般为256）二进制代码串 随机点的选择一般采用高斯分布的形式，匹配时采用汉明距离(两代码串同位不同的个数,比如010和101汉明距离为3) 原始的 BRIEF 描述子不具有旋转不变性，因此在图像发生旋转时容易丢失。原因是其采用了方形领域，当旋转时会造成覆盖的区域发生变化： 而 ORB 在 FAST 特征点提取阶段计算了关键点的方向，所以可以利用方向信息，计算了旋转之后的”Steer BRIEF”特征，使 ORB 的描述子具有较好的旋转不变性。 4. 尺度不变性前面介绍了利用距分析获取特征方向从而实现旋转不变性，同样的我们也需要实现尺度不变性，我们在描述一个特征之前，将两张图像都变换同一个尺度上，然后再在这个统一标准上来描述这个特征。 为了实现尺度不变性，需要给特征加上尺度因子。在进行特征描述的时候，将尺度统一即可。一般采用高斯金字塔模型。 与普通的金子塔不同，我们进行分组构建： 先将原图像扩大一倍之后作为高斯金字塔的第1组第1层，将第1组第1层图像经高斯滤波之后作为第1组金字塔的第2层。 将第一次滤波的方差$\\sigma$乘以比例系数得到$\\sigma_2=k\\sigma_1$,用它来平滑第1组第2层图像，结果图像作为第3层。 如此这般重复，最后得到L层图像，在同一组中，每一层图像的尺寸都是一样的，只是平滑系数不一样。它们对应的平滑系数分别为：$0，σ，kσ，k^2σ,k^3σ……k^(L-2)σ$ 将第1组倒数第三层图像作比例因子为2的降采样(缩小一倍)，得到的图像作为第2组的第1层，重复步骤2 这样反复执行，就可以得到一共O组，每组L层，共计O*L个图像，这些图像一起就构成了高斯金字塔，结构如下： 在高斯金字塔中一共生成O组L层不同尺度的图像，这两个量合起来（O，L）就构成了高斯金字塔的尺度空间，也就是说以高斯金字塔的组O作为二维坐标系的一个坐标，不同层L作为另一个坐标，则给定的一组坐标（O,L）就可以唯一确定高斯金字塔中的一幅图像。","categories":[{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"自适应直方图均衡化","slug":"自适应直方图均衡化","date":"2019-08-14T09:43:35.000Z","updated":"2019-12-30T17:02:45.000Z","comments":true,"path":"2019/08/14/自适应直方图均衡化/","link":"","permalink":"jiangren.work/2019/08/14/%E8%87%AA%E9%80%82%E5%BA%94%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/","excerpt":"介绍直方图均衡化，以及他的升级版。","text":"介绍直方图均衡化，以及他的升级版。 1. 普通的直方图均衡化直方图均衡化可以将灰度分布均匀化，调整对比度。 自适应的直方图均衡(Adaptive histogram equalization, AHE)是一种用于提升图像对比度的计算机图像处理技术。和普通的直方图均衡算法不同的点在于: 它计算那些指定区域的直方图，并用这些值去重新分配图像亮度来改变图像的对比度。 这种方法更适合改进图像的局部对比度和增强图像边缘来获得更多细节。 直方图均衡化利用累计分布函数(Cumulative distribution function, CDF)进行均衡，参照wiki的例子： 假设一个8×8的图像： 该灰度图像的灰度值出现次数如下表所示，为了简化表格，出现次数为0的值已经被省略。 累积分布函数计算可以得到： 其中，灰度78的像素的累积分布函数为46，均衡化后灰度变化为： h(78)=round(\\frac{46-1}{64-1}\\times255)=round(0.714\\times255)=182但是如果直方图存在明显的高峰，均衡化的结果就很不好。 下图就是一个例子。这幅图画面比较统一，因此高峰非常明显（太高了被PhotoShop截取了部分） 均衡化后： 可以看到图像明显走样，对比度显得很不自然。 为了改善这样的情况，我们可以将计算的范围从整体缩小为局部 ，即每个像素通过其周围的一个矩形范围的像素直方图进行均衡化。这就是AHE的原理。 2. 限制对比度的自适应直方图均衡化与AHE不同的是，CLAHE(Contrast Limited Adaptive Histogram Equalization )对每个小区域内的对比度都有限制。这主要是通过限制AHE的对比度提高程度来达到的。 将局部直方图中超过阈值的部分截取，然后将它均匀分布到其他部分，可以保证整个直方图总面积不变。 为了提升计算速度及去除分块处理导致的块边缘过渡不平衡等问题，可以使用插值方法。如下图所示，AHE后图像呈块状： 插值的方式是双线性插值，每个像素点出的值由它周围4个子块的映射函数值进行双线性插值得到，如下图： 首先在 $x$ 方向进行线性插值： \\begin{aligned} f\\left(x, y_{1}\\right) & \\approx \\frac{x_{2}-x}{x_{2}-x_{1}} f\\left(Q_{11}\\right)+\\frac{x-x_{1}}{x_{2}-x_{1}} f\\left(Q_{21}\\right) \\\\ f\\left(x, y_{2}\\right) & \\approx \\frac{x_{2}-x}{x_{2}-x_{1}} f\\left(Q_{12}\\right)+\\frac{x-x_{1}}{x_{2}-x_{1}} f\\left(Q_{22}\\right) \\end{aligned}然后在 $y$ 方向插值： f(x, y) \\approx \\frac{y_{2}-y}{y_{2}-y_{1}} f\\left(x, y_{1}\\right)+\\frac{y-y_{1}}{y_{2}-y_{1}} f\\left(x, y_{2}\\right)现在我可以通过四个点的像素值来预测一个点的像素值，也就是很常见的四点插值法 。这样做的好处就是不需要计算连续的像素值。相当于多重网格中，将细网格下降到粗网格，然后减少计算量。","categories":[{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"ROS基础","slug":"ROS基础","date":"2019-08-13T01:55:25.000Z","updated":"2019-12-30T16:13:57.000Z","comments":true,"path":"2019/08/13/ROS基础/","link":"","permalink":"jiangren.work/2019/08/13/ROS%E5%9F%BA%E7%A1%80/","excerpt":"ROS是一个适用于机器人编程的框架，这个框架把原本松散的零部件耦合在了一起，为他们提供通信架构，相当于应用程序之间的沟通桥梁。","text":"ROS是一个适用于机器人编程的框架，这个框架把原本松散的零部件耦合在了一起，为他们提供通信架构，相当于应用程序之间的沟通桥梁。 ROS采用了分布式的框架，通过点对点的设计让机器人的进程可以分别运行。 分布式：将不同功能数据放到不同模块，将相同数据放到不同服务器，他们之间依靠通信网络沟通。 1. ROS文件系统1.1 Catkin编译 Catkin是基于CMake的编译构建系统，具有以下特点： Catkin沿用了包管理的传统像find_package()基础结构 扩展了CMake，例如：软件包编译后无需安装就可使用；自动生成 find_package()代码，pkg-config文件；解决了多个软件包构建顺序问题。 一个Catkin的软件包（package）必须要包括两个文件： package.xml:包括了package的描述信息 CMakeLists.txt:构建package所需的CMake文件 Catkin工作流程如下： 首先在工作空间catkin_ws/src/下递归的查找其中每一个ROS的package。 package中会有package.xml和CMakeLists.txt文件，Catkin(CMake)编译系统 据CMakeLists.txt文件,从而生成makefiles(放在catkin_ws/build/)。 然后make刚刚生成的makefiles等文件，编译链接生成可执行文件(放在catkin_ws/devel)。 可以看到，Catkin就是将cmake与make指令做了一个封装从而完成整个编译过程的工具。 实际的使用过程如下： cd ~/catkin_ws #回到工作空间,catkin_make必须在工作空间下执行 sudo catkin_make #开始编译 source ~/catkin_ws/devel/setup.bash #刷新坏 注意：catkin编译之前必须要回到工作空间目录(work station)，在其他路径下编译不会成功；如果有新的目标文件产生，那么需要刷新环境，是的系统1.2 Package软件包够遭到刚才编译生成的ROS可执行文件。 package是ROS的基本编译单元，任何ROS程序只有组织成package才能编译，所以package也是ROS源代码存放的地方。一个package可以编译出来多个目标文件（ROS可执行程序、动态静态库、头文件等等）。 一个package下常见的文件、路径有： 其中定义package的是CMakeLists.txt和package.xml，这两个文件是package中必不可少的。catkin编译系统在编译前，首先就要解析这两个文件，这两个文件就定义了一个package。 创建package需要在工作空间目录catkin_ws/src，使用catkin_create_pkg命令，用法是： $ catkin_create_pkg package depends 其中package是包名，depends是依赖的包名，可以依赖多个软件包。 例如，新建一个package叫做test_pkg,依赖roscpp、rospy、std_msgs(常用依赖)。 $ catkin_create_pkg test_pkg roscpp rospy std_msgs 这样就会在当前路径下新建test_pkg软件包，包括： catkin_create_pkg帮你完成了软件包的初始化，填充好了CMakeLists.txt和package.xml，并且将依赖项填进了这两个文件中。需要注意的是，需要刷新文件才能找到。 1.3 CMakeList写法思路是：这个package的依赖是什么？要生成哪些目标？如何编译？ 以turtlesim小海龟这个pacakge为例，可roscd到tuetlesim包下查看，在 turtlesim/CMakeLists.txt find_package(catkin REQUIRED COMPONENTS ...) 项目依赖的其他软件包，都会自动成为catkin的组件（components）（就CMake而言）。因此可以将这些依赖包指定为catkin的组件，而不必再使用find_package，这样将会变得简单。 include_directories(include ${catkin_INCLUDE_DIRS} ${Boost_INCLUDE_DIRS}) 头文件地址，配合后面的link链接过程，参数由上一步find_package生成（省略了Boost的find过程） add_message_files(DIRECTORY msg FILES Color.msg Pose.msg) 在被ROS软件包编译和使用之前，ROS中的消息（.msg）、服务（.srv）和操作（.action）文件需要特殊的预处理器编译步骤。这些宏的要点是生成编程语言特定的文件，以便可以在编程语言中使用消息、服务和操作。编译系统将使用所有可用的生成器（例如gencpp、genpy、genlisp）生成绑定。 提供了三个宏来分别处理消息，服务和操作： add_message_files add_service_files add_action_files 这些宏后面必须调用一个调用生成的宏generate_messages()（不是message专有，通用，只写一次） 示例的命令，是从目标文件的msg子文件下面，添加文件名(FILES) Color.msg和Pose.msg的消息。服务也是同理。 catkin_package(CATKIN_DEPENDS geometry_msgs message_runtime std_msgs std_srvs) catkin_package() 是catkin支持的 CMake 宏指令。用来向编译系统指明 catkin-specific 的信息，而编译系统来生成 pkg-config和CMake files。必须放在消息、服务和操作之后，链接执行之前。 该函数有5个参数，这里只用了CATKIN_DEPENDS这一个，在之前的find_package中就已经找到了 add_executable(turtlesim_node ${turtlesim_node_SRCS} ${turtlesim_node_MOCS}) 作用是添加一个可执行文件构建目标，可执行文件名字叫做turtlesim_node，源代码由set(turtlesim_node_SRCS ...)设置；mocs是QT相关qt5_wrap_cpp(turtlesim_node_MOCS ${turtlesim_node_HDRS}) 后面的target_link_libraries则是将node和widgets与之前find的catkin和boost相链接；然后再为node添加依赖turtlesim_gencpp 2. ROS通信架构ROS的通信方式有以下四种： Topic 主题 Service 服务 Parameter Service 参数服务器 Actionlib 动作库 2.1 Node &amp; Master在Ros中最小的进程单元是节点(Node)，一个软件包里可以有多个可执行文件，可执行文件在运行之后就成了一个进程(process)，这个进程在ROS中就叫做节点。从程序的角度来说，node是一个可执行文件；从功能角度来说，一个node负责某一个单独的功能。 Master是节点管理器，由于实际情况中node数量众多，需要一个管理器在整个网络通信架构里管理各种node。node首先在master处进行注册，之后master会将该node纳入整个ROS程序中。 node之间的通信也是先由master进行“牵线”，才能两两的进行点对点通信。当ROS程序启动 时，第一步首先启动master，由节点管理器处理依次启动node。 当我们要启动ROS时，输入： $ roscore 此时会启动三个功能：ROS master，rosout，parameter server。这其中rosout负责日志输出的一个节点，其作用是告知用户当前系统的状态，包括输出系统的error、warning等 ，并且将log记录于日志文件中。parameter server是参数服务器，它并不是一个node， 而是存储参数配置的一个服务器。 启动master以后，节点管理器就开始按照系统的安排协调进行启动具体的节点，具体启动node的语句是： $ rosrun pkg_name node_name rosrun将会寻找pkg_name下的名为node_name的可执行程序。 rosnode的常用命令如下： 2.2 launch文件通常运行一个机器人系统我们需要启动多个node，为了方便我们用launch的方式来统一启动，命令是： $ roslaunch pkg_name file_name.launch roslaunch命令首先会自动进行检测系统的roscore有没有运行，也即是确认节点管理器是否在运行状态中，如果master没有启动，那么roslaunch就会首先启动master，然后再按照launch的规则执行。 launch文件里已经配置好了启动的规则。所以roslaunch就像是一个启动工 具，减少我们在终端中一条条输入指令的麻烦。 2.3 Topic对于实时性、周期性的消息，使用topic来传输是最佳的选择。topic是一种点对点的单向通信方式，这里的“点”指的是node，也就是说node之 间可以通过topic方式来传递信息。 topic的步骤是： publisher节点和subscriber节点到节点管理器进行注册 publisher发布topic subscriber在master的指挥下订阅该topic Subscriber接收消息会进行处理，一般这个过程叫做回调(Callback)。所谓回调就是提前定义好了一个处理函数（写在代码中），当有消息来就会触发这个处理函数，函数会对消息进行处理。 topic通信的特点是： 异步通信。发送时调用publish()方法，发送完成立即返回，不用等待反 馈。 subscriber通过回调函数的方式来处理消息 topic可以同时有多个subscribers，也可以同时有多个publishers Msg topic有很严格的格式要求，比如摄像头拍摄的rgb图像topic，就必然要遵循ROS中 义好的rgb图像格式，这种数据格式就是Message。Message按照定义解释就是topic内容的数据类型，也称之为topic的格式标准，这里和我们平常用到的Massage直观概念有所不同。 基本的msg包括bool、int8、int16、int32等等常用的数据类型，但实际情况中，我们需要重新封装，比如image类型： std_msg/Header header uint32 seq time stamp string frame_id uint32 height uint32 width string encoding uint8 is_bigendian uint32 step uint8[] data 这种结构类似于C语言结构体，我们可以将msg进一步理解为一个类，我们每次发布的内容可以理解为实例化的对象。 ROS中往往针对不同的传感器、导航系统封装好了许多msg。 2.4 Service道topic是ROS中的一种单向的异步通信方式。然而有些时候单向的通信满足不了通信要求，比如当一些节点只是临时而 非周期性的需要某些数据，如果用topic通信方式时就会消耗大量不必要的系统资源，造成系统的低效率高功耗。 这种情况下，就需要有另外一种请求-查询式的通信模型。这节我们来介绍ROS通信中的另一 种通信方式——service(服务)。 步骤是： 请求方（Client）就会发送一个request，阻塞等待。 server处理，反馈回一个reply。 NodeB是server（应答方），提供了一个服务的接口，叫做/Service，通过这个接口和Clinet通信。 Service是同步通信方式，所谓同步就是说，此时NodeA发布请求后会在原地等待reply，直到 NodeB处理完了请求并且完成了reply，NodeA才会继续执行。这样避免了频繁的消息传递。 Srv 类似msg文件，srv文件是用来描述service数据类型的, service通信的数据格式定义在 *.srv中 举个例子msgs_demo/srv/DetectHuman.srv： bool start_detect --- my_pkg/HumanPose[] pose_data 该服务例子取自OpenNI的人体检测ROS软件包。它是用来查 询当前深度摄像头中的人体姿态和关节数的。第一行是请求格式，中间用—-隔开，第三行是应答格式。在本例中，请求为是否开始检测，应答为一个数组，数组的每个元素为某个人的姿态。而对于人的姿态HumanPose，其实是一个msg，如下。所以srv可以嵌套msg在其中，但它不能嵌套srv。 msgs_demo/msg/HumanPose.msg： std_msgs/Header header string uuid int32 number_of_joints my_pkg/JointPose[] joint_data 2.5 Parameter server除了前文介绍的主题和服务这两种通信方式，另一种特殊的通信方式是参数服务器。于参数服务器是节点存储参数的地方、用于配置参数，全局共享参数。参数服务器使用互联网传输，在节点管理器中运行，实现整个通信过程。参数服务器维护着一个数据字典，字典里存储着各种参数和配置。 每一个key不重复，且每一个key对应着一个value，这就是字典的映射关系。，我们往往将一些不常用到的参数和配置放入参数服务器里的字典里，这样对这些数据进行读写都将方便高效。 2.6 ActionAction是对service的一个改进，适合于长时间通信。假如利用service通信方式，那么publisher会很长时间接受不到反馈的reply，会致使通信受阻。actionlib通信过程可以随时被查看过程进度，也可以终止请求，使得 在一些特别的机制中拥有很高的效率。 通信双方在ROS Action Protocol下进行交流通信是通过接口来实现，类似于TCP下的socket套接字接口。 如上图，客户端会向服务器发送目标指令和取消动作指令,而服务器则可以给客户端发送 实时的状态信息，结果信息，反馈信息等等,从而完成了service没法做到的部分。 动作的内容格式应包含三个部分：目标、结果、反馈 目标：机器人执行一个动作，应该有明确的移动目标信息，包括一些参数的设定，方向、角度、速 度等等。从而使机器人完成动作任务。 结果：当运动最终完成时，动作服务器把本次运动的结果数据发送给客户端，使客户端得到本次动作的全部信息，例如可能包含机器人的运动时长，最终姿势等等。 反馈：在动作进行的过程中，应该有实时的状态信息反馈给服务器的实施者，告诉实施者动作完成的状态，可以使实施者作出准确的判断去修正命令。 Action规范文件的后缀名是.action，它的内容格式如下： # Define the goal uint32 dishwasher_id -- # Define the result uint32 total_dishes_cleaned -- # Define a feedback message float32 percent_complete 3. roscpp如roscpp是C++语言ROS接口，我们直接调用它所 提供的函数就可以实现topic、service等通信功能。roscpp位于/opt/ros/kinetic之下，用C++实现了ROS通信。通常我们要调用ROS的C++接口，首先就需要#include roscpp的主要部分包括： ros::init() 解析传入的ROS参数，创建node第一步需要用到的函数 ros::NodeHandle 和topic、service、param等交互的公共接口 ros::master 包含从master查询信息的函数 ros::this_nod 包含查询这个进程(node)的函数 ros::service 包含查询服务的函数 ros::param 包含查询参数服务器的函数，而不需要用到NodeHandle ros::names 包含处理ROS图资源名称的函数 3.1 编写消息发布器和订阅器创建程序包首先需要创建Catkin工作空间： $ mkdir -p ~/catkin_ws/src #创建一个目录，-p表示如果不存在就创建否则不创建 $ cd ~/catkin_ws/ $ catkin_make 在catkin_ws工作空间内$ cd ~/catkin_ws/src 然后创建一个名为beginner_tutorials的新程序包，这个包依赖于std_msg、roscpp和rospy： $ catkin_create_pkg beginner_tutorials std_msgs rospy roscpp 这将会创建一个名为beginner_tutorials的文件夹，这个文件夹里面包含一个package.xml文件和一个CMakeLists.txt文件，这两个文件都已经自动包含了部分在执行catkin_create_pkg命令时提供的信息。 发布器节点首先进入之前创建的 beginner_tutorials package 路径下，在这之中创建一个src文件夹： cd ~/catkin_ws/src/beginner_tutorials mkdir -p ~/catkin_ws/src/beginner_tutorials/src 这个文件夹将会用来放置 beginner_tutorials package 的所有源代码。然后创建src/talker.cpp 文件，在其中写发布器源代码，如下： #include &quot;ros/ros.h&quot; #include &quot;std_msgs/String.h&quot; #include &lt;sstream&gt; int main(int argc, char **argv) { ros::init(argc, argv, &quot;talker&quot;); ros::NodeHandle n; ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;, 1000); ros::Rate loop_rate(10); int count = 0; while (ros::ok()) { std_msgs::String msg; std::stringstream ss; ss &lt;&lt; &quot;hello world &quot; &lt;&lt; count; msg.data = ss.str(); ROS_INFO(&quot;%s&quot;, msg.data.c_str()); chatter_pub.publish(msg); ros::spinOnce(); loop_rate.sleep(); ++count; } return 0; } 下面分块解释： 1.用init初始化这个节点，唯一命名为talker，然后为他创建一个句柄n（这里是自动对应上的，一个一个进程只能有一个节点） ros::init(argc, argv, &quot;talker&quot;); ros::NodeHandle n; 2.告诉 master 我们将要在 chatter（话题名） 上发布 std_msgs/String 消息类型的消息。这样 master 就会告诉所有订阅了 chatter 话题的节点，将要有数据发布。第二个参数是发布序列的大小，如果我们发布的消息的频率太高，缓冲区中的消息在大于 1000 个的时候就会开始丢弃先前发布的消息。 ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;, 1000); 3.ros::Rate 对象可以允许你指定自循环的频率。它会追踪记录自上一次调用 Rate::sleep() 后时间的流逝，并休眠直到一个频率周期的时间。在这个例子中，我们让它以 10Hz 的频率运行。 ros::Rate loop_rate(10); 4.roscpp 会默认生成一个 SIGINT 句柄，它负责处理 Ctrl-C 键盘操作——使得 ros::ok() 返回 false。如果下列条件之一发生，ros::ok() 返回false： SIGINT 被触发 (Ctrl+C) 被另一同名节点踢出 ROS 网络 ros::shutdown() 被程序的另一部分调用 节点中的所有 ros::NodeHandles 都已经被销毁 while (ros::ok()) {...} 5.为msg添加数据成员hello world；用ROS_INFO 和其他类似的函数可以用来代替 printf/cout 等函数；在这个例子中 ros::spinOnce()非必须，因为我们不接受回调。然而，如果程序里包含其他回调函数，加上 ros::spinOnce()这一语句，否则回调函数就永远也不会被调用了。 这是ROS消息回调处理函数，在ROS的主循环中，程序需要不断调用ros::spin()或 ros::spinOnce()，两者区别在于前者调用后不会再返回，也就是你的主程序到这儿就不往下执行了，而后者在调用后还可以继续执行之后的程序。 loop_rate.sleep();是调用 ros::Rate 对象来休眠一段时间以使得发布频率为 10Hz。 while (ros::ok()) { std_msgs::String msg; std::stringstream ss; ss &lt;&lt; &quot;hello world &quot; &lt;&lt; count; msg.data = ss.str(); ROS_INFO(&quot;%s&quot;, msg.data.c_str()); chatter_pub.publish(msg); ros::spinOnce(); loop_rate.sleep(); ++count; } 订阅器节点在 beginner_tutorials package 目录下创建 src/listener.cpp 文件。 #include &quot;ros/ros.h&quot; #include &quot;std_msgs/String.h&quot; void chatterCallback(const std_msgs::String::ConstPtr&amp; msg) { ROS_INFO(&quot;I heard: [%s]&quot;, msg-&gt;data.c_str()); } int main(int argc, char **argv) { ros::init(argc, argv, &quot;listener&quot;); ros::NodeHandle n; ros::Subscriber sub = n.subscribe(&quot;chatter&quot;, 1000, chatterCallback); ros::spin(); return 0; } 这是一个回调函数，当接收到 chatter 话题的时候就会被调用。消息是以 boost shared_ptr 指针的形式传输，这就意味着可以存储它而又不需要复制数据。 void chatterCallback(const std_msgs::String::ConstPtr&amp; msg) { ROS_INFO(&quot;I heard: [%s]&quot;, msg-&gt;data.c_str()); } 告诉 master 我们要订阅 chatter 话题上的消息。当有消息发布到这个话题时，ROS 就会调用 chatterCallback() 函数。第二个参数是队列大小，以防我们处理消息的速度不够快，当缓存达到 1000 条消息后，再有新的消息到来就将开始丢弃先前接收的消息。 ros::Subscriber sub = n.subscribe(&quot;chatter&quot;, 1000, chatterCallback); 编译节点并测试之前创建包时，创建了创建了 package.xml 和 CMakeLists.txt 文件，在生成好的CMakeLists.txt后面加入 ## Build talker and listener include_directories(include ${catkin_INCLUDE_DIRS}) add_executable(talker src/talker.cpp) target_link_libraries(talker ${catkin_LIBRARIES}) add_dependencies(talker beginner_tutorials_generate_messages_cpp) add_executable(listener src/listener.cpp) target_link_libraries(listener ${catkin_LIBRARIES}) add_dependencies(listener beginner_tutorials_generate_messages_cpp) 然后运行catkin_make。注意：如果你是添加了新的 package，你需要通过 --force-cmake 选项告诉 catkin 进行强制编译 # In your catkin workspace $ catkin_make 按顺序启动并刷新： $ roscore # In your catkin workspace $ cd ~/catkin_ws $ source ./devel/setup.bash 注意！roscore,talker,listener需要开三个不同的terminal，talker和listener开启时都需要刷新。 启动发布器： $ source ./devel/setup.bash $ rosrun beginner_tutorials talker 启动订阅器： $ source ./devel/setup.bash $ rosrun beginner_tutorials listener 3.2 编写简单的服务器和客户端首先需要创建一个srv，用来描述服务器数据类型。 int64 a int64 b --- int64 sum 编写服务器节点创建add_two_ints_server.cpp #include &quot;ros/ros.h&quot; #include &quot;beginner_tutorials/AddTwoInts.h&quot; bool add(beginner_tutorials::AddTwoInts::Request &amp;req, beginner_tutorials::AddTwoInts::Response &amp;res) { res.sum = req.a + req.b; ROS_INFO(&quot;request: x=%ld, y=%ld&quot;, (long int)req.a, (long int)req.b); ROS_INFO(&quot;sending back response: [%ld]&quot;, (long int)res.sum); return true; } int main(int argc, char **argv) { ros::init(argc, argv, &quot;add_two_ints_server&quot;); ros::NodeHandle n; ros::ServiceServer service = n.advertiseService(&quot;add_two_ints&quot;, add); ROS_INFO(&quot;Ready to add two ints.&quot;); ros::spin(); return 0; } 我们自己创建了一个add函数，这个函数提供两个int值求和的服务，int值从request里面获取，而返回数据装入response内，这些数据类型都定义在srv文件内部，函数返回一个boolean值。 Request值从分割线上方获取，Response值从分割线下方获取 bool add(beginner_tutorials::AddTwoInts::Request &amp;req, beginner_tutorials::AddTwoInts::Response &amp;res) { res.sum = req.a + req.b; ROS_INFO(&quot;request: x=%ld, y=%ld&quot;, (long int)req.a, (long int)req.b); ROS_INFO(&quot;sending back response: [%ld]&quot;, (long int)res.sum); return true; } 通过ros::NodeHandle::advertiseService()来创建ros::ServiceServer。 advertiseService() 工作方式类似 subscribe()函数，提供一个服务名和回调函数。 ros::ServiceServer service = n.advertiseService(&quot;add_two_ints&quot;, add); ROS_INFO(&quot;Ready to add two ints.&quot;); 编写客户端节点在beginner_tutorials包中创建src/add_two_ints_client.cpp文件，并复制粘贴下面的代码： #include &quot;ros/ros.h&quot; #include &quot;beginner_tutorials/AddTwoInts.h&quot; #include &lt;cstdlib&gt; int main(int argc, char **argv) { ros::init(argc, argv, &quot;add_two_ints_client&quot;); if (argc != 3) { ROS_INFO(&quot;usage: add_two_ints_client X Y&quot;); return 1; } ros::NodeHandle n; ros::ServiceClient client = n.serviceClient&lt;beginner_tutorials::AddTwoInts&gt;(&quot;add_two_ints&quot;); beginner_tutorials::AddTwoInts srv; srv.request.a = atoll(argv[1]); srv.request.b = atoll(argv[2]); if (client.call(srv)) { ROS_INFO(&quot;Sum: %ld&quot;, (long int)srv.response.sum); } else { ROS_ERROR(&quot;Failed to call service add_two_ints&quot;); return 1; } return 0; } add_two_ints service创建一个client。ros::ServiceClient 对象待会用来调用service。 ros::ServiceClient client = n.serviceClient&lt;beginner_tutorials::AddTwoInts&gt;(&quot;add_two_ints&quot;); 实例化一个由ROS编译系统自动生成的service类，并给其request成员赋值。一个service类包含两个成员request和response。同时也包括两个类定义Request和Response。atoll把字符串转换为long long integer beginner_tutorials::AddTwoInts srv; srv.request.a = atoll(argv[1]); srv.request.b = atoll(argv[2]); 代码是在调用service。由于service的调用是模态过程（调用的时候占用进程阻止其他代码的执行），一旦调用完成，将返回调用结果。如果service调用成功，call()函数将返回true，srv.response里面的值将是合法的值。如果调用失败，call()函数将返回false，srv.response里面的值将是非法的。 if (client.call(srv)) 还是老规矩，三个terminal启动，注意刷新，注意客户端需要传参 $ roscore $ rosrun beginner_tutorials add_two_ints_server $ rosrun beginner_tutorials add_two_ints_client 1 3 服务器窗口：","categories":[{"name":"Linux","slug":"Linux","permalink":"jiangren.work/categories/Linux/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"jiangren.work/tags/Linux/"},{"name":"ROS","slug":"ROS","permalink":"jiangren.work/tags/ROS/"}]},{"title":"SLAM基础8-建图","slug":"SLAM基础8-建图","date":"2019-08-11T11:31:34.000Z","updated":"2019-12-30T14:45:17.000Z","comments":true,"path":"2019/08/11/SLAM基础8-建图/","link":"","permalink":"jiangren.work/2019/08/11/SLAM%E5%9F%BA%E7%A1%808-%E5%BB%BA%E5%9B%BE/","excerpt":"通过前端的信息采集，后端优化，回环优化后我们需要对信息汇总，最终形成一幅地图。本文介绍了SLAM中几种常见的建图策略。","text":"通过前端的信息采集，后端优化，回环优化后我们需要对信息汇总，最终形成一幅地图。本文介绍了SLAM中几种常见的建图策略。 在经典的 SLAM 模型中，我们所谓的地图，即所有路标点的集合。一旦我们确定了路标点的位置，那就可以说我们完成了建图，这就是所谓的稀疏路标地图。这种地图只建模感兴趣的部分，也就特征点（路标点），而稠密地图是指建模所有看到过的部分。 对于同一个桌子，稀疏地图可能只建模了桌子的四个角，而稠密地图则会建模整个桌面。虽然从定位角度看，只有四个角的地图也可以 用于对相机进行定位，但由于我们无法从四个角推断这几个点之间的空间结构，所以无法仅用四个角来完成导航、避障等需要稠密地图才能完成的工作。 1. 单目稠密建图我们从最简单的情况开始：在给定相机轨迹的基础上，如何根据一段时间 的视频序列，来估计某张图像的深度。换言之，我们不考虑 SLAM，先考虑稍为简单的建图问题。 基本思路是：首先提特征，并根据描述子匹配。换言之，通过特征，我们对某一个空间点进行了跟踪，知道了它在各个图像之间的位置。 之后，通过不同视角下的观测，利用三角测量原理估计深度。 如何确定第一张图的某像素，出现在其他图里的位置呢？这需要用到极线搜索和块匹配技术。由于我们拍摄了多张图片，需要使用多次三角测量让深度逐渐收敛，需要使用深度滤波器技术。 1.1 极线搜索与块匹配 左边的相机观测到了像素$p_1$，由于这是一个单目相机，我们无法知道它的深度，因此该像素的空间点分布在图中的这条射线段上。由于知道了相机的运动，所以基线$O_1O_2$和极线$l_2$都是确定的。现在问题就变为：如何根据极线找到$p_2$的位置？由于单个像素不好判断，所以为了提高区分度需要使用块匹配。 我们在$p_1$周围取$w×w$的小块，同时在$l_2$极线附近取若干小块，比较他们的差异。 比较的方法常见的有： SAD(sum of Absolute Difference)取两个小块的绝对值之和 SSD(Sum of Squared Distance)取两个小块的差的平方和 NCC(Normalized Cross Correlation)归一化互相关 S(A, B)_{N C C}=\\frac{\\sum_{i, j} A(i, j) B(i, j)}{\\sqrt{\\sum_{i, j} A(i, j)^{2} \\sum_{i, j} B(i, j)^{2}}}在搜索距离较长的情况下，我们通常会得到一个非凸函数：这个分布存在着许多峰值，然而真实的对应点必定只有一个。 1.2 高斯分布的深度滤波器对深度的分布假设存在着若干种不同的做法。首先，在比较简单的假设条件下，我们 可以假设深度值服从高斯分布，得到一种类卡尔曼式的方法。 在上一节中，我们可以通过匹配求得一帧图片中特征点的大致位置和它的不确定度，现在需要做两件事：像素的不确定度和实际点深度的不确定度的关系？多帧图像的不确定度怎么融合？ 融合的办法采用了高斯分布的计算性质：两个高斯分布的乘积依然是高斯分布。 假设某个点的深度服从$P(d)=N(\\mu,\\sigma^2)$，每当新的数据到来时，我们可以观测到它的深度，假设这个深度依然是高斯分布$P(d{obs})=N(\\mu{obs},\\sigma^2_{obs})$那么根据高斯分布的乘法公式可以得到： \\mu_{\\text {fuse}}=\\frac{\\sigma_{\\text {obs}}^{2} \\mu+\\sigma^{2} \\mu_{\\text {obs}}}{\\sigma^{2}+\\sigma_{\\text {obs}}^{2}}, \\quad \\sigma_{\\text {fuse}}^{2}=\\frac{\\sigma^{2} \\sigma_{\\text {obs}}^{2}}{\\sigma^{2}+\\sigma_{o b s}^{2}}接下来考虑像素的不确定度和实际点深度的不确定度的关系，换句话说需要为上述式子$u{obs},\\sigma^2{obs}$求值。 根据几何计算单个像素引起: p'=t\\frac{\\sin{\\beta'}}{sin{\\gamma}}如果认为极线搜索的块匹配仅有一个像素的误差，那么就可以设： \\sigma_{obs}=p-p'在实际工程中，当不确定性小于一 定阈值之后，就可以认为深度数据已经收敛了。综上所述，我们给出了估计稠密深度的一个完整的过程： 假设所有像素深度满足某个初始的高斯分布； 当新数据产生时，通过极线搜索和块匹配确定投影点的位置； 根据集合关系计算三角化后的深度以及不确定性； 将当前观测融合进上一次的估计中。若收敛则停止计算，否则返回2。 2. RGB-D稠密建图RGBD建图常见的是点云的方式。但是点云有几个明显的缺点： 点云地图通常规模很大. 点云地图产生了很多无用信息(比如地毯上的褶皱、阴暗处的影子) 点云地图无法处理运动物体。因为我们的做法里只有“添加点”，而没有“当点消失时把它移除”的做法。 因此可以采用改进的八叉树建图方法，这是一种灵活的、压缩的、又能随时更新的地图形式。 如果我 们把一个小方块的每个面平均切成两片，那么这个小方块就会变成同样大小的八个小方块。 这个步骤可以不断的重复，直到最后的方块大小达到建模的最高精度。在这个过程中，把 “将一个小方块分成同样大小的八个”这件事，看成“从一个节点展开成八个子节点”，那么，整个从最大空间细分到最小空间的过程，就是一棵八叉树（Octo-tree）。 当某个方块的所有子节点都被占据或都不被占据时，就没必要展开这个节点。例如，一开始地图为空白时，我们就只需一个 根节点，而不需要完整的树。当在地图中添加信息时，由于实际的物体经常连在一起，空白的地方也会常常连在一起，所以大多数八叉树节点都无需展开到叶子层面。所以说，八叉树比点云节省了大量的存储空间。 从点云层面来讲，我们自然可以用0 表示空白，1 表示被占据。这种 0-1 的表示可以用一个比特来存储，节省空间，不过显得有些过于简单了。由于噪声的影响，我们可能会看到某个点一会为 0，一会儿为 1；或者大部分时刻为 0，小部分时刻为 1；或者除了“是、否”两种情况之外，还有一个“未知” 的状态。我们会选择用概率形式表达某节点是否被占据的事情，例如用一个浮点数 [0-1] 来表达。如果不断观测到它被占据，那么让这个值不断增加；反之，如果不断观测到它是空白，那就让它不断减小即可。 为了避免增加超过1，我们采用对数变化性质： y=logit(x)=log(\\frac{x}{1-x})可以看到，当 $y$ 从$−∞$ 变到 $+∞$ 时，$x$ 相应地从 0 变到了 1。而当 $y$ 取 0 时，$x$ 取 到 0.5。 假设我们在 RGB-D 图像中观测到某个像素带有深度 $d$，这说明了一件事：我们在深度值对应的空间点 上观察到了一个占据数据，并且，从相机光心出发，到这个点的线段上，应该是没有物体的（否则会被遮挡）。利用这个信息，可以很好地对八叉树地图进行更新，并且能处理运动的结构。","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"}]},{"title":"SLAM基础7-回环检测","slug":"SLAM基础7-回环检测","date":"2019-08-11T09:33:24.000Z","updated":"2019-12-30T14:53:03.000Z","comments":true,"path":"2019/08/11/SLAM基础7-回环检测/","link":"","permalink":"jiangren.work/2019/08/11/SLAM%E5%9F%BA%E7%A1%807-%E5%9B%9E%E7%8E%AF%E6%A3%80%E6%B5%8B/","excerpt":"本文介绍了回环检测的概念和常用方法。","text":"本文介绍了回环检测的概念和常用方法。 1. 回环检测概述随着时间的推移，机器人的运动轨迹的误差会逐渐加大，一般情况下我们只能做到相邻帧之间的约束$xk,x{k-1}$，我们希望构建一些时间间隔更久远的约束：比如$x1-x{100}$之间的位姿关系。产生这种约束的原因是：我们察觉到相机经过了同一个地方，采集到了相似的数据。 现在问题在于，如何相机如何判断自己经过了同一地方。在解决这个问题之前，我们先引入一个概念： 回环检测的结果分为如上图所示的四种：TP FP FN TN。如下图所示图1不是回环，但由于太过相似被误认为回环，图2是回环但由于光线变化所以没有被检测出来。 我们可以定义两个统计量：正确率和召回率(Precision &amp; Recall) Precision=\\frac{TP}{TP+FP}\\\\ Recall=\\frac{TP}{TP+FN}正确率的意思是：当算法认为它是回环时，它真的是回环的概率是多大；召回率的意思是：对于一个事实上的回环，算法检测出的概率是多大。这两者一般是矛盾的： 当检测条件宽松时，召回率会上升，但准确率会下降。好的算法在较高召回率的情况下也能保证好的准确率。通常情况下，SLAM选择高准确率，适当放弃一些召回率，为了保证不会出现较大的错误可以牺牲一些精确度。 2. 词袋模型如何确定两张图具有相似性，从而判断此处为回环是非常关键的技术。一般来说我们可以任意选取两张图做特征匹配，但这样时间复杂度太高。我们可以借鉴数据结构中字典结构中的键值映射的思路。 词袋，也就是 Bag-of-Words（BoW），目的是用“图像上有哪几种特征”来描述一个图像。它所使用的数据结构是背包模型，也就是没有顺序的容器。假设一张图中发现了“人、车、狗”这三个对象，我们就可以把他们记录为单词$w_1,w_2,w_3$，在另一张图中只发现了“人、车”这两个单词，所以： A=1·w_1+1·w_2+0·w_3直接可以表示为$[1,1,0]^T$,当然也可以考虑出现的个数这样就不是二进制表示了$[2,1,0]^T$，因此我们只需要比较两张图的词袋的一范数(绝对值之和)，就可以判断他们的相似性。 3. 字典模型3.1 创建字典按照前面的介绍，字典由很多单词组成，而每一个单词代表了一个概念。一个单词与一个单独的特征点不同，它不是从单个图像上提取出来的，而是某一类特征的组合。所以，字典生成问题类似于一个聚类（Clustering）问题。 首先，假设我们对大量的图像提取了特征点，比如说有 N 个。现在，我们想找一个有 k 个单词的字典，每 个单词可以看作局部相邻特征点的集合，应该怎么做呢？这可以用经典的 K-means（K均值）算法解决。步骤如下： 随机选取k个中心点； 对每个样本计算他们与中心点的距离，取最小距离为归类； 重新计算每个类的中心点； 如果中心点的变化很小则算法收敛，退出；否则返回2 根据 K-means，我们可以把已经提取的大量特征点聚类成一个含有k个单词的字典了。现在的问题，变为如何根据图像中某个特征点，查找字典中相应的单词？ 一般使用K叉树，步骤是： 在根节点，用k-means将所有样本聚成k类 对上层的每个父节点，把属于该节点的样本再次聚成k类，得到下一层。 以此类推，最后得到叶子层，也就是所谓的单词。 词袋模型利用视觉词典（vocabulary）来把图像转化为向量。过程如下： 这棵树里面总共有$1+K+\\cdots+K^L=(k^{L+1}-1)/(K-1)$个节点，所有叶节点在L层形成$W=K^L$类，每一类用该类中所有特征的平均特征（meanValue）作为代表，称为单词（word）。每个叶节点被赋予一个权重。常见的权重有TF、IDF、TF-IDF等 \\text{IDF}_k=\\log\\left(\\frac{\\text{number of all images}}{\\text{number of images reach k-th leaf node}}\\right)\\\\ \\text{TF}_k=\\frac{\\text{number of features locates in leaf node k}}{\\text{number of all features}}\\\\ \\text{TF-IDF}_k=\\text{TF}_k*\\text{IDF}_k TF-IDF的主要思想是：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。TF-IDF实际上是TF * IDF，TF代表词频(Term Frequency)，表示词条在文档d中出现的频率。IDF代表逆向文件频率(Inverse Document Frequency)。如果包含词条t的文档越少，IDF越大，表明词条t具有很好的类别区分能力。 视觉词典可以通过离线训练大量数据得到。训练中只计算和保存单词的IDF值，即单词在众多图像中的区分度。TF则是从实际图像中计算得到各个单词的频率。单词的TF越高，说明单词在这幅图像中出现的越多；单词的IDF越高，说明单词本身具有高区分度。二者结合起来，即可得到这幅图像的BoW描述。 3.2 特征识别应用离线生成视觉词典以后，我们就能在线进行图像识别或者场景识别。实际应用中分为两步进行： 为图像生成一个表征向量$v_{1×W}$，图像中的每个特征都在词典中搜索其最近邻的叶节点。所有叶节点上的权重集合构成了BoW向量$v$ 根据BoW向量，计算当前图像和其它图像之间的距离: s(v_1,v_2)=1-\\frac{1}{2}\\left |\\frac{v_1}{|v_1|}-\\frac{v_2}{|v_2|}\\right| 在视觉词典之上，引入了正向索引（direct index）和反向索引（inverse index）的概念。 用反向索引记录每个叶节点对应的图像编号。当识别图像时，根据反向索引选出有着公共叶节点的备选图像并计算得分，而不需要计算与所有图像的得分。 比如下面三张图包含了一些特征： imageA：cat, dog, panda imageB： cat imageC:：cat，dog 那么就会得到以下反向文件索引： dog : { A, C } cat：{ A, B , C} panda：{ A } 当新得到一张图片D，它包含了cat和dog，则对应集合$(A,B)\\cap(A,B,C)=(A,B)$所以图片D和图片C最像。 而正排索引非常慢。","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}]},{"title":"SLAM基础6-后端","slug":"SLAM基础6-后端","date":"2019-08-11T04:41:14.000Z","updated":"2020-02-08T19:41:29.000Z","comments":true,"path":"2019/08/11/SLAM基础6-后端/","link":"","permalink":"jiangren.work/2019/08/11/SLAM%E5%9F%BA%E7%A1%806-%E5%90%8E%E7%AB%AF/","excerpt":"前一章讲的非线性优化方法其实是后端优化中的一个工具。后端需要对前端传来的传感信息进行优化，方法有卡尔曼滤波和光束法平差BA两种。","text":"前一章讲的非线性优化方法其实是后端优化中的一个工具。后端需要对前端传来的传感信息进行优化，方法有卡尔曼滤波和光束法平差BA两种。 1. 经典的后端优化方法1.1 状态估计的概率解释视觉里程计只有短暂的记忆，在后端优化中，我们通常考虑一个更长时间内（或所有时间内）的状态估计问题，而且不仅使用过去的信息更新自己的状态，也会用未来的信息来更新自己。 \\begin{equation} \\left\\{ \\begin{array}\\\\ x_k=f(x_{k-1},u_k,\\omega_k) \\\\ z_{k,j}=h(y_j,x_k,v_{k,j}) \\end{array} \\right. \\end{equation}运动方程和观测方程组成了SLAM系统，每个方程都受噪声影响，所以要把这里的位姿 $x$ 和路标 $y$ 看成服从某种概率分布的随机变量，而不是单独的一个数。因此整个问题变成了：当我拥有某些运动数据 $u$ 和观测数据 $z$ 时，如何来确定状态量 $x,y$ 的分布？ 当没有观测数据，只有运动方程时，如左图所示，噪声导致的误差会逐渐累积，不确定性越来越大。如果我们可以观测路标点，误差会得到修正，不确定性就会减小。 下面以定量的角度思考。令$x_k$为$k$时刻的所有未知量，它包含了当前时刻的相机位姿和$m$个路标点。 x_k=(x_k,y_1,...,y_m)​>同时，把$k$时刻的所有观测记为$z_k$，$u_k$还是表示传感器输入，整个方程可以写得比较简单。 \\begin{equation} \\left\\{ \\begin{array}\\\\ x_k=f(x_{k-1},u_k)+w_k\\\\ z_k=h(x_k)+v_k \\end{array} \\right. \\end{equation}现在考虑第$k$时刻的情况。我们希望用过去0到$k$的数据，来估计现在的状态分布： P(x_{k}|x_{0},u_{1:k},z_{1:k})下标 $0:k$表示从 0 时刻到 k 时刻的所有数据。请注意 $z_k$ 来表达所有在k时刻的观测数据，注意它可能不止一个，只是这种记法更加方便。这个式子表达了：已知初始位姿、之前所有的观测数据和传感器数据，通过这些条件来估计$k$时刻的位姿。 按照贝叶斯法则，展开可得： P(x|x_{0},u_{1:k},z_{1:k})\\propto P(z_{k}|x_{k})P(x_{k}|x_{0},u_{1:k},z_{1:k-1})左边为后验概率，右边第一项为似然概率（已知数据求模型参数），第二项为先验概率。似然概率可以由观测方程计算得到，至于先验概率，我们知道当前状态$x(k)$是根据过去所有状态估计得到，所以他至少会受到$x(k-1)$的影响，于是在此处按照条件概率展开： P(x_{k}|x_{0},u_{1:k},z_{1:k-1})=\\int P(x_{k}|x_{k-1},x_{0},u_{1:k},z_{1:k-1})P(x_{k-1}|x_{0},u_{1:k},z_{1:k-1})d_{x_{k-1}}如果我们考虑更久之前的状态，也可以继续对此式进行展开，但现在我们只关心 $k$ 时刻和 $k−1$ 时刻的情况。 后续的处理有两种方式：其一是假设马尔可夫性，即k 时刻状态只与k−1时刻状态有关，而与再之前的无关；其二依然考虑 k 时刻状态与之前所有状态的关系。前一种得到的方法是扩展卡尔曼滤波(EKF)，第二种得到非线性优化。 1.2 线性系统和KF按照马尔科夫性，状态只与上一个时刻有关，因此公式可以进行简化。 P(x_{k}|x_{0},u_{1:k},z_{1:k})=\\int P(x_{k}|x_{k-1},x_{0},u_{1:k},z_{1:k-1})P(x_{k-1}|x_{0},u_{1:k},z_{1:k-1})d_{x_{k-1}}由于$k$时刻的状态与$k-1$之前无关，所以可以简化为只与$x_{k-1}$和$u_k$相关的形式，所以第一项可以简化为： P(x_{k}|x_{k-1},x_{0},u_{1:k},z_{1:k-1})=P(x_{k}|x_{k-1},u_{k})第二项由于输入量$u_k$与$k-1$无关，所以可以将其去掉： P(x_{k-1}|x_{0},u_{1:k},z_{1:k-1})=P(x_{k-1}|x_{0},u_{1:k-1},z_{1:k-1})可以看到这就是$k-1$时刻的状态分布（参照贝叶斯法则展开前$P(x{k}|x{0},u{1:k},z{1:k})$）。我们实际在做的是“如何把 k−1 时刻的状态分布推导至 k 时刻”这样一件事。 首先从简单的线性高斯系统开始。 \\left\\{ \\begin{matrix} x_{k}=A_{k}x_{k-1}+u_{k}+w_{k} \\\\ z_{k}=C_{k}x_{k}+v_{k}\\ \\end{matrix}\\right.第一个公式描述状态量$xk$，$A_k$是状态转移矩阵，负责描述$x{k-1}$时刻到$x_k$的状态，$u_k$是控制矩阵，是k-1到k状态改变的原因，$w_k$是噪声。 第二个公式描述观测量$z_k$，$C_k$时观测矩阵，$v_k$是噪声。并假设所有的状态和噪声均满足高斯分布。记这里的噪声服从零均值高斯分布： w_k\\sim N(0,R),\\ v_k\\sim N(0,Q)假设我们已知$x{k-1}$状态分布的后验状态估计$\\overset{\\wedge }{x}{k-1}$和协方差$\\overset {\\wedge }x{k-1}$根据输入数据和观测数据，确定$x_k$的后验分布。$\\overset{\\wedge }x{k}$表示后验，$\\overset{- }x_{k}$表示先验。 高斯分布运算性质： x+y\\sim N(\\mu_x+\\mu_y,\\sum _{xx}+\\sum_{yy})若$y=\\textbf{A}x$，则y满足： y\\sim N(A\\mu,A\\sum_{xx}A^T) 所以有： P(x_{k}|x_{0},u_{1:k},z_{1:k-1})=N(A_{k}\\overset{-}{x}_{k-1}+u_{k},A_{k}\\overset{-}{P}_{k-1}A_{k}^{T}+R)=N(\\overset{-}{x}_{k},\\overset{-}{P}_{k})因此我们得到了两个公式：状态预测公式，协方差预测公式 \\overset{-}{x}_{k}=A_{k}\\overset{-}{x}_{k-1}+u_{k}\\\\ \\overset{-}{P}_{k}=A_{k}\\overset{-}{P}_{k-1}A_{k}^{T}+R这里$\\overset{-}{x}{k}$表示先验分布，也就是不准确的，$\\overset{\\wedge }{x}{k}$表示的是后验分布，是经过修正的。 得到的这两个结果都是预测结果，他们需要通过观测方程来进行修正。由于计算过程太复杂，直接给出结果： \\overset{\\wedge }{x}_{k}=\\overset{- }{x}_{k}+K(z_{k}-C_{k}\\overset{- }{x}_{k})\\\\ \\overset{\\wedge }{P}_{k}=(I-KC_{k})\\overset{-}{P }_{ k}\\\\计算出$\\overset{\\wedge }{P}_{k}$是为了留给下一次迭代使用。 这里的$K$表示卡尔曼系数，它具有两个作用： 决定相信预测模型$\\overset{- }{x}_{k}$更多一些还是观测模型更多一些 将残差$(z{k}-C{k}\\overset{- }{x}_{k})$的表现形式由观测域转化到状态域 卡尔曼系数的计算公式是： K=\\overset{\\wedge }{P}_{k}C_{k}^{T}Q^{-1}=\\overset{-}{P}_{k}{C}_{k}^{T}({C}_{k}\\overset{-}{P}_{k}{C}_{k}^{T}+Q_{k})^{-1}所以卡尔曼滤波可以由五个公式概括： \\begin{equation} \\left\\{ \\begin{array}{lr} \\overset{-}{x}_{k}=A_{k}\\overset{-}{x}_{k-1}+u_{k}\\\\ \\overset{-}{P}_{k}=A_{k}\\overset{-}{P}_{k-1}A_{k}^{T}+R\\\\ \\overset{\\wedge }{x}_{k}=\\overset{- }{x}_{k}+K(z_{k}-C_{k}\\overset{- }{x}_{k})\\\\ \\overset{\\wedge }{P}_{k}=(I-KC_{k})\\overset{-}{P }_{ k}\\\\ K=\\overset{\\wedge }{P}_{k}C_{k}^{T}Q^{-1}=\\overset{-}{P}_{k}{C}_{k}^{T}({C}_{k}\\overset{-}{P}_{k}{C}_{k}^{T}+Q_{k})^{-1} \\end{array} \\right. \\end{equation}前两个是预测公式，后两个是更新公式（将预测的先验值修正）。 1.3 非线性系统和EKF卡尔曼滤波是针对线性方程，当系统非线性时需要通过一些操作来近似，这就是扩展卡尔曼滤波(Extended Kalman Filter, EKF) EKF的做法主要有两点： 其一是在工作点$\\overset{\\wedge }{x}{k-1},\\overset{-}{x}{k}$附近进行泰勒展开，将系统线性化： \\begin{array}{l}{f\\left(x_{k-1}, v_{k}, w_{k}\\right) \\approx f\\left(\\hat{x}_{k-1}, v_{k}, 0\\right)+\\frac{\\partial f}{\\partial x_{k-1}}\\left(x_{k-1}-\\hat{x}_{k-1}\\right)+\\frac{\\partial f}{\\partial w_{k}} w_{k}} \\\\ {g\\left(x_{k}, n_{k}\\right) \\approx g\\left(\\tilde{x}_{k}, 0\\right)+\\frac{\\partial g}{\\partial x_{k}} n_{k}}\\end{array}这里的偏导数都在工作点附近取值，最后变成了一个线性系统。 其二是在线性系统近似下，把噪声项和状态都当成了高斯分布。经过这两项近似以后得到的结果和普通卡尔曼滤波就一样了： \\begin{aligned} \\tilde{P}_{k} &=F_{k-1} \\hat{P}_{k-1} F_{k-1}^{T}+Q_{k}^{\\prime} \\\\ \\tilde{x}_{k} &=f\\left(\\hat{x}_{k-1}, v_{k}, 0\\right) \\\\ K_{k} &=\\tilde{P}_{k} G_{k}^{T}\\left(G_{k} \\tilde{P}_{k} G_{k}^{T}+R_{k}^{\\prime}\\right)^{-1} \\\\ \\hat{P}_{k} &=\\left(I-K_{k} G_{k}\\right) \\tilde{P}_{k} \\\\ \\hat{x}_{k} &=\\tilde{x}_{k}+K_{k}\\left(y_{k}-g\\left(\\tilde{x}_{k}, 0\\right)\\right) \\\\ \\mathbf{其中，}\\\\F_{k-1} &=\\left.\\frac{\\partial f}{\\partial x_{k-1}}\\right|_{\\hat{x}_{k-1}}, G_{k}=\\left.\\frac{\\partial f}{\\partial x_{k}}\\right|_{\\bar{x}_{k}} \\end{aligned}1.4 EKF的问题讨论EKF主要有三个问题： 滤波器方法假设了马尔可夫性，也就是 k 时刻的状态只与 k−1 时刻相关，而与 k −1 之前的状态和观测都无关。这比较像视觉里程计的原理，但是如果当前帧确实和以前的数据有关（例如回环检测），滤波器就无法应对。 由非线性转化到线性时我们安排了两个假设：展开点取一次项，把噪声项和状态都当成了高斯分布。系统本身线性化过程中，丢掉了高阶项。即使是高斯分布，经过一个非线性变换后也不是高斯分布。举个例子，假设一个$x\\sim N(0,1)$，那么$y=x^2$服从的是卡方分布，当卡方分布n较大时，比较接近高斯分布，这样我们就可以很好近似。但是当n比较小近似的结果就很差。 从程序实现上来说，EKF 需要存储状态量的均值和方差，并对它们进行维护和更新。 如果把路标也放进状态的话，由于视觉 SLAM 中路标数量很大，这个存储量是相当可观的，且与状态量呈平方增长（因为要存储协方差矩阵）。因此，EKF普遍被认为不可适用于大型场景SLAM。 2. 现代优化方法：BA与图优化见专题","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"数学","slug":"数学","permalink":"jiangren.work/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"SLAM基础5-非线性优化","slug":"SLAM基础5-非线性优化","date":"2019-08-10T11:42:22.000Z","updated":"2019-12-29T16:06:51.000Z","comments":true,"path":"2019/08/10/SLAM基础5-非线性优化/","link":"","permalink":"jiangren.work/2019/08/10/SLAM%E5%9F%BA%E7%A1%805-%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/","excerpt":"SLAM系统保证精度的主要手段是优化，本文介绍了优化方程的构建过程和几种常见的非线性优化方法。","text":"SLAM系统保证精度的主要手段是优化，本文介绍了优化方程的构建过程和几种常见的非线性优化方法。 1. 状态估计问题1.1 最大似然概念极大似然估计，通俗理解来说，就是利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值。 对于函数$p(x|\\theta)$输入有两个：$x$表示具体观测数据，$\\theta$表示模型的参数。如果$\\theta$是确定的，$x$是变量，这函数叫做概率函数(probability function)，他表述了在一个模型下，样本点$x$出现的概率是多少。 反之，如果$x$是确定的，$\\theta$是变量，这个函数叫做似然函数(likelihood function)，它描述了在不同的模型下，样本点$x$出现的概率是多少。 举例说明：假如有一个罐子，里面有黑白两种颜色的球，数目多少不知，两种颜色的比例也不知。现在我们可以每次任意从已经摇匀的罐中拿一个球出来，记录球的颜色，然后把拿出来的球再放回罐中。假如在前面的一百次重复记录中，有七十次是白球，请问罐中白球所占的比例最有可能是多少？ P(x_1,x_2...,x_{100}|Model) =P(x_1|M)P(x_2|M)...P(x_{100}|M) =p^{70}(1-p)^{30}要求这个式子的最大值，对他求导即可，得到的结果是：p=0.7时，结果最大，符合我们的日常逻辑认知。 1.2 SLAM中的最大后验与最大似然对于SLAM经典模型，我们知道是由一个运动方程和一个观测方程构成，如下方程： \\left\\{\\begin{matrix} \\mathit{x}_{k}=f(\\mathit{x}_{k-1},\\mathit{u}_{k})+\\mathit{w}_{k} \\\\ {z}_{k,j}=f(\\mathit{y}_{j},\\mathit{x}_{k})+\\mathit{v}_{k,j} \\end{matrix}\\right.其中$\\mathit{x}{k}$为相机位姿，$u_k$为传感器采集到的数据；$z{k,j}$为图像的像素位置，$y_j$为观测到的路标。 在运动方程和观测方程中，假设假设噪声都满足于均值为0的高斯分布： \\mathit{w}_{k}\\sim N(0,\\mathit{R}_{k}),\\mathit{v}_{k}\\sim N(0,\\mathit{Q}_{k,j})因此这个问题变成了：我们希望通过带噪声的数据 z 和 u来推断位姿 x 和地图 y(以及他们的概率分布)，在已知传感器采集数据u和图像数据z的情况下，x的条件概率为： P(x|z,u)如果没有传感器采集数据，只有一张张图片时，就变成了： P(x|z)=\\frac{P(z|x)P(x)}{P(z)}\\propto P(z|x)P(x)其中$P(x|z)$为后验概率，$P(z|x)$为似然，$P(x)$为先验概率。直接求后验概率比较困难，我们可以先求出一个最有可能的模型（$P(z|x)$最大），与先验概率相结合，就可以求出在这个模型下，以后x的可能结果。即：最大后验概率=最大似然×先验概率。 当不知道机器人在哪里时，我们缺乏先验概率，因此需要直接求解最大似然估计(MLE)： x^{*}_{MLE}=\\mathrm{arg} max P(z|x)其中$argmax F(x)$返回的是函数F取得最大时的$x$ 1.3 最小二乘法的引出多变量的高维高斯分布$x\\sim N(u,\\Sigma)$它的概率密度函数展开形式为： P(\\boldsymbol{x})=\\frac{1}{\\sqrt{(2 \\pi)^{N} \\operatorname{det}(\\boldsymbol{\\Sigma})}} \\exp \\left(-\\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})\\right)取负对数可知： -\\ln (P(x))=\\frac{1}{2} \\ln \\left((2 \\pi)^{N} \\operatorname{det}(\\Sigma)\\right)+\\frac{1}{2}(x-\\mu)^{T} \\Sigma^{-1}(x-\\mu)对于观测模型${z}{k,j}=f(\\mathit{y}{j},\\mathit{x}{k})+\\mathit{v}{k,j} $来说，由于我们设置了噪声项$vk\\sim N(0,Q{k,j})$，因此观测到的数据的条件概率是： P(z|x_k,y_j)=N(h(y_j,x_k),Q_{k,j})按照高维高斯模型，第一项和x无关，因此我们可以忽略。最后问题转化为求第二项取最小时，x的取值。 我们定义数据与估计值之间的误差： \\left\\{\\begin{matrix} e_{v,k}=x_{k}-f(x_{k-1},u_{k})\\\\ e_{y,j,k}=z_{k,j}-h(x_{k},y_{j}) \\end{matrix}\\right.并求该误差的平方和： J(x)=\\sum_{k}e_{v,k}^{T}R_{k}^{-1}e_{v,k}+\\sum_{k}\\sum_{j}e_{y,k,j}^{T}Q_{k,j}^{-1}e_{y,k,j}这就得到了一个总体意义下的最小二乘问题（Least Square Problem）。我们明白它的最优解等价于状态的最大似然估计。 2.非线性最小二乘对于一个简单的最小二乘问题${min}\\frac{1}{2}\\left | f(x) \\right |^{2}_{2}$，要求取他的最小值，只需要求取导数即可，通过比较这些极小值，能得到全局最优解，这样一般适用于线性最小二乘。对于非线性最小二乘，最好采用迭代的方式求取，但只能得到局部最优解(极小值)。其步骤如下: 给定某个初值 对于第$k$次迭代，寻找增量$\\Delta x_k$，使得$||f(x_k+\\Delta x_k)||^2$达到最小。 若$\\Delta xk$足够小，则停止；否则令$x{k+1}=x_k+\\Delta x_k$返回第2步 所以现在的问题时，如何选取$\\Delta x_k$ 2.1 一阶和二阶梯度法求解增量最直观的方式是将目标函数在 x 附近进行泰勒展开，得到： \\left \\| f(x+\\Delta x) \\right \\|^{2}_{2}\\approx \\left \\| f(x) \\right \\|^{2}_{2}+J(x)\\Delta x+\\frac{1}{2}\\Delta x^{T}H\\Delta x这里的$J$是$||f(x)||^2$关于x的一阶导数（雅克比矩阵），H则是二阶导数（黑塞矩阵），其中黑塞矩阵是对称矩阵。 \\mathbf{J}=\\left[\\begin{array}{ccc}{\\frac{\\partial \\mathbf{f}}{\\partial x_{1}}} & {\\cdots} & {\\frac{\\partial \\mathbf{f}}{\\partial x_{n}}}\\end{array}\\right]=\\left[\\begin{array}{ccc}{\\frac{\\partial f_{1}}{\\partial x_{1}}} & {\\cdots} & {\\frac{\\partial f_{1}}{\\partial x_{n}}} \\\\ {\\vdots} & {\\ddots} & {\\vdots} \\\\ {\\frac{\\partial f_{m}}{\\partial x_{1}}} & {\\cdots} & {\\frac{\\partial f_{m}}{\\partial x_{n}}}\\end{array}\\right] \\mathbf{H}=\\left[\\begin{array}{cccc}{\\frac{\\partial^{2} f}{\\partial x_{1}^{2}}} & {\\frac{\\partial^{2} f}{\\partial x_{1} \\partial x_{2}}} & {\\cdots} & {\\frac{\\partial^{2} f}{\\partial x_{1} \\partial x_{n}}} \\\\ {\\frac{\\partial^{2} f}{\\partial x_{2} \\partial x_{1}}} & {\\frac{\\partial^{2} f}{\\partial x_{2}^{2}}} & {\\cdots} & {\\frac{\\partial^{2} f}{\\partial x_{2} \\partial x_{n}}} \\\\ {\\vdots} & {\\vdots} & {\\ddots} & {\\vdots} \\\\ {\\frac{\\partial^{2} f}{\\partial x_{n} \\partial x_{1}}} & {\\frac{\\partial^{2} f}{\\partial x_{n} \\partial x_{2}}} & {\\cdots} & {\\frac{\\partial^{2} f}{\\partial x_{n}^{2}}}\\end{array}\\right]其中$J(x)$是一阶梯度，$\\frac{1}{2}\\Delta x^TH$是二阶梯度，我们可以选择保留泰勒展开的一阶或二阶项，对应的求解方法则为一阶梯度或二阶梯度法。 首先考虑只保留一阶梯度。梯度下降的时候我们需要确定下降$\\Delta x$的方向，这就是所谓梯度下降法，下降的方向就是梯度的反方向$-J^T(x)$ 在$y$是标量的情况下，$J^T$便是梯度，在$y$是高维的情况下，$J^T$每个列向量都是对应的$y_i$的梯度。 同时还需要添加一个步长$\\lambda$，有了方向和步长，就可以的到$\\Delta x$顺利求取局部最小值了。步长通过公式求解，越接近目标值，步长越小，前进越慢。这种方法被称为最速下降法。 \\Delta x^*=-\\lambda J^T(x)另一方面，如果保留二阶梯度信息，那么增量方程为： \\left \\| f(x+\\Delta x) \\right \\|^{2}_{2}\\approx \\left \\| f(x) \\right \\|^{2}_{2}+J(x)\\Delta x+\\frac{1}{2}\\Delta x^{T}H\\Delta x我们知道当$f’(x)=0$时函数有极小值，对右侧关于$\\Delta x$求导就得到了增量解： J(x)^T+\\frac{1}{2}(H\\Delta x+H^T\\Delta x)=0化简以后可得： H\\Delta x=-J^T 矩阵求导公式： \\frac{\\partial (X^TAX)}{\\partial X}=(A^T+A)X黑塞矩阵是一个对称矩阵$H^T=H$ 这种方法又称为牛顿法。由于泰勒展开之后函数变成了多项式， 所以求解增量时只需解线性方程即可，避免了直接求导函数为零这样的非线性方程的困难。 牛顿法与最速下降法的区别在于：牛顿法是二阶收敛，最速下降法是一阶收敛。最速下降法每次只从你当前所处位置选一个坡度最大的方向走一步，在局部进行下降，然后步步逼近极值，往往是走之字型的。 牛顿法在二阶导数的作用下，从函数的凸性出发，直接搜索怎样到达极值点。在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比最速下降法看得更远一点，能更快地走到最底部。如图，红色代表牛顿法，绿色代表最速下降法。 这两种方法的缺点在于：最速下降法过于贪心，容易走出锯齿路线，反而增加了迭代次数。牛顿法需要计算H矩阵，十分繁琐。牛顿法则需要计算目标函数的 H 矩阵，这在问题规模较大时非常困难。 2.2 高斯牛顿法 GN优化高斯牛顿法，它的思想是将$f(x)$进行泰勒展开（目标函数不是$f(x)$的二范数，和2.1的内容前提相区别）： f(x+\\Delta x)\\approx f(x)+J(x)\\Delta x根据前面的框架，需要求得下降矢量$\\Delta x$使得$||f(x+\\Delta x)||^{2}$最小，如果将$\\Delta x$看做变量，就会得到如下的最小二乘问题： \\Delta x^*=argmin||f(x)+J(x)\\Delta x||^2目标函数展开后可得： \\begin{aligned} \\frac{1}{2}\\|f(\\boldsymbol{x})+\\boldsymbol{J}(\\boldsymbol{x}) \\Delta \\boldsymbol{x}\\|^{2} &=\\frac{1}{2}(f(\\boldsymbol{x})+\\boldsymbol{J}(\\boldsymbol{x}) \\Delta \\boldsymbol{x})^{T}(f(\\boldsymbol{x})+\\boldsymbol{J}(\\boldsymbol{x}) \\Delta \\boldsymbol{x}) \\\\ &=\\frac{1}{2}\\left(\\|f(\\boldsymbol{x})\\|_{2}^{2}+2 f(\\boldsymbol{x})^{T} \\boldsymbol{J}(\\boldsymbol{x}) \\Delta \\boldsymbol{x}+\\Delta \\boldsymbol{x}^{T} \\boldsymbol{J}(\\boldsymbol{x})^{T} \\boldsymbol{J}(\\boldsymbol{x}) \\Delta \\boldsymbol{x}\\right) \\end{aligned}对目标函数的$\\Delta x$求导，并令其等于0： 2 \\boldsymbol{J}(\\boldsymbol{x})^{T} f(\\boldsymbol{x})+2 \\boldsymbol{J}(\\boldsymbol{x})^{T} \\boldsymbol{J}(\\boldsymbol{x}) \\Delta \\boldsymbol{x}=\\mathbf{0}最后得到： J(x)^{T}J(x)\\Delta x=-J(x)^{T}f(x) $||A||_2=\\sqrt \\lambda$其中$\\lambda$是谱范数，即$A^TA$的最大特征值 这里认为$f(x)^TJ(x)\\Delta x$是对称矩阵 这个方程称之为增量方程，也称之为高斯牛顿方程。将左边的系数设为$H$右边的系数设为$g$，则有： H\\Delta x=g注意这里并不是真正的黑塞矩阵，而是利用$J^TJ$代替了牛顿法中的黑塞矩阵，简化了计算。 求解增量方程是整个优化问题的核心所在。其步骤可以写为： 给定某个初值 对于第$k$次迭代，求出当前的雅克比矩阵$J(x_{k})$和误差$f(x_k)$ 求解增量方程$H\\Delta x=g$ 若$\\Delta xk$足够小，则停止；否则令$x{k+1}=x_k+\\Delta x_k$返回第2步 缺点在于$H$是半正定矩阵，可能是奇异矩阵(不可逆)导致算法不收敛，且即使可逆，如果步长太长可能导致局部近似不准确，甚至不收敛。 2.3 列文伯格-马夸尔特法 LM优化高斯牛顿法只能在展开点附近有比较好的效果，所以我们可以给$\\Delta x$添加一个信赖区域(Trust Region)。 那么如何确定这个信赖区域的范围呢？一个比较好的方法是根据我们的近似模型跟实际函数之间的差异来确定这个范围：如果差异小，我们就让范围尽可能大；如果差异大，我们就缩小这个近似范围。因此，考虑使用： \\rho=\\frac{f(\\boldsymbol{x}+\\Delta \\boldsymbol{x})-f(\\boldsymbol{x})}{\\boldsymbol{J}(\\boldsymbol{x}) \\Delta \\boldsymbol{x}}分子是实际函数下降的值，分母是近似模型下降的值。如果 ρ 接近于 1，则近似是好的。如果 ρ 太小，说明实际减小的值远少于近似减小的值，则认为近似比较差，需要缩小近似范围。反之，如果 ρ 比较大，则说明实际下降的比预计的更大，我们可以放大近似范围。 具体算法步骤如下： 这里近似范围扩大的倍数和阈值都是经验值，可以替换成其他数值。上述约束中相当于把增量限定在半径为u的球里面，认为在球内的才有效。带上D后成为椭圆。 在上述求解中，由于是有约束优化，可以利用拉格朗日乘子将其转化为一个无约束优化问题(其中λ为拉格朗日乘子)： \\underset{\\Delta x_{k}}{min}\\frac{1}{2}||f(x_{k})+J(x_{k}\\Delta x_{k})||^{2}+\\frac{\\lambda }{2}||D\\Delta x||^{2}展开后可得： (H+\\lambda D^{T}D)\\Delta x = g当参数λ较小时，H占主导地位，说明二次近似模型在该范围内是比较好的，该方法接近于高斯牛顿法。当参数λ较大时，λ所在项接近于一阶梯度下降法。该方法可在一定程度上避免线性方程组的系数矩阵的非奇异和病态问题。","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"数学","slug":"数学","permalink":"jiangren.work/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"SLAM基础4-相机模型","slug":"SLAM基础4-相机模型","date":"2019-08-10T09:34:12.000Z","updated":"2019-12-29T16:07:21.000Z","comments":true,"path":"2019/08/10/SLAM基础4-相机模型/","link":"","permalink":"jiangren.work/2019/08/10/SLAM%E5%9F%BA%E7%A1%804-%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/","excerpt":"介绍了三种相机模型：针孔，双目，RGBD","text":"介绍了三种相机模型：针孔，双目，RGBD 1. 针孔模型1.1 小孔成像相机可以抽象为最简单的形式：一个小孔和一个成像平面，小孔位于成像平面和真实的三维场景之间。 描述小孔的成像过程前，首先来定义两个坐标系： 相机坐标系：相机的中心被称为焦点或者光心，以焦点$O_c$为原点和坐标轴$；X_c,Y_c,Z_c$组成了相机坐标系 图像坐标系：以成像平面$O’$为原点和坐标轴$x’,y’$组成了图像坐标系 小孔成像实际就是将相机坐标系中的三维点变换到成像平面中的图像坐标系中的二维点。 假设相机坐标系下P点的坐标为$P_c=[X,Y,Z]^T$，则其在图像坐标系下为$p=[x,y]^T$，由相似三角形可以得到： \\frac{Z}{f}=\\frac{X}{x}=\\frac{Y}{y}\\\\ \\left\\{ \\begin{array}{l} x = f\\frac{X}{Z} \\\\ y = f\\frac{Y}{Z} \\\\ z = f \\end{array} \\right.1.2 内参数从成像平面坐标系到像素坐标系的变换。上面推导中使用的像点坐标$p=(x,y)$是成像平面坐标系下，以成像平面的中心为原点。而实际像素点的表示方法是以像素来描述，坐标原点通常是图像的左上角，X轴沿着水平方向向左，Y轴竖直向下。 像素是一个矩形块，这里假设其在水平和竖直方向的长度分别为：α和β。所以像素坐标和成像平面坐标之间，相差了一个缩放和平移。 假设像素坐标的水平方向的轴为μ，竖直方向的轴为ν，那么将一个成像平面的坐标(x,y)在水平方向上缩放α倍，在竖直方向上缩放β倍，同时平移(cx,cy)，就可以得到像素坐标系的坐标(μ,ν)，其公式如下： \\begin{array}{c} u = \\alpha\\cdot x+ c_x \\\\ v = \\beta \\cdot y + c_y \\end{array}将上面求得的$(x,y)$带入上面公式可得到： \\left\\{\\begin{array}{c} u = \\alpha\\cdot f\\frac{X}{Z}+ c_x \\\\ v = \\beta \\cdot f\\frac{Y}{Z} + c_y \\end{array}\\right. \\Rightarrow \\left\\{\\begin{array}{c} u = f_x\\frac{X}{Z}+ c_x \\\\ v = f_y\\frac{Y}{Z} + c_y \\end{array}\\right. 其中，f_x = \\alpha \\cdot f,f_y = \\beta \\cdot f写成齐次坐标后： \\left[\\begin{array}{c}\\mu\\\\\\nu\\\\1\\end{array}\\right] = \\frac{1}{Z}\\left[ \\begin{array}{ccc}f_x&0&c_x\\\\0&f_y&c_y\\\\0&0&1\\end{array}\\right]\\left[\\begin{array}{c}X_c\\\\Y_c\\\\Z_c\\end{array}\\right]通过上面的的推导，就得到了相机的内参数矩阵（Camera Intrinsic）K K=\\left[ \\begin{array}{ccc}f_x&0&c_x\\\\0&f_y&c_y\\\\0&0&1\\end{array}\\right]$K$有4个未知数和相机的构造相关，$f_x,f_y$和相机的焦距，像素的大小有关；$c_x,c_y$是平移的距离。这些参数在出厂时就设置好，也可以用标定板确定。 1.3 外参数通过上面的推导，知道了相机成像的过程： p = KP其中，p是图像中像点的像素坐标，K是相机的内参数矩阵，P是相机坐标系下的三维点坐标。上面推导使用的三维点坐标是在相机坐标系下的，相机坐标系并是“不稳定”的坐标系，其会随着相机的移动而改变坐标的原点和各个坐标轴的方向。 因此需要引进一个稳定不变坐标系：世界坐标系，该坐标系是绝对不变，SLAM中的视觉里程计就是求解相机在世界坐标系下的运动轨迹。 设$P_c$是$P$在相机坐标系坐标，是$P_w$其在世界坐标系下的坐标，可以使用一个旋转矩阵和一个平移向量，将变换为： P_c = RP_w + t改写为齐次形式就是： \\left[\\begin{array}{c}X_c\\\\Y_c\\\\Z_c\\\\1\\end{array}\\right] = \\left[\\begin{array}{cc}R&t\\\\0^T&1\\end{array}\\right]\\left[\\begin{array}{c}X_w\\\\Y_w\\\\Z_w\\\\1\\end{array}\\right]上面就推导得到相机的外参数（Camera Extrinsic）T T = \\left[\\begin{array}{cc}R&t\\\\0^T&1\\end{array}\\right]1.4 内外参组合$p=(\\mu,\\nu)$是图像中的像点，其坐标系是像素坐标系$P_c=(X_c,Y_c,Z_c)$是场景中的三维点，是相机坐标系。依托上面的公式，进过两次齐次化后，可以推导，像素坐标和世界坐标的关系： \\left[\\begin{array}{c}\\mu\\\\\\nu\\\\1\\end{array}\\right] = \\frac{1}{Z}\\left[ \\begin{array}{ccc}f_x&0&c_x\\\\0&f_y&c_y\\\\0&0&1\\end{array}\\right]\\left[\\begin{array}{c}X_c\\\\Y_c\\\\Z_c\\end{array}\\right]\\\\ \\left[\\begin{array}{c}\\mu\\\\\\nu\\\\1\\end{array}\\right] = \\frac{1}{Z}\\left[ \\begin{array}{ccc}f_x&0&c_x&0\\\\0&f_y&c_y&0\\\\0&0&1&0\\end{array}\\right] \\left[\\begin{array}{cc}R&t\\\\0^T&1\\end{array}\\right]\\left[\\begin{array}{c}X_W\\\\Y_W\\\\Z_W\\\\1\\end{array}\\right]2. 双目相机模型 由相似三角形可知： \\frac{z-f}{z}=\\frac{b-(u_l-u_r)}{b}整理后可得: z=\\frac{fb}{d}, \\ d=u_l-u_r$d$为左右图的横坐标之差，称为视差（Disparity）。根据视差，我们可以估计一个像素离相机的距离。视差与距离成反比：视差越大，距离越近 3. RGB-D相机模型RGB-D相机是主动探测深度，一般分为结构光和脉冲光(TOF),也叫飞行时间法(Time of Flight)。 ToF 原理和激光传感器十分相似，不过激光是通过逐点扫描来获取距离，而 ToF 相机则可以获得整个图像的像素深度，这也正是 RGB-D 相机的特点。 我们可以在同一个图像位置， 读取到色彩信息和距离信息，计算像素的 3D 相机坐标，生成点云（Point Cloud）","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"数学","slug":"数学","permalink":"jiangren.work/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"高斯金字塔与拉普拉斯金字塔","slug":"高斯金字塔与拉普拉斯金字塔","date":"2019-08-10T03:43:35.000Z","updated":"2019-12-30T16:57:45.000Z","comments":true,"path":"2019/08/10/高斯金字塔与拉普拉斯金字塔/","link":"","permalink":"jiangren.work/2019/08/10/%E9%AB%98%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94%E4%B8%8E%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94/","excerpt":"介绍高斯金字塔、拉普拉斯金字塔原理，以及他们的应用——图像融合。","text":"介绍高斯金字塔、拉普拉斯金字塔原理，以及他们的应用——图像融合。 1. 高斯金字塔高斯金字塔本质上是信号的在不同尺度上的表达，即将同一图片多次进行高斯模糊，并向下采样，产生不同尺度下的多组信号或图片以进行后续的处理。 为了获取层级为$G_{i+1}$的金子塔图像，我们采用如下办法： 对图像$G_i$进行高斯平滑 将所有偶数行去除 得到的图像即为$G_{i+1}$的图像。显然，整个图像的大小只有原图的1/4。不断重复操作就能得到整个金字塔。 高斯内核如下： \\frac{1}{256}\\left[\\begin{array}{ccccc}{1} & {4} & {6} & {4} & {1} \\\\ {4} & {16} & {24} & {16} & {4} \\\\ {6} & {24} & {36} & {24} & {6} \\\\ {4} & {16} & {24} & {16} & {4} \\\\ {1} & {4} & {6} & {4} & {1}\\end{array}\\right]降采样过程如下： 在Opencv中调用pyrDown函数即可，默认输出参数为Size((src.cols+1)/2, (src.rows+1)/2) void cv::pyrDown ( InputArray src, OutputArray dst, const Size &amp; dstsize = Size(), int borderType = BORDER_DEFAULT ) 2. 拉普拉斯金字塔拉普拉斯金字塔式高斯金字塔的逆过程，又称差分金字塔(DOG)。 假设我们现在拥有高斯采样图$G_{i + 1}$和$G_i $，则拉普拉斯金字塔计算方式如下： 将$Gi $每列每行赋值一遍，插入到隔行隔列中间，这样图像$G{i+1}^{\\prime}$大小和$G_{i+1}$相同 两者做差$G{i+1}^{\\prime}-G{i+1}$，得到的结果就是拉普拉斯金字塔 同样的在opencv中也有： void cv::pyrUp ( InputArray src, OutputArray dst, const Size &amp; dstsize = Size(), int borderType = BORDER_DEFAULT ) 3. 金字塔的应用-图像融合如12所示，我们能够按如下方法得到图像的高斯金字塔和拉普拉斯金字塔： 在最底层，我们认为高斯等于拉普拉斯，由此我们希望以此为开始，融合两张图片。 首先我们需要准备一个掩模M 通过掩模对两张图像的拉普拉斯每一层做运算，然后相加： LS_i=LA_i\\cdot M+LB_i\\cdot (1-M) 随后将得到的图片进行扩展，然后加上下一层的图片： Res_i = LS_i+expand(LS_{i+1}) 另一种简单的办法是feathr blending，对于交接区域我们做简答的加权即可。 PB(i,j) = (1-w)*PA(i,j) + w*PB(i,j) 这种办法对图像的质量要求很高，如果两张图片存在曝光差异(exposure differences)，算法结果就会很差。","categories":[{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}]},{"title":"SLAM基础3-李群和李代数","slug":"SLAM基础3-李群和李代数","date":"2019-08-09T07:44:12.000Z","updated":"2019-12-30T14:38:05.000Z","comments":true,"path":"2019/08/09/SLAM基础3-李群和李代数/","link":"","permalink":"jiangren.work/2019/08/09/SLAM%E5%9F%BA%E7%A1%803-%E6%9D%8E%E7%BE%A4%E5%92%8C%E6%9D%8E%E4%BB%A3%E6%95%B0/","excerpt":"李群和李代数是非常抽象的数学概念，在SLAM中我们通过他来衡量旋转平移的变化量。","text":"李群和李代数是非常抽象的数学概念，在SLAM中我们通过他来衡量旋转平移的变化量。 1.基本概念李群李代数主要用于SLAM算法中平移以及旋转来的求导。由于旋转矩阵为矩阵形式，不能用$R+\\Delta R$表示变化量。 三维矩阵旋转构成了特殊正交群$SO(3)$，变换矩阵则构成了特殊欧式群$SE(3)$ \\begin{array}{c}{S O(3)=\\left\\{\\boldsymbol{R} \\in \\mathbb{R}^{3 \\times 3} | \\boldsymbol{R} \\boldsymbol{R}^{T}=\\boldsymbol{I}, \\operatorname{det}(\\boldsymbol{R})=1\\right\\}} \\\\ {S E(3)=\\left\\{\\boldsymbol{T}=\\left[\\begin{array}{cc}{\\boldsymbol{R}} & {t} \\\\ {0^{T}} & {1}\\end{array}\\right] \\in \\mathbb{R}^{4 \\times 4} | \\boldsymbol{R} \\in S O(3), \\boldsymbol{t} \\in \\mathbb{R}^{3}\\right\\}}\\end{array}群（Group）是一种集合加上一种运算的代数结构。李群则是光滑的群(整数群就不光滑不连续)。李代数描述了李群的局部性质（变化率,相当于求导数）。 对于任意旋转矩阵$R$，由于它是正交矩阵，所以满足$RR^T=I$，如果$R$连续随时间变化，则我们用$R(t)$表示： R(t)R(t)^T=I对其求导可得： \\dot{R}(t)R(t)^T+R(t)\\dot{R}(t)^T=0\\\\ \\dot{R}(t)R(t)^T=-R(t)\\dot{R}(t)^T=-(\\dot{R}(t)R(t)^T)^T 如果矩阵A满足$A^T=-A$，则称之为反对称矩阵。它的展开形式一定是: \\left[\\begin{array}{ccc}{0} & {-a_{3}} & {a_{2}} \\\\ {a_{3}} & {0} & {-a_{1}} \\\\ {-a_{2}} & {a_{1}} & {0}\\end{array}\\right]所以我们可以用向量$[a_1,a_2,a_3]\\land$表示 由于$\\dot{R}(t)R(t)^T$是一个反对称矩阵，我们可以找到一个三维向量 与之对应。于是有： \\dot{R}(t)R(t)^T=\\phi(t)\\land等式左右两边乘以$R(t)$，由于$R$是正交矩阵，所以有： \\dot{\\boldsymbol{R}}(t)=\\phi(t)^{\\wedge} \\boldsymbol{R}(t)=\\left[\\begin{array}{ccc}{0} & {-\\phi_{3}} & {\\phi_{2}} \\\\ {\\phi_{3}} & {0} & {-\\phi_{1}} \\\\ {-\\phi_{2}} & {\\phi_{1}} & {0}\\end{array}\\right] \\boldsymbol{R}(t)可以看到，每对旋转矩阵求一次导数，只需左乘一个 $\\phi(t)\\land$ 矩阵即可。为方便讨论，我们设 $t_0=0$，并设此时旋转矩阵为 $R(0)=I$，按照导数定义，可以把 $R(t)$ 在 0 附近进行 一阶泰勒展开： \\begin{aligned} \\boldsymbol{R}(t) & \\approx \\boldsymbol{R}\\left(t_{0}\\right)+\\dot{\\boldsymbol{R}}\\left(t_{0}\\right)\\left(t-t_{0}\\right) \\\\ &=\\boldsymbol{I}+\\phi\\left(t_{0}\\right)^{\\wedge}(t) \\end{aligned}同时在 $t_0$ 附近，设$\\phi$ 保持为常数$\\phi(t_0)=\\phi_0$(保证$\\phi{}$在 $t_0 $附近保持不变)则可以推导得出： \\dot{\\boldsymbol{R}}(t)=\\phi\\left(t_{0}\\right)^{\\wedge} \\boldsymbol{R}(t)=\\phi_{0}^{\\wedge} \\boldsymbol{R}(t)解微分方程可以得到： \\boldsymbol{R(t)}=\\exp({\\phi_0}^{\\land} t)由此可知给定某时刻的 $R$，我们就能求得一个 $\\phi$，它描述了 $R$ 在局部的导数关系，它是一个李代数。 2. 映射关系以下关系专门针对三维矩阵旋转构成了特殊正交群$SO(3)$，变换矩阵构成的特殊欧式群$SE(3)$，$\\mathfrak{so}(3)$表示特殊正交群的李代数，此时旋转通过对数映射用$\\phi$表示，$\\mathfrak{se}(3)$表示特殊欧式群的李代数，变换用$\\xi$ 2.1 SO(3)上的映射$\\exp(ϕ∧)$ 是如何计算的？它是一个矩阵的指数，在李群和李代数中，称为指数映射（Exponential Map） 任意矩阵的指数映射可以写成一个泰勒展开： exp(A)=\\sum_{n=0}^\\infty{\\frac{1}{n!}A^n}替换A得到： exp(\\phi\\land)=\\sum_{n=0}^\\infty{\\frac{1}{n!}(\\phi\\land)^n}对于反对称矩阵有两条特殊性质： a^\\land a^\\land=aa^T-I\\\\ a^\\land a^\\land a^\\land=-a^\\land展开可以得到： \\begin{aligned} \\exp \\left(\\phi^{\\wedge}\\right) &=\\exp \\left(\\theta \\boldsymbol{a}^{\\wedge}\\right)=\\sum_{n=0} \\frac{1}{n !}\\left(\\theta \\boldsymbol{a}^{\\wedge}\\right)^{n} \\\\ &=\\boldsymbol{I}+\\theta \\boldsymbol{a}^{\\wedge}+\\frac{1}{2 !} \\theta^{2} \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}+\\frac{1}{3 !} \\theta^{3} \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}+\\frac{1}{4 !} \\theta^{4}\\left(\\boldsymbol{a}^{\\wedge}\\right)^{4}+\\ldots \\\\ &=\\boldsymbol{a} \\boldsymbol{a}^{T}-\\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}+\\theta \\boldsymbol{a}^{\\wedge}+\\frac{1}{2 !} \\theta^{2} \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}-\\frac{1}{3 !} \\theta^{3} \\boldsymbol{a}^{\\wedge}-\\frac{1}{4 !} \\theta^{4}\\left(\\boldsymbol{a}^{\\wedge}\\right)^{2}+\\ldots \\\\ &=\\boldsymbol{a} \\boldsymbol{a}^{T}+\\left(\\theta-\\frac{1}{3 !} \\theta^{3}+\\frac{1}{5 !} \\theta^{5}-\\ldots\\right) \\boldsymbol{a}^{\\wedge}-\\left(1-\\frac{1}{2 !} \\theta^{2}+\\frac{1}{4 !} \\theta^{4}-\\ldots\\right) \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge} \\\\ &=(1-\\cos \\theta) \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}+\\boldsymbol{I}+\\sin \\theta \\boldsymbol{a}^{\\wedge} \\\\ &=\\cos \\theta \\boldsymbol{I}+(1-\\cos \\theta) \\boldsymbol{a} \\boldsymbol{a}^{T}+\\sin \\theta \\boldsymbol{a}^{\\wedge} \\end{aligned}最后就得到了类似罗德里格斯公式的式子： \\exp(\\theta a^\\land)=\\cos(\\theta)I+(1-\\cos\\theta)aa^T+\\sin(\\theta)a^\\land罗德里格斯公式如下： \\mathbf{R}=\\cos\\theta \\mathbf\\cdot \\mathbf{I}+(1-\\cos\\theta)\\mathbf{nn^T}+\\sin\\theta\\cdot \\mathbf{n} {\\land}因此我们可以知道，$\\mathfrak{so}(3)$ 实际上就是由所谓的旋转向量组成的空间，而指数映射即罗德里格斯公式 反之也可以定义对数映射： \\phi=\\ln (\\boldsymbol{R})^{\\vee}=\\left(\\sum_{n=0}^{\\infty} \\frac{(-1)^{n}}{n+1}(\\boldsymbol{R}-\\boldsymbol{I})^{n+1}\\right)^{\\vee}2.2 SE(3)上的指数映射相较于之前，我们把旋转矩阵$R$替换为变换矩阵$T$： \\begin{equation} \\mathbf{\\dot{T}}(t) = \\mathbf{\\xi}^\\wedge(t) \\mathbf{T}(t) \\end{equation}解微分方程可以得到： \\mathbf{T(t)}=\\exp({\\xi_0}^{\\land} t)仿照前面的指数展开可以得到： \\begin{aligned} \\exp \\left(\\boldsymbol{\\xi}^{\\wedge}\\right) &=\\left[\\begin{array}{cc}{\\sum_{n=0}^{\\infty} \\frac{1}{n !}\\left(\\boldsymbol{\\phi}^{\\wedge}\\right)^{n}} & {\\sum_{n=0}^{\\infty} \\frac{1}{(n+1) !}\\left(\\boldsymbol{\\phi}^{\\wedge}\\right)^{n} \\boldsymbol{\\rho}} \\\\ {0^{T}} & {1}\\end{array}\\right] \\\\ & \\triangleq\\left[\\begin{array}{cc}{\\boldsymbol{R}} & {\\boldsymbol{J} \\boldsymbol{\\rho}} \\\\ {\\boldsymbol{0}^{T}} & {1}\\end{array}\\right]=\\boldsymbol{T} \\end{aligned}右上角的 $J$ 可整理为： J=\\frac{\\sin \\theta}{\\theta} I+\\left(1-\\frac{\\sin \\theta}{\\theta}\\right) a a^{T}+\\frac{1-\\cos \\theta}{\\theta} a^{\\wedge}3. 李代数求导3.1 BCH公式与近似形式在$SO3$中完成两个矩阵乘法时，在$\\mathfrak{so}(3)$是否对应着加法？如果成立的话，相当于： \\exp(\\phi_1^\\land)\\exp(\\phi_2^\\land)=\\exp((\\phi_1+\\phi_2)^\\land)换言之，我们需要研究下述公式是否成立： \\ln(\\exp(A)\\exp(B))=A+B然而这个式子在矩阵时并不成立，他真实的成立条件由BCH公式给出： \\ln \\left( {\\exp \\left( A \\right)\\exp \\left( B \\right)} \\right) = A + B + \\frac{1}{2}\\left[ {A,B} \\right] + \\frac{1}{12}\\left[ {A,\\left[ {A,B} \\right]} \\right] - \\frac{1}{12}\\left[ {B,\\left[ {A,B} \\right]} \\right] + \\cdots其中[ ]为李括号。 一般来说李括号$\\left[ {A,B} \\right] = AB - BA$，若满足$\\mathbf{\\phi}$为反对称矩阵，则李括号的结果为： [\\phi_1,\\phi_2]=(\\Phi_1\\Phi_2-\\Phi_2\\Phi_1)^\\lor 取近似项可得： \\begin{equation} \\ln {\\left( {R_1}{R_2} \\right)^ \\vee } \\approx \\left\\{ \\begin{array}{l} {J_l}{\\left( {\\phi _2} \\right)^{ - 1}}{\\phi _1} + {\\phi _2}\\\\ {J_r}{\\left( {\\phi _1} \\right)^{ - 1}}{\\phi _2} + {\\phi _1} \\end{array} \\right. \\end{equation}在 $\\phi_1$ 较小时，使用第一个式；在在 $\\phi_2$ 较小时，使用第二个式（换句话说依据是左乘一个微小位移还是右乘）。 以第一个近似为例。该式告诉我们，当对一个旋转矩阵 $R_2$李代数为 $\\phi_2$左乘一个微小旋转矩阵 $R_1$李代数为 $\\phi_1$时，可以近似地看作，在原有的李代数 $\\phi_2$ 上，加上了一 项 ${J_l}{\\left( {\\phi _2} \\right)^{ - 1}}{\\phi _1}$ 这里的 $J_l$ 和 $J_r$ 也称为左/右雅可比&mdash;&mdash;从而李代数就分成了左右两种模型（因此，李代数程序库会声明它使用的是左乘模型还是右乘模型） 这两个雅克比矩阵可以表示为如下形式，他和旋转向量$\\theta a$的关系 \\begin{equation} {J_l} = J = \\sum\\limits_{n = 0}^\\infty {\\frac{1}{\\left( {n + 1} \\right)!}{\\left( {\\phi ^ \\wedge } \\right)}^n} ,{J_r} = J\\left( { - \\phi } \\right) \\end{equation} 雅克比矩阵表示的是m个n元函数的一阶导数组成的矩阵 \\mathbf{J}=\\left[\\begin{array}{ccc}{\\frac{\\partial \\mathbf{f}}{\\partial x_{1}}} & {\\cdots} & {\\frac{\\partial \\mathbf{f}}{\\partial x_{n}}}\\end{array}\\right]=\\left[\\begin{array}{ccc}{\\frac{\\partial f_{1}}{\\partial x_{1}}} & {\\cdots} & {\\frac{\\partial f_{1}}{\\partial x_{n}}} \\\\ {\\vdots} & {\\ddots} & {\\vdots} \\\\ {\\frac{\\partial f_{m}}{\\partial x_{1}}} & {\\cdots} & {\\frac{\\partial f_{m}}{\\partial x_{n}}}\\end{array}\\right] 3.2 李代数求导模型假设我们对一个空间点 $p$ 进行了旋转，得到了 $R_p$。现 在，要计算旋转之后点的坐标相对于旋转的导数，我们记为： \\frac{\\partial(Rp)}{\\partial R}按照李代数的写法： \\frac{\\partial(\\exp(\\phi^\\land)p)}{\\partial\\phi}按照3.1所推导的结论： \\begin{aligned} \\frac{\\partial\\left(\\exp \\left(\\phi^{\\wedge}\\right) \\boldsymbol{p}\\right)}{\\partial \\boldsymbol{\\phi}} &=\\lim _{\\delta \\phi \\rightarrow 0} \\frac{\\exp \\left((\\phi+\\delta \\phi)^{\\wedge}\\right) \\boldsymbol{p}-\\exp \\left(\\phi^{\\wedge}\\right) \\boldsymbol{p}}{\\delta \\phi} \\\\ &=\\lim _{\\delta \\phi \\rightarrow 0} \\frac{\\exp \\left(\\left(\\boldsymbol{J}_{l} \\delta \\phi\\right)^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right) \\boldsymbol{p}-\\exp \\left(\\phi^{\\wedge}\\right) \\boldsymbol{p}}{\\delta \\phi} \\\\ & \\approx \\lim _{\\delta \\phi \\rightarrow 0} \\frac{\\left(\\boldsymbol{I}+\\left(\\boldsymbol{J}_{l} \\delta \\phi\\right)^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right) \\boldsymbol{p}-\\exp \\left(\\phi^{\\wedge}\\right) \\boldsymbol{p}}{\\delta \\phi} \\\\ &=\\lim _{\\delta \\phi \\rightarrow 0} \\frac{\\left(\\boldsymbol{J}_{l} \\delta \\phi\\right)^{\\wedge} \\exp \\left(\\phi^{\\wedge}\\right) \\boldsymbol{p}}{\\delta \\phi}=-(\\boldsymbol{R} \\boldsymbol{p})^{\\wedge} \\boldsymbol{J}_{l} \\\\ &=\\lim _{\\delta \\phi \\rightarrow 0} \\frac{-\\left(\\exp \\left(\\phi^{\\wedge}\\right) \\boldsymbol{p}\\right)^{\\wedge} \\boldsymbol{J}_{l} \\delta \\phi}{\\delta \\phi}=-(\\boldsymbol{R} \\boldsymbol{p})^{\\wedge} \\boldsymbol{J}_{l} \\end{aligned}第二行的近似为 BCH 线性近似，第三行为泰勒展开舍去高阶项后近似，第四行至第 五行将反对称符号看作叉积，交换之后变号。于是，我们推导了旋转后的点相对于李代数的导数： \\frac{d\\left( {RP} \\right)}{d\\phi }= {(-RP)^ \\wedge }{J_l}得到的结果中包含雅克比矩阵，我们希望进一步简化，因此可以采用扰动模型。 3.3 扰动模型上一种求导方式比较复杂，下面介绍另一种另一种求导方式，是对 $R$ 进行一次扰动 $∆R$。这个扰动可以乘在左边也可以乘在右 边，最后结果会有一点儿微小的差异。 假设我们对一个空间点 $p$ 进行了旋转，得到了 $R_p$。现 在，要计算旋转之后点的坐标相对于旋转的导数，我们记为： \\frac{\\partial(\\boldsymbol{R} \\boldsymbol{p})}{\\partial \\boldsymbol{\\varphi}}=\\lim _{\\varphi \\rightarrow 0} \\frac{\\exp \\left(\\varphi^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right) \\boldsymbol{p}-\\exp \\left(\\phi^{\\wedge}\\right) \\boldsymbol{p}}{\\varphi}这里和李代数求导模型有很大区别，李代数求导模型是老老实实按照求导定义来的，因此出现了李代数加法从而引出了雅克比矩阵，而扰动模型用乘法来近似。 近似后可以得到： \\begin{aligned} \\frac{\\partial(\\boldsymbol{R} p)}{\\partial \\varphi} &=\\lim _{\\varphi \\rightarrow 0} \\frac{\\exp \\left(\\varphi^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right) p-\\exp \\left(\\phi^{\\wedge}\\right) p}{\\varphi} \\\\ & \\approx \\lim _{\\varphi \\rightarrow 0} \\frac{\\left(1+\\varphi^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right) p-\\exp \\left(\\phi^{\\wedge}\\right) p}{\\varphi} \\\\ &=\\lim _{\\varphi \\rightarrow 0} \\frac{\\varphi^{\\wedge} R p}{\\varphi}=\\lim _{\\varphi \\rightarrow 0} \\frac{-(R p)^{\\wedge} \\varphi}{\\varphi}=-(R p)^{\\wedge} \\end{aligned}同理在SE3上的李代数求导结果为 \\frac{\\partial(\\boldsymbol{T} \\boldsymbol{p})}{\\partial \\delta \\boldsymbol{\\xi}}=\\left[\\begin{array}{cc}{\\boldsymbol{I}} & {-(\\boldsymbol{R} \\boldsymbol{p}+\\boldsymbol{t})^{\\wedge}} \\\\ {\\boldsymbol{0}^{T}} & {\\boldsymbol{0}^{T}}\\end{array}\\right] \\triangleq(\\boldsymbol{T} \\boldsymbol{p})^{\\odot}其中⊙算符把一个4×4的矩阵变换成一个4×6的矩阵，计算方式如下： \\begin{equation} p = \\left[ \\begin{array}{l} x_{3 \\times 1}\\\\ w_{1 \\times 1} \\end{array} \\right], \\quad {p^ \\odot } = \\left[ {\\begin{array}{*{20}{c}} w{I_{3 \\times 3}}&{ - {x^ \\wedge }_{3 \\times 3}}\\\\ {0^T}_{3 \\times 1}&{0^T}_{3 \\times 1} \\end{array}} \\right] \\end{equation}","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"数学","slug":"数学","permalink":"jiangren.work/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"SLAM基础2-三维刚体运动","slug":"SLAM基础2-三维刚体运动","date":"2019-08-09T04:53:22.000Z","updated":"2019-12-29T15:41:32.000Z","comments":true,"path":"2019/08/09/SLAM基础2-三维刚体运动/","link":"","permalink":"jiangren.work/2019/08/09/SLAM%E5%9F%BA%E7%A1%802-%E4%B8%89%E7%BB%B4%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/","excerpt":"三维刚体运动主要分为旋转和平移，其中最重要最难的就是旋转。本文介绍了三种表示旋转的办法：旋转矩阵，旋转向量，四元数。","text":"三维刚体运动主要分为旋转和平移，其中最重要最难的就是旋转。本文介绍了三种表示旋转的办法：旋转矩阵，旋转向量，四元数。 1. 旋转矩阵1.1 向量积质点在空间中可由 $xyz$ 坐标确定，但如果考虑刚体，需要考虑姿态问题。 点积$\\mathbf {a \\cdot b}=x_1x_2+y_1y_2+z_1z_2$，表示两个向量在同一方向的乘积。叉积表示垂直于两个方向的积。 \\mathbf{a\\times b}=\\begin{bmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k}\\\\ x_1 & y_1 & z_1\\\\ x_2 & y_2 & z_2 \\end{bmatrix}点积可以描述向量间的投影关系。叉积可以表示向量的旋转。对于外积，我们引入了 $∧$符号，把 a 写成一个矩阵。事实上是一个反对称矩阵 （Skew-symmetric），可以将 $∧$ 记成一个反对称符号。这样就把外积 $a×b$，写成了矩阵与向量的乘法 $a∧b$，把它变成了线性运算。 a \\times b=\\left[\\begin{array}{lll}{i} & {j} & {k} \\\\ {a_{1}} & {a_{2}} & {a_{3}} \\\\ {b_{1}} & {b_{2}} & {b_{3}}\\end{array}\\right]=\\left[\\begin{array}{l}{a_{2} b_{3}-a_{3} b_{2}} \\\\ {a_{3} b_{1}-a_{1} b_{3}} \\\\ {a_{1} b_{2}-a_{2} b_{1}}\\end{array}\\right]=\\left[\\begin{array}{ccc}{0} & {-a_{3}} & {a_{2}} \\\\ {a_{3}} & {0} & {-a_{1}} \\\\ {-a_{2}} & {a_{1}} & {0}\\end{array}\\right] b \\triangleq a^{\\wedge} b我们可以用一个向量来描述三维空间中两个向量的旋转关系。在右手法则下，我们用右手的四个指头从 a 转向 b，其大拇指朝向就是旋转向量的方向，事实上也是 $a×b$ 的方向。a 到 b 的旋转可以由向量 $\\mathbf{w}$ 来描述。 1.2 坐标系的欧氏变换我们可以描述两个坐标系之间的旋转和平移，统称为坐标系之间的变换关系。欧氏变换则是指同一个向量在各个坐标系下的长度和夹角都不会发生变化。比如把手机抛到空中，在它落地摔碎之前，只可能有空间位置和姿态的不同，而它自己的长度、各个面的角度等性质不会有任何变化。 每一个欧氏变换由旋转和平移组成。 首先考虑旋转。我们设某个单位正交基 $(e_1,e_2,e_3)$ 经过一次旋转，变成了 $(e_1’ ,e_2’,e_3’)$ 。那么，对于同一个向量 $\\mathbf{a}$（注意该向量并没有 随着坐标系的旋转而发生运动，它在两个坐标系下的坐标为 $[a_1,a_2,a_3]^T$ 和 $[a_1’,a_2’,a_3’]^T$。 根据坐标的定义 \\left[e_{1}, e_{2}, e_{3}\\right]\\left[\\begin{array}{c}{a_{1}} \\\\ {a_{2}} \\\\ {a_{3}}\\end{array}\\right]=\\left[\\begin{array}{ccc}{e_{1}^{\\prime}} & {e_{2}^{\\prime}} & {e_{3}^{\\prime}}\\end{array}\\right]\\left[\\begin{array}{c}{a_{1}^{\\prime}} \\\\ {a_{2}^{\\prime}} \\\\ {a_{3}^{\\prime}}\\end{array}\\right]为了描述两个坐标之间的关系，我们对上面等式左右同时乘$\\begin{bmatrix} e1^T \\ e 2^T\\ e_3^T \\end{bmatrix}$ 那么左边的系数变成了单位矩阵。 \\begin{bmatrix} a_1\\\\a_2\\\\a_3\\end{bmatrix} = \\begin{bmatrix} e_1^T e_1' & e_1^T e_2' & e_1^T e_3'\\\\e_2^T e_1'&e_2^T e_2'&e_1^T e_3'\\\\e_3^T e_1'&e_3^T e_2'&e_3^T e_3'\\end{bmatrix} \\begin{bmatrix} a_1'\\\\a_2'\\\\a_3'\\end{bmatrix} =Ra'我们把中间的阵拿出来，定义成一个矩阵 $R$ ，这个矩阵由两组基之间的内积组成，刻画了旋转前后同一个向量的坐标变换关系。只要旋转是一样的，那么 这个矩阵也是一样的， $R$ 就是旋转矩阵 旋转矩阵是一个行列式为 1 的正交矩阵（orthogonal matrix）。反之，行列式为1的正交矩阵也是一个旋转矩阵。 它的逆（即转置）描述了一个相反的旋转。即 $R^T$ 刻画了一个相反的旋转。 Q^{T}=Q^{-1} \\Leftrightarrow Q^{T} Q=Q Q^{T}=I正交矩阵的转置和逆矩阵相等，正交矩阵与转置矩阵相乘得到单位矩阵 然后考虑平移。考虑世界坐标系中的向量 $\\mathbf{a}$，经过一次旋转（用 $R$ 描述）和一次平移 $t$ 后，得到了 ，那么$\\mathbf{a’}$把旋转和平移合到一起，有： a^{\\prime}=R a+t1.3 变换矩阵与齐次坐标我们把一个三维向量的末尾添加 1，变成了四维向量，称为齐次坐标。对于这个四维向量，我们可以把旋转和平移写在一个矩阵里面，使得整个关系变成 了线性关系。矩阵 T 称为变换矩阵（Transform Matrix）。 \\left[\\begin{array}{c}{a^{\\prime}} \\\\ {1}\\end{array}\\right]=\\left[\\begin{array}{cc}{R} & {t} \\\\ {0^{T}} & {1}\\end{array}\\right]\\left[\\begin{array}{l}{a} \\\\ {1}\\end{array}\\right] \\triangleq T\\left[\\begin{array}{l}{a} \\\\ {1}\\end{array}\\right]2. 旋转向量与欧拉角2.1 旋转向量由旋转矩阵来描述旋转，变换矩阵描述一个六自由度的三维刚体运动，但这样过于冗余。旋转矩阵有九个量，但一次旋转只有三个自由度。变换矩阵用十六个量表达了六自由度的变换。需要使用新的表达方式来精简。 外积可以将两个向量的旋转关系表达为一个向量，即任意旋转都可以用一个旋转轴和一个旋转角来刻画。于是，我们可以使用一个向量，其方向与旋转轴一致，而长度等于旋转角（为了更紧凑的表达，旋转轴的长度为旋转角）。这种向量，称为旋转向量。这种表示法只需一个三维向量即可描述旋转。同样，对于变换矩阵，我们使用一个旋转向量和一个平移向量即可表达一次变换。这时的维数正好是六维。 假设有一个旋转轴为 $\\mathbf{n}$，角度为 $θ$ 的旋转，显然，它对应的旋转向量为 $θ\\cdot \\mathbf{n}$ 。旋转向量与旋转矩阵的转化方式可以由罗德里格斯公式表明： \\mathbf{R}=\\cos\\theta \\mathbf\\cdot \\mathbf{I}+(1-\\cos\\theta)\\mathbf{nn^T}+\\sin\\theta\\cdot \\mathbf{n} {\\land}2.2 欧拉角无论是旋转矩阵、旋转向量，虽然它们能描述旋转，但对我们人类是非常不直观的。欧拉角使用三个分离的转角，把一个旋转分解成三次绕不同轴的旋转。 绕物体的 Z 轴旋转，得到偏航角 yaw； 绕旋转之后的 Y 轴旋转，得到俯仰角 pitch； 绕旋转之后的 X 轴旋转，得到滚转角 roll。 这种旋转方式称之为rpy角。 欧拉角的一个重大缺点是会碰到著名的万向锁问题（Gimbal Lock)，若第二次旋转90°，则会使得物体与X轴垂直，使得系统丢失了一个自由度。 一般不会在程序中直接使用欧拉角表达姿态，同样不会在滤波或优化中使用欧拉角表达旋转。不过，若想验证自己算法是否有错时，转换成欧拉角能够快速辨认结果的正确与否。 3. 四元数除了旋转向量和旋转矩阵表示旋转外，还可以采用四元数的形式。 3.1 四元数的定义四元数拥有一个实部和三个虚部，可定义为: \\textbf{q}=q_0+q_1i+q_2j+q_3k其中$i,j,k$是四元数的三个虚部，满足关系式： \\begin{equation} \\left\\{ \\begin{array}\\\\ i^2=j^2=k^2=-1 & \\\\ ij=k, ji=-k &\\\\ jk=i,kj=-i& \\\\ ki=j,ik=-j \\end{array} \\right. \\end{equation}有时候也可以用一个标量和一个矢量来表示四元数： \\textbf{q}=[s,\\textbf{v}],\\quad s=q_0\\in \\mathbb{R},\\textbf{v}=[q_1,q_2,q_3]^T\\in\\mathbb{R}^3$s$ 称为四元数的实部，而$v$ 称为它的虚部。如果一个四元数虚部为 0，称之为实四元数。反之，若它的实部为 0，称之为虚四元数。 假设某个旋转是绕单位向量$\\textbf{n}=[n_x,n_y,n_z]^T$旋转了$θ$，那么这个旋转就可以用四元数表示为： \\textbf{q}=[\\cos\\frac{\\theta}{2},n_x\\sin\\frac{\\theta}{2},n_y\\sin\\frac{\\theta}{2},n_z\\sin\\frac{\\theta}{2}]^T反之，我们亦可从单位四元数中计算出对应旋转轴与夹角： \\begin{equation} \\left\\{ \\begin{array}\\\\ \\theta=2\\arccos{q_0}\\\\ [n_x,n_y,n_z]^T=[q_1,q_2,q_3]^T/ \\sin\\frac{\\theta}{2} \\end{array} \\right. \\end{equation}3.2 四元数旋转假设空间有三维点$p=[x,y,z]$，如果绕着轴$\\mathbf{n}$以$θ$旋转，则将其表示为四元数形式有： p=[0,x,y,z]=[0,\\textbf{v}]用四元数$q$表示这个旋转： q=[\\cos\\frac{\\theta}{2},\\textbf{n}\\sin\\frac{\\theta}{2}]旋转后$p’$就可以表示为: p'=qpq^{-1}上面描述了某个点的旋转，下面表示的是如何由旋转四元数表示旋转矩阵： \\mathbf{R} = \\left[ {\\begin{array}{*{20}{c}} {1 - 2q_2^2 - 2q_3^2}&{2{q_1}{q_2} + 2{q_0}{q_3}}&{2{q_1}{q_3} - 2{q_0}{q_2}}\\\\ {2{q_1}{q_2} - 2{q_0}{q_3}}&{1 - 2q_1^2 - 2q_3^2}&{2{q_2}{q_3} + 2{q_0}{q_1}}\\\\ {2{q_1}{q_3} + 2{q_0}{q_2}}&{2{q_2}{q_3} - 2{q_0}{q_1}}&{1 - 2q_1^2 - 2q_2^2} \\end{array}} \\right]反之旋转轴四元数也可以由旋转矩阵求取： q_{0}=\\frac{\\sqrt{\\operatorname{tr}(R)+1}}{2}, q_{1}=\\frac{m_{23}-m_{32}}{4 q_{0}}, q_{2}=\\frac{m_{31}-m_{13}}{4 q_{0}}, q_{3}=\\frac{m_{12}-m_{21}}{4 q_{0}}","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"数学","slug":"数学","permalink":"jiangren.work/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"SLAM基础1-综述","slug":"SLAM基础1-综述","date":"2019-08-08T03:55:25.000Z","updated":"2019-12-29T16:07:35.000Z","comments":true,"path":"2019/08/08/SLAM基础1-综述/","link":"","permalink":"jiangren.work/2019/08/08/SLAM%E5%9F%BA%E7%A1%801-%E7%BB%BC%E8%BF%B0/","excerpt":"这个系列是对SLAM的基本介绍。分为8+1个部分，其中视觉里程计的部分被单独拆分为小专题的形式。 第一部分是综述，主要介绍SLAM的基本概念。","text":"这个系列是对SLAM的基本介绍。分为8+1个部分，其中视觉里程计的部分被单独拆分为小专题的形式。 第一部分是综述，主要介绍SLAM的基本概念。 1. 什么是SLAM同步定位与地图构建（SLAM或Simultaneous localization and mapping）是一种概念：希望机器人从未知环境的未知地点出发，在运动过程中通过重复观测到的地图特征（比如，墙角，柱子等）定位自身位置和姿态，再根据自身位置增量式的构建地图，从而达到同时定位和地图构建的目的。 2. 经典视觉SLAM框架 视觉SLAM分为以下几步： 传感器信息读取。在视觉 SLAM 中主要为相机图像信息的读取和预处理。 视觉里程计 (Visual Odometry, VO)。视觉里程计任务是估算相邻图像间相机的运动， 以及局部地图的样子。VO 又称为前端（Front End）。 后端优化（Optimization）。后端接受不同时刻视觉里程计测量的相机位姿，以及回环检测的信息，对它们进行优化，得到全局一致的轨迹和地图。由于接在 VO 之后，又称为后端（Back End）。 回环检测（Loop Closing）。回环检测判断机器人是否曾经到达过先前的位置。如果 检测到回环，它会把信息提供给后端进行处理。 建图（Mapping）。它根据估计的轨迹，建立与任务要求对应的地图 2.1 视觉里程计视觉里程计关心相邻图像之间的相机运动，而和再往前的信息没有关联。换句话说，里程计记录的是相对差值而不是绝对值。我们可以通过将相邻时刻的运动串起来，构成最终的运动轨迹。 仅通过视觉里程计来估计轨迹，将不可避免地出现累计漂移（Accumulating Drift）。这是由于视觉里程计（在最简单的情况下）只估计两个图像间运动造成的。每次估计都带有一定的误差，而由于里程计的工作方式，先前时刻的误差将会传递到下一时刻，导致经过一段时间之后，估计的轨迹将不再准确。因此我们还需要后端优化和回环检测。 2.2 后端优化后端优化主要指处理 SLAM 过程中噪声的问题。 后端优化要考虑的问题， 就是如何从这些带有噪声的数据中，估计整个系统的状态，以及这个状态估计的不确定性有多大——这称为最大后验概率估计（Maximum-a-Posteriori，MAP）。 在视觉 SLAM 中，前端和计算机视觉研究领域更为相关，比如图像的特征提取与匹配等，后端则主要是滤波与非线性优化算法。 2.3 回环检测回环检测，又称闭环检测（Loop Closure Detection），主要解决位置估计随时间漂移的问题。实现的途径就是让机器人具有识别曾到达过的场景的能力，比如识别二维码、环境特征等等。 在检测到回环之后，我们会把“A 与 B 是同一个点”这样的信息告诉后端优化算法。 然后，后端根据这些新的信息，把轨迹和地图调整到符合回环检测结果的样子。这样就可以消除累积误差，得到全局一致的轨迹地图。 2.4 建图建图（Mapping）是指构建地图的过程。地图是对环境的描述，但这个描述并不是固定的，需要视 SLAM 的应用而定。 地图可分为度量地图（Metric Map）和 拓扑地图（Topological Map） 度量地图强调精确地表示地图中物体的位置关系，通常我们用稀疏（Sparse）与稠密 （Dense）对它们进行分类。 稀疏地图进行了一定程度的抽象，并不需要表达所有的物体。例如，我们选择一部分具有代表意义的东西，称之为路标（Landmark），那么一张稀疏地图就是由路标组成的地图，而不是路标的部分就可以忽略掉，一般适用于定位。 稠密地图通常按照某种分辨率，由许 多个小块组成，一个小块含有占据、空闲、未知三种状态，以表达该格内是否有物体。一般适用于导航。 拓扑地图则更强调地图元素之间的关系。拓扑地图是一个图（Graph），由节点和边组成，只考虑节点间的连通性。它放松了地图对精确位置的需要，去掉地图的细节问题， 是一种更为紧凑的表达方式 3. SLAM的数学表达假设将时间变为离散 $t=1,2,…,K$，然后我们用$x$表示机器人的位置 $x_1,…,x_k$，而每个时刻，传感器会测量到一部分路标点，得到它们的观测数据。不妨设路标点一共有$N$个，用 $y_1,…,y_N$表示它们。 那么机器人携带传感器在环境中的运动就可以描述为： 什么是运动？我们要考虑从 $k−1$ 时刻到 $k$ 时刻，机器人的位置 $x$ 是如何变化的。 什么是观测？假设机器人在 $k$ 时刻，于 $x_k$ 处探测到了某一个路标 $y_j$，我们要考虑这件事情是如何用数学语言来描述的。 运动方程$xk$和观测方程$z{k,j}$可以分别抽象为如下数学表达式： \\begin{equation} \\left\\{ \\begin{array}\\\\ x_k=f(x_{k-1},u_k,\\omega_k) \\\\ z_{k,j}=h(y_j,x_k,v_{k,j}) \\end{array} \\right. \\end{equation}$\\omegak$和$v{k,j}$为噪声，$uk$为运动测量读数，$y_j$为路标点，$z{k,j}$为传感器读数。 因此问题就转化为：知道运动测量的读数 $u$，以及传感器的读数 $z$ 时，如何求解定位问题（估计 $x$）和建图问题（估计 $y$）？","categories":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"}]},{"title":"GDB使用方法","slug":"GDB使用方法","date":"2019-08-07T06:34:35.000Z","updated":"2019-12-29T15:30:18.000Z","comments":true,"path":"2019/08/07/GDB使用方法/","link":"","permalink":"jiangren.work/2019/08/07/GDB%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"GDB在LINUX是一项重要的调试工具，本文介绍它的基本使用方法。","text":"GDB在LINUX是一项重要的调试工具，本文介绍它的基本使用方法。 1. 安装GDB在linux中需要先安装gcc和gdb # 安装 gcc yum install gcc # 安装 g++ yum install gcc-c++ # 安装 gdb yum install gdb 当要调试某程序时，需要在gcc编译时加上-g，目的是保留编译后的程序中调试符号信息。 当输入gdb hello时能看到： Reading symbols from /root/testclient/hello_server...done. (gdb) 说明保留调试符号信息成功。 2. 启动GDB调试启动有三种方式：直接调试目标程序，附加进程，调试core文件 2.1 直接调试目标程序gdb filename filename是需要启动的调试文件名，可以直接使用gdb启动一个程序调试，此时并没有完全启动，而是附加了一个可执行文件，需要输入run才能真正运行。 2.2 附加进程号gdb attach ProcessID 有时候程序已经启动，我们并不想重启它（比如服务器），此时需要利用attach指令将进程号添加到GDB调试器。获取进程号的方法如下所示： [zhangyl@iZ238vnojlyZ flamingoserver]$ ps -ef | grep chatserver zhangyl 21462 21414 0 18:00 pts/2 00:00:00 grep --color=auto chatserver zhangyl 26621 1 5 Oct10 ? 2-17:54:42 ./chatserver -d 得到charserver的PID为26621，使用gdb attach 26621将GDB附加到chatserver中，看到attaching to process 26661时表示已经附加成功。 [zhangyl@localhost flamingoserver]$ gdb attach 26621 Attaching to process 26661 Reading symbols from /home/zhangyl/flamingoserver/chatserver...done. Reading symbols from /usr/lib64/mysql/libmysqlclient.so.18...Reading symbols from /usr/lib64/mysql/libmysqlclient.so.18...(no debugging symbols found)...done. Reading symbols from /lib64/libpthread.so.0...(no debugging symbols found)...done. [New LWP 42931] [New LWP 42930] [New LWP 42929] [Thread debugging using libthread_db enabled] Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;. Loaded symbols for /lib64/libpthread.so.0 Reading symbols from /lib64/libc.so.6...(no debugging symbols found)...done. 调试完成时，可以使用detach将其分离。 2.3 调试core文件gdb filename corename 有时候，服务器程序运行一段时间后会突然崩溃，只要程序在崩溃的时候有 core 文件产生，就可以使用这个 core 文件来定位崩溃的原因。 默认情况下，Linux关闭了core文件机制，使用ulimit -c命令来查看系统是否启动这一机制。0表示关闭，数字表示启动但限制core文件大小，unlimited表示启动且不限制大小。 [zhangyl@localhost flamingoserver]$ ulimit -c core file size (blocks, -c) 0 使用ulimit -c unlimited指令来启动。 [zhangyl@localhost flamingoserver]$ ulimit -c unlimited [zhangyl@localhost flamingoserver]$ ulimit -c core file size (blocks, -c) unlimited 生成的 core 文件的默认命名方式是 core.pid，比如某个程序运行时的进程 ID 是 16663，那么它崩溃产生的 core 文件的名称就是 core.16663，可以通过gdb chatserver core.16663来启动调试。 多个程序同时崩溃，我们根本没法通过 core 文件名称中的 PID 来区分。因此可以再程序中记录一下自己的PID。 void writePid() { uint32_t curPid = (uint32_t) getpid(); FILE* f = fopen(&quot;xxserver.pid&quot;, &quot;w&quot;); assert(f); char szPid[32]; snprintf(szPid, sizeof(szPid), &quot;%d&quot;, curPid); fwrite(szPid, strlen(szPid), 1, f); fclose(f); } 我们在程序启动时调用上述 writePID函数，将程序当时的 PID 记录到 xxserver.pid 文件中去，这样当程序崩溃时，可以从这个文件中得到进程当时运行的 PID，这样就可以与默认的 core 文件名后面的 PID 做匹配了。 3. 常用命令首先下载redis开源代码作为示例 Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API Redis 的最新源码下载地址可以在 Redis 官网获得，使用 wget 命令将 Redis 源码文件下载下来： [root@localhost gdbtest]# wget http://download.redis.io/releases/redis-4.0.11.tar.gz 然后解压： [root@localhost gdbtest]# tar zxvf redis-4.0.11.tar.gz 使用Makefile编译，加入MALLOC=libc防止jemalloc问题，make distclean清除上次失败的编译残留文件。 make distclean make MALLOC=libc 进入src目录，使用gdb redis-server启动程序。 3.1 流控制语句rungdb filename 命令只是附加的一个调试文件，并没有启动这个程序，需要输入 run 命令（简写为 r）启动这个程序 redis-server 启动后能看到一个四方堆叠结构，说明启动成功了。假设程序已经启动，再次输入 run 命令则是重启程序。我们在 GDB 界面按 Ctrl + C 快捷键让 GDB 中断下来，再次输入 r 命令，GDB 会询问我们是否重启程序，输入 yes 确认重启。 continue当 GDB 触发断点或者使用 Ctrl + C 命令中断下来后，想让程序继续运行，只要输入 continue命令即可（简写为 c） ^C Program received signal SIGINT, Interrupt. 0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6 (gdb) c Continuing. next、step、until、finish、return 和 jump 命令next 命令（简写为 n）是让 GDB 调到下一条命令去执行，这里的下一条命令不一定是代码的下一行，而是根据程序逻辑跳转到相应的位置。 在 GDB 命令行界面如果直接按下回车键，默认是将最近一条命令重新执行一遍，因此，当使用 next 命令单步调试时，不必反复输入 n 命令，直接回车就可以。 (gdb) n 3736 spt_init(argc, argv); (gdb) 3738 setlocale(LC_COLLATE,&quot;&quot;); (gdb) 3739 zmalloc_set_oom_handler(redisOutOfMemoryHandler); next 命令用调试的术语叫“单步步过”（step over），即遇到函数调用直接跳过，不进入函数体内部。而step 命令（简写为 s）就是“单步步入”（step into），顾名思义，就是遇到函数调用，进入函数内部。 在某个函数中调试一段时间后，不需要再一步步执行到函数返回处，希望直接执行完当前函数并回到上一层调用处，就可以使用 finish 命令。与 finish 命令类似的还有 return 命令，return 命令的作用是结束执行当前函数，还可以指定该函数的返回值。 #include &lt;stdio.h&gt; int func() { int a = 9; printf(&quot;a=%d.\\n&quot;, a); } int main() { int c = func(); printf(&quot;c=%d.\\n&quot;, c); return 0; } 上述代码在func函数里直接输入 return 命令以后，不会返回任何值，如果输入retrun 9999，那么打印出来结果就是9999。 until 命令（简写为 u）可以指定程序运行到某一行停下来，可以代替break+continue，比如当前运行到338行，想要运行到992行，直接u 992 jump命令也是跳转，但中间的步骤不会执行。比如从338行跳转到992行j 992。从338行到992行之间的所有代码都不会执行（可能会因为没有初始化造成问题），并且会从992行以后持续执行（如果没有碰到断点） 3.2 断点语句break 命令（简写为 b）即我们添加断点的命令，可以使用以下方式添加断点： break functionname，在函数名为 functionname 的入口处添加一个断点； break LineNo，在当前文件行号为 LineNo 处添加一个断点； break filename:LineNo，在 filename 文件行号为 LineNo 处添加一个断点。 在程序中加了很多断点，而我们想查看加了哪些断点时，可以使用 info break 命令。 如果我们想禁用某个断点，使用“disable 断点编号”就可以禁用这个断点了，被禁用的断点不会再被触发；同理，被禁用的断点也可以使用“enable 断点编号”重新启用。如果 disable 命令和 enable 命令不加断点编号，则分别表示禁用和启用所有断点。 使用“delete 编号”可以删除某个断点，如 delete 2 3 则表示要删除的断点 2 和断点 3。同样的道理，如果输入 delete 不加命令号，则表示删除所有断点。 tbreak 命令也是添加一个断点，第一个字母“t”的意思是 temporarily（临时的），也就是说这个命令加的断点是临时的，所谓临时断点，就是一旦该断点触发一次后就会自动删除。 3.2 堆栈和线程查看语句listlist 命令（简写为 l）可以查看当前断点处的代码。使用 frame 命令切换到刚才的堆栈 #3 处，然后输入 list 命令看下效果： (gdb) f 4 #4 0x000000000042fa77 in initServer () at server.c:1852 1852 listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR) (gdb) l 1847 } 1848 server.db = zmalloc(sizeof(redisDb)*server.dbnum); 1849 1850 /* Open the TCP listening socket for the user commands. */ 1851 if (server.port != 0 &amp;&amp; 1852 listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR) 1853 exit(1); 1854 1855 /* Open the listening Unix domain socket. */ 1856 if (server.unixsocket != NULL) { (gdb) list语句现实的是目标语句处前后附近的代码，再次输入list命令后，代码继续往后显示 10 行。 list 指令还可以往前和往后显示代码，命令分别是list + （加号）和list - （减号）。 backtrace和framebacktrace 命令（简写为 bt）用来查看当前调用堆栈。若redis-server 现在中断在 anet.c:452 行，可以通过 backtrace 命令来查看当前的调用堆栈： (gdb) bt #0 anetListen (err=0x746bb0 &lt;server+560&gt; &quot;&quot;, s=10, sa=0x7e34e0, len=16, backlog=511) at anet.c:452 #1 0x0000000000426e35 in _anetTcpServer (err=err@entry=0x746bb0 &lt;server+560&gt; &quot;&quot;, port=port@entry=6379, bindaddr=bindaddr@entry=0x0, af=af@entry=10, backlog=511) at anet.c:487 #2 0x000000000042793d in anetTcp6Server (err=err@entry=0x746bb0 &lt;server+560&gt; &quot;&quot;, port=port@entry=6379, bindaddr=bindaddr@entry=0x0, backlog=511) at anet.c:510 #3 0x000000000042b0bf in listenToPort (port=6379, fds=fds@entry=0x746ae4 &lt;server+356&gt;, count=count@entry=0x746b24 &lt;server+420&gt;) at server.c:1728 #4 0x000000000042fa77 in initServer () at server.c:1852 #5 0x0000000000423803 in main (argc=1, argv=0x7fffffffe648) at server.c:3862 (gdb) 这里一共有 6 层堆栈，最顶层是 main() 函数，最底层是断点所在的 anetListen()函数，堆栈编号分别是 #0 ~ #5。比如我们在利用pthread_creat函数创建线程时可以利用bt查看创建过程。 使用bt以后可以看到如下结果，说明creat线程创建过程是clone-&gt;start_thread-&gt;MainTcpEpollThread #0 MainTcpEpollThread (lpParam=0x0) at ./Server.cpp:1035 #1 0x00007ffff7bc6dd5 in start_thread () from /lib64/libpthread.so.0 #2 0x00007ffff68f3ead in clone () from /lib64/libc.so.6 如果想切换到其他堆栈处，可以使用 frame 命令（简写为 f），该命令的使用方法是frame 堆栈编号（编号不加 #） (gdb) f 1 #1 0x0000000000426e35 in _anetTcpServer (err=err@entry=0x746bb0 &lt;server+560&gt; &quot;&quot;, port=port@entry=6379, bindaddr=bindaddr@entry=0x0, af=af@entry=10, backlog=511) at anet.c:487 487 if (anetListen(err,s,p-&gt;ai_addr,p-&gt;ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR; (gdb) f 2 #2 0x000000000042793d in anetTcp6Server (err=err@entry=0x746bb0 &lt;server+560&gt; &quot;&quot;, port=port@entry=6379, bindaddr=bindaddr@entry=0x0, backlog=511) at anet.c:510 510 return _anetTcpServer(err, port, bindaddr, AF_INET6, backlog); (gdb) 通过查看上面的各个堆栈，可以得出这里的调用层级关系，即： main() 函数在第 3862 行调用了 initServer() 函数 initServer() 在第 1852 行调用了 listenToPort()函数 listenToPort() 在第 1728 行调用了 anetTcp6Server() 函数 anetTcp6Server() 在第 510 行调用了 _anetTcpServer() 函数 _anetTcpServer() 函数在第 487 行调用了 anetListen() 函数 当前断点正好位于 anetListen() 函数中 thread 命令使用 info thread 命令来查看当前进程有哪些线程 (gdb) info thread Id Target Id Frame 4 Thread 0x7fffef7fd700 (LWP 53065) &quot;redis-server&quot; 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0 3 Thread 0x7fffefffe700 (LWP 53064) &quot;redis-server&quot; 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0 2 Thread 0x7ffff07ff700 (LWP 53063) &quot;redis-server&quot; 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0 * 1 Thread 0x7ffff7fec780 (LWP 53062) &quot;redis-server&quot; 0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6 通过 info thread 的输出可以知道 redis-server 正常启动后，一共产生了 4 个线程，包括一个主线程和三个工作线程，线程编号（Id 那一列）分别是 4、3、2、1。三个工作线程（2、3、4）分别阻塞在 Linux API pthread_cond_wait 处，而主线程（1）阻塞在 epoll_wait 处。 虽然第一栏的名称叫 Id，但第一栏的数值不是线程的 Id，第三栏括号里的内容（如 LWP 53065）中，53065 这样的数值才是当前线程真正的 Id。 LWP 是Light Weight Process（轻量级进程），之前Linux没有线程，用进程代替后来 Linux 系统有了真正的线程实现，这个名字仍然被保留了下来。 可以通过“thread 线程编号”切换到具体的线程上去。例如，想切换到线程 2 上去，只要输入 thread 2 即可，然后输入 bt 就能查看这个线程的调用堆栈了。当把 GDB 当前作用的线程切换到线程 2 上之后，线程 2 前面就被加上了星号。 3.4 变量信息查看语句print和ptype命令通过 print 命令（简写为 p）我们可以在调试过程中方便地查看变量的值，也可以修改当前内存中的变量值。切换当前断点到堆栈 #4 ，然后打印以下三个变量： (gdb) f 4 #4 0x000000000042fa77 in initServer () at server.c:1852 1852 listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR) (gdb) l 1847 } 1848 server.db = zmalloc(sizeof(redisDb)*server.dbnum); 1849 1850 /* Open the TCP listening socket for the user commands. */ 1851 if (server.port != 0 &amp;&amp; 1852 listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR) 1853 exit(1); 1854 1855 /* Open the listening Unix domain socket. */ 1856 if (server.unixsocket != NULL) { (gdb) p server.port $15 = 6379 (gdb) p server.ipfd $16 = {0 &lt;repeats 16 times&gt;} (gdb) p server.ipfd_count $17 = 0 这里使用 print 命令分别打印出 server.port 、server.ipfd 、server.ipfd_count 的值，其中 server.ipfd 显示 “{0 …}”，这是 GDB 显示字符串或字符数据特有的方式，当一个字符串变量或者字符数组或者连续的内存值重复若干次，GDB 就会以这种模式来显示以节约空间. 此外我们可以输入 p &amp;server.port 来输出 server.port 的地址值。 func() 是一个可以执行的函数，p func() 命令可以输出该变量的执行结果。举一个最常用的例子，某个时刻，某个系统函数执行失败了，通过系统变量 errno 得到一个错误码，则可以使用 p strerror(errno) 将这个错误码对应的文字信息打印出来，这样就不用费劲地去 man 手册上查找这个错误码对应的错误含义了。 ptype ，顾名思义，其含义是“print type”，就是输出一个变量的类型。例如，我们试着输出 Redis 堆栈 #4 的变量 server 和变量 server.port 的类型： (gdb) ptype server type = struct redisServer { pid_t pid; char *configfile; char *executable; char **exec_argv; int hz; redisDb *db; ...省略部分字段... (gdb) ptype server.port type = int info args命令info args可以用来查看当前函数的参数值 (gdb) thread 1 [Switching to thread 1 (Thread 0x7ffff7fec780 (LWP 53062))] #0 0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6 (gdb) bt #0 0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6 #1 0x00000000004265df in aeApiPoll (tvp=0x7fffffffe300, eventLoop=0x7ffff08350a0) at ae_epoll.c:112 #2 aeProcessEvents (eventLoop=eventLoop@entry=0x7ffff08350a0, flags=flags@entry=11) at ae.c:411 #3 0x0000000000426aeb in aeMain (eventLoop=0x7ffff08350a0) at ae.c:501 #4 0x00000000004238ef in main (argc=1, argv=0x7fffffffe648) at server.c:3899 (gdb) f 2 #2 aeProcessEvents (eventLoop=eventLoop@entry=0x7ffff08350a0, flags=flags@entry=11) at ae.c:411 411 numevents = aeApiPoll(eventLoop, tvp); (gdb) info args eventLoop = 0x7ffff08350a0 flags = 11 (gdb) 上述代码片段切回至主线程 1，然后切换到堆栈 #2，堆栈 #2 调用处的函数是 aeProcessEvents() ，一共有两个参数，使用 info args 命令可以输出当前两个函数参数的值，参数 eventLoop 是一个指针类型的参数，对于指针类型的参数，GDB 默认会输出该变量的指针地址值，如果想输出该指针指向对象的值，在变量名前面加上解引用即可，这里使用 p* eventLoop 命令： (gdb) p *eventLoop $26 = {maxfd = 11, setsize = 10128, timeEventNextId = 1, lastTime = 1536570672, events = 0x7ffff0871480, fired = 0x7ffff08c2e40, timeEventHead = 0x7ffff0822080, stop = 0, apidata = 0x7ffff08704a0, beforesleep = 0x429590 &lt;beforeSleep&gt;, aftersleep = 0x4296d0 &lt;afterSleep&gt;} watch命令watch 命令可以用来监视一个变量或者一段内存，当这个变量或者该内存处的值发生变化时，GDB 就会中断下来。被监视的某个变量或者某个内存地址会产生一个 watch point（观察点）， watch 命令就可以通过添加硬件断点来达到监视数据变化的目的。它有两种形式： //形式一：整型变量 int i; watch i //形式二：指针类型 char *p; watch p 与 watch *p //形式三：watch 一个数组或内存区间 char buf[128]; watch buf 注意：watch p 与 watch *p 是有区别的，前者是查看* (&amp;p)，是 p 变量本身；后者是 p 所指内存的内容。我们需要查看地址，因为目的是要看某内存地址上的数据是怎样变化的。 display命令display 命令监视的变量或者内存地址，每次程序中断下来都会自动输出这些变量或内存的值。例如，假设程序有一些全局变量，每次断点停下来我都希望 GDB 可以自动输出这些变量的最新值，那么使用“display 变量名”设置即可 比如输入(gdb) display $ebx，那么每次调试的最后无论有没有print最后都会打印出$ebx的结果。 以使用 info display 查看当前已经自动添加了哪些值，使用 delete display 清除全部需要自动输出的变量，使用 delete diaplay 编号 删除某个自动输出的变量。","categories":[{"name":"Linux","slug":"Linux","permalink":"jiangren.work/categories/Linux/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"jiangren.work/tags/Linux/"}]},{"title":"Socket网络编程实战","slug":"Socket网络编程实战","date":"2019-08-05T05:44:35.000Z","updated":"2019-12-29T15:22:15.000Z","comments":true,"path":"2019/08/05/Socket网络编程实战/","link":"","permalink":"jiangren.work/2019/08/05/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/","excerpt":"从实际的角度出发，讲解如何利用Socket进行网络编程。","text":"从实际的角度出发，讲解如何利用Socket进行网络编程。 1. 基本流程 服务器端可以分为3个过程： 初始化：初始化DLL，创建套接字，绑定套接字端口号IP地址 工作：监听客户端，接受连接，收发数据 结束：关闭套接字，终止DLL的使用 客户端也分为这3个过程 初始化：DLL、套接字，但不用绑定 工作：连接服务器，收发数据 结束：关闭套接字，终止DLL的使用 2. 关键API以windows下的socket为例，讲解如何调用这些API 2.1 WSAStartup( )作用是添加链接库函数DLL，当某个程序调用WSAStartup()函数时，操作系统根据请求的Socket版本来搜索相应的库，然后将找到的库绑定到该应用程序中。成功返回0，失败返回错误代码。 MAKEWORD(2, 1)表示socket版本号。 使用前需要加上： #include &lt;WinSock2.h&gt; #pragma comment(lib, &quot;ws2_32.lib&quot;) //加载 一般用法是 WSADATA wsaData; int iResult = WSAStartup(MAKEWORD(2, 2), &amp;wsaData); if (iResult != 0) { printf(&quot;WSAStartup failed: %d\\n&quot;, iResult); return 1; } 2.2 Socket( )类似于fopen，文件打开时，返回一个文件描述字，而socket( )用于创建一个socket描述符，相当于socket的名字。 int socket(int domain, int type, int protocol); 如果成功则返回描述符，失败返回-1。 Domain：协议族，常用的有AF_INET和AF_UNIX。前者表示使用ipv4地址(32位)和端口号(16位)的组合，后者表示使用一个绝对路径。 Type：指定socket的类型，常用的有 SOCK_STREAM，流套接字，应用了传输控制协议TCP，保证数据无差错按数据收发 SOCK_DGRAM数据报套接字，应用UDP协议，不校验，可靠性差，会丢失，但速度快； Protocol：指定协议，常用的有IPPROTO_TCP、IPPROTO_UDP，分别对应TCP/UDP 2.3 Bind( )将套接字、地址、端口号绑定在一起 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 通常服务器在启动的时候需要绑定一个众所周知的地址(IP+端口号)，客户端以此来连接。而客户端则不需要指定，在connect时由系统随机生成一个。这就是为什么在服务器端，我们要在listen之前调用bind的原因。 2.4 Listen( ), Connect( )listen第一个是服务器的描述字，backlog是可以排队的最大连接个数。成功则返回0, 失败返回-1, 错误原因存于errno 中 int listen(int sockfd, int backlog); int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 2.5 accept( )提取出所监听套接字的等待连接队列中第一个连接请求，创建一个新的套接字，并返回指向该套接字的文件描述符。 SOCKET accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); CCopy sockfd, 利用系统调用socket()建立的套接字描述符，通过bind()绑定到一个本地地址(一般为服务器的套接字)，并且通过listen()一直在监听连接； addr, 指向struct sockaddr的指针，该结构用通讯层服务器对等套接字的地址(一般为客户端地址)填写 addrlen, 一个值结果参数，调用函数必须初始化为包含addr所指向结构大小的数值 通过这个函数我们能知晓：客户端的socket端口号，客户端地址。 如果队列中没有等待的连接，套接字也没有被标记为Non-blocking，accept()会阻塞调用函数直到连接出现；如果套接字被标记为Non-blocking，队列中也没有等待的连接，accept()返回错误EAGAIN 2.6 closesocket( )关闭socket，成功返回0，失败返回-1。 int closesocket(int sockfd); 注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。 2.7 recv/sendint recv(int sockfd, const void *buf, size_t nbytes, int flags); int send(int sockfd, const void *buf, size_t nbytes, int flags); buf：保存接收数据的缓冲地址值; nbytes：可接收最大字节数; flags：接收数据时指定的可选项信息。成功时返回发送的字节数，失败返回-1 2.8 sockaddr_in结构体sockaddr_in系统封装的一个结构体，包含了: sin_family：定义地址族，AF和PF都一样，INET表示TCP/IP协议； sin_port：保存端口号； sin_addr：保存IP地址信息； sin_zero：无意义。 sockaddr_in sockAddr; memset(&amp;sockAddr, 0, sizeof(sockAddr)); //每个字节都用0填充 sockAddr.sin_family = PF_INET; //使用IPv4地址 sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); //回送IP地址 sockAddr.sin_port = htons(1234); //端口 字节顺序包括NBO网络字节顺序和HBO主机字节顺序。NBO按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。 不同的机器HBO不相同，与CPU设计有关。比如Intelx86架构下，short型数0x1234表示为34 12，而IBM power PC结构下,short型数0x1234表示为12 34。 为此我们需要进行转化： htonl():host to network long ntohl():network to host long htons():host to network short htons():network to host short 3. 实例使用方法：在Visual Studio中建立两个解决方案，分别放入Server和Client，运行后在DEBUG文件中得到exe文件，先运行Server.exe然后运行Client.exe即可。 3.1 Server #define _WINSOCK_DEPRECATED_NO_WARNINGS #include &lt;winsock2.h&gt; #include&lt;iostream&gt; #include&lt;string&gt; #pragma comment (lib, &quot;ws2_32.lib&quot;) //加载 ws2_32.dll #define BUF_SIZE 10086 using namespace std; //直接用std好像会出现bug using std::cout; int main() { //初始化dll WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //创建套接字 SOCKET servSock = socket(AF_INET, SOCK_STREAM, 0); //绑定套接字 sockaddr_in sockAddr; memset(&amp;sockAddr, 0, sizeof(sockAddr)); //每个字节都用0填充 sockAddr.sin_family = PF_INET; //使用IPv4地址 sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); //回送IP地址 sockAddr.sin_port = htons(1234); //端口 bind(servSock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR)); //进入监听状态 listen(servSock, 20); //接收客户端请求 SOCKADDR clntAddr; int nSize = sizeof(SOCKADDR); char buffer[BUF_SIZE] = { 0 }; //缓冲区 while (1) { SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize); int strLen = recv(clntSock, buffer, BUF_SIZE, 0); //接收客户端发来的数据 cout &lt;&lt; &quot;收到的数据是：&quot; &lt;&lt; buffer&lt;&lt;endl; send(clntSock, buffer, strLen, 0); //将数据原样返回 closesocket(clntSock); //关闭套接字 memset(buffer, 0, BUF_SIZE); //重置缓冲区 } //关闭套接字 closesocket(servSock); //终止 DLL 的使用 WSACleanup(); return 0; } 3.2 Client #define _WINSOCK_DEPRECATED_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;stdlib.h&gt; #include &lt;WinSock2.h&gt; #pragma comment(lib, &quot;ws2_32.lib&quot;) //加载 ws2_32.dll #define BUF_SIZE 10086 using std::cout; using std::cin; using std::endl; int main() { //初始化DLL WSADATA wsaData; int iResult = WSAStartup(MAKEWORD(2, 2), &amp;wsaData); if (iResult != 0) { printf(&quot;WSAStartup failed: %d\\n&quot;, iResult); return 1; } //向服务器发起请求 sockaddr_in sockAddr; memset(&amp;sockAddr, 0, sizeof(sockAddr)); //每个字节都用0填充 sockAddr.sin_family = PF_INET; sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); //回送地址 sockAddr.sin_port = htons(1234); char bufSend[BUF_SIZE] = { 0 }; char bufRecv[BUF_SIZE] = { 0 }; while (1) { //创建套接字 SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR)); //获取用户输入的字符串并发送给服务器 cout &lt;&lt; &quot;输入&quot;; cin &gt;&gt; bufSend; send(sock, bufSend, strlen(bufSend), 0); //接收服务器传回的数据 recv(sock, bufRecv, BUF_SIZE, 0); //输出接收到的数据 cout &lt;&lt; &quot;服务器传送回的数据为：&quot; &lt;&lt; bufRecv &lt;&lt; endl; memset(bufSend, 0, BUF_SIZE); //重置缓冲区 memset(bufRecv, 0, BUF_SIZE); //重置缓冲区 closesocket(sock); //关闭套接字 } WSACleanup(); //终止使用 DLL return 1; }","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP协议","slug":"TCP-IP协议","permalink":"jiangren.work/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"},{"name":"Socket","slug":"Socket","permalink":"jiangren.work/tags/Socket/"}]},{"title":"Socket网络编程原理","slug":"Socket网络编程原理","date":"2019-08-01T11:53:35.000Z","updated":"2019-12-30T14:38:32.000Z","comments":true,"path":"2019/08/01/Socket网络编程原理/","link":"","permalink":"jiangren.work/2019/08/01/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86/","excerpt":"简单介绍了SOCKET的原理模型——TCP/IP模型，包括了三次握手/四次握手。","text":"简单介绍了SOCKET的原理模型——TCP/IP模型，包括了三次握手/四次握手。 1. 网络模型TCP/IP模型，又称传输控制协议/网际协议(Transmission Control Protocol/Internet Protocol)。 简单来说，此协议的通信过程如同数据出栈入栈的过程。 入栈：数据发送方每层不断地封装头部和尾部，向中间添加传输信息 出栈：数据接收方每层不断拆除头部尾部，读取中间的传输信息 TCP/IP协议借鉴了OSI参考模型(Open System Interconnect)，主要针对计算机网络体系。 应用层：具有HTTP和FTP等协议 传输层：具有TCP和UDP(User Datagram Protocol)用户数据报协议 网络层：包含了IP协议 数据链路层：也称网络接口层，为等待传送的数据加入一个以太网协议头，为传输做好准备 如果用发快递作比喻 应用层：帮客户打包 传输层：从快递点送到集散中心 网络层：集散中心确定将要发送的地址 数据链路层：将小包裹打包成集装箱（装帧），由此控制发送流量等信息 物理层：高速路、铁路送走 2. Socket原理2.1 概念socket是应用层和传输层之间的抽象层，他是一组接口，将复杂的传输层和网络层协议隐藏到socket接口后面。 socket是从Unix/Linux引入的概念，而Unix/Linux的哲学就是：一切皆文件，都可以用”open—&gt;write/read—&gt;close”模式进行操作。同样的，socket的思路也是打开、读写IO、关闭。 2.2 三次握手所谓三次握手是指建立一个TCP连接时，需要客户端和服务器发送3个包。 名词解释： SYN：Synchronize，同步标志位，为1时表示序列号有效 ACK：Acknowledgment，确认标志位 seq：Synchronize Sequence Number，同步序列号 ack：确认序列号 握手过程： 第一次握手：客户端发送SYN标志为1的包，以及同步序列号x，并指明打算连接的服务器端口。此时，connect进入阻塞状态。 第二次握手：服务器收到后，发送SYN和ACK标志为1的包，同时也发送一个自己的同步序列号y，外加一个确认序列号ack=x+1。此时accept进入阻塞状态。 第三次握手：客户端收到后，再次发送ACK=1，以及同步序列号seq和确认序列号ack，与此同时，connect返回。当服务器收到ACK=1时，accept返回。 2.3 四次挥手指中断连接时需要发送4个包，此时客户端和服务器均可主动发起挥手操作，只需要调用close()函数即可。 B收到FIN结束消息时，干两件事：发送确认标志和通知其他进程准备关闭（这也是为什么要多一次挥手）。当准备完毕时，发送FIN。 A收到FIN时，也干两件事：发送确认标志和等待2MSL(Maximum Segment Lifetime) 2.4 常见问题为什么不能用两次握手连接 三次握手完成两个重要功能： 双方都知道彼此已经准备好 确认彼此的序列号 假设只有两次握手，A向B发送连接请求，B收到后回复消息，B认为此时已经连接成功，开始发送数据。然而，如果B的回复消息丢失了，A没有收到确认消息，只有再次发送连接请求，而此时B有在向A发送数据，这样就会造成死锁。 为什么连接是三次握手，而关闭时是四次？ 关闭连接时，服务端需要回复两次 第一次告诉客户端，我已经收到了你的请求了，但我的剩余报文还没有处理完，等一等。客户端收到后不再发送请求，开始默默等待。 第二次告诉客户端处理完成。 为什么TIME_WAIT状态需要经过2MSL？ 2MSL是一次发送和回复的最大时间，客户端最后一次发送ACK可能会丢失，如果此时冒然关闭，会导致服务器没收到ACK，然后一直发一直发。所以需要等2MSL，如果超过这个时间，都还没有收到服务器的信息，说明已经完成，可以关闭。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"TCP/IP协议","slug":"TCP-IP协议","permalink":"jiangren.work/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"},{"name":"Socket","slug":"Socket","permalink":"jiangren.work/tags/Socket/"}]},{"title":"详解Epoll-下篇","slug":"详解Epoll-下篇","date":"2019-07-31T05:54:35.000Z","updated":"2019-12-29T15:19:34.000Z","comments":true,"path":"2019/07/31/详解Epoll-下篇/","link":"","permalink":"jiangren.work/2019/07/31/%E8%AF%A6%E8%A7%A3Epoll-%E4%B8%8B%E7%AF%87/","excerpt":"下篇针对一些特定问题进行分析，主要分析epoll_event结构体，并给出了两个实例。","text":"下篇针对一些特定问题进行分析，主要分析epoll_event结构体，并给出了两个实例。 1. epoll_event结构体分析上篇我们讲到了epoll_wait函数的功能。 int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 这个函数只能获取是否有注册事件发生，至于说事件的细节，我们并不清楚。好比一个人在山洞中，只能听到声响，至于这个声响从何发出并不清楚。而这些关键信息就存储在epoll_event结构中。 结构体如下所示： typedef union epoll_data { void *ptr; int fd; __uint32_t u32; __uint64_t u64; } epoll_data_t; struct epoll_event { __uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; 它分为events和data两个部分 events是epoll注册的事件，比如EPOLLIN、EPOLLOUT等等，这个参数在epoll_ctl注册事件时，可以明确告知注册事件的类型。 data是一个联合体，用于传递参数。 2. epoll_event使用实例2.1 实例1：服务器侦听客户端连接这个例子很棒的展示了epoll_data中的int fd该怎么用。先看下面一段代码： //创建socket nSocketListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); ... //绑定地址 struct sockaddr_in local; memset(&amp;local, 0, sizeof(local)); local.sin_family = AF_INET; local.sin_addr.s_addr = htonl(INADDR_ANY);//0.0.0.0所有地址都合法 local.sin_port = htons(TCP_PORT); bind(nSocketListen, (struct sockaddr*) &amp; local, sizeof(local)) //创建epoll nListenEpoll = epoll_create(MAX_LISTEN_EVENTS); //注册事件 struct epoll_event Ev; memset(&amp;Ev, 0, sizeof(epoll_event)); Ev.events= EPOLLIN | EPOLLET Ev.data.fd = nSocketListen; epoll_ctl(nListenEpoll, EPOLL_CTL_ADD, nSocketListen, &amp;Ev); //侦听 int nFdNumber = epoll_wait(nListenEpoll, lpListenEvents, MAX_LISTEN_EVENTS, -1); //处理侦听结果 for (int i = 0; i &lt; nFdNumber; i++) { if (lpListenEvents[i].data.fd != nSocketListen) continue; ... } 这段代码在网上很常见，作用是建立一个服务器，侦听所有客户端的连接。具体过程是先建立了一个socket，地址设为设为0.0.0.0（所有人都可以连接），然后将这个socket的句柄nSocketListen附加在注册事件Ev.data.fd上。在wait等到结果后做一个判断，看看接收到和预设的是否一致。上篇的demo也用到了类似的思路。 if (lpListenEvents[i].data.fd != nSocketListen) continue; 虽然这段代码用到了fd，但他并没有体现出fd的作用！整个程序仅仅设置并注册了一个socket来连接所有IP地址htonl(INADDR_ANY);，wait收到的消息必然来自于这个唯一的socket，所以这句判断根本是多此一举。 正确的用法是：创建多个socket来管理不同的字段，比如： Socket句柄 管理的IP范围 101 100-120 102 121-191 103 192-255 将这三个socket都注册进epoll里面，当wait到来时，我们就可以根据Ev.data.fd传进来的socket句柄来进行处理。 比如上午8点到10点这个时间段，服务器只允许100-120范围的IP连接进来，就可以做一个判断if (lpListenEvents[i].data.fd == 101),如果是再接受连接。 这个例子中，fd传递了socket的句柄，帮助我们管理不同的网络连接。 2.2 实例2：进程间通信epoll常常用于线程间的协同工作。 //线程A代码 struct epoll_event Ev; memset(&amp;Ev, 0, sizeof(Ev)); Ev.events= EPOLLOUT | EPOLLET | EPOLLERR | EPOLLHUP Ev.data.ptr = lpCatList; epoll_ctl(iClientEpoll, EPOLL_CTL_ADD, lpCatList-&gt;nClientSocket, &amp;Ev); //线程B代码 int nFdNumber = epoll_wait(iClientEpoll, lpEvent, MAX_CLIENT_EVENTS, -1); IOPACKHEAD_LIST* RelpCatList = (IOPACKHEAD_LIST*)lpEvent[i].data.ptr; 线程AB都是服务器上的线程。 线程A功能相当于接线员，跟前面展示的服务器功能相同：监听客户的连接，accept客户的请求，建立客户与服务器间的socket连接通道（此处的建立的socket句柄为nClientSocket）。然后将这些客户连接注册到iClientEpoll中 这些通道建立后，客户一般不会时刻收发数据，也就是说客户可能不定时的使用为他们建立的socket连接通道，线程B的iClientEpoll就是用来监听有没有已经建立连接的客户需要收发数据的。 如果像上一个例子一样，只用Ev.data.fd传一个客户socket的句柄，这样线程B能得到的信息太少了。所以我们需要使用结构体lpCatList来传参。 lpCatList相当于一个令牌，他是一个指针，指向的地址存储了客户的信息（Socket句柄，IP地址，MAC地址，请求时间等等），A线程在接收客户连接后，将他们写到这个令牌中，一并注册到iClientEpoll。B线程就可以利用Ev.data.ptr包含的重要的地址信息。 这样ptr就相当于一个小纸条，A线程通过iClientEpoll将这个小纸条交到B线程手中，B线程就能了解A线程的信息，实现了线程间的通信。 下面我们打印一下线程A的lpCatlist (gdb) p lpCatList $18 = (IOPACKHEAD_LIST *) 0x7ffff0001120 再打印一下线程B的ptr，可以发现他们指向同一个地址0x7ffff0001120，说明参数成功传递 (gdb) p lpEvent[0] $14 = {events = 4, data = {ptr = 0x7ffff0001120, fd = -268431072, u32 = 4026536224, u64 = 140737219924256}}","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"并发","slug":"并发","permalink":"jiangren.work/tags/%E5%B9%B6%E5%8F%91/"},{"name":"Socket","slug":"Socket","permalink":"jiangren.work/tags/Socket/"},{"name":"Linux","slug":"Linux","permalink":"jiangren.work/tags/Linux/"},{"name":"Epoll","slug":"Epoll","permalink":"jiangren.work/tags/Epoll/"}]},{"title":"详解Epoll-上篇","slug":"详解Epoll-上篇","date":"2019-07-29T11:58:35.000Z","updated":"2020-02-19T10:45:57.000Z","comments":true,"path":"2019/07/29/详解Epoll-上篇/","link":"","permalink":"jiangren.work/2019/07/29/%E8%AF%A6%E8%A7%A3Epoll-%E4%B8%8A%E7%AF%87/","excerpt":"通过上下两篇详细讲述EPOLL的是原理及使用方法，上篇主要针对基本概念和基础用法","text":"通过上下两篇详细讲述EPOLL的是原理及使用方法，上篇主要针对基本概念和基础用法 1. 概念1.1 基本概念解释流(stream) 指计算机中顺序读写字节序列。对应于现实中的输入模型(磁带、纸带，他们都是按顺序从头开始) 流是能统一描述所有常见输入输出类型的模型，包括文件、键盘、显示器等等，能够通过输入输出重定向（不使用标准IO函数，编写相应的读写函数，处理文件、键盘等模型）。相较于随机读写，流模型能兼容不同的读写介质，提高读写效率。 缓冲区(Buffer) 假设有一个管道，A端为输入，B端为输出。 一开始管道是空的，对应内核缓冲区为空，B被阻塞。 当A开始写入数据时，缓冲区非空，B可能还是读取也可能继续休息。 若A写满了缓冲区，则A被阻塞，等待B读取数据。 若B读取所有数据，缓冲区为空，则B又被阻塞。 总结起来就是： 缓冲区空：两种可能，A没开始输入，B读取完毕所有数据，两种情况下B都被阻塞 缓冲区非满：A开始写入数据，B可能读取也可能休息 缓冲区满：A不能再写入，被阻塞，等待B醒来。B读取时，A可能接着写入可能继续休息。 1.2 四种事件处理的方式阻塞IO：一个线程只能处理一个流的I/O事件。除非采用多线程，否则效率很低。 非阻塞忙轮询IO：即Non-Blocking Busy Polling，等待某个事件的时候，放弃其他事情，休息，专门等待，称之为阻塞。等待过程中不休息，不断询问事件是否完成，称之为非阻塞忙轮询。可以同时处理多个流，但需要从头到尾轮询，浪费资源。 Select：相当于一位代理，帮我们观察流。但这位代理只会告诉我们此刻是否有IO事件发生，我们却不知道是哪些流，只能无差别轮询。 Epoll：即event poll，不同于无差别轮询，epoll会把哪个流发生什么样的事情通知我们。 1.3 Select/Poll的缺点 单个进程能够监视的文件描述为最大为1024，轮询越多，性能越差 Select需要复制大量句柄数据结构，开销巨大。 Select返回整个句柄数组，程序需要遍历数组才能知道哪些句柄发生了什么事件。 触发方式为水平触发，如果程序没有对一个就绪的文件进行IO操作，之后每次Select调用还是会将文件描述符通知给进程。 Poll使用链表保存文件，没有1的限制，但其他三个缺点依然比较明显。 2. Epoll模型2.1 Epoll机制解析Epoll也就是events poll，它分为三个部分实现： 调用epoll_creat建立一个epoll对象 调用epoll_ctl向epoll对象中添加众多套接字 调用epoll_wait收集发生的事件的连接 某一进程调用epoll_creat时，Linux内核会创建一个eventpoll结构体。结构体中存在两个成员： 红黑树的根节点，存储epoll需要监控的事件 双链表的头部，存储epoll_wait返回给用户的满足条件的事件 用户通过epoll_ctl向epoll对象中注册事件，这些事件会挂载到红黑树中，能高效识别重复事件。所有注册的事件都会和驱动程序建立回调关系，事件发生时调用这个回调方法，将发生的事件添加到双链表rdlist中。 当调用epoll_wait检查事件发生时，只需要检查双链表rdlist是否有元素即可。通过epoll_ctl把所有事件传入内核，一起wait，避免了不必要的重复拷贝。 当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体： struct eventpoll{ .... /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/ struct rb_root rbr; /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/ struct list_head rdlist; .... }; 每次调用epoll_create方法都会创建一个epoll对象，每一个对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示： struct epitem{ struct rb_node rbn;//红黑树节点 struct list_head rdllink;//双向链表节点 struct epoll_filefd ffd; //事件句柄信息 struct eventpoll *ep; //指向其所属的eventpoll对象 struct epoll_event event; //期待发生的事件类型 } 总结一下，epoll内部有两个重要的结构体： eventpoll：每个epoll都有一个，维护一个红黑树和双向链表，ctl注册的事件挂载到红黑树，发生的事件挂载到链表。 epitem：每个事件都有一个，记载了事件在红黑树和链表中的位置，以及事件的属性。 2.2 Epoll使用方法1.创建Epoll句柄 int epfd = epoll_create(intsize); 创建一个epoll句柄，size用来告诉内核这个监听的数目有多大。注意：当创建好epoll句柄后，它就是会占用一个fd值，所以使用完epoll以后，需要及时调用close()关闭，否则会导致fd耗尽。 2.注册或修改监听事件 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event) 参数： epfd，之前creat的句柄 op，动作类型 EPOLL_CTL_ADD：注册新的fd到epfd中 EPOLL_CTL_MOD：修改已经注册的fd的监听事件 EPOLL_CTL_DEL：从epfd中删除一个fd fd，需要监听的文件句柄 event，需要监听的事件 调用成功返回0，不成功返回-1。以下是epoll_event结构体 // 保存触发事件的某个文件描述符相关的数据 typedef union epoll_data { void *ptr; int fd; __uint32_t u32; __uint64_t u64; } epoll_data_t; // 注册所感兴趣的事件和回传所发生待处理的事件 struct epoll_event { __uint32_t events; // Epoll events epoll_data_t data; // User data variable }; 其中events包含了如下的宏集合： EPOLLIN：表示对应的文件描述符可读（包括对端Socket） EPOLLOUT：表示对应的文件描述符可写 EPOLLPRI：表示对应的文件描述符有紧急数据可读（带外数据） EPOLLERR：表示对应的文件描述符发生错误； EPOLLHUP：表示对应的文件描述符被挂断； EPOLLET：将EPOLL设为边缘触发（Edge Triggered），这是相对于水平触发（Level Triggered）而言的。 边缘触发和水平触发的区别是： 水平触发LT：默认方式，支持阻塞和非阻塞。内核告诉你某个fd就位了，如果你不对这个fd进行IO操作，内核会一直通知你。所以这种模式安全性较高。 边缘触发ET：只支持非阻塞，内核只会通知你一次，如果你不操作他也不管你了，速度快 3.等待事件触发 int epoll_wait(int epfd, struct epoll_event * events, intmaxevents, int timeout); 参数: events是分配好的epoll_event结构体数组，epoll将会把发生的事件赋值到events数组中。 maxevents告诉内核这个events数组有多大，这个maxevents的值不能大于创建epoll_create时的size。 参数timeout是超时时间（毫秒）。 该函数返回需要处理的事件数目，如返回0表示已超时。 等侍注册在epfd上的socket fd的事件的发生. 如果发生则将发生的socket fd和事件类型放入到events数组中，并将注册在epfd上的socket fd的事件类型给清空。 如果下一个循环还要关注这个socket fd的话，则需要用epoll_ctl(epfd,EPOLL_CTL_MOD,listenfd,&amp;ev)来重新设置socket fd的事件类型。这时不用EPOLL_CTL_ADD，因为socket fd并未清空，只是事件类型清空。 3. 实战使用epoll的基本逻辑如下。我们需要用到多个socket句柄，首先本地服务器肯定要创建一个socket，同时也需要将这个fd注册到epoll中。 实际代码如下，主要工作是初始化服务器socket，并将其注册到epoll中。 /*步骤1：设置socket */ struct sockaddr_in clientaddr; struct sockaddr_in serveraddr; listenfd = socket(AF_INET, SOCK_STREAM, 0); setnonblocking(listenfd); //自己写的函数，把socket设置为非阻塞方式 /*步骤2：创建并设置epoll */ struct epoll_event ev, events[20]; //声明epoll_event结构体的变量,ev用于注册事件,数组用于回传要处理的事件 epfd = epoll_create(256); //生成用于处理accept的epoll专用的文件描述符 ev.data.fd = listenfd; //设置与要处理的事件相关的文件描述符 ev.events = EPOLLIN | EPOLLET; //设置要处理的事件类型 epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev); //注册epoll事件 /*步骤3：连接并监听网络 */ bzero(&amp;serveraddr, sizeof(serveraddr)); //置零 serveraddr.sin_family = AF_INET; char *local_addr = &quot;127.0.0.1&quot;; inet_aton(local_addr, &amp;(serveraddr.sin_addr)); //将一个字符串IP地址转换为一个32位的网络序列IP地址 serveraddr.sin_port = htons(portnumber); //portnumber自己设的端口号 bind(listenfd, (sockaddr *)&amp;serveraddr, sizeof(serveraddr)); listen(listenfd, 20); //最大等待20个 客户端与服务器沟通分为两步： 客户端连接，事件的句柄fd是服务器的fd。 客户端收发数据，事件的句柄fd是客户端本身的socket句柄 代码如下： /*步骤4：处理事件 */ while (1) { nfds = epoll_wait(epfd, events, 20, 500); //等待epoll事件的发生,最大20个，超时500ms for (i = 0; i &lt; nfds; ++i) //处理所发生的所有事件 { if (events[i].data.fd == listenfd) //如果新监测到一个SOCKET用户连接到了绑定的SOCKET端口，建立新的连接。 { connfd = accept(listenfd, (sockaddr *)&amp;clientaddr, &amp;clilen); char *str = inet_ntoa(clientaddr.sin_addr); cout &lt;&lt; &quot;accapt a connection from &quot; &lt;&lt; str &lt;&lt; endl; ev.data.fd = connfd; //设置用于读操作的文件描述符 ev.events = EPOLLIN | EPOLLET; //设置用于注测的读操作事件 epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev); //注册ev } else if (events[i].events &amp; EPOLLIN) //如果是已经连接的用户，并且收到数据，那么进行读入。 { cout &lt;&lt; &quot;EPOLLIN&quot; &lt;&lt; endl; int n = read(sockfd, line, MAXLINE))//传送到line中，返回n传送的字节数 line[n] = &#39;/0&#39;; cout &lt;&lt; &quot;read &quot; &lt;&lt; line &lt;&lt; endl; ev.data.fd = sockfd; //设置用于写操作的文件描述符 ev.events = EPOLLOUT | EPOLLET; //设置用于注测的写操作事件 epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev); //修改sockfd上要处理的事件为EPOLLOUT } else if (events[i].events &amp; EPOLLOUT) // 如果有数据发送 { sockfd = events[i].data.fd; write(sockfd, line, n); ev.data.fd = sockfd; //设置用于读操作的文件描述符 ev.events = EPOLLIN | EPOLLET; //设置用于注测的读操作事件 epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev); //修改sockfd上要处理的事件为EPOLIN } } }","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"并发","slug":"并发","permalink":"jiangren.work/tags/%E5%B9%B6%E5%8F%91/"},{"name":"Socket","slug":"Socket","permalink":"jiangren.work/tags/Socket/"},{"name":"Linux","slug":"Linux","permalink":"jiangren.work/tags/Linux/"},{"name":"Epoll","slug":"Epoll","permalink":"jiangren.work/tags/Epoll/"}]}],"categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"jiangren.work/categories/Objective-C/"},{"name":"go","slug":"go","permalink":"jiangren.work/categories/go/"},{"name":"C++","slug":"C","permalink":"jiangren.work/categories/C/"},{"name":"算法","slug":"算法","permalink":"jiangren.work/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux","slug":"Linux","permalink":"jiangren.work/categories/Linux/"},{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/categories/SLAM/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"jiangren.work/tags/Objective-C/"},{"name":"面试经验","slug":"面试经验","permalink":"jiangren.work/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"},{"name":"计算机网络","slug":"计算机网络","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"go","slug":"go","permalink":"jiangren.work/tags/go/"},{"name":"并发","slug":"并发","permalink":"jiangren.work/tags/%E5%B9%B6%E5%8F%91/"},{"name":"C++","slug":"C","permalink":"jiangren.work/tags/C/"},{"name":"算法","slug":"算法","permalink":"jiangren.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据库","slug":"数据库","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux","slug":"Linux","permalink":"jiangren.work/tags/Linux/"},{"name":"Beego","slug":"Beego","permalink":"jiangren.work/tags/Beego/"},{"name":"多线程","slug":"多线程","permalink":"jiangren.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"读书笔记","slug":"读书笔记","permalink":"jiangren.work/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Redis","slug":"Redis","permalink":"jiangren.work/tags/Redis/"},{"name":"数据结构","slug":"数据结构","permalink":"jiangren.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"教程","slug":"教程","permalink":"jiangren.work/tags/%E6%95%99%E7%A8%8B/"},{"name":"MySQL","slug":"MySQL","permalink":"jiangren.work/tags/MySQL/"},{"name":"图像处理","slug":"图像处理","permalink":"jiangren.work/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"jiangren.work/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"Leetcode","slug":"Leetcode","permalink":"jiangren.work/tags/Leetcode/"},{"name":"SLAM","slug":"SLAM","permalink":"jiangren.work/tags/SLAM/"},{"name":"数学","slug":"数学","permalink":"jiangren.work/tags/%E6%95%B0%E5%AD%A6/"},{"name":"ROS","slug":"ROS","permalink":"jiangren.work/tags/ROS/"},{"name":"TCP/IP协议","slug":"TCP-IP协议","permalink":"jiangren.work/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"},{"name":"Socket","slug":"Socket","permalink":"jiangren.work/tags/Socket/"},{"name":"Epoll","slug":"Epoll","permalink":"jiangren.work/tags/Epoll/"}]}